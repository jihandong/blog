<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Gensokyo">
<meta property="og:url" content="https://dracit7.github.io/blog/index.html">
<meta property="og:site_name" content="Gensokyo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Gensokyo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://dracit7.github.io/blog/">





  <title>Gensokyo</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Gensokyo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Youkai's Mountain</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/blog/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2019/03/10/在ArchLinux下安装和配置LaTex编译环境/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/03/10/在ArchLinux下安装和配置LaTex编译环境/" itemprop="url">在ArchLinux下安装和配置LaTex编译环境</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-10T22:22:37+08:00">
                2019-03-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2019/03/10/在ArchLinux下安装和配置LaTex编译环境/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/03/10/在ArchLinux下安装和配置LaTex编译环境/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="在ArchLinux下安装和配置LaTex编译环境"><a href="#在ArchLinux下安装和配置LaTex编译环境" class="headerlink" title="在ArchLinux下安装和配置LaTex编译环境"></a>在ArchLinux下安装和配置LaTex编译环境</h2><p>之前写文档的时候一直用的是Markdown内置Latex，但这样不如直接编译<code>.tex</code>文件来的灵活，而在安装texlive的时候又遇到了很多坑，因此在这里总结一下安装与配置过程。</p>
<h3 id="安装xeLatex"><a href="#安装xeLatex" class="headerlink" title="安装xeLatex"></a>安装xeLatex</h3><p>用pacman可以安装texlive的许多组件，它们的统一格式是<code>texlive-</code>后跟一个具体的扩展。要安装基本组件只需要其中的<code>bin</code>，<code>core</code>和<code>lang</code>扩展，有特殊需求可以按照文档去安装其他的扩展。</p>
<p>这里我是如下安装：</p>
<p><code>sudo pacman -S texlive-{core,bin,langchinese,latexextra,fontsextra}</code></p>
<h3 id="扩展包的配置"><a href="#扩展包的配置" class="headerlink" title="扩展包的配置"></a>扩展包的配置</h3><h4 id="配置fontawesome"><a href="#配置fontawesome" class="headerlink" title="配置fontawesome"></a>配置fontawesome</h4><p>Fontawesome组件本身是在fontsextra扩展中的，但是由于扩展名问题无法被正常识别，需要在使用了这个组件的tex文件开头加上一句<code>\defaultfontfeatures{Extension = .otf}</code>。</p>
<h4 id="中文字体的问题"><a href="#中文字体的问题" class="headerlink" title="中文字体的问题"></a>中文字体的问题</h4><p>如果系统中没有安装<code>poppler-data</code>包，编译出的pdf文件将会无法显示中文。这个包可以直接使用<code>pacman</code>来安装。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2019/02/24/MIT_6.828/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/02/24/MIT_6.828/" itemprop="url">MIT 6.828 Labs 实验记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-24T20:10:08+08:00">
                2019-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Technical</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2019/02/24/MIT_6.828/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/02/24/MIT_6.828/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="MIT-6-828-Labs-实验记录"><a href="#MIT-6-828-Labs-实验记录" class="headerlink" title="MIT 6.828 Labs 实验记录"></a>MIT 6.828 Labs 实验记录</h2><h3 id="Overall"><a href="#Overall" class="headerlink" title="Overall"></a>Overall</h3><ul>
<li>6.828自带了一个打分系统，在Lab文件夹下执行<code>make grade</code>即可运行这个系统来检验自己的解答。</li>
</ul>
<h3 id="Build-up-the-environment"><a href="#Build-up-the-environment" class="headerlink" title="Build up the environment"></a>Build up the environment</h3><h4 id="Compiler-Toolchain"><a href="#Compiler-Toolchain" class="headerlink" title="Compiler Toolchain"></a>Compiler Toolchain</h4><p>由于Archlinux中的objdump和gcc均满足Lab的要求，不需要手动搭建编译环境。</p>
<h4 id="QEMU-emulator"><a href="#QEMU-emulator" class="headerlink" title="QEMU emulator"></a>QEMU emulator</h4><p>建议follow一下MIT官网上最新版的6.828课程页面。老的课程页面上的链接可能不可用。此处根据<a href="https://pdos.csail.mit.edu/6.828/2018/tools.html" target="_blank" rel="noopener">Fall 2018的课程页面</a>进行配置。</p>
<p>由于QEMU的调试系统不完善，课程组准备了改进过的QEMU，使它可以与系统中的GDB调试器绑定，并使用GDB来调试。执行以下步骤安装打好补丁的QEMU:</p>
<ol>
<li>执行<code>git clone https://github.com/mit-pdos/6.828-qemu.git qemu</code>拉取源代码</li>
<li>安装各种依赖。在Archlinux下的安装方式如下：<ul>
<li>libdtc：<code>yay DTC</code>，任选一项安装。</li>
<li>python：坑爹的是都8102年了这门课还不支持python3.不过Arch一般自带python2,问题不大</li>
</ul>
</li>
<li>进入源代码文件夹，Configure the source code<ul>
<li>执行<code>./configure --disable-kvm --disable-werror --python= &lt;pathToPython2&gt;</code></li>
</ul>
</li>
<li>执行<code>make &amp;&amp; make install</code>进行安装</li>
</ol>
<p>安装到一半，报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">qga/commands-posix.c: 在函数‘dev_major_minor’中:</span><br><span class="line">qga/commands-posix.c:634:21: 警告：implicit declaration of function ‘major’; did you mean ‘_m_por’? [-Wimplicit-function-declaration]</span><br><span class="line">         *devmajor = major(st.st_rdev);</span><br><span class="line">                     ^~~~~</span><br><span class="line">                     _m_por</span><br><span class="line">qga/commands-posix.c:634:21: 警告：对‘major’的嵌套的外部声明 [-Wnested-externs]</span><br><span class="line">qga/commands-posix.c:635:21: 警告：implicit declaration of function ‘minor’; did you mean ‘mknod’? [-Wimplicit-function-declaration]</span><br><span class="line">         *devminor = minor(st.st_rdev);</span><br><span class="line">                     ^~~~~</span><br><span class="line">                     mknod</span><br><span class="line">qga/commands-posix.c:635:21: 警告：对‘minor’的嵌套的外部声明 [-Wnested-externs]</span><br></pre></td></tr></table></figure>
<p>很显然是有两个函数major和minor在使用之前并未声明。这是两个库函数，在linux下的<code>&lt;sys/sysmacros.h&gt;</code>头文件中有定义，然而MIT给的代码里并没有包含这个头文件。根据报错信息打开<code>qga/commands-posix.c</code>，添加<code>#include &lt;sys/sysmacros.h&gt;</code>，保存。</p>
<p>再次安装，装到一半又报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: ../hw/9pfs/virtio-9p.o: in function `stat_to_v9stat&apos;:</span><br><span class="line">/home/drac_zhang/Downloads/qemu/hw/9pfs/virtio-9p.c:796: undefined reference to `minor&apos;</span><br><span class="line">/usr/bin/ld: /home/drac_zhang/Downloads/qemu/hw/9pfs/virtio-9p.c:796: undefined reference to `major&apos;</span><br><span class="line">/usr/bin/ld: ../hw/9pfs/virtio-9p.o: in function `v9fs_mknod&apos;:</span><br><span class="line">/home/drac_zhang/Downloads/qemu/hw/9pfs/virtio-9p.c:2803: undefined reference to `makedev&apos;</span><br><span class="line">/usr/bin/ld: ../hw/9pfs/virtio-9p.o: in function `v9fs_create&apos;:</span><br><span class="line">/home/drac_zhang/Downloads/qemu/hw/9pfs/virtio-9p.c:2124: undefined reference to `makedev&apos;</span><br><span class="line">collect2: 错误：ld 返回 1</span><br></pre></td></tr></table></figure>
<p>差不多的理由，还是缺少库函数。也不管重复包含dirty不dirty了，向<code>hw/9pfs/virtio-9p.c</code>中添加<code>#include &lt;sys/sysmacros.h&gt;</code>，保存后再次编译。</p>
<p>因为类似的理由，还需要添加这个头文件的源文件有<code>linux-user/strace.c</code>。</p>
<h3 id="Lab-1-Booting-a-PC"><a href="#Lab-1-Booting-a-PC" class="headerlink" title="Lab 1 Booting a PC"></a>Lab 1 Booting a PC</h3><p>Lab1的源码可以从<code>https://pdos.csail.mit.edu/6.828/2018/jos.git</code>处clone到。</p>
<h4 id="Part-1-PC-bootstrap"><a href="#Part-1-PC-bootstrap" class="headerlink" title="Part 1 PC bootstrap"></a>Part 1 PC bootstrap</h4><p>这一部分的目的是让我们熟悉x86汇编语言和PC bootstrap过程，并熟悉QEMU和gdb的操作。</p>
<p>首先在lab目录下执行<code>make</code>命令来编译内核和启动器。编译完成的内核与启动器位于<code>obj/kern/kernal.img</code>镜像文件中，这个镜像文件是一个用于模拟真实硬盘的虚拟磁盘。</p>
<p>执行<code>make qemu</code>可以正式在qemu中运行编译好的操作系统，此时命令行终端会创建一个新的窗口，同时在终端中显示与窗口中同样的内容(并接受同样的输入)。方便起见，这里我们用终端进行接下来的操作。</p>
<p>一开始这个shell只有两条简单的指令：<code>help</code>和<code>kerninfo</code>。后者会打印出目前的内核状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Special kernel symbols:</span><br><span class="line">  _start                  0010000c (phys)</span><br><span class="line">  entry  f010000c (virt)  0010000c (phys)</span><br><span class="line">  etext  f01019df (virt)  001019df (phys)</span><br><span class="line">  edata  f0113060 (virt)  00113060 (phys)</span><br><span class="line">  end    f01136a0 (virt)  001136a0 (phys)</span><br><span class="line">Kernel executable memory footprint: 78KB</span><br></pre></td></tr></table></figure>
<p>要退出qemu可以打出<code>Ctrl+a x</code>。</p>
<h5 id="Layout-of-the-physical-address-space"><a href="#Layout-of-the-physical-address-space" class="headerlink" title="Layout of the physical address space"></a>Layout of the physical address space</h5><table>
<thead>
<tr>
<th>—————–</th>
<th>&lt;- 0xFFFFFFFF(4GB)</th>
</tr>
</thead>
<tbody>
<tr>
<td>内存映射的虚拟地址</td>
<td></td>
</tr>
<tr>
<td>—————–</td>
<td>&lt;- 取决于RAM的数量</td>
</tr>
<tr>
<td>扩展内存</td>
<td></td>
</tr>
<tr>
<td>—————–</td>
<td>&lt;- 0x00100000 (1MB)</td>
</tr>
<tr>
<td>BIOS所在的ROM</td>
<td></td>
</tr>
<tr>
<td>—————–</td>
<td>&lt;- 0x000F0000 (960KB)</td>
</tr>
<tr>
<td>16位机使用的扩展ROM</td>
<td></td>
</tr>
<tr>
<td>—————–</td>
<td>&lt;- 0x000C0000 (768KB)</td>
</tr>
<tr>
<td>VGA Display</td>
<td></td>
</tr>
<tr>
<td>—————–</td>
<td>&lt;- 0x000A0000 (640KB)</td>
</tr>
<tr>
<td>Low Memory</td>
<td></td>
</tr>
<tr>
<td>—————–</td>
<td>&lt;- 0x00000000</td>
</tr>
</tbody>
</table>
<p>对于一开始的16位机来说，它们只能使用一共最下面那1MB的物理存储，而可用的内存只有标识为Low Memory的640KB。VGA区是硬件保留区，用于当作视频播放缓冲区等。</p>
<p>就算是在Intel突破了“1MB的瓶颈”之后，PC设计师也仍然对于最低的1MB地址空间使用原始的架构，这是为了软件的向后兼容性。这样就在LowMemory和扩展内存之间留下了一个 <strong>空洞</strong> ，为那些16位的软硬件所使用。</p>
<p>在计算机从32位升级为64位时，BIOS在地址空间的最顶段因为类似的理由留下了第二个空洞。</p>
<h5 id="The-ROM-BIOS"><a href="#The-ROM-BIOS" class="headerlink" title="The ROM BIOS"></a>The ROM BIOS</h5><p>为了单步调试计算机的启动过程，我们需要两个终端，一个用<code>make qemu-gdb</code>来启动qemu虚拟机，一个用<code>make gdb</code>来将gdb调试环境连接到虚拟机上。</p>
<p><code>make qemu-gdb</code>会将处理器暂停在即将执行第一条指令之前并等待gdb的连接，这时在另一个终端中使用<code>make gdb</code>就可以通过gdb来调试操作系统内核。</p>
<p>gdb终端会显示一段结尾如下的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The target architecture is assumed to be i8086</span><br><span class="line">[f000:fff0]    0xffff0: ljmp   $0xf000,$0xe05b</span><br><span class="line">0x0000fff0 in ?? ()</span><br><span class="line">+ symbol-file obj/kern/kernel</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>其中的第二行代表着目前将要执行的指令，也就是虚拟机开启过程的第一条指令。</p>
<p>这条指令的含义是：</p>
<ul>
<li><code>0xffff0:</code>：指令位于的虚拟存储系统地址，对应于上面的架构，这个位置是属于BIOS的ROM区域的最上面，也就是BIOS程序的起始位置。</li>
<li><code>[f000:fff0]</code>：指示当前CS和IP寄存器的值。CS寄存器指示代码所在的数据段，IP则是偏移量。</li>
<li><code>ljmp</code>：跳转指令，跳转到CS和IP为<code>[f000:e05b]</code>的位置，转换成存储地址就是<code>0xfe05b</code>。<ul>
<li>CS和IP寄存器与物理地址的转换规则为<code>ADDR = CS&lt;&lt;4 + IP</code>。</li>
</ul>
</li>
</ul>
<p>保证启动时优先执行BIOS代码是很重要的，因为一开始内存中根本不会有其他可以执行的代码。BIOS会初始化所有启动所需要的重要设备，检查内存和磁盘的挂载情况。最后，就像操作系统课程中所学的那样，它找到磁盘上的boot loader并将控制权转移给它。</p>
<ul>
<li>对GDB使用<code>si</code>命令可以继续单步调试之后的汇编代码，观察BIOS所做的工作。</li>
</ul>
<h4 id="Part-2-The-boot-loader"><a href="#Part-2-The-boot-loader" class="headerlink" title="Part 2 The boot loader"></a>Part 2 The boot loader</h4><p>众所周知，软盘和硬盘都被分成大小为<code>512字节</code>的段，而这些段是系统级IO的最小单位。如果一个磁盘是启动盘，那么它的第一个段就被称为 <strong>boot sector</strong> ，并被存放boot loader的代码。当BIOS找到一个boot sector后，它就会将其加载到内存中，并将控制权转交给boot loader代码段。</p>
<p>(对于CD-ROM来说，它的前2M都属于boot sector，因此可以存放更大的启动镜像)</p>
<p>在6.828文件夹中，boot loader的代码存放于<code>boot/boot.S</code>与<code>boot/main.c</code>中。这些代码主要完成两件事：</p>
<ol>
<li>将处理器模式切换到<code>32位保护模式</code>，这样软件才可以访问大于1MB的物理地址空间。这个工作由<code>boot.S</code>完成。除此之外，<code>boot.S</code>还要建立一个程序栈，让C程序得以运行。</li>
<li>将内核代码从硬盘中加载到内存，并将控制转交给内核代码的入口函数。这个工作由<code>main.c</code>完成。</li>
</ol>
<p>阅读<code>main.c</code>的代码可以发现很多 <del>非常dirty的</del> 细节(<del>包括但不限于：使用goto，while(1)代替sleep，写的很乱的函数指针</del>)，如果对于这个过程的细节感兴趣可以直接阅读源码，注释写的很详细明白。</p>
<p>bootloader的代码会被BIOS加载到<code>0x7c00</code>，这是由<code>boot/Makefrag</code>文件所决定的。修改这个文件中<code>-Ttext</code>参数后面的地址可以让BIOS从其他地址来加载，执行<code>make clean &amp;&amp; make</code>重新编译可以查看这样做会引发什么样的系统错误(事实上系统会停机并进入一个无限循环等待用户的操作)；在GDB调试时可以在这个位置设置断点，以精确地进入bootloader代码段。</p>
<p><code>obj/boot/boot.asm</code>和<code>obj/kern/kernel.asm</code>分别包含着bootloader和kernel的反汇编结果以及注释，可以用于调试和分析。下面就来分析一下BootLoader的代码逻辑。</p>
<ul>
<li>BootLoader代码逻辑研究<ul>
<li>第一阶段：<strong>初始化</strong><ul>
<li><strong>宏常量的设定</strong>：<code>.set CR0_PE_ON 0x1</code> 这个常量是控制32位保护模式开关的指标。</li>
<li><strong>全局设置</strong>：<code>cli</code>指令关闭中断处理，<code>cld</code>指令将串操作的内存地址访问模式设为增序</li>
<li><strong>寄存器初始化</strong>：用xor和mov指令将几个关键寄存器清零<ul>
<li><code>ds</code>：数据段寄存器，存放全局变量区域的头指针</li>
<li><code>ss</code>：栈段寄存器，存放堆栈段的首地址(<code>esp</code>寄存器存储的是偏移量)</li>
<li><code>es</code>：扩展段寄存器</li>
</ul>
</li>
</ul>
</li>
<li>第二阶段：<strong>打开32位保护模式</strong><ul>
<li><strong>开启A20地址线</strong>：在16位模式下，用于寻址的地址总线只有20根，这种情况下大于1MB的地址空间是全部被置为0的。只有开启20～23号四条地址线，才能对1MB以上的地址空间进行寻址，从而进入32位模式。<ul>
<li>通过一个循环来等待A20设备准备完毕：用<code>in</code>指令从<code>0x64</code>端口接受信息，如果不是代表准备完毕的信息则继续循环。</li>
<li>向<code>0x64</code>和<code>0x60</code>端口发送信号，打开A20地址线。</li>
</ul>
</li>
<li><strong>建立32位段虚拟内存与物理存储器的映射关系表</strong>：<code>lgdt gdtdesc</code>指令。</li>
<li><strong>启动32位保护模式</strong>：用<code>CR0_PE_ON</code>与<code>cr0</code>寄存器的值做或运算，打开32位保护模式。<code>cr0</code>到<code>cr3</code>四个寄存器是系统控制寄存器，它们的值直接决定系统的运行状态。<code>cr0</code>控制的是处理器，因此可以通过修改其值来进入其他运行模式。</li>
<li><strong>跳转到32位代码区的下一条指令</strong>。</li>
</ul>
</li>
<li>第三阶段：修改段寄存器的值为32位区地址，初始化<code>esp</code>寄存器的值，建立C程序栈</li>
<li>第四阶段：进入<code>main.c</code>的bootmain函数，开始读取内核代码。</li>
<li>第五阶段：跳转到内核代码区，交还控制权。</li>
</ul>
</li>
</ul>
<blockquote>
<h5 id="习题解答"><a href="#习题解答" class="headerlink" title="习题解答"></a>习题解答</h5><p>Q: 处理器什么时候开始执行32位代码？哪条指令切换了处理器模式？</p>
<p>A：<code>0x7c2a:  mov    %eax,%cr0</code>指令切换了处理器模式，从随后的跳转指令开始，处理器开始执行32位代码。</p>
<p>Q：Bootloader执行的最后一条指令是什么？Kernal执行的第一条指令又是什么?</p>
<p>A：Bootloader执行的最后一条指令是向内核代码段跳转的指令<code>0x7d71:      call   *0x10018</code>，kernel执行的第一条指令是<code>0x10000c:    movw   $0x1234,0x472</code>。</p>
<p>Q：Bootloader是如何决定它要读取多少数据的？它从哪里获取的kernal大小信息？</p>
<p>A：Bootloader首先从内核代码区读取了长度固定的ELF头部，再从头部中获取了这个区域是否为ELF文件、数据段数量、每段的长度、起始地址等信息。</p>
</blockquote>
<p>(课程网页在这一部分讲了一大堆ELF头和指针的知识，如果已经学过CSAPP第7章的话完全可以跳过。需要注意的是，6.828所采用的可执行目标文件代码 <strong>并非是位置无关代码</strong> ，因而 <strong>链接器会将程序将加载到的内存位置写在文件中</strong> 。利用这一点，我们可以执行<code>objdump -f &lt;filename&gt;</code>命令，获取程序在内存中的入口位置。)</p>
<h4 id="Part-3-The-kernel"><a href="#Part-3-The-kernel" class="headerlink" title="Part 3 The kernel"></a>Part 3 The kernel</h4><p>在内核被授予控制权后，它要做如下几件事：</p>
<h5 id="Virtual-memory-address-mapping"><a href="#Virtual-memory-address-mapping" class="headerlink" title="Virtual memory address mapping"></a>Virtual memory address mapping</h5><p>当我们观察bootloader程序的时候，我们可以发现它的 <strong>链接地址</strong>(指用<code>objdump -h</code>打印出来的ELF节头部信息中的<code>LMA</code>，linked memory address) 和 <strong>虚拟地址</strong>(指用<code>objdump -h</code>打印出来的ELF节头部信息中的<code>VMA</code>，virtual memory address) 是完全一致的；然而对于kernel，这两个地址却有着不小的差距。</p>
<p>操作系统内核常常会在非常高的虚拟地址空间(例如0xf0100000)运行，这是为了把比较低的虚拟地址空间留给用户进程使用。然而大部分机器没有这么多的内存，于是它们将虚拟地址0xf0100000映射到物理地址0x00100000。这样一来虽然内核所在的加载地址很高，它的实际加载地址却是位于RAM区域的最底端，挨着BIOS所在的ROM地址区域。</p>
<p>虚拟地址映射操作是由专门的硬件来完成的，要打开虚拟地址映射只需要对<code>cr0</code>寄存器设置<code>CR0_PG</code>标志，就像之前打开32位保护模式所做的那样。</p>
<p>kernal被加载的地址为0x100000,因此它从此处开始运行。它所做的第一项工作就是打开虚拟地址映射，然后跳转到虚拟地址<code>0xf010002f</code>的位置，恰好对应于物理地址中下一条指令所在的位置。这样，内核就自然地实现了从物理地址到虚拟地址的转换。</p>
<h5 id="Formatted-printing-to-the-console"><a href="#Formatted-printing-to-the-console" class="headerlink" title="Formatted printing to the console"></a>Formatted printing to the console</h5><p>在完成虚拟地址映射之后，下一步是对终端进行格式化输入输出以创建交互式操作界面。</p>
<p><code>lib/printfmt.c</code>中提供了输出函数的原型，<code>kern/printf.c</code>和<code>kern/console.c</code>则提供了有关内核输出和交互的函数。</p>
<blockquote>
<p><strong>Answer to Exercise 8</strong></p>
<p>本题要求补全printfmt函数对于<code>%o</code>(8进制输出)的处理机制，只需要仿照下面十六进制的机制即可。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">  num = getuint(&amp;ap, lflag);</span><br><span class="line">  base = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">goto</span> number;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>习题解答</strong></p>
<p>Q：解释printf.c和console.c之间的接口，尤其是console.c中的哪个函数被如何用于printf.c。</p>
<p>A：console.c向printf.c提供了cputchar函数,它希望在调用printf.c中的输出函数时可以利用cputchar函数来输出每一个字符。printf.c遵守这个约定,以包含cputchar的外壳函数调用printfmt.c中的输出函数,保证了所有输出都按照console.c所规定的标准来输出。</p>
<p>Q：解释console.c中的这一段代码:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">  <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">    crt_buf[i] = <span class="number">0x0700</span> | <span class="string">' '</span>;</span><br><span class="line">    crt_pos -= CRT_COLS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>A：</p>
<p>这段代码来自cga_putc函数,这个函数是在CGA显示屏图形卡上打印字符的函数。crt_pos是一个整形全局变量,它的含义是目前光标在屏幕上的位置。阅读<code>console.h</code>的内容可以发现CRT_SIZE被定义为屏幕上能够容纳的字符个数,而CRT_COLS则是屏幕的宽度。</p>
<p>条件判断是为了确认当前光标的位置是否已经超出了屏幕底端。如果超出了，就把屏幕上第二行到最后一行的内容全部上移一行，并将空出来的位置用<code>0x0700 | &#39; &#39;</code>填满。</p>
<p>总而言之，这段代码是为了实现屏幕满了之后向上滚动的功能。</p>
<p>Q：单步调试如下代码：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</span><br><span class="line">cprintf(<span class="string">"x %d, y %x, z %d\n"</span>, x, y, z);</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>在对cprintf的调用中，fmt对应的实参是什么？ap呢？</li>
<li>列出对<code>cons_putc</code>, <code>va_arg</code>和<code>vcprintf</code>的每一次调用，以及<code>cons_putc</code>的参数,<code>va_arg</code>中ap的指向和<code>vcprintf</code>的参数值。</li>
</ol>
<p>A：</p>
<ol>
<li>fmt对应的实参是<code>&quot;x %d, y %x, z %d\n&quot;</code>，ap指向带有x，y和z的参数数组。</li>
<li>甚至不需要单步调试，自己阅读<code>lib/printfmt.c</code>就足够了。</li>
</ol>
<p>Q：运行如下代码：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line">cprintf(<span class="string">"H%x Wo%s"</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释输出结果。如果这段代码运行在大端序机器上而非小端序机器上，你会如何修改它来得到同样的结果？</p>
<p>A：输出结果是<code>He110 World</code>。前面的e110是57616在十六进制下的表示(因为使用了<code>%x</code>)，后面的rld是字符串输出的结果。int占4个字节而每个字符占一个字节，因而i所占的内存空间与一个长度为4的字符数组是相同的。这样一来，如果用i的地址去输出字符串，就会从i的地址开始按字符去读取内存中的数据，直到读到0为止。由于运行在小端序机器，0x72排在最前面一个字节，被解析成ASCII码值为0x72的<code>r</code>；接下来0x6c和0x64分别被解释为<code>l</code>和<code>d</code>。最后一个字节是0x00,正好是字符串终结符。</p>
<p>如果机器是大端序，只需要将i修改为<code>0x726c6400</code>即可，57616不需要改变。</p>
<p>Q：被<code>cprintf(&quot;x=%d y=%d&quot;, 3);</code>打印出的y值会是多少？为什么？</p>
<p>A：会是一个随机的整形数。因为cprintf解析到了两个<code>%d</code>符号，但<code>ap</code>的长度只有1,这导致第二个<code>%d</code>读到了一片未赋值的内存地址，其值自然是随机的。</p>
</blockquote>
<h5 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h5><p>(仔细读过CSAPP第三章的话汇编语言和程序栈这一块应该没问题了，就不说了)</p>
<blockquote>
<p><strong>Answer to Exercise 9</strong></p>
<p>Q：确定内核在什么时候初始化程序栈及程序栈的初始位置。内核是如何为栈保存空间的？</p>
<p>A：<code>f010034: mov $0xf0110000, %esp</code>：这一条指令初始化了栈指针，将程序栈建立于虚拟地址<code>0xf0110000</code>位置。从这个地址开始，程序栈随着程序运行向下增长。</p>
</blockquote>
<p><code>ebp</code>指针被称为“基指针”，它的作用是追踪每个函数的栈帧位置。每个被调用的C函数都要进行如下操作：将ebp寄存器的值压栈、将当前esp指针值拷贝到ebp寄存器。在返回之前，这个函数从栈中取出并恢复ebp寄存器的值。通过这种机制，<strong>任何时候ebp寄存器的值都指向正在执行的函数的栈帧头部，而栈帧头部的前一个数据节的值指向该函数调用者的栈帧头部</strong>，于是可以通过ebp链来还原函数调用链。</p>
<blockquote>
<p><strong>Answer to Exercise 10</strong></p>
<p>这个Exercise的目的是让学生熟悉backtrace的操作和C的程序栈结构。在kernel中有一个自我递归的<code>test_backtrace</code>函数,通过对这个函数打上断点可以使用<code>p $ebp</code>获取每次调用的栈帧起始位置.</p>
<p>第一次调用:栈帧的起始位置为<code>0xf010ffd8</code><br>第二次调用:栈帧的起始位置为<code>0xf010ffb8</code></p>
<p>可以看出这个函数的每个栈帧大小都是<code>0x20</code>,也就是32个字节，对于32位系统来说是八个数据。</p>
<p>使用<code>x/xw</code>命令查看从<code>0xf010ffe0</code>开始整个栈帧的结构。(因为32位系统每个数据是四个字节，所以使用<code>x/xw</code>来查看)</p>
<p><code>x/xw 0xf010ffe0</code>：<code>0x00000005</code> 按照栈帧的结构，这个位置应该是调用者压入栈内的参数。第一次对<code>test_backtrace</code>的调用的确只有一个实参5。</p>
<p><code>x/xw 0xf010ffdc</code>：<code>0xf01000f4</code> 由于栈帧是向下的，这条指令其实查看的是上一个栈帧的最后一部分，也就是函数的返回地址，经验证的确指向调用者的下一条指令。</p>
<p><code>x/xw 0xf010ffd8</code>：<code>0xf010fff8</code> 当前函数栈帧的第一部分，保存着上一个函数的基指针值(<code>%ebp</code>的值)，由于上一个函数已经是整个程序栈底部的函数了，这个地址向上就没有数据了，上个函数的基指针指向的是物理内存区的函数。</p>
<p><code>x/xw 0xf010ffd4</code>：<code>0x000100b4</code> 被调用者保存的<code>%esi</code>寄存器的值 </p>
<p><code>x/xw 0xf010ffd0</code>：<code>0xf011304c</code> 被调用者保存的<code>%ebx</code>寄存器的值</p>
<p><code>x/xw 0xf010ffcc</code>：<code>0xf010004a</code> 是<code>test_backtrace</code>中一行代码的地址</p>
<p><code>x/xw 0xf010ffc8</code>：<code>0x00000000</code> 空的，没有数据</p>
<p><code>x/xw 0xf010ffc4</code>：<code>0x00000005</code> 局部变量5</p>
<p><code>x/xw 0xf010ffc0</code>：<code>0x00000004</code> 即将进行下一次递归调用，这是压入的参数4</p>
<p>再往下就是返回地址，然后就是下一个栈帧。总的来说，<code>test_backtrace</code>函数的栈帧结构就是这样。</p>
</blockquote>
<p>完成了对栈帧结构的观察后，就可以利用观察结果去做一下任务了。Exercise 11要求我们实现一个<code>mon_backtrace</code>函数，它记录并打印出栈帧信息。<code>inc/x86.h</code>中提供了<code>read_ebp()</code>函数可以直接返回ebp寄存器的值。</p>
<p>输出格式规定如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack backtrace:</span><br><span class="line">  ebp f0109e58  eip f0100a62  args 00000001 f0109e80 f0109e98 f0100ed2 00000031</span><br><span class="line">  ebp f0109ed8  eip f01000d6  args 00000000 00000000 f0100058 f0109f28 00000061</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Answer to Exercise 11</strong></p>
<p>本题要求是按上面的要求修改<code>kern/monitor.c</code>中的<code>mon_backtrace</code>函数，并将其添加到指令集中。</p>
<p>对代码的修改如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一处修改</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Command</span> <span class="title">commands</span>[] = &#123;</span></span><br><span class="line">        &#123; <span class="string">"help"</span>, <span class="string">"Display this list of commands"</span>, mon_help &#125;,</span><br><span class="line">        &#123; <span class="string">"kerninfo"</span>, <span class="string">"Display information about the kernel"</span>, mon_kerninfo &#125;,</span><br><span class="line">        &#123; <span class="string">"backtrace"</span>, <span class="string">"Display the structure of the stack"</span>, mon_backtrace &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第二处修改</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Your code here.</span></span><br><span class="line">        cprintf(<span class="string">"Stack backtrace:\n"</span>);</span><br><span class="line">        <span class="keyword">int</span> ebp = read_ebp();</span><br><span class="line">        <span class="keyword">int</span> eip = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">int</span> args[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                args[i] = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>*i + <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,ebp,eip,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],args[<span class="number">3</span>],args[<span class="number">4</span>]);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                ebp = *(<span class="keyword">int</span> *)ebp;</span><br><span class="line">                <span class="keyword">if</span> (!ebp) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> eip = *(<span class="keyword">int</span> *)(ebp+<span class="number">4</span>);</span><br><span class="line">                <span class="keyword">int</span> args[<span class="number">5</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                        args[i] = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>*i + <span class="number">8</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,ebp,eip,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],args[<span class="number">3</span>],args[<span class="number">4</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Exercise 12要求我们升级这个函数，使其支持如下的输出格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stack backtrace:</span><br><span class="line">  ebp f010ff78  eip f01008ae  args 00000001 f010ff8c 00000000 f0110580 00000000</span><br><span class="line">         kern/monitor.c:143: monitor+106</span><br><span class="line">  ebp f010ffd8  eip f0100193  args 00000000 00001aac 00000660 00000000 00000000</span><br><span class="line">         kern/init.c:49: i386_init+59</span><br><span class="line">  ebp f010fff8  eip f010003d  args 00000000 00000000 0000ffff 10cf9a00 0000ffff</span><br><span class="line">         kern/entry.S:70: &lt;unknown&gt;+0</span><br></pre></td></tr></table></figure>
<p>为了根据eip找到函数名，行数和文件名等一系列信息，<code>kern/kdebug.c</code>中提供了<code>debuginfo_eip()</code>函数，我们需要完整地实现<code>debuginfo_eip()</code>函数，并在<code>mon_backtrace</code>中调用这个函数来获得信息。</p>
<blockquote>
<p><strong>Answer to Exercise 12</strong></p>
<p>在<code>debuginfo_eip</code>函数中有一些以<code>__STAB_</code>开头的宏常量,它们所代表的是ELF文件中<code>.stab</code>(在CSAPP中是<code>.symtab</code>)区的开头和结尾位置,以及<code>.stabstr</code>(在CSAPP中是<code>.strtab</code>)区的开头和结尾位置,它们是在链接过程中由<code>kernal.ld</code>定义的。</p>
<p>以下是修改内容：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kern/monitor.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Your code here.</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">        cprintf(<span class="string">"Stack backtrace:\n"</span>);</span><br><span class="line">        <span class="comment">// Parse the structure of the stack</span></span><br><span class="line">        <span class="keyword">int</span> ebp = read_ebp();</span><br><span class="line">        <span class="keyword">int</span> eip = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">int</span> args[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                args[i] = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>*i + <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Print some information in restricted format.</span></span><br><span class="line">        cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,ebp,eip,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],args[<span class="number">3</span>],args[<span class="number">4</span>]);</span><br><span class="line">        <span class="comment">// Exercise 12, get the debuginfo by eip</span></span><br><span class="line">        debuginfo_eip(eip, &amp;info);</span><br><span class="line">        cprintf(<span class="string">"         %s:%d: "</span>,info.eip_file, info.eip_line);</span><br><span class="line">        <span class="comment">// info.eip_fn_name is a non-null-terminated string</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;info.eip_fn_namelen;i++) cprintf(<span class="string">"%c"</span>,*(info.eip_fn_name+i));</span><br><span class="line">        cprintf(<span class="string">"+%d\n"</span>,eip - info.eip_fn_addr);</span><br><span class="line">        <span class="comment">// Backtracing</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                ebp = *(<span class="keyword">int</span> *)ebp;</span><br><span class="line">                <span class="keyword">if</span> (!ebp) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> eip = *(<span class="keyword">int</span> *)(ebp+<span class="number">4</span>);</span><br><span class="line">                <span class="keyword">int</span> args[<span class="number">5</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                        args[i] = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>*i + <span class="number">8</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,ebp,eip,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],args[<span class="number">3</span>],args[<span class="number">4</span>]);</span><br><span class="line">                debuginfo_eip(eip, &amp;info);</span><br><span class="line">                cprintf(<span class="string">"         %s:%d: "</span>,info.eip_file, info.eip_line);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;info.eip_fn_namelen;i++) cprintf(<span class="string">"%c"</span>,*(info.eip_fn_name+i));</span><br><span class="line">                cprintf(<span class="string">"+%d\n"</span>,eip - info.eip_fn_addr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kern/kdebug.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">debuginfo_eip(<span class="keyword">uintptr_t</span> addr, struct Eipdebuginfo *info)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line">    stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</span><br><span class="line">    <span class="keyword">if</span> (lline &lt;= rline) info-&gt;eip_line = stabs[lline].n_desc;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此Lab1结束。运行<code>make grade</code>，<code>50/50</code>大成功。</p>
<h3 id="Lab2-Memory-Management"><a href="#Lab2-Memory-Management" class="headerlink" title="Lab2 Memory Management"></a>Lab2 Memory Management</h3><p>在这个Lab中，我们需要实现操作系统的内存管理系统。内存管理系统包括两个部分：</p>
<ul>
<li>物理内存调度：我们要实现一个以4096个字节大小的页为单位的内存分配器，它将空闲的内存分配给内核和用户，并释放使用完的内存。</li>
<li>虚拟内存映射</li>
</ul>
<p>执行<code>git checkout -b lab2 origin/lab2</code>命令切换到lab2分支，执行<code>git merge lab1</code>合并在lab1所做的更改。</p>
<p>Lab2增加的文件有：</p>
<ul>
<li><code>inc/memlayout.h</code>：定义描述虚拟内存空间的布局的函数，定义PageInfo结构体</li>
<li><code>kern/pmap.c</code>和<code>kern/pmap.h</code>：实现<code>inc/memlayout.h</code>中定义的函数</li>
<li><code>kern/kclock.c</code>和<code>kern/kclock.h</code>：与CMOS硬件沟通，读取PC的硬件信息</li>
</ul>
<p><code>inc/mmu.h</code>同样可能对这个lab有所帮助。</p>
<h4 id="Part-1-Physical-page-management"><a href="#Part-1-Physical-page-management" class="headerlink" title="Part 1 Physical page management"></a>Part 1 Physical page management</h4><p>在这个部分我们需要实现物理内存管理器。这个函数追踪一个由<code>PageInfo</code>结构体组成的链表(这个链表的节点代表着一页未分配的内存)，并负责物理内存的分配和回收。</p>
<p>6.828的代码充满了缩写这种使人不明所以的命名,且有些地方码风诡异,因而将一些可能用到的概念和缩写列举如下:</p>
<ul>
<li><code>K</code>和<code>P</code>:带K的标识符往往指<code>kernel</code>,与内核虚拟内存有关；而带P的标识符指<code>physical</code>,与物理存储有关</li>
<li><code>kva</code>:<code>kernel virtual address</code>的简写</li>
<li><code>pa</code>:<code>physical address</code>的简写</li>
<li><code>la</code>:<code>linear address</code>,</li>
</ul>
<p>为了实现目标功能的代码，我们需要调用许多定义好的函数或者宏，为了方便查看和使用将所有可能需要使用的函数和宏列举如下：</p>
<ul>
<li><code>pmap.h</code>:<ul>
<li><code>PADDR(addr)</code>:将虚拟地址addr转换为物理地址返回</li>
<li><code>KADDR(addr)</code>:将物理地址addr转换为虚拟地址返回</li>
<li><code>page2pa(PageInfo*)</code>:将PageInfo结构体转换为对应Page的物理地址</li>
<li><code>pa2page(addr)</code>:将物理地址转换为pages数组中的PageInfo</li>
<li><code>page2kva(PageInfo*)</code>:将PageInfo结构体转换为对应Page的虚拟地址</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2018/11/24/用自己建造的DockerImage创建k8s容器/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/24/用自己建造的DockerImage创建k8s容器/" itemprop="url">用自己建造的DockerImage创建k8s容器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-24T14:40:37+08:00">
                2018-11-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Technical/Cluster/" itemprop="url" rel="index">
                    <span itemprop="name">Cluster</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2018/11/24/用自己建造的DockerImage创建k8s容器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/11/24/用自己建造的DockerImage创建k8s容器/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="用自己建造的DockerImage创建k8s容器"><a href="#用自己建造的DockerImage创建k8s容器" class="headerlink" title="用自己建造的DockerImage创建k8s容器"></a>用自己建造的DockerImage创建k8s容器</h2><p>本篇文章记载了定制k8s容器以满足实验需要的具体方法，以供参考。</p>
<h3 id="构建需要的DockerFile"><a href="#构建需要的DockerFile" class="headerlink" title="构建需要的DockerFile"></a>构建需要的DockerFile</h3><p>kubernetes的Pod是以docker容器为基础的，因此每个pod在创建时都需要提供一个基础的容器镜像。因此，要定制一个符合我们需求的Pod，就需要先定制容器镜像。</p>
<p>Docker提供的定制镜像的方式是 <strong>Dockerfile</strong> 。关于Dockerfile的具体写法参见<a href="https://docs.docker.com/v17.09/engine/reference/builder/" target="_blank" rel="noopener">Reference</a></p>
<p>「示例」这是一个简单的CounterImage的DockerFile：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu                     # 每个DockerFile必须在开头用FROM语句指明其母镜像</span><br><span class="line">COPY counter.sh /etc/           # COPY指令可以将目标文件拷贝到镜像内的目标目录中</span><br><span class="line">RUN chmod +x /etc/counter.sh    # RUN指令让目标镜像执行指定指令</span><br></pre></td></tr></table></figure>
<h3 id="用DockerFile建造DockerImage"><a href="#用DockerFile建造DockerImage" class="headerlink" title="用DockerFile建造DockerImage"></a>用DockerFile建造DockerImage</h3><p>写好DockerFile之后，执行<code>docker build</code>指令来构建镜像。</p>
<ul>
<li>关于<code>docker build</code>的参数问题<ul>
<li><code>-f &lt;filepath&gt;</code> 指定DokcerFile的位置，默认在当前目录下寻找DockerFile</li>
<li><code>-t &lt;tag&gt;</code> 为创建的镜像指定tag，tag格式一般是<code>&lt;repo&gt;/&lt;imagename&gt;:&lt;version&gt;</code></li>
</ul>
</li>
</ul>
<p>执行完毕之后，构建好的DockerImage可以用<code>docker images</code>查看到。</p>
<h3 id="用kubectl创建pod"><a href="#用kubectl创建pod" class="headerlink" title="用kubectl创建pod"></a>用kubectl创建pod</h3><p>用kubectl构建pod需要用yaml或json文件指定pod的属性。</p>
<p>「示例」这是用于运行CounterImage实例的Pod配置文件</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> <span class="comment"># 指定k8s版本，一般是v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>      <span class="comment"># 指定要创建的对象的类型，这里是Pod</span></span><br><span class="line"><span class="attr">metadata:</span>      <span class="comment"># 元数据，指定Pod信息</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">testpod</span>   <span class="comment"># 指定Pod的名称</span></span><br><span class="line"><span class="attr">  annotations:</span>    <span class="comment"># 一些必要的注释，可以用于传递信息</span></span><br><span class="line"><span class="attr">spec:</span>          <span class="comment"># 一些其他信息</span></span><br><span class="line"><span class="attr">  containers:</span>     <span class="comment"># 指定Pod使用的基础镜像</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">testcontainer</span>               <span class="comment"># 指定将要创建的容器名称，这个不重要</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">drac/counter:v1</span>            <span class="comment"># 指定使用的镜像名称，这里使用刚刚创建的镜像名</span></span><br><span class="line"><span class="attr">      imagePullPolicy:</span> <span class="string">"IfNotPresent"</span>   </span><br><span class="line">      <span class="comment"># 由于刚刚的镜像并没有上传到远程仓库中，这里需要指定镜像拉取策略为优先使用本地镜像</span></span><br><span class="line"><span class="attr">      command:</span>                          <span class="comment"># 指定容器要运行的指令</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">"etc/counter.sh"</span></span><br><span class="line"><span class="attr">      ports:</span>                            <span class="comment"># 指定容器对外开放的端口</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">8086</span></span><br><span class="line"><span class="attr">          hostPort:</span> <span class="number">8086</span></span><br><span class="line"><span class="attr">  tolerations:</span>    </span><br><span class="line">  <span class="comment"># 这个属性与node的taints有关，由于master节点默认不能调度pods，这里要设置一些tolerations</span></span><br><span class="line"><span class="attr">    - key:</span> <span class="string">"node.kubernetes.io/not-ready"</span></span><br><span class="line"><span class="attr">      operator:</span> <span class="string">"Exists"</span></span><br><span class="line"><span class="attr">      effect:</span> <span class="string">"NoSchedule"</span></span><br><span class="line"><span class="attr">    - key:</span> <span class="string">"node-role.kubernetes.io/master"</span></span><br><span class="line"><span class="attr">      operator:</span> <span class="string">"Exists"</span></span><br><span class="line"><span class="attr">      effect:</span> <span class="string">"NoSchedule"</span></span><br></pre></td></tr></table></figure>
<p>写好配置文件之后，就可以用<code>kubectl create -f &lt;配置文件名&gt;</code>来创建pod了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2018/11/04/在archlinux上单机搭建kubernetes/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/04/在archlinux上单机搭建kubernetes/" itemprop="url">在archlinux上单机搭建kubernetes</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-04T21:38:22+08:00">
                2018-11-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Technical/Cluster/" itemprop="url" rel="index">
                    <span itemprop="name">Cluster</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2018/11/04/在archlinux上单机搭建kubernetes/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/11/04/在archlinux上单机搭建kubernetes/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="kubernetes单机搭建流程"><a href="#kubernetes单机搭建流程" class="headerlink" title="kubernetes单机搭建流程"></a>kubernetes单机搭建流程</h2><p>由于工作需要，今天试着在archlinux主机上搭建了k8s。网上完全没有针对archlinux系统的配置教程，因此踩了很多坑，现将archlinux下的搭建流程记录如下。</p>
<h4 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h4><h5 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h5><ul>
<li><code>docker</code>：k8s中担任container职责的依赖，必须安装</li>
<li><code>sudo swapoff -a</code>：k8s的运行不支持内存交换，所以要关掉swap分区</li>
<li><code>ss</code>和<code>privoxy</code>：提供代理环境(k8s的镜像源多是google，而google相关网站大部分被GFW墙掉了)<ul>
<li><strong>注意：</strong>privoxy的监听端口应配置为8008(kubeadm的默认端口)</li>
</ul>
</li>
</ul>
<h5 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h5><p>手动编译kubernetes对内存要求过高，<del>OOM了3次</del>，只好另寻他途。</p>
<p>幸运的是，<code>kubeadm</code>,<code>kubectl</code>,<code>kubelet</code>,<code>kubernetes-cni</code>四项依赖的bin文件都有AUR包，可以用<code>yaourt</code>或者<code>yay</code>来下载。在下载时注意选择二进制文件(即<code>&lt;name&gt;-bin</code>)并提前打开privoxy代理映射。</p>
<p>(注意：这几个包的镜像源服务器都不支持axel，所以请将yay的下载工具换为wget)</p>
<h5 id="初始化集群"><a href="#初始化集群" class="headerlink" title="初始化集群"></a>初始化集群</h5><p>首先要设置docker的代理(这里的代理端口设置与privoxy的设置保持一致)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建conf文件</span></span><br><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line">sudo vim /etc/systemd/system/docker.service.d/http-proxy.conf</span><br><span class="line"><span class="comment"># 在新建的conf文件中加入如下内容</span></span><br><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">"HTTP_PROXY=http://127.0.0.1:8008/"</span></span><br><span class="line"><span class="comment"># 创建conf文件</span></span><br><span class="line">sudo vim /etc/systemd/system/docker.service.d/https-proxy.conf</span><br><span class="line"><span class="comment"># 在新建的conf文件中加入如下内容</span></span><br><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">"HTTPS_PROXY=http://127.0.0.1:8008/"</span></span><br><span class="line"><span class="comment"># 重启service</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>执行<code>sudo kubeadm init --pod-network-cidr=10.244.0.0/16</code>，根据显示的提示信息补全依赖，启动service后再次执行。</p>
<p>在init成功后根据显示的提示信息创建config文件。</p>
<p>执行<code>kubectl get pods --all-namespaces</code>，如果正常显示pods信息则说明正常。</p>
<p>接下来安装网络模块(这里使用的是<code>flannel</code>，当然其他模块也可以，只是要在init的时候指定相应的<code>pod-network-cidr</code>)，执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/bc79dd1505b0c8681ece4de4c0d86c5cd2643275/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>
<p>安装好flannel模块之后，如果<code>/etc/cni</code>文件夹没有被创建，coredns无法正常创建容器，可以在root身份下执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/cni/net.d/</span><br><span class="line">cat &lt;&lt;EOF&gt; /etc/cni/net.d/10-flannel.conf</span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"cbr0"</span>,<span class="string">"type"</span>:<span class="string">"flannel"</span>,<span class="string">"delegate"</span>: &#123;<span class="string">"isDefaultGateway"</span>: <span class="literal">true</span>&#125;&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>来进行配置。</p>
<p>这里如果出现问题可以参考<a href="https://blog.csdn.net/qq_34857250/article/details/82562514" target="_blank" rel="noopener">这篇博客</a></p>
<p>执行<code>watch kubectl get pods --all-namespaces</code>，等待一到两分钟，所有pods状态都为running则说明安装成功。(期间各种crash都是有可能的，耐心等待它自己重启即可)</p>
<h5 id="部署服务"><a href="#部署服务" class="headerlink" title="部署服务"></a>部署服务</h5><p>搭建大成功，接下来只要部署具体的service就可以了。</p>
<h4 id="常见问题及解决方案"><a href="#常见问题及解决方案" class="headerlink" title="常见问题及解决方案"></a>常见问题及解决方案</h4><ul>
<li><p>非root用户使用kubectl时出现错误</p>
<ul>
<li><p>错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unable to connect to the server: net/http: TLS handshake timeout</span><br></pre></td></tr></table></figure>
</li>
<li><p>状态：暂未解决</p>
</li>
<li>折中方案：将config文件放在root目录的<code>.kube</code>目录下，用sudo运行kubectl</li>
</ul>
</li>
<li><p>flannel网络模块安装之后coredns无法正常创建容器</p>
<ul>
<li><p>错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed create pod sandbox: rpc error: code = Unknown desc = [failed to set up sandbox container &quot;dd087d2655e98a25040f7b041e23dffa59aa52206b921e481ad20781d1de4320&quot; network for pod &quot;coredns-86c58d9df4-gtrt4&quot;: NetworkPlugin cni failed to set up pod &quot;coredns-86c58d9df4-gtrt4_kube-system&quot; network: failed to find plugin &quot;portmap&quot; in path [/opt/cni/bin], failed to clean up sandbox container &quot;dd087d2655e98a25040f7b041e23dffa59aa52206b921e481ad20781d1de4320&quot; network for pod &quot;coredns-86c58d9df4-gtrt4&quot;: NetworkPlugin cni failed to teardown pod &quot;coredns-86c58d9df4-gtrt4_kube-system&quot; network: failed to find plugin &quot;portmap&quot; in path [/opt/cni/bin]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">su</span><br><span class="line">mkdir -p /etc/cni/net.d/</span><br><span class="line">cat &lt;&lt;EOF&gt; /etc/cni/net.d/10-flannel.conf</span><br><span class="line">&#123;&quot;name&quot;:&quot;cbr0&quot;,&quot;type&quot;:&quot;flannel&quot;,&quot;delegate&quot;: &#123;&quot;isDefaultGateway&quot;: true&#125;&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Pod无法正常创建Container，出现netplugin error</p>
<ul>
<li><p>错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed create pod sandbox: rpc error: code = Unknown desc = failed to set up sandbox container &quot;81e89630eeb39a5c7b24e330082af265d3cd4480c83664316df3bd92fcfaaa91&quot; network for pod &quot;testpod&quot;: NetworkPlugin cni failed to set up pod &quot;testpod_default&quot; network: &quot;cni0&quot; already has an IP address different from 10.244.0.1/24</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决方案：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubeadm reset 过程</span></span><br><span class="line">systemctl stop kubelet</span><br><span class="line">systemctl stop docker</span><br><span class="line">rm -rf /var/lib/cni/</span><br><span class="line">rm -rf /var/lib/kubelet/*</span><br><span class="line">rm -rf /etc/cni/</span><br><span class="line">ifconfig cni0 down</span><br><span class="line">ifconfig flannel.1 down</span><br><span class="line">ifconfig docker0 down</span><br><span class="line">ip link delete cni0</span><br><span class="line">ip link delete flannel.1</span><br><span class="line">systemctl start kubelet</span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="comment"># kubeadm init 过程</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2018/07/11/ArchLinux下的软件安装/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/07/11/ArchLinux下的软件安装/" itemprop="url">ArchLinux下的软件安装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-11T09:39:48+08:00">
                2018-07-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Technical/Archlinux/" itemprop="url" rel="index">
                    <span itemprop="name">Archlinux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2018/07/11/ArchLinux下的软件安装/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/07/11/ArchLinux下的软件安装/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Archlinux下的软件安装方式总结"><a href="#Archlinux下的软件安装方式总结" class="headerlink" title="Archlinux下的软件安装方式总结"></a>Archlinux下的软件安装方式总结</h2><p>虽然Archlinux既有稳定的官方镜像源又有完善的aur社区，仍然有一些软件是我们通过这两种方式无法安装的。今天就来总结一下Archlinux下所有的安装方式，让我们能方便舒适地使用所有软件。</p>
<h3 id="pacman"><a href="#pacman" class="headerlink" title="pacman"></a>pacman</h3><p><code>pacman</code>是Arch官方的包管理工具。这里能下载到的都是Arch官方支持的软件，因此很多软件是无法从这种途径获取的。</p>
<h4 id="找到需要的软件包"><a href="#找到需要的软件包" class="headerlink" title="找到需要的软件包"></a>找到需要的软件包</h4><p>有些时候我们会发现有的软件依赖的二进制文件并没有被安装，导致软件无法运行。想要查找一个二进制文件所在的pacman软件包，可以使用<code>pkgfile</code>工具。使用方法是<code>pkgfile &lt;文件名&gt;</code>。它会输出这个文件所在的软件包名。</p>
<h4 id="pacman的使用方式"><a href="#pacman的使用方式" class="headerlink" title="pacman的使用方式"></a>pacman的使用方式</h4><ul>
<li>常用参数<ul>
<li><code>-S</code> 后面跟软件包名，与镜像源同步，一般使用这个参数安装新的软件包或升级旧的软件包。</li>
<li><code>-U</code> 后面跟一个文件名，通过下载到本地的安装包安装软件</li>
<li><code>-R</code> 后面跟软件包名，卸载这个软件并删除软件包</li>
<li><code>-Syu</code> 俗称 <em>滚Arch</em> ，进行全面的系统更新</li>
</ul>
</li>
</ul>
<h4 id="定制pacman下载工具"><a href="#定制pacman下载工具" class="headerlink" title="定制pacman下载工具"></a>定制pacman下载工具</h4><p><code>pacman</code>的配置文件是<code>/etc/pacman.conf</code>。在这个文件中我们可以对<code>pacman</code>的行为进行自定义。</p>
<ul>
<li>常用的自定义项<ul>
<li>改变<code>pacman</code>的镜像源：修改<code>/etc/pacman.d/mirrorlist</code>文件内容</li>
<li>改变<code>pacman</code>使用的下载工具：修改<code>XferCommand</code>变量的值<ul>
<li><code>/usr/bin/curl -C - -f %u &gt; %o</code> pacman默认使用<code>curl</code>作为下载工具</li>
<li><code>/usr/bin/wget --passive-ftp -c -O %o %u</code> <code>wget</code>是一款非常优秀的单线程下载工具，功能比<code>curl</code>更为强大</li>
<li><code>/usr/bin/axel -o %o %u</code> <code>axel</code>是一款多线程下载工具，速度比前两者要快，推荐设置它为<code>pacman</code>的默认工具。</li>
<li><strong>注意</strong>：<code>wget</code>和<code>axel</code>需要提前用pacman安装。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="yaourt-yay"><a href="#yaourt-yay" class="headerlink" title="yaourt/yay"></a>yaourt/yay</h3><p>官方支持的软件毕竟是有限的，很多我们需要的第三方软件并没有官方提供的支持。在这种时候，Archlinux丰富而强大的aur社区就体现出其威力了——我们可以很方便地从aur社区下载别人制作好的应用软件包或二进制文件，还可以将自己制作的软件包发布在这个社区上(关于发布方式的细节不在这里讨论)。</p>
<p>从aur社区下载软件包所需要的工具是<code>yaourt</code>(现在yaourt已经停止更新了，取而代之的是<code>yay</code>)。使用<code>pacman</code>可以安装<code>yaourt</code>，使用<code>yaourt</code>可以安装<code>yay</code>。</p>
<h4 id="yaourt-yay的使用方式"><a href="#yaourt-yay的使用方式" class="headerlink" title="yaourt/yay的使用方式"></a>yaourt/yay的使用方式</h4><p>与<code>pacman</code>类似，yaourt可以用<code>-S</code>参数来下载并安装软件包。如果不加参数，yaourt会在aur库中搜索所有名字与给出的名字相近的软件包或二进制文件，并以表的形式列出，供用户选择。下载到的二进制文件会默认保存在当前目录中。</p>
<h4 id="定制yaourt-yay下载工具"><a href="#定制yaourt-yay下载工具" class="headerlink" title="定制yaourt/yay下载工具"></a>定制yaourt/yay下载工具</h4><p><code>yaourt</code>和<code>yay</code>的配置文件都是<code>/etc/makepkg.conf</code>。</p>
<p>修改下载工具的方式与pacman类似，只不过修改的是DLAGENTS变量。修改时可以直接删除这个变量原来的所有值，改为<code>DLAGENTS = (&#39;http::/usr/bin/wget --passive-ftp -c -O %o %u&#39;,&#39;https::/usr/bin/wget --passive-ftp -c -O %o %u&#39;)</code></p>
<h3 id="通过下载好的软件包安装"><a href="#通过下载好的软件包安装" class="headerlink" title="通过下载好的软件包安装"></a>通过下载好的软件包安装</h3><p>如果一个软件既无法通过<code>pacman</code>下载又无法通过aur库得到，那就只能手动安装了。首先我们要通过各种渠道获取软件的安装包(<code>GitHub</code>/<code>wget</code>/软件官网/其他)，随后的操作要视软件包而定。</p>
<h4 id="软件是单文件-二进制文件"><a href="#软件是单文件-二进制文件" class="headerlink" title="软件是单文件(二进制文件)"></a>软件是单文件(二进制文件)</h4><p>这种情况最简单，没有软件包，直接把二进制文件移动到<code>/usr/bin</code>文件夹下即可(注意要加<code>sudo</code>)。</p>
<h4 id="软件包中有安装脚本"><a href="#软件包中有安装脚本" class="headerlink" title="软件包中有安装脚本"></a>软件包中有安装脚本</h4><p>大多软件会在软件包中放一个命名为<code>install.sh</code>(或其他名字)的安装脚本。在这种情况下，可以直接执行<code>sh install.sh</code>或<code>./install.sh</code>来安装软件。(最好结合软件的READ.ME或官方说明安装)</p>
<h4 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h4><p>如果安装脚本不能在Arch下正常运行，那就只好手动拆包安装了。这种时候可以搜索一下各种后缀的软件包的格式，然后手动将二进制文件，lib文件和其他配置文件cp到需要的位置完成安装。</p>
<h3 id="downgrade"><a href="#downgrade" class="headerlink" title="downgrade"></a>downgrade</h3><p>和前面几种方式不同，downgrade是一种给软件包<strong>降级</strong>的方式。使用这个工具可以很方便地回滚软件包等级，从而解决一些可能存在的依赖问题。</p>
<p>执行<code>yay downgrade</code>命令可以直接从aur仓库安装downgrade工具。</p>
<p>使用downgrade工具需要root权限。使用方式：<code>sudo downgrade &lt;软件包&gt;</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2018/04/12/Note of CSAPP/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/04/12/Note of CSAPP/" itemprop="url">CSAPP学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-12T08:22:15+08:00">
                2018-04-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2018/04/12/Note of CSAPP/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/04/12/Note of CSAPP/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<h1 id="CSAPP-Note-Taking"><a href="#CSAPP-Note-Taking" class="headerlink" title="CSAPP Note Taking"></a>CSAPP Note Taking</h1></blockquote>
<p>这是阅读《深入理解计算机系统》一书时所做的学习笔记。</p>
<hr>
<h1 id="Chapter-1-计算机系统漫游"><a href="#Chapter-1-计算机系统漫游" class="headerlink" title="Chapter 1 计算机系统漫游"></a>Chapter 1 计算机系统漫游</h1><p>首先从“hello.c”文件开始讲起。</p>
<p>Unix-like系统下有两个重要概念：</p>
<ul>
<li>只由ASCII字符构成的文件为文本文件，其余皆为二进制文件</li>
<li>系统中所有信息都是由一串bits构成的。<br>区分它们的不同方式在于它们的上下文。</li>
</ul>
<h2 id="有关C语言"><a href="#有关C语言" class="headerlink" title="有关C语言"></a>有关C语言</h2><ol>
<li>C语言是贝尔实验室的研究员在1969-1973年间创建的。</li>
<li>ASCI标准在1989年由美国国家标准学会颁布。</li>
<li>C语言是为了开发UNIX而设计的，由是，它是系统级编程的首选。但它缺乏对一些抽象的显式实现（如异常，类，对象），因此在应用级编程方面弱于C++与JAVA等语言。</li>
</ol>
<h2 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello.c -预处理-&gt; hello.i -编译-&gt; hello.s -汇编-&gt; hello.o -链接-&gt; hello</span><br></pre></td></tr></table></figure>
<ul>
<li>执行这四个阶段的程序（预处理器，编译器，汇编器，连接器）共同构成了 <strong>编译系统</strong> 。<ul>
<li>预处理 ：对源程序中所有 <em>#</em> 打头的语句进行处理</li>
<li>编译 ： 将处理过的源程序翻译为汇编程序</li>
<li>汇编 ： 将汇编程序翻译为机器语言，并打包成为 <em>可重定位目标程序</em></li>
<li>链接 ： 将标准库函数所在的 <em>.o文件</em> 链接到hello.o并生成 <em>可执行目标文件</em></li>
</ul>
</li>
</ul>
<h3 id="有关GNU项目"><a href="#有关GNU项目" class="headerlink" title="有关GNU项目"></a>有关GNU项目</h3><ol>
<li>GNU（GNU‘s not UNIX）是一个免税慈善项目，它的目标是开发一个完整的开源系统。</li>
<li>GNU环境包括 <em>EMACS</em>,<em>GCC</em>,<em>GDB</em>,编器，链接器，处理二进制文件的一些工具以及其他部件<pre><code>（~~然而不包括内核，内核是LINUX独立发展的~~）
</code></pre></li>
<li>它是现代 <strong>开放源码运动</strong> 的思想起源。</li>
</ol>
<h2 id="计算机系统的硬件组成"><a href="#计算机系统的硬件组成" class="headerlink" title="计算机系统的硬件组成"></a>计算机系统的硬件组成</h2><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>总线是在系统的各个部件之间传递信息的渠道，通常被设计为传送定长的字节块。</p>
<ul>
<li>xx位系统的含义:<ul>
<li>xx代表的是这个系统的基本属性：<strong>字长</strong> ,即总线一次传送信息的最小单位。比如，64位系统代表字长是64个位，也就是8个字节。</li>
<li>字长不仅是总线传送信息的最小单位，还是内存中数据单元的一种单位。</li>
</ul>
</li>
</ul>
<h3 id="I-O-设备"><a href="#I-O-设备" class="headerlink" title="I/O 设备"></a>I/O 设备</h3><p>I/O设备通过适配器或控制器与I/O总线相连。</p>
<ul>
<li>控制器与适配器的区别<ul>
<li>控制器是设备本身或者系统主板上的芯片组;</li>
<li>适配器是插在主板插槽上的卡。</li>
</ul>
</li>
</ul>
<h3 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h3><p>主存由一组 <strong><em>动态随机存取存储器</em></strong> 芯片组成。</p>
<h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><p>中央处理单元，简称处理器，是解释执行储存在主存中指令的引擎。</p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>处理器的核心是一个大小为一个字的存储设备 - <strong>程序计数器</strong>，它保存主存中某条指令的地址。处理器读出主存中的指令，执行指令，再更新程序计数器使其指向下一个指令。</p>
<h4 id="算数逻辑单元"><a href="#算数逻辑单元" class="headerlink" title="算数逻辑单元"></a>算数逻辑单元</h4><p>算数逻辑单元（ALU）用于计算数据和地址值。</p>
<h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><p>系统将信息在磁盘，I/O，主存，处理器间来回移动的时间开销过大，一种解决方式是高速缓存。</p>
<p>高速缓存：作为暂时的集结区域，存放处理器近期可能需要的信息。</p>
<p>高速缓存的分级：</p>
<pre><code>* 一级高速缓存：访问速度与大小和寄存器相当
* 二级高速缓存：大小要大很多，但是速度也要慢一些
* ...以此类推
</code></pre><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="操作系统的基本功能："><a href="#操作系统的基本功能：" class="headerlink" title="操作系统的基本功能："></a>操作系统的基本功能：</h3><ol>
<li>防止硬件被失控的应用程序滥用</li>
<li>向应用程序提供简单一致的机制来控制复杂的硬件设备</li>
</ol>
<h4 id="有关Unix"><a href="#有关Unix" class="headerlink" title="有关Unix"></a>有关Unix</h4><p>20世纪60年代末，由于当时开发的Multics操作系统过于复杂，贝尔实验室的研究员用 <strong>机器语言</strong> 写了一个简单易用的操作系统，并在1970年将其命名为“UNIX”。</p>
<ul>
<li>1973年，UNIX内核被用C重新构建</li>
<li>1974年，UNIX正式对外发布</li>
<li>80年代中期，为了防止Unix厂商所加入的新特性导致的不兼容问题，IEEE研发了 <em>POSIX标准</em>。</li>
</ul>
<h3 id="操作系统提供的抽象表示"><a href="#操作系统提供的抽象表示" class="headerlink" title="操作系统提供的抽象表示"></a>操作系统提供的抽象表示</h3><h4 id="1-进程"><a href="#1-进程" class="headerlink" title="1.进程"></a>1.进程</h4><p><strong>进程</strong>是操作系统对一个正在运行的程序的一种抽象。</p>
<p>无论是在单核还是多核系统，操作系统看起来并发地执行多个进程，是通过在进程间切换实现的。<br>这种切换称为 <strong>上下文切换</strong> 。</p>
<ul>
<li>关于 <em>上下文切换</em> ：<ul>
<li>操作系统保持跟踪进程运行所需的所有状态信息。这种信息称为 <strong>上下文</strong> 。</li>
<li>上下文包括程序计数器（PC）和寄存器的当前值，以及主存的内容。</li>
<li>上下文切换就是保存当前进程的上下文并恢复新进程的上下文，然后递交控制权。</li>
</ul>
</li>
</ul>
<p>进程的切换是由操作系统的 <strong>内核</strong>（kernel） 管理的。</p>
<ol>
<li>在应用程序进行系统调用时，控制权移交给内核</li>
<li>内核执行被请求的操作并将控制权返还给应用程序。</li>
</ol>
<h4 id="2-线程"><a href="#2-线程" class="headerlink" title="2.线程"></a>2.线程</h4><p>每个 _进程_ 由许多个更小的执行单元 <strong>线程</strong> 组成，它们共享进程代码和全局数据。</p>
<ul>
<li>多线程的优势所在：<ol>
<li>多线程比多进程更容易共享数据</li>
<li>线程一般比进程更为高效（开销更小）        </li>
</ol>
</li>
</ul>
<h4 id="3-虚拟内存"><a href="#3-虚拟内存" class="headerlink" title="3.虚拟内存"></a>3.虚拟内存</h4><p>虚拟内存提供了一个假象：每个进程都在独立地使用主存。<br>对每个进程来说，它们所看到的主存是一样的，它们所看到的主存称为 <strong>虚拟地址空间</strong> 。</p>
<p>虚拟地址空间的结构：（<strong>地址由高到低</strong>）</p>
<table>
<thead>
<tr>
<th>内核所用的虚拟内存</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户栈（向下增长）</td>
</tr>
<tr>
<td>「预留区域」</td>
</tr>
<tr>
<td>动态链接库映射到内存中的区域（向上增长）</td>
</tr>
<tr>
<td>「预留区域」</td>
</tr>
<tr>
<td>malloc申请的堆内存（向上增长）</td>
</tr>
<tr>
<td>读/写数据</td>
</tr>
<tr>
<td>只读数据和代码</td>
</tr>
</tbody>
</table>
<h4 id="4-文件"><a href="#4-文件" class="headerlink" title="4.文件"></a>4.文件</h4><p><strong>文件</strong> 就是字节序列。在UNIX系统中万物皆文件，包括各种I/O设备。</p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>从一个单独的系统来看，网络可以视为一个I/O设备。</p>
<h1 id="Chapter-2-信息的表示与处理"><a href="#Chapter-2-信息的表示与处理" class="headerlink" title="Chapter 2 信息的表示与处理"></a>Chapter 2 信息的表示与处理</h1><p>数字革命的基础之一就是 <strong>二进制表示法</strong> 。当我们把位组合在一起，我们就可以表示任何一个有限集内的元素。</p>
<p>对于二进制表示数字来讲，三种表示最为重要:</p>
<ol>
<li>Unsigned code ：传统的二进制表示法，表示大于等于零的数字</li>
<li>two’s-complement code ：补码，可以表示有符号的整数</li>
<li>floating-point code ：浮点数编码，可以（近似地）表示所有实数</li>
</ol>
<p>由于编码的位数有限，当结果超出表示范围时就会发生 <strong>溢出</strong> 。</p>
<ul>
<li>对于整数来说，溢出并不影响运算的性质。<ul>
<li>举个例子：以不同的先后顺序计算200×300×400×500,溢出结果是一样的。</li>
</ul>
</li>
<li>但对于浮点数来讲，其数学性质截然不同。<ul>
<li>再举个例子：计算 （0.1+1e20）-1e20 得出的结果是0.0,但先计算1e20-1e20则会得出正确结果</li>
<li>这说明浮点数的表示只是近似的。</li>
</ul>
</li>
</ul>
<p>了解计算机上数字的运算对于提高程序的可移植性和减少漏洞都是有帮助的。</p>
<ul>
<li>C语言标准的发展<ol>
<li>在C语言被开发出来之后，各种标准化组织在为C语言标准化作出努力。1989年，ASCI C标准推出。</li>
<li>1990年，国际标准化组织从美国国家标准协会手中 <del>接锅</del>，开发了ISO C90标准，跟ASCI C的内容基本一致。</li>
<li>1999年，ISO C99标准发布，引入了一些新的数据类型。</li>
<li>在2011年的C11标准中，增加了更多的数据类型和特性。</li>
</ol>
</li>
</ul>
<h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><p>一般来讲，计算机 <strong>可寻址</strong> 的最小单位就是字节。<br>要进行位操作，需要一些其他特殊的手段。</p>
<h3 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h3><p>1 × 十六进制数 == 4 × 二进制数 == 4 × bits == 0.5 × byte</p>
<p>这个换算一定要搞清楚。（不同进制之间是次方关系而非乘法关系）</p>
<ul>
<li>熟练掌握二进制数和十六进制数之间的转换<ul>
<li>对于十六进制对应的四个二进制位来说，一个十六进制数就是1,2,4,8的有机组合。</li>
<li>对于位串来说，每四个二进制数组成一个十六进制数。</li>
</ul>
</li>
</ul>
<h3 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a><strong>字数据大小</strong></h3><p>之前讲到过 <strong>虚拟地址空间</strong> ，每个程序运行时都会从主存分配一个地址从零开始的虚拟地址空间，这个空间（一般来说）就是它们能够使用的最大主存。</p>
<p>之前还讲到过 <strong>字长</strong> ，它的含义是 <strong>ALU</strong>（CPU中的算数逻辑单元） 一次运算能够处理的最大位数，所以也是总线一次能够传递的最大位数。</p>
<p>那么由于操作系统一般是用指针去进行虚拟地址空间中的寻址的， <strong>一个指针的最大大小</strong> 也就决定了 <strong>虚拟地址空间的最大大小</strong> 。而指针身为数据类型的一种，它的大小是受ALU算力的限制的。</p>
<p>也就是说， <strong>计算机字长</strong> 决定 <strong>指针数据的标称大小</strong> ，从而决定 <strong>虚拟地址空间的最大大小</strong> 。由于每一个指针值都对应着虚拟地址空间中的一个字节，一个 <strong>w位</strong> 的机器的虚拟地址空间最大为 <strong>2^w-1</strong> 。</p>
<ul>
<li>为避免程序在不同位系统间切换时数据类型默认大小不同带来的问题，C99标准加入了固定大小的数据类型，比如 <code>int32_t</code> 和 <code>int64_t</code> 。</li>
</ul>
<h3 id="寻址和字节序"><a href="#寻址和字节序" class="headerlink" title="寻址和字节序"></a>寻址和字节序</h3><p><strong>大端序</strong> 和 <strong>小端序</strong> ：最低有效字节（一个数中最右边的）在前为小端序，反之为大端序。</p>
<ul>
<li>大部分Intel兼容机都采用小端序。</li>
<li>这两个名词起源于 <em>格列佛游记</em> 中小人国的大端派和小端派。</li>
</ul>
<p>在一些特定的情景（如网络数据传输，字节级操作）中，大小端序的区别可能会导致错误，需要注意。</p>
<h3 id="表示字符串"><a href="#表示字符串" class="headerlink" title="表示字符串"></a>表示字符串</h3><ul>
<li><p>由于char型变量使用的是单字节，文本型数据在跨平台方面要强于二进制数据 ：它不受字大小和字节序区别的干扰。</p>
</li>
<li><p>字符编码缘起（参考知乎<a href="https://www.zhihu.com/question/23374078" target="_blank" rel="noopener">于洋的回答</a>）：</p>
<ul>
<li>最开始的 <strong>ASCII编码</strong> 标准涵盖了 <strong>控制码</strong>（0x00-0x20） 与用于显示的字符，共128个，每个字节对应一个ASCII码。</li>
<li><p>由于一个字节最多可以表示256种状态，人们添加了 <strong>扩展字符集</strong> ，用来表示一些特殊字符（如某些非英文国家的字母，数学和制表符号等）</p>
</li>
<li><p>由于中文汉字过多，中国采用了两个字节对应一个字符的编码方式-GB2312，一个字节的值不大于127则仍是ASCII码（称为 <strong>半角字符</strong> ），大于127则与后一个字节共同表示一个字符（称为 <strong>全角字符</strong> ）。</p>
</li>
<li><p>后来该协议又有扩展，不再要求后一个字节的值大于127,此次更新的方案称为 <strong>GBK标准</strong>。</p>
</li>
<li><p>再之后ISO出手了，制定了 <strong>UNICODE标准</strong> ，规定用所有字符都用两个字节表示。</p>
</li>
<li>为了网络数据传输的方便，一系列 <strong>UTF编码规则</strong> 被制定出来（UTF-8代表一次传输一个字节）。UTF标准规定可以用1～4个字节来表示一个字符</li>
</ul>
</li>
</ul>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>C标准并没有规定在位右移时是采用 <strong>算术右移</strong> （也就是高位补有效位）还是 <strong>逻辑右移</strong> （也就是高位一律补0），所以导致了一系列可移植性问题（不过一般来说，编译器一律采用算术右移）；但是java用&gt;&gt;和&gt;&gt;&gt;的区别很好地区分了两种移位的判定。</p>
<h2 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h2><p>无非就是两种主要表示形式：signed和unsigned，signed又一般用补码表示。</p>
<h3 id="补码的计算原理"><a href="#补码的计算原理" class="headerlink" title="补码的计算原理"></a>补码的计算原理</h3><p>补码的最左边一位是负权位，如果该整数占w位，那么它的值是-2^(w-1)。补码的计算就是非补码位表示的正值加上补码位负权表示的负值。</p>
<h3 id="补码的符号扩展"><a href="#补码的符号扩展" class="headerlink" title="补码的符号扩展"></a>补码的符号扩展</h3><p>为了保持补码表示的数值不变，补码在扩展时在左边补’1’，原码则是补’0’。因此，一个补码在左边加任意x个1,正如十进制数左边加零一样，其值不变。</p>
<h3 id="补码的截断"><a href="#补码的截断" class="headerlink" title="补码的截断"></a>补码的截断</h3><p>和原码一样，都是去高位留低位，然后根据低位表示的值求出截断后的值。</p>
<h3 id="非补码的数据表示"><a href="#非补码的数据表示" class="headerlink" title="非补码的数据表示"></a>非补码的数据表示</h3><p>在系统级编程和网络编程当中，经常会需要用一个变量代表一串没有数学意义的位。这种时候，补码特殊的负权位会带来一些不必要的麻烦，于是我们可以使用unsigned值来代替。</p>
<p>这里介绍signed和unsigned间隐式类型转换可能带来的漏洞：</p>
<ul>
<li>现在有一个读出缓冲区中信息的函数，这个缓冲区中有些信息是隐私信息，不允许阅读。</li>
<li>为防止这个函数被用来读出不该读的东西，该函数被设置为从可读信息的开始处开始阅读，阅读长度为一个int参数，函数会实现判定其大小是否超出了可读范围。</li>
<li>然而，这个函数调用的用来复制缓冲区中一段信息的系统函数中长度参数的类型为size_t(它被定义为unsigned int)</li>
<li>那么如果有人心怀不轨，将-1作为参数传入，作为int它能通过函数的检验，但在这个函数调用系统函数来复制缓冲区中的信息时，-1就会被隐式类型转换换为unsigned int类型，由于-1的二进制位最左边为1,此时它的值就会变成一个特别大的整数。</li>
<li>这样，这个人就成功读到了本来不应该被他读到的信息。</li>
</ul>
<h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><p>整数运算所产生的大部分漏洞都是溢出所导致的。<br>因此，要格外注意可能引发溢出的情形。</p>
<h3 id="unsigned-int的运算"><a href="#unsigned-int的运算" class="headerlink" title="unsigned int的运算"></a>unsigned int的运算</h3><ul>
<li>无符号数加法的溢出<ul>
<li>溢出的处理规则：舍弃最高位</li>
<li>溢出的判定方法：如果加法得数小于两个加数中的任意一个，则该结果是溢出的。</li>
<li>溢出的应用：阿贝尔群<ul>
<li>概念：任取一个无符号数a，必定存在另一个无符号数b使a+b的结果为0。</li>
<li>原理：a+b的值正好为2^w</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="补码的运算"><a href="#补码的运算" class="headerlink" title="补码的运算"></a>补码的运算</h3><ul>
<li>补码加法的溢出<ul>
<li>如果是正溢出，得数为 <strong><em>原得数 - 2^w</em></strong> 。</li>
<li>如果是负溢出，得数为 <strong><em>原得数 - 2^w</em></strong> 。</li>
<li>溢出的判定方法：如果两个负数相加得到了正数，则发生了负溢出；反之，则为正溢出。</li>
</ul>
</li>
</ul>
<ul>
<li>补码的非<ul>
<li>注意：非和补不是一个东西，非是-，补是～</li>
<li>补码取非就是简单的求反加一</li>
<li>还有一种方法就是找到二进制表示中 <em>从右到左第一个值为‘1’的位</em> ，然后对 <em>这一位左边的所有位</em> 取反。</li>
</ul>
</li>
</ul>
<ul>
<li>补码的乘法<ul>
<li>先直接计算乘积，将其截断后由无符号数转换为补码形式。</li>
<li><strong>这里比较难，之后可以翻回来看一下</strong></li>
</ul>
</li>
</ul>
<h3 id="对于整数乘法的优化"><a href="#对于整数乘法的优化" class="headerlink" title="对于整数乘法的优化"></a>对于整数乘法的优化</h3><p>一般的整数运算（如加减，移位）只需要一个时钟周期，但整数乘法比它们慢的多，需要数个时钟周期来完成。为了提高计算效率，编译器采用了一项重要的优化：用 <strong>移位和加法运算的组合</strong> 来代替。</p>
<ol>
<li>易得， <em>对一个数乘以2的n次方</em> 相当于 <em>将这个数进行n位左移</em> （这两种方式在溢出时得到的结果也是等价的）。</li>
<li>而任意一个整数都可以由 <em>数个2的k次方的和</em> 表示。</li>
<li>于是，由乘法分配律，一个数乘一个常数因子就等价于将若干个它的左移结果相加。</li>
<li>更好的是，有时可以用减法进一步减小计算量。</li>
</ol>
<h3 id="对于整数除法的优化"><a href="#对于整数除法的优化" class="headerlink" title="对于整数除法的优化"></a>对于整数除法的优化</h3><p>在大多数机器上，整数除法比乘法还要慢，大概需要30多个时钟周期。<br>因此，采用与乘法的优化相似的思路来进行优化。</p>
<p>但与乘法不同的是， <strong>移位优化</strong> 只能适用于 $x|(2^k)$ 的情形。(<code>|</code>是离散数学中的符号，意思是能够整除)</p>
<h4 id="整数除法的舍入问题"><a href="#整数除法的舍入问题" class="headerlink" title="整数除法的舍入问题"></a>整数除法的舍入问题</h4><p>我们知道，整数的除法结果应该是 <strong>向零取整</strong> 的（无论正数还是负数），然而直接采用移位法进行除法运算会导致 <strong>向下取整</strong> 的舍入结果。这个问题需要得到解决。</p>
<p>为了解决这个问题，需要引入 <strong>偏置数</strong> 作为修正。</p>
<ul>
<li>对于正数的除法，直接移位即可</li>
<li>对于负数的除法，先进行偏置，再移位。</li>
</ul>
<p>偏置的方式：<strong>将原来的数加上</strong> $(1&lt;&lt;k)-1$ <strong>后再移位，k是将要移动的位数。</strong></p>
<ul>
<li>解析：以除以16来说明。<ul>
<li>当除以16时，应该右移4位，因此k=4</li>
<li>$(1&lt;&lt;k)-1$ = 0b1111</li>
<li>如果将要右移的四位全为0,说明可以整除，则加上0b1111后不进位，移位后结果不变</li>
<li>如果将要右移的四位不全为0,说明有小数部分，则一旦加上0b1111一定会进位，于是结果比向下取整大1,也就实现了向零取整的效果。</li>
</ul>
</li>
</ul>
<p>因此，采用如下表达式来计算 $\frac x {(2^k)}$ :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( x &lt; <span class="number">0</span> ? x + (<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span> : x) &gt;&gt; k</span><br></pre></td></tr></table></figure>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>现在被普遍采用的一种浮点数表示方式为 <strong>IEEE浮点格式</strong> 。<br>它在1985年前后由IEEE（电气和电子工程师协会）推出。</p>
<h3 id="IEEE小数的结构"><a href="#IEEE小数的结构" class="headerlink" title="IEEE小数的结构"></a>IEEE小数的结构</h3><p>IEEE标准表示的小数由以下几部分组成：</p>
<ol>
<li>符号：用一个二进制位来表示小数的正负</li>
<li>尾数：用小数字段frac编码一个范围为 <em>1~2-epsilon</em> 的二进制小数</li>
<li>阶码：用阶码字段exp对这个浮点数加权，权重为2的E次幂</li>
</ol>
<p>对于单精度浮点数而言，exp占8位，frac占23位；对于双精度浮点数而言，exp占11位，frac占52位</p>
<h4 id="三类浮点数"><a href="#三类浮点数" class="headerlink" title="三类浮点数"></a>三类浮点数</h4><p>根据exp的值的情况可以将浮点数分为三类（以float为例）：</p>
<ol>
<li>当exp不为0且不为255时：</li>
</ol>
<p>这是最普遍的情况。</p>
<p>在这种情况下，阶码字段是以偏置形式表示的无符号数。其偏置值为 <strong>2^(k-1)-1</strong> ，从而将 <strong><em>1～2^k-2</em></strong> 的无符号正数映射到了 <strong><em>-2^(k-1)+2</em></strong> ~ <strong><em>2^(k-1)-1</em></strong> (对于单精度浮点数而言，这个映射区间就是 -126～127 )。</p>
<p>而小数字段frac表示小数点后的位，也就是说小数点（等价地）位于整个小数字段的左边，小数点的左边则 <strong>默认为1</strong> 。这样，frac表示的就是一个大小为1.xxxxxx……的小数。</p>
<ol start="2">
<li>当exp为0时：</li>
</ol>
<p>这种数称为 <strong>非规格化形式</strong> 的数。</p>
<p>此时阶码字段的值为 <strong>1-偏置值</strong> ，而小数字段小数点左边改为 <strong>默认为0</strong> 。</p>
<ul>
<li>非规格化数的用途：<ol>
<li>表示+0.0与-0.0</li>
<li>表示极为接近0.0的值</li>
</ol>
</li>
</ul>
<ol start="3">
<li>当exp=255,也就是阶码字段全为1时：</li>
</ol>
<p>此时该浮点数表示的是一个特殊值。</p>
<ol>
<li>frac字段全为0时：表示无穷，无穷的符号由符号位决定。</li>
<li>frac字段不为0时：表示 <strong>NaN</strong>(Not a Number)<ul>
<li>当运算结果既不是实数又不是无穷时使用NaN来代替。（如：sqrt(-1)，∞-∞等）</li>
<li>有些时候用以表示未初始化的数据</li>
</ul>
</li>
</ol>
<ul>
<li><p>这种设计的优点</p>
<p>  经过精心设计，这种表示方法使得浮点数在增大时其位级表示的变化规律和整数增大时是一样的。<br>  这对于排序工作的优化起到了相当大的作用，因为比较的时候不需要进行浮点运算。</p>
</li>
</ul>
<h3 id="浮点数的运算"><a href="#浮点数的运算" class="headerlink" title="浮点数的运算"></a>浮点数的运算</h3><ul>
<li><p>浮点数的舍入运算</p>
<p>  IEEE标准定义了四种不同的舍入方式。</p>
<ol>
<li>向偶数舍入（也就是向最近的数舍入）<ul>
<li>这是最通用的方法，也就是人们常说的“四舍五入”。</li>
<li>对二进制数来讲，一个数的奇偶由最右边的二进制位决定，我们倾向于在舍入后让最低位为0。</li>
</ul>
</li>
<li>向零舍入</li>
<li>向上舍入</li>
<li>向下舍入<br> 这三种方法可以产生一个数实际值的 <strong>确界</strong></li>
</ol>
</li>
<li><p>浮点数的算术运算</p>
<p>  与整数的运算相似，浮点数算术运算也构成了 <strong>阿贝尔群</strong> 。<br>  但要特别注意的是，就像之前所说的， <strong>浮点数运算不满足结合律和分配律</strong> ，这是舍入所造成的。<br>  缺少这两个运算基本属性让浮点运算给编程者们带来了很多麻烦，它使得很多判定变得十分麻烦。</p>
<p>  然而，由于浮点数特殊的溢出判定，它具有补码运算和无符号数运算不具有的 <strong>单调性</strong> 。</p>
</li>
</ul>
<h3 id="浮点数与其他数据类型的转换"><a href="#浮点数与其他数据类型的转换" class="headerlink" title="浮点数与其他数据类型的转换"></a>浮点数与其他数据类型的转换</h3><ol>
<li>int -&gt; float：不会溢出，但是可能会被舍入</li>
<li>int/float -&gt; double：可以完整保留精确数值</li>
<li>double -&gt; float：可能溢出也可能会舍入</li>
<li>float/double -&gt; int：不出意外值会向零舍入，但有可能发生 <strong>浮点溢出</strong> ，产生 <strong>整数不确定值</strong> （对于Intel兼容机，它被定义为0b10000……0）</li>
</ol>
<h1 id="Chapter-3-程序的机器级表示"><a href="#Chapter-3-程序的机器级表示" class="headerlink" title="Chapter 3 程序的机器级表示"></a>Chapter 3 程序的机器级表示</h1><p>在高级语言如此发达和完善的今天，为什么还要学习汇编语言?</p>
<ol>
<li>通过阅读汇编代码，我们能够理解编译器优化代码的原理，从而找出代码中隐含的低效率。</li>
<li>有些时候，高级语言的抽象层会隐藏我们想要了解的程序运行时行为。</li>
<li>了解漏洞的产生与防御恶意攻击需要了解机器级代码表示。</li>
</ol>
<p><strong>x86-64</strong>：Intel兼容机使用的机器语言</p>
<h2 id="x86-64缘起"><a href="#x86-64缘起" class="headerlink" title="x86-64缘起"></a>x86-64缘起</h2><p>Intel系列处理器俗称x86，经历了一个漫长的发展过程。<br>其中，后面的处理器可以兼容前面的机器程序。</p>
<ul>
<li><strong>8086</strong>（1978）：它是第一代单芯片16位处理器之一，它的变种8088是第一代IBM兼容机的心脏</li>
<li><strong>8087</strong>（1980）：浮点协处理器，与8086或8088一同工作，进行浮点运算</li>
<li><strong>80286</strong>（1982）：增加了更多寻址模式，是MS Windows最初的使用平台</li>
<li><strong>i386</strong>（1985）：体系结构升级到32位，这是Intel第一台全面支持Unix操作系统的处理器。它所增加的 <strong>平坦寻址模式</strong> 至今仍被大部分Linux和Windows机型使用。</li>
<li><strong>i486</strong>（1989）：将浮点单元集成到了处理器芯片</li>
<li><strong>Pentium系列</strong>（1993-2004）：不断扩展指令集，引入了SSE：增加了新的处理整数和浮点数向量的指令，增加了新的数据类型。在04年的Pentium 4E实现了超线程。增加了EM64T，它是对AMD提出的 <strong>IA32</strong> 的64位扩展的实现，被人们称为x86-64.</li>
<li><strong>Core 2</strong>（2006）：Intel第一个 <strong>多核微处理器</strong> ，但是不支持超线程。</li>
<li><strong>Core i7</strong>（2008）：同时支持多核处理和超线程，引入了SSE的扩展AVX，增加了更多的指令和指令格式。</li>
</ul>
<h2 id="研究汇编程序编码"><a href="#研究汇编程序编码" class="headerlink" title="研究汇编程序编码"></a>研究汇编程序编码</h2><ul>
<li><p>对于机器级编程来讲尤为重要的两种抽象</p>
<ul>
<li><p><strong>指令集架构</strong>（ISA）</p>
<ul>
<li>它定义了处理器状态，指令的格式，以及每条指令对状态的影响</li>
<li>大多数ISA（包括x86-64）将指令的执行抽象为顺序执行，但其硬件实现其实是并发的，只不过有措施保证其执行顺序与ISA规制的相同。</li>
</ul>
</li>
<li><p><strong>虚拟地址空间</strong></p>
<ul>
<li>存储器系统的实际实现是将多个存储器和操作系统结合起来。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>汇编代码的表示很接近于机器语言，但是它使用了文本这种更适合人类阅读的表示方法。</p>
<p>x86的代码和原始C代码差别很大，一些在C语言中不显示的硬件状态都会体现出来：</p>
<ul>
<li>程序计数器：用 <strong>%rip</strong> 表示，给出内存中要执行的下一条指令的地址。</li>
<li>整数寄存器：包含16个位置，分别储存64位的值。<ul>
<li>记录重要的程序状态</li>
<li>保存临时数据，如过程参数，局部变量，函数返回值</li>
</ul>
</li>
<li>条件寄存器：用来实现控制或数据流中的条件变化</li>
</ul>
<h3 id="需要用到的调试工具"><a href="#需要用到的调试工具" class="headerlink" title="需要用到的调试工具"></a>需要用到的调试工具</h3><ol>
<li>GCC编译器<ul>
<li>gcc：执行GCC的bash命令</li>
<li><strong>-Og</strong>：指定优化方式，以防过于高级的优化使源代码和汇编代码差距过大不便于研究。</li>
<li><strong>-S</strong>：只进行预处理和编译过程，生成汇编代码 <strong>.s文件</strong> 。</li>
<li><strong>-c</strong>：只进行预处理，编译，汇编过程，生成二进制文件 <strong>.o文件</strong> 。</li>
<li><strong>-masm = &lt; format &gt;</strong>：指定生成汇编代码的格式。</li>
</ul>
</li>
<li>GDB调试器</li>
<li>objdump -d &lt; file name &gt;：反汇编器，根据机器代码生成对应的汇编代码</li>
</ol>
<h3 id="x86-64机器代码的特性"><a href="#x86-64机器代码的特性" class="headerlink" title="x86-64机器代码的特性"></a>x86-64机器代码的特性</h3><ol>
<li>x86-64的指令长度为1-15个字节不等。其中，常用或操作数少的指令占字节数较少，反之较多。</li>
<li>从某个给定位置开始，可以唯一地将字节解码成为机器指令。</li>
</ol>
<h3 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h3><p>以内容如下的 test.c 文件为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long mult2(long,long);</span><br><span class="line"></span><br><span class="line">void multstore(long x,long y,long* dest) &#123;</span><br><span class="line">    long t=mult2(x,y);</span><br><span class="line">    *dest=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将其编译之后产生的 test.s 文件内容如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.file   &quot;test.c&quot;</span><br><span class="line">        .text</span><br><span class="line">        .globl  multstore</span><br><span class="line">        .type   multstore, @function</span><br><span class="line">multstore:</span><br><span class="line">.LFB0:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        pushq   %rbx</span><br><span class="line">        .cfi_def_cfa_offset 16</span><br><span class="line">        .cfi_offset 3, -16</span><br><span class="line">        movq    %rdx, %rbx</span><br><span class="line">        call    mult2@PLT</span><br><span class="line">        movq    %rax, (%rbx)</span><br><span class="line">        popq    %rbx</span><br><span class="line">        .cfi_def_cfa_offset 8</span><br><span class="line">        ret</span><br><span class="line">        .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">        .size   multstore, .-multstore</span><br><span class="line">        .ident  &quot;GCC: (GNU) 8.1.0&quot;</span><br><span class="line">        .section        .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure></p>
<ul>
<li>所有以 <strong>‘.’</strong> 开头的行都是指导 <strong>汇编器</strong> 和 <strong>链接器</strong> 工作的伪指令</li>
<li><p>具体语句的作用：</p>
<ul>
<li>pushq %rbx：将rbx寄存器中保存的值压入程序栈</li>
<li>movq %rdx，%rbx：将rdx中的值(dest指针)传递给rbx</li>
<li>call：调用函数，函数的返回值保存在寄存器rax中</li>
<li>movq %rax，（%rbx）：将返回值赋给dest指针</li>
<li>popq %rbx：恢复rbx寄存器中原有的值</li>
<li>ret：该函数返回</li>
</ul>
</li>
<li><p>两种不同的汇编代码格式</p>
<p>  <strong>ATT格式</strong>：这是根据 <strong>AT&amp;T公司</strong> 命名的汇编格式，是GCC，OBJDUMP等工具的默认格式<br>  <strong>Intel格式</strong>：Intel文档和Microsoft的工具使用的都是Intel格式。</p>
<p>  两种格式的主要区别有：</p>
<ol>
<li>Intel格式省略了操作指令后指定大小的”q”字符与寄存器名前面的”%”。</li>
<li>Intel用不同的方式来描述内存中的位置。</li>
<li>两者列出操作数的顺序相反。</li>
</ol>
</li>
<li><p>在C程序中插入汇编代码</p>
<p>  C语言缺乏一些特定API或操作符来访问一些机器特性。<br>  比如：在x86-64处理器每一次执行算术或逻辑运算时，都会设置一个表示奇偶的称为 <strong>PF</strong> 的1位条件码的值，从而储存这个结果的奇偶性信息。而C语言要想得到这个信息需要至少7次移位、掩码和逻辑运算。</p>
<p>  在C程序中插入汇编代码有两种方式。</p>
<p>  第一，可以将一个完整的函数单独编写到一个汇编文件中，再用GCC将它和另一个C代码生成的.s文件合并;第二，可以利用GCC的内联汇编（asm指令）在C代码中插入少量汇编代码。</p>
</li>
</ul>
<h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>由于是从16位系统扩展成32位的，Intel将16位数据类型称为“字”。<br>因此，32位数据类型就称为“双字”，64位就是“四字”。</p>
<p>x86-64对于基础数据类型的大小如下定义（括号内为汇编代码中的后缀）：</p>
<ul>
<li><p>普通类型（后缀仅表示操作数大小）：</p>
<ul>
<li>char（b）：1字节</li>
<li>short（w）：2字节</li>
<li>int（l）：4字节</li>
<li>long（q）：8字节</li>
<li>pointer（q）：8字节</li>
</ul>
</li>
<li><p>浮点类型：</p>
<ul>
<li>float（s）：4字节</li>
<li>double（l）：8字节</li>
</ul>
</li>
</ul>
<p>两种类型使用的指令和寄存器完全不同，所以后缀相同也无妨。</p>
<h2 id="访问信息操作"><a href="#访问信息操作" class="headerlink" title="访问信息操作"></a>访问信息操作</h2><p>一个x86-64的CPU包含一组（16个）储存64位值的 <strong>通用目的寄存器</strong> 。<br>每个寄存器都有特殊的用途，它们的名字便反映出这些不同的用途。</p>
<ul>
<li><p>16个寄存器的用途（从左到右分别是8字节，4字节，2字节，1字节对应的寄存器名）</p>
<ul>
<li>%rax %eax %ax %al 保存函数返回值</li>
<li>%rbx %ebx %bx %bl 被调用者保存</li>
<li>%rcx %ecx %cx %cl 第四个参数在内存中的地址</li>
<li>%rdx %edx %dx %dl 第三个参数在内存中的地址</li>
<li>%rsi %esi %si %sil 第二个参数在内存中的地址</li>
<li>%rdi %edi %di %dil 第一个参数在内存中的地址</li>
<li>%rbp %ebp %bp %bpl 被调用者保存</li>
<li>%rsp %esp %sp %spl 栈指针</li>
<li>%r8,%r9 %r8d,%r9d %r8w,%r9w %r8b,%r9b 第5,6个参数在内存中的地址</li>
<li>%r10，%r11 同理 同理 同理 调用者保存</li>
<li>%r12～%r15 同理 同理 同理 被调用者保存</li>
</ul>
</li>
<li><p>当寄存器中被存入新的变量时的约定：</p>
<ul>
<li>若存入的是1,2字节的值，则不改变寄存器中剩余字节</li>
<li>若存入的是4字节的值，则将剩余字节置为0</li>
</ul>
</li>
</ul>
<h3 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h3><p><strong>操作数</strong>指示出指令需要的原数据值，以及放置结果的位置。</p>
<ul>
<li>操作数可以被分为三种类型：<ul>
<li><strong>立即数</strong>（immediate）：通过 <strong>$Imm</strong> 的格式表示常数，Imm为任意C-style数</li>
<li><strong>寄存器</strong>（register）：直接用寄存器名将寄存器中的部分位作为操作数</li>
<li><strong>内存引用</strong> ：根据计算出的地址访问内存中的某个位置，格式为 <strong>[Imm]（[rb]，[ri]，[s]）</strong><ul>
<li>Imm：立即数表示的偏移量，缺省表示不偏移</li>
<li>rb：基址寄存器，缺省则无基址</li>
<li>ri：变址寄存器，缺省表示无变址寻址</li>
<li>s：比例因子，必须为1,2,4或8，缺省默认为1</li>
<li><strong>计算规则</strong>：最终的内存地址为 <strong>rb + s*ri + Imm</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p><strong><em>MOV S,D</em></strong></p>
<ul>
<li><p>效果：将S中的储存值移动到D</p>
<ul>
<li>S（源操作数）：指定一个寄存器或者内存地址中的立即数</li>
<li>D（目的操作数）：指定一个寄存器或内存地址</li>
<li>注：<strong>x86-64规定两者不能同时为内存地址</strong></li>
</ul>
</li>
<li><p>可能的操作数组合：</p>
<ul>
<li>movl $0x4050,%eax — 立即数-&gt;寄存器 移动4个字节</li>
<li>movw %bp，%sp — 寄存器-&gt;寄存器 移动2个字节</li>
<li>movb （%rdi，%rcx），%al — 内存-&gt;寄存器 移动1个字节</li>
<li>movb %-17,（%rsp） — 立即数-&gt;内存 移动1个字节</li>
<li>movq %rax，-12（%rbp） — 寄存器-&gt;内存 移动8个字节</li>
</ul>
</li>
<li><p>特殊指令：movabsq</p>
<ul>
<li>常规的movq指令只能以 <strong>32位补码</strong> 形式作为源操作数，然后将其扩展成为64位的值放入目的位置</li>
<li>而movabsq指令能以任意的 <strong>64位立即数值</strong> 作为源操作数，但 <strong>只能以寄存器作为目的位置</strong></li>
</ul>
</li>
<li><p>其他的数据传送指令</p>
<ul>
<li><strong>MOVZ</strong>：有两个后缀，分别指定源大小和目的大小。缺少的位用0填充。<ul>
<li>movzlq指令并不存在，因为它完全可以被更简单的movl所取代。（想想4字节的填充特性）</li>
</ul>
</li>
<li><strong>MOVS</strong>：和上面相似，但缺少的位用源操作数的最高位填充。<ul>
<li>cltq指令：将%eax中的值符号扩展到%rax中，没有操作数。</li>
</ul>
</li>
</ul>
</li>
<li><p>一些常见的错误</p>
<ul>
<li>movb %0xF,(%ebx)<ul>
<li>Since address in 64-bits os should be 8-bytes, use %ebx(a 4-bytes register)’s value to index is dangerous and should not be allowed.</li>
</ul>
</li>
<li>movl %rax,(%rsp) <ul>
<li>movl 必须以四字节大小的寄存器号作为其源操作数。</li>
</ul>
</li>
<li>movl %eax,%rdx<ul>
<li>movl 必须以四字节大小的寄存器号作为其目的操作数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="入栈出栈指令"><a href="#入栈出栈指令" class="headerlink" title="入栈出栈指令"></a>入栈出栈指令</h3><p><strong>PUSH &lt; register &gt;</strong>: 将一个寄存器中的值压入程序栈。</p>
<p><strong>POP &lt; register &gt;</strong>: 弹出程序栈顶元素并移入指定寄存器。</p>
<ul>
<li><p>实现（以四字后缀为例）:</p>
<ul>
<li>pushq:<ul>
<li>subq $8,%rsp<ul>
<li>含义：<strong>%rsp</strong>(程序栈指针寄存器)<strong>的值减小8</strong>(因为程序栈从上往下增长)。</li>
</ul>
</li>
<li>movq &lt; register &gt;,(%rsp)</li>
</ul>
</li>
<li>popq:<ul>
<li>movq (%rsp),&lt; register &gt;</li>
<li>addq $8,%rsp<ul>
<li><strong>%rsp的值增大8</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对于用户程序来说，栈内元素的地址是透明的，也就是说可以直接以 <strong>%rsp</strong> 为基准指针去访问栈内的第n个元素。</p>
</li>
</ul>
<h2 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h2><h3 id="加载有效地址"><a href="#加载有效地址" class="headerlink" title="加载有效地址"></a>加载有效地址</h3><p><strong>LEA</strong>(load effective address)指令：将一个有效地址记录到一个寄存器中。</p>
<ul>
<li>使用方法：<ul>
<li>基本用法(以四字为例)：<strong>leaq &lt; effective address &gt; &lt; target register &gt;</strong></li>
<li>其他用法：<ul>
<li>可以用于简单的算术操作：利用内存地址的计算法则来实现简单计算。如：<ul>
<li>寄存器%rdx的值为x</li>
<li>命令 leaq 7(%rdx,%rdx,4), %rax 即是计算5x+7.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="一元算术运算"><a href="#一元算术运算" class="headerlink" title="一元算术运算"></a>一元算术运算</h3><ul>
<li>INC 自增</li>
<li>DEC 自减</li>
<li>NEG 取负</li>
<li><p>NOT 取补</p>
</li>
<li><p>注</p>
<ul>
<li>一元算术运算的操作数可以是 <strong>寄存器</strong> 或 <strong>内存位置</strong> 。</li>
<li>运算符后缀决定了进行该运算的位数。如：incq就是四字自增，notb就是低字节取补。</li>
</ul>
</li>
</ul>
<h3 id="二元算术运算"><a href="#二元算术运算" class="headerlink" title="二元算术运算"></a>二元算术运算</h3><ul>
<li>ADD 加</li>
<li>SUB 减</li>
<li>IMUL 乘</li>
<li>XOR 异或</li>
<li>OR 或</li>
<li><p>AND 与</p>
</li>
<li><p>注</p>
<ul>
<li>二元算术运算相当于是C语言中的 <strong>～=运算</strong> (～代表一个运算符)。如：SUB S,D 相当于 D-=S</li>
<li>这些运算的第一个操作数可以是 <strong>立即数、寄存器或内存位置</strong>，而第二个操作数只能是 <strong>寄存器或内存位置</strong></li>
</ul>
</li>
</ul>
<h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><ul>
<li>SAL，SHL 左移</li>
<li>SAR 算术右移</li>
<li><p>SHR 逻辑右移</p>
</li>
<li><p>注</p>
<ul>
<li>移位运算在运算符后先后给出两个操作数，分别代表移位量和要移位的数</li>
<li>移位量可以是一个 <strong>立即数</strong> ，也可以是 <strong>单字节寄存器%cl</strong> 的值</li>
<li>运算符后缀决定的是取%cl的后几位作为移位量。</li>
</ul>
</li>
</ul>
<h3 id="特殊算术操作"><a href="#特殊算术操作" class="headerlink" title="特殊算术操作"></a>特殊算术操作</h3><ul>
<li><p>imulq指令和mulq指令</p>
<ul>
<li>imulq指令有两种含义。<ul>
<li>作二元操作符：将两个64位操作数相乘得到一个 <strong>64位</strong> 的值，并寄存在后一个操作数的位置。</li>
<li>作一元操作符：将操作数与%rax储存的值相乘得到一个 <strong>128位</strong> 的值，并储存在%rdx(高64位)和%rax(低64位)中。</li>
<li><strong>这两种含义中乘法均为补码乘法</strong>。</li>
</ul>
</li>
<li>mulq指令和imulq的第二种含义相似，只不过它做的是无符号乘法。</li>
</ul>
</li>
<li><p>idivq和divq指令</p>
<ul>
<li>这两种指令与上面的两种用法类似，只不过是除法加取模运算。</li>
<li>idivq指令将%rdx(高64位)和%rax(低64位)表示的128位有符号数作为被除数，而操作数作为除数，得到的 <strong>整数商</strong> 储存在%rax中，<strong>余数</strong>储存在%rdx中。</li>
<li>由于一般来说被除数是64位的，所以可以 <strong>将被除数放在%rax中</strong> ，再使用 <strong>cqto</strong> 指令将符号位扩展。<ul>
<li>cqto指令没有操作数，它自动读出%rax的符号位并将符号位扩展覆盖到%rdx。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="控制操作"><a href="#控制操作" class="headerlink" title="控制操作"></a>控制操作</h2><h3 id="条件操作"><a href="#条件操作" class="headerlink" title="条件操作"></a>条件操作</h3><ul>
<li>条件码寄存器<ul>
<li>除整数寄存器之外，CPU还维护一组 <strong>条件码寄存器</strong> 。它们描述 <strong>最近一次</strong> 算术或逻辑操作的属性。常用的条件码有：<ul>
<li>CF 进位标志 显示操作有没有造成操作数最高位发生进位</li>
<li>ZF 零标志   显示操作的结果是不是0</li>
<li>SF 符号标志 显示操作的结果是不是负数</li>
<li>OF 溢出标志 显示补码操作有没有造成正溢出或负溢出</li>
</ul>
</li>
<li>只有 <strong>leaq指令</strong> 不会改变条件码寄存器</li>
<li>有两种指令只设置条件码而不改变其他寄存器的值：<ul>
<li>CMP 求出两个操作数之差(ATT格式是右减左)，并以此为结果设置条件码</li>
<li>TEST 以两个操作数按位与的结果设置条件码</li>
</ul>
</li>
</ul>
</li>
<li><p>对条件码的访问</p>
<ul>
<li><strong>SET指令</strong><ul>
<li>set指令是一个单元操作指令集，每条指令的功能取决于set的后缀。</li>
<li>所有set指令共同的功能是将某一个 <strong>条件码寄存器</strong> 的值(或某些值的组合)储存到操作数表示的 <strong>单字节寄存器</strong> 中</li>
<li>set指令共有(含义解释按上一次操作为a-b):<ul>
<li>sete(setz) - ZF</li>
<li>setne(setnz) - ~ZF</li>
<li>sets,setns - SF,~SF</li>
<li>setl(setnge) - SF^OF       // SF=0,OF=1 =&gt; 补码溢出后值大于0，发生负溢出，说明a&lt;0,b&gt;0 =&gt; a &lt; b</li>
<li>setle(setng) - (SF^OF)|ZF  // SF=1,OF=0 =&gt; 无溢出，a-b<0 ==""> a &lt;= b</0></li>
<li>setg(setnle) - ~(SF^OF)&amp;~ZF</li>
<li>setge(setnl) - ~(SF^OF)    // SF=OF=1 =&gt; 补码溢出后值小于0，发生正溢出，说明a&gt;0,b<0 ==""> a &gt; b</0></li>
<li>setb(setnae) - CF  // CF=1，最高位进位，由无符号数减法原理知减法得到了负数，故 a &lt; b</li>
<li>setbe(setna) - CF | ZF</li>
<li>seta(setnbe) - ~CF &amp; ~ZF   </li>
<li>setae(setnb) - ~CF</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>用条件控制来实现条件分支</p>
<ul>
<li><p><strong>控制</strong>的条件转移：传统方式，先判断条件是否满足，而后根据判断结果将控制流转移到代码段的某个位置继续执行。</p>
<ul>
<li><p><strong>JMP指令</strong></p>
<ul>
<li><p>直接使用：操作数是一个label，在代码段中有标记。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  movq $2333 %rax</span><br><span class="line">  jmp .L1</span><br><span class="line">  leaq 8(%rdx,%rax)     # 这一句被跳过了</span><br><span class="line">.L1:                    # L1是label</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>还有一种使用方式是间接跳转：jmp *&lt;寄存器或内存地址&gt; 取出小括号内储存的值作为label。</p>
</li>
<li><p>条件使用：以j+后缀构成，后缀的使用规则和set指令集类似。</p>
</li>
</ul>
</li>
<li><p>跳转指令的编码方式</p>
<ul>
<li><strong>PC-relative</strong>：将目标指令的地址与jmp指令后一句指令地址的差编码，可以为1,2,4个字节</li>
<li>绝对地址：直接将目标指令的绝对地址编码，用4个字节指定。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>数据</strong>的条件转移：先将条件满足和不满足的两种情况下的操作都做完，随后判断条件是否满足，并根据判断结果采用两种情况下操作得出的结果中的一种。</p>
<ul>
<li>数据条件传送指令：<strong>CMOV</strong>指令<ul>
<li>与SET，JMP相似，CMOV指令也是带有指定后缀的指令集。</li>
<li>每条CMOV指令都有两个操作数，当后缀所指定的条件满足时，CMOV指令会执行与MOV指令相同的功能。</li>
<li>源和目的值支持单字节以外的任意大小，这个大小可以由寄存器的型号看出，指令本身不给出。</li>
</ul>
</li>
</ul>
</li>
<li><p>两种条件控制方式的比较</p>
<ul>
<li><p>现代处理器使用的是 <strong>流水线策略</strong> ，即将要执行的指令序列填充进流水线，并同时做一条流水线上的所有工作。当遇到条件分支时，处理器只能预测控制流的走向而去完成那一个分支的工作，而这就意味着一旦预测失误，处理器就必须放弃之前对那一个分支做出的所有工作，并重新填充流水线。这会浪费非常多的时间。而数据条件转移就不存在这个问题。</p>
</li>
<li><p>然而，不是所有条件表达式都可以用条件传送来编译。更重要的是，由于这种处理方式会事先进行两种情况下的操作，如果其中某一种在某种条件下会产生副作用或者错误，那就会导致非法的行为。与此同时，如果两种条件下的计算量都比较大的话，无论怎样编译器都会白白浪费很多资源。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="循环操作"><a href="#循环操作" class="headerlink" title="循环操作"></a>循环操作</h3><ul>
<li><p>对于dowhile循环的实现：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func:</span><br><span class="line">  ...         # ...</span><br><span class="line">.Loop:        # do &#123;</span><br><span class="line">  ...         # ...</span><br><span class="line">  &lt;judging&gt;   # &#125;while</span><br><span class="line">  j** .Loop   # (condition)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于while循环的实现：</p>
<ul>
<li><p>第一种实现方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func:</span><br><span class="line">  ...</span><br><span class="line">  jmp .Test   # 一上来先跳到后面的条件判断部分</span><br><span class="line">.Loop:        # 循环体</span><br><span class="line">  ...</span><br><span class="line">.Test         # 条件判断部分</span><br><span class="line">  &lt;judging&gt;</span><br><span class="line">  j** .Loop   # 如果满足条件则回到循环体</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种实现方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func:</span><br><span class="line">  ...</span><br><span class="line">  &lt;judging&gt;   # 先判断是否不符合条件</span><br><span class="line">  j** .Done   # 如果不符合，直接结束循环</span><br><span class="line">.Loop:</span><br><span class="line">  ...         # 循环体</span><br><span class="line">  &lt;judging&gt;</span><br><span class="line">  j** .Loop   # 如果符合条件则回到循环体</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>对于for循环的实现</p>
<p>  for循环可以按如下方式翻译成while循环：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (init;judge;iteration) &#123;</span><br><span class="line">    body_statement;</span><br><span class="line">&#125;</span><br><span class="line">&lt;=&gt;</span><br><span class="line">init;</span><br><span class="line">while(judge) &#123;</span><br><span class="line">    body_statement;</span><br><span class="line">    iteration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="switch操作"><a href="#switch操作" class="headerlink" title="switch操作"></a>switch操作</h3><p>这边要用到跳转表，等学了表再回来看</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>过程提供了一种封装代码的方式，用一组指定的参数和返回值实现某种功能。常见的过程有函数，方法，子例程，处理函数等等。</p>
<p>在过程调用中，需要牵涉到以下机制：</p>
<ul>
<li>传递控制：调用者要将程序计数器设置为被调用者的起始地址，待调用结束后被调用者又要交还控制权。</li>
<li>传递数据：参数和返回值需要在两块代码间进行交流。</li>
<li>分配内存：局部变量需要临时分配内存，在返回前又要释放这些内存。</li>
</ul>
<h3 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h3><p>C语言调用机制的一个关键特性在于使用了栈提供的 <strong>后进先出</strong> 内存管理原则。</p>
<p>对于局部变量而言，这种机制保证了它可以在作用范围内始终有效，在作用范围外被安全回收：某个过程在入栈时申请了局部变量，则它所调用的所有其他过程都在它之后入栈，在它之前出栈，而它申请的变量在它自身出栈时才销毁。</p>
<ul>
<li>运行时栈的调度机制<ul>
<li>当某一个过程所需要的空间超出了寄存器能提供的范围，就会在栈上分配空间。这一部分空间称为 <strong>过程的栈帧</strong> 。</li>
<li>在这个过程被调用时，它的栈帧会被事先分配好。在这个空间内它可以申请局部变量，设置它所调用的其他过程的参数，保存寄存器的值。有些情况下栈帧的长度会变化，但大部分时候帧的长度是固定的。</li>
<li>一个过程在调用另一个过程时，它会先在寄存器内分配参数；如果六个参数寄存器不够用，多出的参数会被保存在栈帧内。在被调用者分配栈帧之前，调用者会将返回地址压入自己的栈，以指明被调用者返回时调用者的继续执行位置。</li>
<li>如果所有局部变量都可以保存在寄存器中，且这个过程不会调用任何其他过程，这个过程便不会分配栈帧。</li>
</ul>
</li>
</ul>
<h3 id="转移控制"><a href="#转移控制" class="headerlink" title="转移控制"></a>转移控制</h3><ul>
<li>控制的转移使用的指令是 <strong>call</strong> 指令和 <strong>ret</strong> 指令。<ul>
<li>call 的使用方式与 jmp 类似，可以直接接&lt;<strong>Label</strong>&gt;也可以接&lt;<strong>*被调用者的起始地址</strong>&gt;来间接调用。</li>
<li>call指令会将后一条指令的地址压栈，并将PC(%rip)设置为被调用者的起始地址。</li>
<li>ret指令会保存弹出栈的值，并将PC(%rip)设置为这个值。</li>
</ul>
</li>
</ul>
<h3 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h3><ul>
<li>当参数的数目小于等于六个时，全部参数通过寄存器传递。调用者在执行call指令之前需要将实参填充到对应的寄存器中，被调用者需要使用参数时则只需从寄存器中取数据。</li>
<li>若参数的数目大于六个，多余的数据压入运行时栈。<ul>
<li>所有数据的以八字节(四字)为最小单位存储。</li>
<li>参数的顺序是越靠近栈顶的参数越靠后。被调用者可以通过栈顶指针运算来访问这些参数。</li>
<li>参数区域在返回地址区域之前，所以访问时要从 %rsp+8 开始访问。</li>
</ul>
</li>
</ul>
<h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>有些时候，寄存器不足以满足过程的需要，因此需要在运行时栈上位局部变量分配内存：</p>
<ol>
<li>寄存器不够用</li>
<li>对一个局部变量进行取地址操作，此时这个局部变量必须有内存地址</li>
<li>局部变量是数组或结构体</li>
</ol>
<ul>
<li>分配局部内存的方式<ol>
<li>减小栈顶指针%rsp的值</li>
<li>将局部变量的值填充入因为栈顶指针减小而多出来的栈空间内</li>
<li>通过栈顶指针运算访问局部变量</li>
<li>在ret执行之前增大栈顶指针的值，释放内存</li>
</ol>
</li>
</ul>
<h3 id="寄存器使用"><a href="#寄存器使用" class="headerlink" title="寄存器使用"></a>寄存器使用</h3><p>为了避免不同过程中新的寄存器值覆盖旧的寄存器值带来损失，x86-64有一套寄存器使用规范。</p>
<ul>
<li>被调用者保存寄存器：%rbx,%rbp,%r12~%r15<ul>
<li>被调用者有义务在自身返回时保证这些寄存器的值与被调用时相同。</li>
<li>被调用者可以选择不改变这些寄存器中的值。</li>
<li>如果必须改变，可以先将其值压栈，在返回前再将旧值从栈中取回寄存器中。</li>
<li>压栈的寄存器值所处的部分称为“保存的寄存器”部分，位于局部变量区域之前。</li>
</ul>
</li>
<li>调用者保存寄存器：除%rsp以外的其他寄存器<ul>
<li>任何过程都可以修改这些寄存器的值。</li>
</ul>
</li>
</ul>
<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><p>由于函数栈的性质，递归调用自身和调用其他函数并没有什么区别，递归的实现可谓水到渠成。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>C语言的数组实现与汇编语言相当接近，因此可以使用头指针和内存运算方便地实现数组。</p>
<ul>
<li>数组元素a[i+j]的汇编形式：j(a,i,q)<ul>
<li>a为储存着数组头指针的寄存器或内存位置</li>
<li>i为变量，可以是循环变量</li>
<li>q是数组元素的数据类型大小，可以用sizeof得出</li>
<li>j是常数，用于定址索引</li>
</ul>
</li>
<li>高维数组的储存<ul>
<li>C语言对高维数组采取行优先的线性存储。</li>
<li>对于大小为R行C列的数组a来说，a[i][j]的地址应该是(i<em>C+j)</em>size + a</li>
</ul>
</li>
<li>对变长数组的处理<ul>
<li>由于数组存储的线性性，不事先知道数组的列数就无法表达第二行开始的数组元素。</li>
<li>因此需要将数组的大小n也作为参数传入才能处理</li>
</ul>
</li>
</ul>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构的各个字段通过结构的头指针和字段大小构成的偏移量来访问。机器代码不包含关于字段名字或者字段声明的信息。</p>
<p>联合同理，只不过结构在访问字段时其指针偏移量需要加上该字段前面所有字段的偏移量，而联合每个字段都以联合的头指针为起点。</p>
<p>.align &lt; num &gt; 这个指令可以保证指令后的数据都以num个字节为单位进行数据对齐。</p>
<h2 id="使用GDB调试器"><a href="#使用GDB调试器" class="headerlink" title="使用GDB调试器"></a>使用GDB调试器</h2><ul>
<li>GDB常用指令<ul>
<li>Breakpoints<ul>
<li>b &lt; function name &gt; :在函数前加断点</li>
</ul>
<ul>
<li>delete &lt; bp &gt; ：删除断点</li>
</ul>
</li>
<li>Debug<ul>
<li>s :前进一步，可以进入函数</li>
<li>r &lt; para &gt; ：以命令行参数para运行程序</li>
<li>kill ：中止正在运行的程序</li>
<li>c ：从断点处继续运行</li>
</ul>
</li>
<li>View<ul>
<li>print &lt; var &gt; ：查看变量的值</li>
<li>i r &lt; regis &gt; ：查看寄存器的值</li>
<li>x/[options] &lt; addr &gt; ：查看内存地址的值<ul>
<li>[u]：后跟一个后缀，前加一个数字来表示读取长度<ul>
<li>b -单字节为一个单位</li>
<li>h -双字节为一个单位</li>
<li>w -四字节为一个单位</li>
<li>g -八字节为一个单位</li>
</ul>
</li>
<li>[f]：将其替换成一个字母，来表示输出的格式<ul>
<li>x：十六进制数</li>
<li>d：十进制数</li>
<li>c：单个字符</li>
<li>s：字符串</li>
<li>u：无符号整形十进制</li>
<li>f：浮点数</li>
</ul>
</li>
</ul>
</li>
<li>layout asm ：查看汇编代码与执行到了哪一步</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="内存越界引用和缓冲区溢出"><a href="#内存越界引用和缓冲区溢出" class="headerlink" title="内存越界引用和缓冲区溢出"></a>内存越界引用和缓冲区溢出</h2><ul>
<li>对抗Buffer attack的手段<ul>
<li>地址空间布局随机化<ul>
<li>采用这种方式，每次运行时程序所使用的运行时栈，堆内存，全局变量区以及代码段都会随机被储存在内存的不同区域，这样就避免了一些简单而重复的攻击</li>
<li>破解方式：nop sled<ul>
<li>具体方式是在攻击代码之前插入一段很长的nop操作，这样只要随机化过的栈地址与这段nop操作有重合，程序的执行就会沿着这一系列的nop滑到攻击代码。</li>
</ul>
</li>
</ul>
</li>
<li>栈破坏检测<ul>
<li>程序在每次运行时首先随机产生一个canary值，并储存在栈帧中一个空余的位置(一般在变量区之后)。在返回之前，程序会取出并检查这个canary有没有被改变。如果被改变了，那么程序会异常中止。</li>
<li>GCC会根据一个函数是否容易被进行栈溢出攻击来决定是否要进行这种检测。如果不想使用这种检测，可以在编译时加上-fno-stack-protector选项。</li>
</ul>
</li>
<li>限制可执行代码区域<ul>
<li>将只需要读写的内存区和可执行的内存区分开，可以有效避免注入攻击。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="浮点数操作"><a href="#浮点数操作" class="headerlink" title="浮点数操作"></a>浮点数操作</h2><h3 id="浮点数使用的寄存器"><a href="#浮点数使用的寄存器" class="headerlink" title="浮点数使用的寄存器"></a>浮点数使用的寄存器</h3><p>AVX浮点体系结构允许浮点数储存在16个YMM浮点数寄存器中。</p>
<ul>
<li>16个寄存器的名称分别为ymm0-ymm15，长度均为32个字节。但是float只使用最低的四个字节，double只使用最低的八个字节。</li>
<li>汇编代码通常用xmm0-15来引用这些寄存器。xmm是ymm的后16个字节。</li>
</ul>
<h3 id="浮点数的操作命令"><a href="#浮点数的操作命令" class="headerlink" title="浮点数的操作命令"></a>浮点数的操作命令</h3><ul>
<li>移动操作<ul>
<li>vmovss - 移动单精度数</li>
<li>vmovsd - 移动双精度数</li>
<li>vmovaps，vmovapd - 移动封装好的已经对齐的单精度（双精度）数，一般用于寄存器之间的传送</li>
</ul>
</li>
<li>转换操作<ul>
<li>vcvttss2si - 单精度数转整数</li>
<li>vcvttsd2si - 双精度数转整数<ul>
<li>第一个操作数是储存浮点数的寄存器，第二个操作数是储存结果整数的寄存器。</li>
<li>这两个操作会进行自动的 <strong>截断</strong> 而非四舍五入。</li>
<li>转成四字整数只需要在指令后面加后缀q即可</li>
</ul>
</li>
<li>vcvtsi2ss - 整数转单精度数</li>
<li>vcvtsi2sd - 整数转双精度数<ul>
<li>这两个操作是三操作数操作，前一个是整数寄存器，后两个一般写同一个浮点寄存器。</li>
</ul>
</li>
<li>vunpcklps，vmovddup - 交叉存放两个寄存器中的字</li>
<li>vcvtpd2psx，vcvtps2pd - 单双精度之间的转换</li>
</ul>
</li>
<li>算术运算<ul>
<li>算术运算是由运算名和后缀组成的。<ul>
<li>运算名代表运算的种类：<ul>
<li>vadd：加法</li>
<li>vdiv：减法</li>
<li>vmul：乘法</li>
<li>vdiv：除法</li>
<li>vmax：最大</li>
<li>vmin：最小</li>
<li>sqrt：开方</li>
</ul>
</li>
<li>后缀：ss表示单精度操作，sd表示双精度操作</li>
</ul>
</li>
<li>操作数的数量视操作而定。除了开方之外，所有操作都有三个操作数：前两个进行运算，结果存在第三个中。</li>
</ul>
</li>
<li>位运算<ul>
<li>vxorps，vxorpd 位级异或</li>
<li>vandps，vandpd 位级与</li>
<li>位级操作是同时对两个寄存器中的所有128位同时进行进行操作，并将结果储存在第三个操作数中</li>
</ul>
</li>
<li>比较操作<ul>
<li>vucomiss 单精度比较操作，结果是S2-S1</li>
<li>vucomisd 双精度比较操作，结果一样</li>
<li>jp 当比较的对象不可以比较时跳转</li>
</ul>
</li>
</ul>
<h3 id="过程中的浮点数"><a href="#过程中的浮点数" class="headerlink" title="过程中的浮点数"></a>过程中的浮点数</h3><ul>
<li>浮点数使用 <strong>%xmm0</strong> 来储存返回值</li>
<li>浮点数的传参最大数量是 <strong>八</strong> 个，多出的参数要出存在栈中</li>
<li>所有xmm寄存器都是调用者保存的</li>
<li><strong>浮点常数</strong>的定义和使用<ul>
<li>编译器必须为所有的浮点数常量值分配内存空间，然后代码从内存空间读入。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Doubletest:</span><br><span class="line">    vmulsd .LC0(%rip),%xmm0,%xmm0 </span><br><span class="line">    # 通过程序计数器和标号的结合去引用内存中的浮点数常量</span><br><span class="line">    ret</span><br><span class="line">.LC0:</span><br><span class="line">    .long 3435973837                    # double低位4字节的十进制表示</span><br><span class="line">    .long 1073532108                    # double高位4字节的十进制表示</span><br><span class="line">Floattest:</span><br><span class="line">    vmulss .LC1(%rip),%xmm1,%xmm0</span><br><span class="line">    ret</span><br><span class="line">.LC1:</span><br><span class="line">    .long 1065353216                    # float编码的十进制表示</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="Chapter-4-处理器体系结构"><a href="#Chapter-4-处理器体系结构" class="headerlink" title="Chapter 4 处理器体系结构"></a>Chapter 4 处理器体系结构</h1><p>处理器要处理的指令被编码为由一个或者多个字节序列组成的二进制格式。一个处理器支持的 <strong>指令集和指令的编码方式</strong> 称为这个处理器的 <strong>指令集体系结构(ISA)</strong> 。</p>
<p>不同的处理器家族所使用的ISA是不兼容的，但是同一家族内的各型号处理器一般使用同种ISA。</p>
<p>在本教材中，我们使用一种比较简单的指令集，称为Y86-64.</p>
<h2 id="Y86-64-ISA"><a href="#Y86-64-ISA" class="headerlink" title="Y86-64 ISA"></a>Y86-64 ISA</h2><h3 id="程序员可见的状态"><a href="#程序员可见的状态" class="headerlink" title="程序员可见的状态"></a>程序员可见的状态</h3><p>指令集能够修改与读取的那些处理器组成部分称为 <strong>程序员可见状态</strong> 。</p>
<ul>
<li>Y86-64的状态包括以下部分：<ul>
<li><strong>15个64位寄存器</strong>：比x86-64少了一个%r15</li>
<li><strong>程序计数器PC</strong>：存放当前指令的地址</li>
<li><strong>条件码CC</strong>：有三个条件码，比x86-64少了进位符CF</li>
<li><strong>内存</strong>：用 <strong>虚拟地址</strong> 引用内存位置，它是物理地址的一组字节映像。</li>
<li><strong>程序状态码</strong>：用来处理程序异常以防系统崩溃</li>
</ul>
</li>
</ul>
<h3 id="Y86-64指令集"><a href="#Y86-64指令集" class="headerlink" title="Y86-64指令集"></a>Y86-64指令集</h3><ul>
<li><p>由于Y86-64是简化版的x86-64指令集，因此有很多限制：</p>
<ul>
<li>只能操作 <strong>八字节大小的整数</strong></li>
<li>寻址方式：基址+偏移量，不支持变址寻址，更不支持变址伸缩</li>
<li>不允许在内存地址之间移动数据，不允许将立即数直接写入内存</li>
<li>x86-64的限制它也一样具有</li>
</ul>
</li>
<li><p>我们需要实现以下指令：</p>
<ul>
<li>移动指令(movq被分成了四个单独的指令)<ul>
<li>irmovq 获取一个立即数(立即数移动到寄存器)</li>
<li>rrmovq 寄存器间的值传递</li>
<li>mrmovq 从内存中读数据</li>
<li>rmmovq 向内存中写数据</li>
</ul>
</li>
<li>条件和运算指令：操作数只能是寄存器，不能是内存寻址<ul>
<li>addq</li>
<li>subq</li>
<li>andq</li>
<li>xorq</li>
</ul>
</li>
<li>跳转指令(由于条件码少了一个CF，无符号数的比较无法实现)<ul>
<li>jmp 直接跳转</li>
<li>jle &lt;=</li>
<li>jl &lt;</li>
<li>je =</li>
<li>jne !=</li>
<li>jge &gt;=</li>
<li>jg &gt;</li>
</ul>
</li>
<li>条件传送指令(同样不支持无符号数)</li>
<li>函数调用指令<ul>
<li>call 返回地址入栈并将PC的值设为目标地址</li>
<li>ret 返回地址出栈并将PC的值设为返回地址</li>
</ul>
</li>
<li>程序栈操作指令<ul>
<li>pushq</li>
<li>popq</li>
</ul>
</li>
<li>停止指令：停止指令的执行<ul>
<li>halt 处理器停止，状态码设置为HLT</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="指令集编码"><a href="#指令集编码" class="headerlink" title="指令集编码"></a>指令集编码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> 指令名 操作数 操作数2    指令编码</span><br><span class="line">halt                    0 0</span><br><span class="line">nop                     1 0</span><br><span class="line">rrmovq  rA    rB        2 0    rA   rB</span><br><span class="line">irmovq  V     rB        3 0    0xF  rB      V</span><br><span class="line">rmmovq  rA    D(rB)     4 0    rA   rB      D</span><br><span class="line">mrmovq  D(rA) rB        5 0    rA   rB      D</span><br><span class="line">OPq     rA    rB        6 fn   rA   rB</span><br><span class="line">jXX     Dir             7 fn   Dir</span><br><span class="line">cmovXX  rA    rB        2 fn   rA   rB</span><br><span class="line">call    Dir             8 0    Dir</span><br><span class="line">ret                     9 0</span><br><span class="line">pushq   rA              A 0    rA   0xF</span><br><span class="line">popq    rA              B 0    rA   0xF</span><br><span class="line"></span><br><span class="line">附注</span><br><span class="line">fn：编码的功能部分(见附表：指令集功能码表)</span><br><span class="line">rA，rB：寄存器(见下面的寄存器码)</span><br><span class="line">Dir：jmp类和call指令的目标地址</span><br><span class="line">D：偏移量</span><br><span class="line">V：立即数</span><br></pre></td></tr></table></figure>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">    指令集功能码表</span><br><span class="line">    - OPq类</span><br><span class="line">      addq      60</span><br><span class="line">      subq      61</span><br><span class="line">      andq      62</span><br><span class="line">      xorq      63</span><br><span class="line">    - jXX类</span><br><span class="line">      jmp       70</span><br><span class="line">      jle       71</span><br><span class="line">      jl        72</span><br><span class="line">      je        73</span><br><span class="line">      jne       74</span><br><span class="line">      jge       75</span><br><span class="line">      jg        76</span><br><span class="line">    - cmov类</span><br><span class="line">      rrmovq    20</span><br><span class="line">      cmovle    21</span><br><span class="line">      cmovl     22</span><br><span class="line">      cmove     23</span><br><span class="line">      cmovne    24</span><br><span class="line">      cmovge    25</span><br><span class="line">      cmovg     26</span><br><span class="line">    ``` </span><br><span class="line"></span><br><span class="line">- 编码规范</span><br><span class="line">    + 每条指令的第一个字节表明指令的具体类型</span><br><span class="line">        * 前四位是 __代码部分__ ，表示指令的种类</span><br><span class="line">        * 后四位是 __功能部分__ ，表示指令是大类中的哪一个</span><br><span class="line">    + rA和rB都是寄存器，用一个范围在0到E之间的 __寄存器标识符__ 表示。</span><br><span class="line">        * %rax---0</span><br><span class="line">        * %rcx---1</span><br><span class="line">        * %rdx---2</span><br><span class="line">        * %rbx---3</span><br><span class="line">        * %rsp---4</span><br><span class="line">        * %rbp---5</span><br><span class="line">        * %rsi---6</span><br><span class="line">        * %rdi---7</span><br><span class="line">        * %r8----8</span><br><span class="line">        * %r9----9</span><br><span class="line">        * %r10---A</span><br><span class="line">        * %r11---B</span><br><span class="line">        * %12----C</span><br><span class="line">        * %r13---D</span><br><span class="line">        * %r14---E</span><br><span class="line">        * 不需要--F</span><br><span class="line">    + 由于小端序的问题，八字节长的立即数，偏移量和地址都要反序书写。也就是说一个指令(以rmmovq $0x12345678,%rax为例)的完整编码是 40 F0 78 56 34 12 00 00 00 00.</span><br><span class="line"></span><br><span class="line">- __RISC__ 与 __CISC__</span><br><span class="line"></span><br><span class="line">    CISC，也就是复杂指令集计算机，是比较早发展起来的一种计算机。它们的指令集比较庞大，指令类型多样，功能强大，对硬件的要求和复杂度都很高。为了开发一种能用较少硬件实现的指令集，RISC(精简指令集计算机)成为了人们的研究对象。</span><br><span class="line"></span><br><span class="line">    RISC的主要特点是指令少而简单，编码方式固定(所有指令都用4字节编码)，寻址方式简单，因而执行速度很快，对硬件要求很小。但因为本来应该由条件码和内存引用承担的一部分工作现在要全部让寄存器来承担，所以这种指令集需要很多性能优良的寄存器，最多有32个。</span><br><span class="line"></span><br><span class="line">### 异常处理</span><br><span class="line"></span><br><span class="line">- 状态码可能的值</span><br><span class="line">    + AOK---1：表示程序运行正常</span><br><span class="line">    + HLT---2：执行了halt指令</span><br><span class="line">    + ADR---3：遇到了非法地址</span><br><span class="line">    + INS---4：执行了非法指令</span><br><span class="line"></span><br><span class="line">在遇到异常的时候，完善的架构会调用一个异常处理函数来处理特定的异常。但在Y86-64这里，我们只简单地让程序停止运行。</span><br><span class="line"></span><br><span class="line">### 伪指令</span><br><span class="line"></span><br><span class="line">以“.”开头的词是汇编器伪指令。它们用来告知汇编器调整地址。</span><br><span class="line"></span><br><span class="line">- 标号的作用</span><br><span class="line">    + 在汇编语言程序中，不缩进而后跟冒号的 __标号__ 用以指定一个内存地址。通过引用这个标号，指令可以获得这个标号所在代码段位置的内存地址。</span><br><span class="line">- 汇编器伪指令</span><br><span class="line">    + .pos &lt; addr &gt; 指定一个地址，这条指令之后的代码从这个地址开始存放。</span><br><span class="line">    + .align &lt; num &gt; 指定对齐方式</span><br><span class="line"></span><br><span class="line">## 硬件控制语言HCL</span><br><span class="line"></span><br><span class="line">要实现一个数字系统，需要三个主要的组成部分：__位运算函数的组合逻辑__，__存储位的存储器单元__，__以及更新存储位信息的时钟信号__。</span><br><span class="line"></span><br><span class="line">__HDL__ 是描述硬件的一种文本表示，典型的例子是Verilog语言，其语法类似于C。而 __HCL__ 只表达硬件的控制部分，需要翻译成Verilog之后结合一些其他Verilog代码来产生HDL描述，从而生成对应的硬件。</span><br><span class="line"></span><br><span class="line">### 逻辑门和组合电路</span><br><span class="line"></span><br><span class="line">将很多逻辑门组合在一起，就可以构成 __计算块__ ，称为 __组合电路__ 。</span><br><span class="line"></span><br><span class="line">- 构建这样的电路有几个限制：</span><br><span class="line">    + 每个逻辑门的输入必须连接到以下选项之一：</span><br><span class="line">        * 系统输入</span><br><span class="line">        * 某个存储单元的输出</span><br><span class="line">        * 某个逻辑门的输出</span><br><span class="line">    + 逻辑门的输出不能连接在一起，否则可能造成信号紊乱。</span><br><span class="line">    + 这个网必须是无环的。</span><br><span class="line"></span><br><span class="line">我们可以通过构造HCL表达式的方式来设计这样的组合电路。例如：</span><br><span class="line"></span><br><span class="line">- 位相等判断器：(a&amp;&amp;b)||(!a&amp;&amp;!b)</span><br><span class="line">- 多路复用器(选择器):(s&amp;&amp;a)||(!s&amp;&amp;b)</span><br><span class="line"></span><br><span class="line">- HCL表达式与C表达式的区别：</span><br><span class="line">    + HCL表达式只对单个位进行操作，可能的值只有0和1,可能的操作只有与或非，因此情况简单，需要进行的操作比较少；而C中的True可以是任一个非0的数，且同时操作一整个字，这样要达到相同的功能就会更加复杂(见datalab中的多路复用器位实现)</span><br><span class="line">    + HCL表达式的变量和值都是动态更新的</span><br><span class="line">    + C表达式有部分求值的特性，而HCL没有。</span><br><span class="line"></span><br><span class="line">### 字级别的组合电路</span><br><span class="line"></span><br><span class="line">- 字级别组合电路的实现</span><br><span class="line">    + 字相等判断器：对每两个对应的位进行相等判断，所有结果用一个与门并起来</span><br><span class="line"></span><br><span class="line">- 组合电路的表达</span><br><span class="line">    - 在HCL语言中，我们把表达式定义为 ___bool___ 型，而字级的 __信号__ 不论大小都为 ___int___ 型。</span><br><span class="line">    - 在画字级电路时，用虚线表示布尔信号结果，而用中等粗度的线表示携带字的每个位的线路。</span><br><span class="line">    - __多路复用函数__是用 __情况表达式__ 来描述的。其通用格式如下：</span><br></pre></td></tr></table></figure>

word Out = [
    select_1 : expr_1;
    select_2 : expr_2;
    ...
    select_k : expr_k;
    1        : expr_default     # 如果前面的都没选中则执行这个
];
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">    与C中的多路复用不同的是，这里只要有一个条件满足就会跳过剩下的。</span><br><span class="line"></span><br><span class="line">__算术逻辑单元__(ALU)是一种很重要的组合电路。它有一组控制输入和一组参数输入，根据控制输入的不同，ALU会对参数做不同的操作，然后输出结果。</span><br><span class="line"></span><br><span class="line">### 集合关系</span><br><span class="line"></span><br><span class="line">判断集合关系的通用格式是: __iexpr in &#123;expr1,...exprn&#125;__</span><br><span class="line"></span><br><span class="line">如果iexpr在集合内有出现，则表达式的值为真，否则为假。</span><br><span class="line"></span><br><span class="line">### 存储器与时钟</span><br><span class="line"></span><br><span class="line">组合电路只会接受输入，传送输出而不会存储任何信息。因此，为了产生 __时序电路__ ，必须引入按位存储信息的设备。</span><br><span class="line"></span><br><span class="line">- 存储器设备</span><br><span class="line">    + 寄存器(这里指硬件上的物理寄存器) ：是CPU的一部分，存储单个位或者单个字。</span><br><span class="line">        * 寄存器的值随着时钟周期更新。</span><br><span class="line">    + 随机访问存储器 ：存储多个字，用地址来决定读写哪个字。具体的例子包括：</span><br><span class="line">        - 处理器的 __虚拟内存系统__ (也就是我们通常讲的内存):操作系统辅助硬件使CPU能够访问一个很大地址空间中的任意一个字。</span><br><span class="line">            + 在需要读得时候，将write位输入设为0，将address字设置好，等一个时钟周期，在时钟发信号之后就可以在data字接收到输出。如果出现错误，error位会设为1,否则为0.</span><br><span class="line">            + 在需要写的时候，将write位输入设为1，同样地设置address值，并设置输入值到data，等一个时钟周期，再查看error位有没有出现错误。</span><br><span class="line">        - __寄存器文件__(就是我们通常说的寄存器的总和)：由所有物理寄存器组成的寄存器阵列构成。</span><br><span class="line">            - 寄存器文件被划分为数个 __程序寄存器__ 。这些程序寄存器的 __标识符__ 就代表着它们在寄存器文件中的地址。</span><br><span class="line">            - 寄存器文件有两个 __读端口__ 和一个 __写端口__ 。每个端口都有一个地址输入(用来指定程序寄存器)，另外读端口还有一个读数据输出，写端口还有一个写数据输入。</span><br><span class="line"></span><br><span class="line">## Y86-64的顺序实现</span><br><span class="line"></span><br><span class="line">__顺序实现处理器__(__SEQ__)是非常低效的，因为它要在一个时钟周期内完成一条指令的全部步骤。但是，SEQ是开发流水线化处理器必不可少的一个中间过程。</span><br><span class="line"></span><br><span class="line">### 将指令划分阶段</span><br><span class="line"></span><br><span class="line">- 绝大部分指令都遵循以下的操作序列：</span><br><span class="line">    + __取指令__(fetch)：根据程序计数器的值从内存中读取指令内容。</span><br><span class="line">        * 首先读取代表指令种类的两个四位部分，辨别指令类型</span><br><span class="line">        * 根据指令类型决定的数据长度读取剩下的数据。</span><br><span class="line">    + __译码__(decode)：这个阶段从寄存器文件读入至多两个操作数。</span><br><span class="line">    + __执行__(execute)：__算术逻辑单元__执行指令，进行数学和逻辑运算，改变栈指针，设置或检验条件码。</span><br><span class="line">    + __访存__(memory)：将运算结果写入内存或从内存读出数据。</span><br><span class="line">    + __回写__(writeback)：写入最多两个数据到寄存器文件</span><br><span class="line">    + __更新PC__(update)：更新程序寄存器的值</span><br><span class="line"></span><br><span class="line">### SEQ硬件结构</span><br><span class="line"></span><br><span class="line">采用SEQ顺序式设计，时基发生器需要将一条指令整个完成的时间作为时钟周期。</span><br><span class="line"></span><br><span class="line">- 硬件对指令六个步骤的配合</span><br><span class="line">    + 取指令：</span><br><span class="line">        + 读程序计数器的值，以其为地址取内存中保存的指令。</span><br><span class="line">        + PC增加器同时计算下一条指令的地址valP并保存。</span><br><span class="line">    + 译码：寄存器文件有两个读端口，从这两个端口分别读入两个寄存器的值</span><br><span class="line">        * 两个端口的设计保证了这一步骤能够在一个时钟周期内完成</span><br><span class="line">    + 执行：ALU接受输入，进行操作，传递输出</span><br><span class="line">        * 由于Y86-64的计算命令过于简单，所有操作能在一个时钟周期内完成。</span><br><span class="line">    + 访存：从数据内存读入或者写出一个内存字</span><br><span class="line">    + 写回：寄存器文件有两个写端口</span><br><span class="line">        * 一个用来写入ALU的计算结果</span><br><span class="line">        * 一个用来写入从内存中读出的值</span><br><span class="line">    + PC更新：程序计数器的新值可能是：</span><br><span class="line">        * 下一条指令的地址valP(一般情况)</span><br><span class="line">        * jXX或call指令指定的指令地址(指令是call或jXX时)</span><br><span class="line">        * 从内存读入的返回地址(指令是ret时)</span><br><span class="line"></span><br><span class="line">- SEQ时序控制</span><br><span class="line">    + SEQ的实现包括 __组合逻辑__ 和 __两种存储器__(时钟寄存器和随机访问存储器)</span><br><span class="line">        * 组合逻辑不需要时序控制，只要输入产生变化，变化会以光速通过逻辑网进行传播</span><br><span class="line">        * 在小型电路中，对指令内存的访问可以看成和组合逻辑一样的操作；而大型电路可以使用特殊的时基发生器来达到类似的效果。</span><br><span class="line">        * 而对于程序计数器，条件码寄存器，数据内存和寄存器文件，它们通过一个时钟信号来控制，这个信号会触发向寄存器和数据内存的写操作。</span><br><span class="line">    + 组织计算的原则：__从不回读__，也就是处理器不需要为了完成一条指令而去读因为这条指令更新过的状态。</span><br><span class="line">        * 如pushq指令，它既要使用%rsp的值又要更新%rsp的值，这种情况下为了这个原则要把使用这个步骤放在更新前面。分步来看，首先在执行阶段指令计算%rsp+8并保存，然后访存阶段用%rsp的值去写内存，写回阶段再将%rsp+8的值写回%rsp中。</span><br><span class="line">        * 另外的一个例子是CC的更新。没有指令会同时改变CC的值和使用CC的值，因此任何指令试图读CC的之后它的值都是已经更新的。</span><br><span class="line"></span><br><span class="line">- SEQ的HCL实现</span><br><span class="line">    + 用作HCL参数的常数预定义</span><br><span class="line">        * 指令代码</span><br><span class="line">            - IHALT</span><br><span class="line">            - INOP</span><br><span class="line">            - IRRMOVQ</span><br><span class="line">            - IIRMOVQ</span><br><span class="line">            - IRMMOVQ</span><br><span class="line">            - IMRMOVQ</span><br><span class="line">            - IOPL</span><br><span class="line">            - IJXX</span><br><span class="line">            - ICALL</span><br><span class="line">            - IRET</span><br><span class="line">            - IPUSHQ</span><br><span class="line">            - IPOPQ</span><br><span class="line">        * FNONE 默认功能码</span><br><span class="line">        * 寄存器</span><br><span class="line">            - RRSP %rsp的寄存器ID</span><br><span class="line">            - RNONE 表示无寄存器参与</span><br><span class="line">        * ALUADD 加法运算的功能</span><br><span class="line">        * 状态码</span><br><span class="line">            - SAOK 正常</span><br><span class="line">            - SADR 地址异常</span><br><span class="line">            - SINS 操作异常</span><br><span class="line">            - SHLT Halt</span><br><span class="line">    + 取指令</span><br><span class="line">        * 以PC为起始地址，从内存中读出10个字节</span><br><span class="line">            - 如果地址不合法，就舍弃后9个字节，并将第一个字节设置为nop指令，同时产生一个 __imem_error信号__ ，传递到下一步骤</span><br><span class="line">        * 从第一个字节中取得icode与ifun值，并进行一系列逻辑判断，判断结果传递至下一步骤</span><br><span class="line">            - __instr_valid__：该指令是否为合法的Y86-64指令</span><br><span class="line">            - __need_regids__：该指令是否包含寄存器字节</span><br><span class="line">            - __need_valC__：该指令是否包含常数字</span><br><span class="line">            - 这三个判断使用一个HCL中的 __集合关系判断__ 就可以实现。</span><br><span class="line">        * 根据icode与ifun值产生 __alufun__ 信号并传递到执行阶段</span><br><span class="line">        * 标号为“__Align__”的硬件单元处理后面的九个字节</span><br><span class="line">            - if need_regids : 将第二个字节分开分别放入 __rA__ 和 __rB__ 指示符，后八个字节作为常数字</span><br><span class="line">            - else : 将第二个到第九个字节作为常数字</span><br><span class="line">        * __PC增加器__计算生成valP</span><br><span class="line">            - PC值为p，need_rigids值为r，need_valC值为c</span><br><span class="line">            - 则valP = p + r + 8c + 1</span><br><span class="line">    + 译码和写回阶段</span><br><span class="line">        * 寄存器文件的两个读端口和两个写端口都各有两个输入(或一个输入一个输出)：一个地址输入表示寄存器的编号，一个数据输入输出表示读写的数据。两个读端口的地址输入是 __srcA__ 和 __srcB__ ，两个写端口则是 __dstE__ 和 __dstM__ (分别存放计算结果和内存中取出的值)。</span><br><span class="line">        * 根据icode值，通过逻辑控制填入两个读端口(或者写端口)的地址输入</span><br><span class="line">        * 当遇到popq %rsp指令时，两个写端口的目标将会是同一个寄存器。这时需要在两个写端口之间确定一个优先级。为了让从内存中读出的值能存到%rsp，让 __dstM优先级更高__ ，也就是冲突的时候不写入dstE。</span><br><span class="line">    + 执行阶段</span><br><span class="line">        * 将两个操作数填入ALU</span><br><span class="line">            - 前一个操作数填valB</span><br><span class="line">            - 后一个操作数根据情况填valA或常数C或8，-8</span><br><span class="line">        * 产生一个信号 __set_cc__ 判断操作是否为OPq，不是则没必要更新条件码寄存器。</span><br><span class="line">        * 标号为“__cond__”的硬件单元根据条件码CC和icode，ifun值判断是否需要跳转或条件传送。判断结果作为一个 __Cnd信号__ 传递给下一个步骤</span><br><span class="line">        * ALU进行计算，计算结果是 __valE__</span><br><span class="line">    + 访存阶段</span><br><span class="line">        * 读写控制模块根据icode的值判断是应该读还是应该写。</span><br><span class="line">        * 地址控制模块根据icode的值判断内存地址是valA还是valE</span><br><span class="line">        * 数据控制模块根据icode的值判断数据是valA还是valP(返回地址)</span><br><span class="line">        * 进行读写操作，读出的值为 __valM__</span><br><span class="line">        * 根据数据内存产生的 __dmem_error__ 信号及之前产生的三种信号设置程序的stat状态码</span><br><span class="line">    + 更新PC阶段</span><br><span class="line">        * 控制模块根据Cnd信号和icode值判断采用valC，valM，valP中的哪一个作为新的PC值</span><br><span class="line"></span><br><span class="line">SEQ的HCL实现：</span><br></pre></td></tr></table></figure>
</code></pre><h1 id="由于HCL语言不像HDL那样有着对硬件本身的封装，这里使用一些类似于类的语法来表示硬件"><a href="#由于HCL语言不像HDL那样有着对硬件本身的封装，这里使用一些类似于类的语法来表示硬件" class="headerlink" title="由于HCL语言不像HDL那样有着对硬件本身的封装，这里使用一些类似于类的语法来表示硬件"></a>由于HCL语言不像HDL那样有着对硬件本身的封装，这里使用一些类似于类的语法来表示硬件</h1><h1 id="程序开始运行"><a href="#程序开始运行" class="headerlink" title="程序开始运行"></a>程序开始运行</h1><h1 id="取指令"><a href="#取指令" class="headerlink" title="取指令"></a>取指令</h1><p>word p = PC.read(); # 读出PC中的值<br>if p == SADR：<br>    word ins = INOP;<br>    bool imem_error = 1;</p>
<pre><code># 如果PC中储存的地址不合法，产生imem_error信号并将指令设置为nop
</code></pre><p>else：<br>    word ins = MEM.read(baseptr=p,size=10); # 以p为基址在内存中读出10个字节<br>    int icode,int ifun = SPLIT.split(ins[0]); # 指令的第一个字节被split硬件单元解析<br>    bool instr_valid = ***;</p>
<pre><code># 这个判断就是依次判断每个可能的icode对应的ifun是否符合，过于长这里不写了
bool need_regids = 
    icode in {IRRMOVQ,IIRMOVQ,IMRMOVQ,IRMMOVQ,IOPQ,IPUSHQ,IPOPQ};
bool need_valC = 
    icode in {IIRMOVQ,IMRMOVQ,IRMMOVQ,IJXX,ICALL};
# 这两个判断看一下哪些指令需要常数字段和寄存器字段就好了
if need_regids：
    int rA,int rB = ALIGN.align(ins[1]);
    if need_valC：
        word valC = ALIGN.align(ins[2:10]);
    # 如果指令需要寄存器就从第二个字节中读出
    # valC同理，都由align硬件单元读出
else：
    int rA = 0xF;
    int rB = 0xF;
    if need_valC：
        word valC = ALIGN.align(ins[1:9]);
    # 反之，如果不需要寄存器就将两个寄存器值都设为0xF，即无寄存器
    # 这样valC就会存放在指令的2到9字节。
word valP = p + need_regids + 8*need_valC;
# valP代表下一条指令的地址
</code></pre><h1 id="译码"><a href="#译码" class="headerlink" title="译码"></a>译码</h1><p>word srcA = [<br>    icode in {IRRMOVQ,IMRMOVQ,IOPQ,IPUSHQ} : rA;</p>
<pre><code># 需要读rA寄存器的值时
icode in {IPOPQ,IRET} : RRSP;
# 这里与后面访存阶段的访问联系
1 : RNONE;
# 默认情况是没有寄存器需求
</code></pre><p>]; # srcA一般用来提供运算的第二个参数</p>
<p>word srcB = [<br>    icode in {IRMMOVQ,IOPQ} : rB;</p>
<pre><code># 需要读rB寄存器的值时
icode in {IPUSHQ,IPOPQ,ICALL,IRET} : RRSP;
1 : RNONE;
</code></pre><p>]; # srcB提供运算的主参数与rsp地址信息</p>
<p>word valA = REG.read(srcA);<br>word valB = REG.read(srcB);</p>
<h1 id="从寄存器文件中读出对应的值并保存为valA和valB"><a href="#从寄存器文件中读出对应的值并保存为valA和valB" class="headerlink" title="从寄存器文件中读出对应的值并保存为valA和valB"></a>从寄存器文件中读出对应的值并保存为valA和valB</h1><h1 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h1><p>word aluA = [<br>    icode in {IRRMOVQ,IOPQ} : valA;</p>
<pre><code># 寄存器rA的值直接作操作数
icode in {IIRMOVQ,IMRMOVQ,IRMMOVQ} : valC;
# 内存与寄存器之间的移动需要计算地址加偏移量，所以将valC作操作数
icode in {ICALL,IPUSHQ} : -8;
icode in {IRET,IPOPQ} : 8;
# 这几个指令涉及对栈地址的计算，以8为单位进行增减，需要用到ALU计算
</code></pre><p>]; # 辅助操作数</p>
<p>word aluB = [<br>    icode in {IRMMOVQ,IOPQ} : valB;</p>
<pre><code># 寄存器rB的值直接做操作数或需要做地址运算
icode in {IMRMOVQ} : valA;
# 寄存器rA的值需要做地址运算
icode in {ICALL,IRET,IPUSHQ,IPOPQ} : valB;
# 这些时候valB的值是%rsp寄存器的值，作为栈基址操作数
icode in {IIRMOVQ,IRRMOVQ} : 0;
# 保留aluA的值不受操作影响
</code></pre><p>]; # 主操作数</p>
<p>word alufun = [<br>    icode == IOPQ : ifun;<br>    1 : 1;</p>
<pre><code># 除了在使用IPOQ指令时，所有时候ALU都是当加法器用的，其对应的alufun值为1
</code></pre><p>]; # 操作类型</p>
<p>bool set_cc = icode in {IOPQ};</p>
<h1 id="如果指令是IOPQ，还要设置条件码"><a href="#如果指令是IOPQ，还要设置条件码" class="headerlink" title="如果指令是IOPQ，还要设置条件码"></a>如果指令是IOPQ，还要设置条件码</h1><p>int cc = ALU.calculate(aluA,aluB,func=alufun);</p>
<h1 id="ALU进行运算并返回条件码"><a href="#ALU进行运算并返回条件码" class="headerlink" title="ALU进行运算并返回条件码"></a>ALU进行运算并返回条件码</h1><p>if set_cc:<br>    CC.set(cc);</p>
<pre><code># 设置条件码
</code></pre><p>bool Cnd = COND.gencnd(CC.get())</p>
<h1 id="生成Cnd信号，传输给写回阶段"><a href="#生成Cnd信号，传输给写回阶段" class="headerlink" title="生成Cnd信号，传输给写回阶段"></a>生成Cnd信号，传输给写回阶段</h1><h1 id="访存"><a href="#访存" class="headerlink" title="访存"></a>访存</h1><p>word mem_addr = [<br>    icode in {IRMMOVQ,IMRMOVQ,ICALL,IMRMOVQ} : valE;</p>
<pre><code># 正常状态的地址都要经过ALU的计算成为valE
icode in {IRET,IPOPQ} : valA;
# 这边是与译码部分联系
</code></pre><p>]; # 确定内存访问的地址</p>
<p>bool mem_read = icode in {IMRMOVQ,IPOPQ,IRET};<br>bool mem_write = icode in {IRMMOVQ,IPUSHQ,ICALL};</p>
<h1 id="确定指令要求的访存方式是读还是写"><a href="#确定指令要求的访存方式是读还是写" class="headerlink" title="确定指令要求的访存方式是读还是写"></a>确定指令要求的访存方式是读还是写</h1><p>word mem_data = [<br>    icode in {IRMMOVQ,IPUSHQ} : valA;</p>
<pre><code># 从寄存器中获取写入值
icode == ICALL : valP;
# CALL指令要写入的是返回地址，也就是下一条指令的地址valP。
</code></pre><p>]; # 确定读写的数据</p>
<p>try:<br>    if mem_read:<br>        valM = MEM.read(baseptr=mem_addr,size=8);<br>    if mem_write:<br>        MEM.write(baseptr=mem_addr,data=mem_data);</p>
<pre><code># 读写数据
</code></pre><p>except:<br>    bool dmem_error = 1;</p>
<p>word stat = [<br>    imem_error || dmem_error : SADR;<br>    !instr_valid : SINS;<br>    icode == IHALT : SHLT;<br>    1 : SAOK;<br>];<br>STAT.set(stat);</p>
<h1 id="判断程序运行状态并更新状态码"><a href="#判断程序运行状态并更新状态码" class="headerlink" title="判断程序运行状态并更新状态码"></a>判断程序运行状态并更新状态码</h1><h1 id="写回"><a href="#写回" class="headerlink" title="写回"></a>写回</h1><p>word dstE = [<br>    icode in {IIRMOVQ,IOPQ} : rB<br>    icode in {IRRMOVQ} &amp;&amp; Cnd : rB</p>
<pre><code># 这里要包含一下条件传送的情况
icode in {IPUSHQ,IPOPQ,ICALL,IRET} : RRSP
1 : RNONE
</code></pre><p>] # 需要写入计算结果时</p>
<p>word dstM = [<br>    icode in {IMRMOVQ} : rB<br>    icode in {IPOPQ} : rA<br>    1 : RNONE<br>] # 需要写入访存结果时</p>
<p>REG.write(dstE,data=valE);<br>REG.write(dstM,data=valM);</p>
<h1 id="进行写回"><a href="#进行写回" class="headerlink" title="进行写回"></a>进行写回</h1><h1 id="更新PC"><a href="#更新PC" class="headerlink" title="更新PC"></a>更新PC</h1><p>word new_pc = [<br>    icode == ICALL : valC;</p>
<pre><code># 调用函数则直接跳到函数起始地址
icode == IJXX &amp;&amp; Cnd : valC;
# 条件跳转需要判断条件
icode == IRET : valM;
# 读取返回地址
1 : valP;
# 正常情况下就到下一句指令
</code></pre><p>];</p>
<p>PC.set(new_pc);</p>
<h1 id="更新PC-1"><a href="#更新PC-1" class="headerlink" title="更新PC"></a>更新PC</h1><h1 id="指令执行完毕，回到开头，开始执行下一条指令…"><a href="#指令执行完毕，回到开头，开始执行下一条指令…" class="headerlink" title="指令执行完毕，回到开头，开始执行下一条指令…"></a>指令执行完毕，回到开头，开始执行下一条指令…</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 流水线化原理</span><br><span class="line"></span><br><span class="line">流水线化的重要优点就是增加了系统的 __吞吐量__ ，也就是单位时间内能够服务顾客的数量；但缺点是会稍稍增加对单独顾客的 __延迟(处理某一阶段需要的时间)__ ，因为每个顾客都要经历每个步骤，不管它需不需要某些步骤。</span><br><span class="line"></span><br><span class="line">在硬件设计中，只需要将整个过程划分为数个步骤，在每两个步骤之间插入储存中间结果的寄存器，就可以实现SEQ的流水线化。</span><br><span class="line"></span><br><span class="line">### 流水线化的局限性</span><br><span class="line"></span><br><span class="line">+ 不一致的划分</span><br><span class="line">    * 如果流水线上的几个步骤所需要的延迟差距较大，由于流水线的时钟周期必须适应延迟最长的那个步骤，整个流水线的效率都会被拖慢，造成很大的资源浪费。</span><br><span class="line">    * 对硬件设计来说，划分延迟相差不大的阶段是一件比较难的事。</span><br><span class="line">+ 流水线过深的惩罚</span><br><span class="line">    * 比起顺序执行，流水线化执行需要在它划分的每两个阶段之间插入一组流水线寄存器，以储存中间结果。在这组寄存器上的读写也会产生延迟，而当流水线过深(也就是划分阶段过多)时，这些延迟会拖慢整体的吞吐量。</span><br><span class="line">    * 为了减轻这个惩罚，现在的流水线寄存器延迟已经很小。</span><br><span class="line"></span><br><span class="line">### 带反馈的流水线化系统</span><br><span class="line"></span><br><span class="line">对于条件控制的条件码处理，以及PC的更新和寄存器的更新，这些都属于 __反馈路径__ ，每一条指令产生的变化都会反馈给下一条指令。</span><br><span class="line"></span><br><span class="line">然而在流水线系统中，这个处理会带来危险。我们知道由于流水线化的进行，每个阶段执行的时候与它同时执行的前一个阶段就不是它所在指令的阶段，而是后一个指令的阶段了。这样如果仍然使用原来的反馈机制，就会导致一个指令的反馈信息反馈到了之后的指令那里。</span><br><span class="line"></span><br><span class="line">### 设计流水线化的Y86-64处理器</span><br><span class="line"></span><br><span class="line">+ 重新安排计算阶段</span><br><span class="line">    * 为了避免反馈机制被流水线化干扰，有必要调整一下各个阶段的内容与顺序。</span><br><span class="line">    * 一个可能的改进是移动计算PC阶段，使其在一个时钟周期的开始时作用而不是在时钟周期结束。在每个时钟周期开始时，根据状态寄存器中的值动态地计算PC值。</span><br><span class="line">    ![SEQ+示意图](/images/CSAPP/Chapter_4/SEQ+.png)</span><br><span class="line">    * 这种策略称为 __电路重定时__ ，它是指在不改变电路逻辑的情况下调整一个系统的状态表示。电路重定时通常用来平衡流水线各阶段之间的延迟。</span><br><span class="line">+ 插入流水线寄存器</span><br><span class="line">    * 在各个阶段之间插入流水线寄存器并对信号重新排列，得到PIPE-处理器结构。</span><br><span class="line">    ![PIPE-示意图](/images/CSAPP/Chapter_4/PIPE-.png)</span><br><span class="line">    * 五个流水线寄存器的职能</span><br><span class="line">        - F 保存程序计数器的预测值</span><br><span class="line">        - D 保存icode,ifun,rA,rB,valC,valP等指令信息</span><br><span class="line">        - E 保存从寄存器文件中读出的值及计算得出的srcA、srcB、dstE、dstM信息，传递icode,ifun,valC信息</span><br><span class="line">        - M 保存计算结果valE与状态码Cnd，传递icode，dstE，dstM信息</span><br><span class="line">        - W 保存将要写回寄存器的valE和valM以及写回地址dstE和dstM</span><br><span class="line">            + 将dstE和dstM一直传递到这一步的目的是保证写回地址和写回数据匹配。</span><br><span class="line">    * 在流水线化系统的一个时钟周期中，状态码的值stat是随时会变化的。这要求我们仔细地处理stat的值。对于寄存器中储存的stat值，我们使用D_stat,E_stat,M_stat,W_stat来表示；对于阶段中的stat值，我们改用小写字母前缀表示。</span><br><span class="line">+ PC值的预测</span><br><span class="line">    * 除了条件转移类指令和ret指令，我们都可以在解析一条指令的同时准确地得知PC的下一个值，从而在下一个阶段PC读入新一条指令之前更新PC的值。因此，通过预测PC值，大部分指令都可以做到每个时钟周期发射一条指令。</span><br><span class="line">        * 对于条件转移类指令，根据条件码PC既有可能是valC(跳转),又有可能是valP(不跳转)。因此，如果预测发生错误，我们需要设计完善的修正错误的机制。</span><br><span class="line">        * 猜测分支的方向并根据猜测取指的技术称为 __分支预测__ 。PIPE-简化了预测过程，即我们总是预测将要将valC作为PC的新值。</span><br><span class="line">            - 由于分支预测发生错误会极大影响程序性能，__条件传送__ 一般比 __条件跳转__ 要更好一些。</span><br><span class="line">        * 对于ret指令，由于PC的新值有近乎无限种可能性，我们放弃预测，转而暂停流水线的运行直到PC的值有确定的结果。</span><br><span class="line">            - 在一些硬件设计中，会有一个程序员不可见的硬件栈，它在每次函数call的时候将返回地址压栈，而在每次ret指令时从栈顶弹出一个地址作为新的PC值。</span><br><span class="line">+ Streamline Hazard</span><br><span class="line">    * 根据相邻指令之间的反馈方式，Hazard可以分为Data Hazard和Control Hazard两类。</span><br><span class="line">    * Data Hazard</span><br><span class="line">        * Data Hazard的类型</span><br><span class="line">            - 寄存器：一条指令要改变某个寄存器，但在写回阶段之前另一条指令读取了该寄存器的值。</span><br><span class="line">            - 程序计数器：错误的预测和ret的影响</span><br><span class="line">            - 内存：如果程序在访存阶段修改代码部分内存，会引起之后的指令取指出错。我们简单地禁止程序修改自身代码段来避免这种情况。除此之外，由于内存读写发生在同一阶段，不同指令之间不会发生冲突。</span><br><span class="line">            - 条件码寄存器：不会发生Hazard。</span><br><span class="line">            - 状态寄存器stat：采用多状态码机制。</span><br><span class="line">        * 如何避免Data Hazard的发生</span><br><span class="line">            - Stalling(暂停)：暂停一条或多条指令(通过插入bubble)，直到Hazard的条件不再满足。</span><br><span class="line">            - Forwarding(转发)：对于某些情况，可以直接将将要写回寄存器的结果转发至另一条指令的读寄存器端口。这样可以大幅减少需要的暂停时间。</span><br><span class="line">            - load interlock：将暂停和转发技术合理地结合起来，基本可以实现高吞吐量。</span><br><span class="line">        ![PIPE示意图](/images/CSAPP/Chapter_4/PIPE.png)</span><br><span class="line">    * Control Hazard</span><br><span class="line">        - 当处理器无法通过取指阶段的指令去预测下一个指令的地址时会发生控制冒险。</span><br><span class="line">        - Control Hazard的处理措施</span><br><span class="line">            + ret：使用Stalling策略</span><br><span class="line">            + jxx：使用Cancel策略。设当前指令为指令1,则它在执行阶段就可以通过状态码CC的设置判断之前的预测是否发生了失误。如果发生失误，由于指令2和指令3还分别在译码和取指阶段而没有进行任何数据写操作，它们对程序状态其实是没有影响的。于是，我们重新设定PC值，并用bubble取代指令2和指令3剩余的阶段，以消除错误带来的影响。</span><br><span class="line"></span><br><span class="line">### 异常处理</span><br><span class="line"></span><br><span class="line">- 在Y86-64处理器模型中，我们主要处理三种内部异常：</span><br><span class="line">    + halt指令</span><br><span class="line">    + 由非法指令和有非法功能码组合的指令引起的异常</span><br><span class="line">    + 取指和数据读写使用了非法地址</span><br><span class="line"></span><br><span class="line">引起异常的指令称为 __异常指令__ 。在异常触发之后，一个完整设计过的操作系统会调用异常处理程序，但在简化模型中处理器会直接停止并设置状态码。</span><br><span class="line"></span><br><span class="line">对于优先级问题，在流水线中位置最深的指令引发的异常优先级最高。</span><br><span class="line"></span><br><span class="line">当处于访存或者写回阶段的指令引发异常时，流水线控制逻辑应当立即禁止处理器或内存的更新。</span><br><span class="line"></span><br><span class="line">### 控制逻辑</span><br><span class="line"></span><br><span class="line">处理器的控制逻辑处理其他机制无法处理的四种情况：</span><br><span class="line"></span><br><span class="line">- Data Hazard</span><br><span class="line">- ret语句</span><br><span class="line">- 预测失误</span><br><span class="line">- 异常</span><br><span class="line"></span><br><span class="line">处理它们的主要方式是插入气泡(bubble)，也就是将某些步骤的icode设置为INOP，并用RNONE填充流水线寄存器；以及暂停(stalling)，就是禁止流水线寄存器更新状态以将指令阻塞在某个阶段。</span><br><span class="line"></span><br><span class="line">控制逻辑机制</span><br><span class="line"></span><br><span class="line">|序号|   条件             |  F    |  D     |    E   |   M   |   W   |</span><br><span class="line">|---|-------------------|-------|---------|-------|--------|------|</span><br><span class="line">|1  |处理ret语句          | Stall | Bubble |   -&gt;   |   -&gt;  |  -&gt;   |</span><br><span class="line">|2  |Regid/Memory Hazard| Stall |  Stall  | Bubble |   -&gt; |  -&gt;   |</span><br><span class="line">|3  |预测错误的分支(E中发现)|  -&gt;   | Bubble | Bubble |   -&gt;  |   -&gt;  |</span><br><span class="line">|4  |1,3的组合情况(同时)   | Stall | Bubble | Bubble |  -&gt;   |  -&gt;   |</span><br><span class="line"></span><br><span class="line">## 完整的Y86-64流水线化处理器</span><br><span class="line"></span><br><span class="line">### PIPE的HCL实现</span><br></pre></td></tr></table></figure>
<h1 id="可以发现PIPE的实现与SEQ是大部分一致的，只是在信号前加入了前缀"><a href="#可以发现PIPE的实现与SEQ是大部分一致的，只是在信号前加入了前缀" class="headerlink" title="可以发现PIPE的实现与SEQ是大部分一致的，只是在信号前加入了前缀"></a>可以发现PIPE的实现与SEQ是大部分一致的，只是在信号前加入了前缀</h1><h1 id="大写的前缀代表寄存器中的值，小写的前缀代表产生的信号"><a href="#大写的前缀代表寄存器中的值，小写的前缀代表产生的信号" class="headerlink" title="大写的前缀代表寄存器中的值，小写的前缀代表产生的信号"></a>大写的前缀代表寄存器中的值，小写的前缀代表产生的信号</h1><blockquote>
<blockquote>
<blockquote>
<p>取指和PC Selection</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="控制逻辑，对于F阶段只有Stall的可能"><a href="#控制逻辑，对于F阶段只有Stall的可能" class="headerlink" title="控制逻辑，对于F阶段只有Stall的可能"></a>控制逻辑，对于F阶段只有Stall的可能</h1><p>bool F_stall = </p>
<pre><code># 寄存器/内存 Hazard
E_icode in {IMRMOVQ,IPOPQ} &amp;&amp; E_dstM in {d_srcA,d_srcB} || 
IRET    in {D_icode,E_icode,M_icode}; # RET指令
</code></pre><h1 id="解析阶段，与SEQ基本没有区别"><a href="#解析阶段，与SEQ基本没有区别" class="headerlink" title="解析阶段，与SEQ基本没有区别"></a>解析阶段，与SEQ基本没有区别</h1><p>word p = PC.read(); # 读出PC中的值<br>if p == SADR：<br>    word f_ins = INOP;<br>    bool imem_error = 1;</p>
<pre><code># 如果PC中储存的地址不合法，产生imem_error信号并将指令设置为nop
</code></pre><p>else：<br>    word f_ins = MEM.read(baseptr=p,size=10); # 以p为基址在内存中读出10个字节<br>    int f_icode,f_ifun = SPLIT.split(ins[0]); # 指令的第一个字节被split硬件单元解析<br>    bool instr_valid = ***;</p>
<pre><code># 这个判断就是依次判断每个可能的icode对应的ifun是否符合，过于长这里不写了
bool need_regids = 
    icode in {IRRMOVQ,IIRMOVQ,IMRMOVQ,IRMMOVQ,IOPQ,IPUSHQ,IPOPQ};
bool need_valC = 
    icode in {IIRMOVQ,IMRMOVQ,IRMMOVQ,IJXX,ICALL};
# 这两个判断看一下哪些指令需要常数字段和寄存器字段就好了
if need_regids：
    int f_rA,f_rB = ALIGN.align(ins[1]);
    if need_valC：
        word f_valC = ALIGN.align(ins[2:10]);
    # 如果指令需要寄存器就从第二个字节中读出
    # valC同理，都由align硬件单元读出
else：
    int f_rA = 0xF;
    int f_rB = 0xF;
    if need_valC：
        word f_valC = ALIGN.align(ins[1:9]);
    # 反之，如果不需要寄存器就将两个寄存器值都设为0xF，即无寄存器
    # 这样valC就会存放在指令的2到9字节。
word f_valP = p + need_regids + 8*need_valC;
# valP代表下一条指令的地址
</code></pre><h1 id="对于PC值的运算"><a href="#对于PC值的运算" class="headerlink" title="对于PC值的运算"></a>对于PC值的运算</h1><p>word f_predPC = [<br>    f_icode in {ICALL,IJXX} : f_valC<br>    1 : f_valP<br>]; # 预测PC的值</p>
<p>f_predPC =&gt; F_predPC # 将预测结果存入流水线寄存器F</p>
<p>word f_pc = [<br>    M_icode == IJXX &amp;&amp; !M_Cnd : M_valA; # 预测发生错误的情况，根据M寄存器储存的值判断<br>    W_icode == IRET : W_valM; # ret指令<br>    1 : F_predPC # 大多数情况，预测模块给出的值都是正确的<br>]; # 确定PC的值，为取出下一条指令作准备</p>
<h1 id="信号的传递"><a href="#信号的传递" class="headerlink" title="信号的传递"></a>信号的传递</h1><p>f_icode =&gt; D_icode<br>f_ifun =&gt; D_ifun<br>F_stat += (imem_error,instr_valid) =&gt; D_stat<br>f_rA =&gt; D_rA<br>f_rB =&gt; D_rB<br>f_valC =&gt; D_valC<br>f_valP =&gt; D_valP</p>
<blockquote>
<blockquote>
<blockquote>
<p>译码和写回</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="控制逻辑，这里可能会发生Stall或Bubble"><a href="#控制逻辑，这里可能会发生Stall或Bubble" class="headerlink" title="控制逻辑，这里可能会发生Stall或Bubble"></a>控制逻辑，这里可能会发生Stall或Bubble</h1><p>bool D_stall = E_icode in {IMRMOVQ,IPOPQ} &amp;&amp; E_dstM in {d_srcA,d_srcB};</p>
<p>bool D_bubble = (E_icode == IJXX &amp;&amp; !e_Cnd) || # 预测出现失误的情况<br>               !(E_icode in {IMRMOVQ,IPOPQ} &amp;&amp; E_dstM in {d_srcA,d_srcB}) &amp;&amp; IRET in {D_icode,E_icode,M_icode}; # 处理RET指令</p>
<h1 id="译码部分与SEQ大部分一致"><a href="#译码部分与SEQ大部分一致" class="headerlink" title="译码部分与SEQ大部分一致"></a>译码部分与SEQ大部分一致</h1><p>word d_srcA = [<br>    D_icode in {IRRMOVQ,IRMMOVQ,IOPQ,IPUSHQ} : D_rA;<br>    D_icode in {IPOPQ,IRET} : RRSP;<br>    1 : RNONE;<br>];</p>
<p>word d_srcB = [<br>    D_icode in {IRMMOVQ,IOPQ} : D_rB;<br>    D_icode in {IPUSHQ,IPOPQ,ICALL,IRET} : RRSP;<br>    1 : RNONE;<br>];</p>
<p>word d_dstE = [<br>    D_icode in {IIRMOVQ,IOPQ,IRRMOVQ} : D_rB;<br>    D_icode in {IPUSHQ,IPOPQ,ICALL,IRET} : RRSP<br>    1 : RNONE<br>]; # 写回阶段的地址计算放在了译码阶段</p>
<p>word d_dstM = [<br>    icode in {IMRMOVQ} : D_rB<br>    icode in {IPOPQ} : D_rA<br>    1 : RNONE<br>]; # 初步的地址计算</p>
<p>word d_rvalA = REG.read(d_srcA);<br>word d_rvalB = REG.read(d_srcB);</p>
<h1 id="由于PIPE对valA和valP有个合并机制，这里读出的并不是最终的valA"><a href="#由于PIPE对valA和valP有个合并机制，这里读出的并不是最终的valA" class="headerlink" title="由于PIPE对valA和valP有个合并机制，这里读出的并不是最终的valA"></a>由于PIPE对valA和valP有个合并机制，这里读出的并不是最终的valA</h1><h1 id="合并信号valA和valP的依据是，只有call和跳转指令需要valP的值，而它们都不会需要valA"><a href="#合并信号valA和valP的依据是，只有call和跳转指令需要valP的值，而它们都不会需要valA" class="headerlink" title="合并信号valA和valP的依据是，只有call和跳转指令需要valP的值，而它们都不会需要valA"></a>合并信号valA和valP的依据是，只有call和跳转指令需要valP的值，而它们都不会需要valA</h1><h1 id="在这个阶段要处理数据转发，转发源有五个，需要分情况讨论"><a href="#在这个阶段要处理数据转发，转发源有五个，需要分情况讨论" class="headerlink" title="在这个阶段要处理数据转发，转发源有五个，需要分情况讨论"></a>在这个阶段要处理数据转发，转发源有五个，需要分情况讨论</h1><p>word d_valA = [<br>    D_icode in {IJXX,ICALL} : D_valP;<br>    d_srcA == e_dstE : e_valE;</p>
<pre><code># Forwarding，直接接受上一条指令execute阶段的计算结果
d_srcA == M_dstM : m_valM;
# Forwarding，接受上上条指令memory阶段的读内存结果
d_srcA == M_dstE : M_valE;
# Forwarding，接受上上条指令memory阶段进行前还未写回的计算结果
d_srcA == W_dstM : W_valM;
d_srcA == W_dstE : W_valE;
# Forwarding，接受上上上条指令在写回之前W寄存器中储存的访存和计算结果
1 : d_rvalA;
# 没有Forwarding，直接采取寄存器中读出的valA
</code></pre><p>];</p>
<p>word d_valB = [<br>    d_srcB == e_dstE : e_valE;</p>
<pre><code># Forwarding，直接接受上一条指令execute阶段的计算结果
d_srcB == M_dstM : m_valM;
# Forwarding，接受上上条指令memory阶段的读内存结果
d_srcB == M_dstE : M_valE;
# Forwarding，接受上上条指令memory阶段进行前还未写回的计算结果
d_srcB == W_dstM : W_valM;
d_srcB == W_dstE : W_valE;
# Forwarding，接受上上上条指令在写回之前W寄存器中储存的访存和计算结果
1 : d_rvalB;
# 没有Forwarding，直接采取寄存器中读出的valA
</code></pre><p>];</p>
<h1 id="信号传递"><a href="#信号传递" class="headerlink" title="信号传递"></a>信号传递</h1><p>D_stat =&gt; E_stat<br>d_icode =&gt; E_icode<br>d_ifun =&gt; E_ifun<br>d_valC =&gt; E_valC<br>d_valA =&gt; E_valA<br>d_valB =&gt; E_valB<br>d_srcA,d_srcB,d_dstE,d_dstM =&gt; E_srcA,E_srcB,E_dstE,E_dstM</p>
<blockquote>
<blockquote>
<blockquote>
<p>执行</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="控制逻辑，只会出现Bubble"><a href="#控制逻辑，只会出现Bubble" class="headerlink" title="控制逻辑，只会出现Bubble"></a>控制逻辑，只会出现Bubble</h1><p>bool E_bubble = E_icode in {IMRMOVQ,IPOPQ} &amp;&amp; E_dstM in {d_srcA,d_srcB} ||<br>                (E_icode == IJXX &amp;&amp; !e_Cnd)</p>
<h1 id="这部分实现基本与SEQ无异"><a href="#这部分实现基本与SEQ无异" class="headerlink" title="这部分实现基本与SEQ无异"></a>这部分实现基本与SEQ无异</h1><p>word e_aluA = [<br>    E_icode in {IRRMOVQ,IOPQ} : E_valA;</p>
<pre><code># 寄存器rA的值直接作操作数
E_icode in {IIRMOVQ,IMRMOVQ,IRMMOVQ} : E_valC;
# 内存与寄存器之间的移动需要计算地址加偏移量，所以将valC作操作数
E_icode in {ICALL,IPUSHQ} : -8;
E_icode in {IRET,IPOPQ} : 8;
# 这几个指令涉及对栈地址的计算，以8为单位进行增减，需要用到ALU计算
</code></pre><p>]; # 辅助操作数</p>
<p>word e_aluB = [<br>    E_icode in {IRMMOVQ,IOPQ} : E_valB;</p>
<pre><code># 寄存器rB的值直接做操作数或需要做地址运算
E_icode in {IMRMOVQ} : E_valA;
# 寄存器rA的值需要做地址运算
E_icode in {ICALL,IRET,IPUSHQ,IPOPQ} : E_valB;
# 这些时候valB的值是%rsp寄存器的值，作为栈基址操作数
E_icode in {IIRMOVQ,IRRMOVQ} : 0;
# 保留aluA的值不受操作影响
</code></pre><p>]; # 主操作数</p>
<p>word e_alufun = [<br>    E_icode == IOPQ : E_ifun;<br>    1 : 1;</p>
<pre><code># 除了在使用IPOQ指令时，所有时候ALU都是当加法器用的，其对应的alufun值为1
</code></pre><p>]; # 操作类型</p>
<h1 id="设置条件码，这里要小心异常触发的情况"><a href="#设置条件码，这里要小心异常触发的情况" class="headerlink" title="设置条件码，这里要小心异常触发的情况"></a>设置条件码，这里要小心异常触发的情况</h1><p>bool set_CC =<br>    !(m_stat in {SADR,SINS,SHLT}) &amp;&amp;<br>    !(W_stat in {SADR,SINS,SHLT}) &amp;&amp;<br>    E_icode == IOPQ ;</p>
<h1 id="如果memory和writeback阶段的指令触发了异常，任何对条件码的修改都应该中止。"><a href="#如果memory和writeback阶段的指令触发了异常，任何对条件码的修改都应该中止。" class="headerlink" title="如果memory和writeback阶段的指令触发了异常，任何对条件码的修改都应该中止。"></a>如果memory和writeback阶段的指令触发了异常，任何对条件码的修改都应该中止。</h1><p>word e_valE, int cc = ALU.calculate(e_aluA,e_aluB,func=e_alufun);<br>if set_cc:<br>    CC.set(cc);<br>bool e_Cnd = COND.gencnd(CC.get());</p>
<h1 id="进行计算，设置条件码"><a href="#进行计算，设置条件码" class="headerlink" title="进行计算，设置条件码"></a>进行计算，设置条件码</h1><h1 id="信号传输"><a href="#信号传输" class="headerlink" title="信号传输"></a>信号传输</h1><p>E_stat =&gt; M_stat<br>e_icode =&gt; M_icode<br>e_Cnd =&gt; M_Cnd<br>e_valE =&gt; M_valE<br>E_valA =&gt; M_valA<br>e_dstE =&gt; M_dstE<br>E_dstM =&gt; M_dstM</p>
<blockquote>
<blockquote>
<blockquote>
<p>访存</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="控制逻辑，这部分需要处理异常"><a href="#控制逻辑，这部分需要处理异常" class="headerlink" title="控制逻辑，这部分需要处理异常"></a>控制逻辑，这部分需要处理异常</h1><p>bool M_bubble = m_stat in {SADR,SINS,SHLT} || W_stat in {SADR,SINS,SHLT};</p>
<h1 id="这一部分与SEQ相同"><a href="#这一部分与SEQ相同" class="headerlink" title="这一部分与SEQ相同"></a>这一部分与SEQ相同</h1><p>word mem_addr = [<br>    M_icode in {IRMMOVQ,IMRMOVQ,ICALL,IMRMOVQ} : M_valE;<br>    M_icode in {IRET,IPOPQ} : M_valA;<br>];</p>
<p>bool mem_read = M_icode in {IMRMOVQ,IPOPQ,IRET};<br>bool mem_write = M_icode in {IRMMOVQ,IPUSHQ,ICALL};</p>
<h1 id="确定读写数据的步骤被省略了，因为之前已经将valA和valP进行了merge操作"><a href="#确定读写数据的步骤被省略了，因为之前已经将valA和valP进行了merge操作" class="headerlink" title="确定读写数据的步骤被省略了，因为之前已经将valA和valP进行了merge操作"></a>确定读写数据的步骤被省略了，因为之前已经将valA和valP进行了merge操作</h1><p>try:<br>    if mem_read:<br>        m_valM = MEM.read(baseptr=mem_addr,size=8);<br>    if mem_write:<br>        MEM.write(baseptr=mem_addr,data=M_valA);<br>except:<br>    bool dmem_error = 1;</p>
<h1 id="信号传输-1"><a href="#信号传输-1" class="headerlink" title="信号传输"></a>信号传输</h1><p>m_stat += dmem_eroor =&gt; W_stat<br>M_icode =&gt; W_icode<br>M_valE =&gt; W_valE<br>m_valM =&gt; W_valM<br>M_dstE =&gt; W_dstE<br>M_dstM =&gt; W_dstM</p>
<blockquote>
<blockquote>
<blockquote>
<p>写回</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="在下一个时钟周期开始之前，handle一下异常"><a href="#在下一个时钟周期开始之前，handle一下异常" class="headerlink" title="在下一个时钟周期开始之前，handle一下异常"></a>在下一个时钟周期开始之前，handle一下异常</h1><p>bool W_stall = W_stat in {SADR,SINS,SHLT};</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 示意图</span><br><span class="line"></span><br><span class="line">![memory](/images/CSAPP/Chapter_4/memory.png)</span><br><span class="line">![execute](/images/CSAPP/Chapter_4/execute.png)</span><br><span class="line">![decode](/images/CSAPP/Chapter_4/decode.png)</span><br><span class="line">![fetch](/images/CSAPP/Chapter_4/fetch.png)</span><br><span class="line">![control](/images/CSAPP/Chapter_4/control.png)</span><br><span class="line"></span><br><span class="line">## 改进的空间</span><br><span class="line"></span><br><span class="line">- 多周期指令</span><br><span class="line">    + 整数乘法需要3-4个时钟周期完成，而整数除法更是需要64个周期。对于这样的多周期操作，必须调整流水线的设计以适应其运行时间。</span><br><span class="line">- 与存储系统的接口</span><br><span class="line">    + 在PIPE设计中，我们假设取指单元和数据内存的读写都可以在一个时钟周期内完成(但这显然是不可能的)。</span><br><span class="line">    + 通过高速缓存和翻译后备缓冲器(将物理地址翻译为虚拟地址)，可以将数据内存读写的速度尽可能降低到一个时钟周期以内。</span><br><span class="line">    + 对于高速缓存不命中和pagefault异常触发等问题，可以使用stall来等待数据就位。</span><br><span class="line"></span><br><span class="line"># Chapter 5 优化程序性能</span><br><span class="line"></span><br><span class="line">## 绪论</span><br><span class="line"></span><br><span class="line">- 编写高效程序的要素</span><br><span class="line">    + 合适的算法和数据结构</span><br><span class="line">    + 写出适于编译器优化的代码</span><br><span class="line">        * 不同的语言优化的难度是不同的，越灵活的语言越是难以优化。</span><br><span class="line">        * 程序员应当在代码性能和代码可读性之间作出权衡。</span><br><span class="line">    + 使用并行计算的策略</span><br><span class="line"></span><br><span class="line">## 编译器优化的局限性</span><br><span class="line"></span><br><span class="line">### 编译器的优化级别</span><br><span class="line"></span><br><span class="line">编译器会对其在编译过程中做的优化工作量做一个分级。以GCC为例，参数-Og表示使用基本的优化，-O1到-O3则代表着越来越大的优化量。</span><br><span class="line"></span><br><span class="line">优化量越大，程序的效率一般会越高，但程序和源程序的差距也越大，越难以调试。企业采用的优化标准一般是-O2级，本书采用的级别是-O1.</span><br><span class="line"></span><br><span class="line">### 保证优化的安全性</span><br><span class="line"></span><br><span class="line">为了避免优化前后程序的行为出现差异，编译器被限制为只能做出“安全”的优化。这就意味着编译器能做的改动更小，程序员的优化显得更为重要。</span><br><span class="line"></span><br><span class="line">不安全的优化大致有以下几种：</span><br><span class="line"></span><br><span class="line">#### Memory aliasing</span><br><span class="line"></span><br><span class="line">在对指针的目标值进行操作的过程中，可能出现两个指针指向同一个内存地址的情况，这种状况称为 __内存别名使用(Memory aliasing)__ 。编译器必须假设两个不同的指针可能指向同一位置，这就大大限制了可以作出的优化。</span><br><span class="line"></span><br><span class="line">例如，执行下面代码段：</span><br></pre></td></tr></table></figure>
<p><em>ptr1 = 3000;
</em>ptr2 = 1000;<br>x = *ptr1;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果两个指针指向不同的位置，那么x无疑等于3000,但如果反之，由于逻辑顺序，x等于1000。考虑到可能出现二义性的后果，编译器不能产生类似这样的代码段(除非源程序有意为之)。</span><br><span class="line"></span><br><span class="line">#### 函数调用</span><br><span class="line"></span><br><span class="line">同一个函数，以同样的参数调用，其返回的值可能不同，这是过程式语言的一大弱点，即所谓的side effect。这就导致了，编译器无法把以几次函数调用的返回值为操作数的多次操作化简为一次操作，比如不能把`f()+f()`化简为`2*f()`。</span><br><span class="line"></span><br><span class="line">## 度量程序的性能</span><br><span class="line"></span><br><span class="line">对于线性类复杂度的程序，我们引入 __每元素周期数(CPE)__ 作为度量标准。每元素周期数指的是输入每增加一个元素，程序所多消耗的时钟周期数。本质上讲，也就是复杂度公式中n项的参数。</span><br><span class="line"></span><br><span class="line">## 对循环过程进行的优化</span><br><span class="line"></span><br><span class="line">### 代码移动</span><br><span class="line"></span><br><span class="line">将在循环过程中结果不会改变的操作移到循环外进行，这个过程称为 __代码移动(code motion)__ 。编译器在遇到函数调用或内存访问的情况下不敢进行代码移动，因为它们可能产生side effect。这种时候就需要程序员宏观地修改代码进行代码移动。</span><br><span class="line"></span><br><span class="line">代码移动是一项简朴易懂但十分有效的优化。虽然看似有经验的程序员都能够自动完成这项工作，但大型项目中也不乏由于没有进行代码移动而导致的效率危机。</span><br><span class="line"></span><br><span class="line">### 减少过程调用</span><br><span class="line"></span><br><span class="line">是应该进行更多的封装，使程序更加模块化和易于复用还是减少过程的调用，直接操作底层数据结构一直是一个保受争议的问题。对于C程序员来说，灵活地操作底层数据结构虽然会增大程序崩溃的几率，但可以大大提高程序的运行效率(因为减少了不必要的条件检查)。</span><br><span class="line"></span><br><span class="line">### 消除不必要的内存引用</span><br><span class="line"></span><br><span class="line">众所周知，内存读写比寄存器的读写要慢的多。因此，在循环过程中用临时变量存储计算中间结果要大大优于每次都进行内存读写。尽量消除不必要的内存读写可以大大提高程序性能，尤其是在循环结构中。</span><br><span class="line"></span><br><span class="line">## 利用硬件特性进行的优化</span><br><span class="line"></span><br><span class="line">现代处理器的微体系结构已经相当发达，这使得汇编语言指定的行为与机器实际的行为大相径庭。由于 __指令级并行__ 的存在，现代处理器同时对多条指令进行求值，通过hazard消除技术避免副作用，并通过巧妙的安排让执行结果看上去像是顺序执行的。</span><br><span class="line"></span><br><span class="line">在上一章对处理器流水线结构设计的了解中，我们知道要避免Hazard必须满足前后两条指令之间没有依赖关系，否则无论如何后一条指令都必须在前一条指令执行完后才能执行。一系列操作之间的依赖性导致的性能瓶颈称为 __延迟界限(latency bound)__，而处理器本身算力所导致的性能瓶颈称为 __吞吐量界限(throughput bound)__ 。</span><br><span class="line"></span><br><span class="line">### 现代微处理器设计</span><br><span class="line"></span><br><span class="line">与之前的流水线顺序处理器不同，现代处理器是乱序处理的，也就是说指令执行顺序甚至不一定与机器语言中规定的相同。为了达成这个目的，处理器分为两部分：__指令控制单元(ICU)__ 和 __执行单元(EU)__ 。前者负责读出指令序列并生成操作，后者执行这些操作。</span><br><span class="line"></span><br><span class="line">ICU会从指令高速缓存中取指令，并利用分支预测技术来决定下一个指令从哪里取出。每取出一个指令，ICU都将其拆分成一个个单元操作，并将单元操作们输送给EU，再由EU中的多个操作单元并行执行各种单元操作。</span><br><span class="line"></span><br><span class="line">### 功能单元的性能</span><br><span class="line"></span><br><span class="line">功能单元的性能从三个方面衡量：__延迟(latency)__，__发射时间(issuetime)__，__容量(capacity)__。</span><br><span class="line"></span><br><span class="line">延迟表示运算需要的总时间，而发射时间表示开始执行一次运算后到开始执行下一次运算所需要的时间。在完全顺序执行的情况下两者应该相等，但由于流水线化的设计，一条指令可以在上一条结束前就开始执行，这使得发射时间大大减小了。发射时间为1的操作称为完全流水线化操作，这种操作的两次之间必须是完全无依赖的。</span><br><span class="line"></span><br><span class="line">容量则表示了能执行一个操作的功能单元数。一个处理器的 __吞吐量__ 由功能单元的发射时间和容量决定，其具体值为 capacity/issuetime。</span><br><span class="line"></span><br><span class="line">### 关键路径</span><br><span class="line"></span><br><span class="line">将操作全部分解为基本操作，理清寄存器的占用与操作之间的依赖关系之后，便可以找出所有依赖链中最长最粗的一条，这条操作链就是关键路径。关键路径的长度和单位长度耗时直接决定着延迟界限，也就是程序性能。</span><br><span class="line"></span><br><span class="line">## 循环展开</span><br><span class="line"></span><br><span class="line">将原循环过程中的每两次循环合并为一次来书写循环体，这种修改称为 __循环展开__ 。</span><br><span class="line"></span><br><span class="line">循环展开有如下好处：</span><br><span class="line"></span><br><span class="line">- 减少了条件判断和迭代量计算的次数</span><br><span class="line">- 提供了变化代码，减少关键路径上操作的机会</span><br><span class="line"></span><br><span class="line">在不改变关键路径操作的情况下，循环展开能将性能改善到逼近延迟界限的程度。</span><br><span class="line"></span><br><span class="line">优化等级-O3会使GCC自动使用循环展开优化。</span><br><span class="line"></span><br><span class="line">## 提高并行性</span><br><span class="line"></span><br><span class="line">这一部分，《串并行算法与数据结构》已经讲的足够清楚了。</span><br><span class="line"></span><br><span class="line">## 其他的制约因素</span><br><span class="line"></span><br><span class="line">### 寄存器溢出</span><br><span class="line"></span><br><span class="line">虽然程序的并行度可以提高，但是处理器的寄存器数量是有限的。如果我们只顾着提高并行度，建立更多的临时循环变量，寄存器就可能发生不够用的情况。这时，处理器会在程序栈甚至内存中存放临时变量，这样甚至会使程序性能变得更低。</span><br><span class="line"></span><br><span class="line">### 预测错误处罚</span><br><span class="line"></span><br><span class="line">分支预测技术的错误处罚代价是很大的，因为要抛弃所有正在运行的指令和结果并跳回到新位置重新开始。很难帮助处理器避免预测错误，因为其预测逻辑不为程序员所见。但是，如果能够尽量用 __条件数据传送__ 来取代 __条件控制转移__ 命令，就可以大大减少分支预测错误的处罚，因为数据传送一般不涉及控制流跳转问题，发生错误只需要更改结果即可。</span><br><span class="line"></span><br><span class="line">对于GCC来说，用条件操作计算值并用值更新程序状态会编译出条件数据传送，而直接用条件操作改变程序状态则会编译出条件控制转移。因此，在一些关键位置改变代码风格可以大大降低错误预测的开销。</span><br><span class="line"></span><br><span class="line">## 程序分析工具gprof</span><br><span class="line"></span><br><span class="line">gprof以二进制可执行文件为参数，它记录输入的程序执行过程中每个函数所花的时间。</span><br><span class="line"></span><br><span class="line"># Chapter 6 存储器层次结构</span><br><span class="line"></span><br><span class="line">## 存储技术</span><br><span class="line"></span><br><span class="line">### 随机访问存储器(RAM)</span><br><span class="line"></span><br><span class="line">随机访问存储器分为两类：静态的(SRAM)和动态的(DRAM)。SRAM比DRAM更快(1000倍)，常常用作高速缓存。</span><br><span class="line"></span><br><span class="line">SRAM由双稳态存储单元组成。每个单元都是一个六晶体管电路，它只有两种稳态值，只要有电，就算受到扰动也会迅速回归到稳态值上去。</span><br><span class="line"></span><br><span class="line">DRAM由C很小的电容组成，用对电容的充电或无电表示1和0。DRAM存储器单元对扰动非常敏感，一旦电压被扰乱便无法恢复。</span><br><span class="line"></span><br><span class="line">#### 内存条的存储结构</span><br><span class="line"></span><br><span class="line">每一块DRAM芯片的存储位被组织成同样大小的 __单元__ ，每个单元一般含有若干个字节的信息。单元在DRAM芯片中以矩阵形式排列，每个单元都有其唯一的可以被索引的地址。</span><br><span class="line"></span><br><span class="line">DRAM芯片通过 __引脚__ 和外界沟通，一块芯片有8个data引脚，用以传递一个字节的信息；还有若干个addr引脚，用以索引具体的单元。每个芯片还有一个行缓冲区。</span><br><span class="line"></span><br><span class="line">所有的DRAM芯片都连接到一个内存控制器上，内存控制器可以同时向每个DRAM芯片发送一位。在需要读取的时候，控制器首先将需要读取的地址转换成DRAM中的行和列索引，随即向每个DRAM芯片的addr发送一个相同的行索引，让其将对应的行复制到行缓冲区中；然后发送一个列索引，从每个芯片中取到目标单元值，最后内存控制器整合所有的单元值并输出。</span><br><span class="line"></span><br><span class="line">### 非易失性存储器</span><br><span class="line"></span><br><span class="line">#### 只读存储器(ROM)</span><br><span class="line"></span><br><span class="line">PROM存储器(programmable read-only memory)只能被编程一次，它由能用高电流熔断的熔丝组成。EPROM(erasable PROM)和EEPROM(electrical EPROM)则可以多次编程。</span><br><span class="line"></span><br><span class="line">存储在ROM中的程序称为 __固件(firmware)__ 。它包括一些基本的输入输出函数和计算机系统启动所必需的程序。</span><br><span class="line"></span><br><span class="line">### 磁盘</span><br><span class="line"></span><br><span class="line"># Chapter 7 链接</span><br><span class="line"></span><br><span class="line">## Compiler driver</span><br><span class="line"></span><br><span class="line">大多数需要编译的语言都会提供一个 __编译器驱动程序(Compiler driver)__ ，以C语言为例，这个程序会依次调用预处理器，编译器，汇编器和链接器，将源代码转换为二进制文件。</span><br><span class="line"></span><br><span class="line">当我们使用gcc去将多个互相关联的文件编译为一个二进制文件时，这些源文件的预处理、编译和汇编过程都是分别进行的，而在最后的链接过程中被合为一体。</span><br><span class="line"></span><br><span class="line">当我们运行可执行文件时，shell调用加载器，将文件内容拷贝到内存中并将控制流转移到二进制文件开头。</span><br><span class="line"></span><br><span class="line">## 静态链接</span><br><span class="line"></span><br><span class="line">静态链接器所接受的 __可重定位目标文件__ 由各种不同的代码和数据节组成，其中每一节都是一个连续的字节序列。指令、未初始化的全局变量和初始化过的全局变量分居不同的section。</span><br><span class="line"></span><br><span class="line">链接器要完成的主要任务是：</span><br><span class="line"></span><br><span class="line">- __符号解析__：将目标文件中的每个每个符号引用和其符号定义关联起来。</span><br><span class="line">- __重定位__：将每个符号引用指向其对应的符号定义的内存位置。</span><br><span class="line"></span><br><span class="line">注意：链接器进行重定位的依据是汇编器所产生并记录在目标文件中的重定位条目。其自身并不做过多工作。</span><br><span class="line"></span><br><span class="line">## 目标文件</span><br><span class="line"></span><br><span class="line">目标文件有三种：</span><br><span class="line"></span><br><span class="line">- 可重定位目标文件：无法直接执行，但包括所有数据和代码的文件</span><br><span class="line">- 可执行目标文件：经过链接，可以直接复制到内存中执行的文件</span><br><span class="line">- 共享目标文件：可以动态地加载到内存中进行运行或链接的可重定位目标文件</span><br><span class="line"></span><br><span class="line">### 可重定位目标文件</span><br><span class="line"></span><br><span class="line">现代Linux系统下的目标文件格式一般为 __ELF(Executable and Linkable format)__ 格式。下表大致地描述了一个ELF可重定位目标文件的组成格式。</span><br><span class="line"></span><br><span class="line">| ELF头 |</span><br><span class="line">|-------|</span><br><span class="line">| .text |</span><br><span class="line">|.rodata|</span><br><span class="line">| .data |</span><br><span class="line">|  .bss |</span><br><span class="line">|.symtab|</span><br><span class="line">|.rel.text|</span><br><span class="line">|.rel.data|</span><br><span class="line">|.debug|</span><br><span class="line">| .line |</span><br><span class="line">|.strtab|</span><br><span class="line">|节头部表|</span><br><span class="line"></span><br><span class="line">灵活地使用linux下的`readelf`工具可以有很大帮助。</span><br><span class="line"></span><br><span class="line">#### ELF头</span><br><span class="line"></span><br><span class="line">ELF头记录着一个目标文件的基本信息。其内容如下：</span><br><span class="line"></span><br><span class="line">- 描述系统 __字长__ 和 __字节序__ 的一个16字节序列</span><br><span class="line">- ELF头的大小</span><br><span class="line">- 目标文件类型</span><br><span class="line">- 机器类型</span><br><span class="line">- 节头部表的位置</span><br><span class="line">- 节头部表中条目的大小和数量</span><br><span class="line"></span><br><span class="line">#### 节头部表</span><br><span class="line"></span><br><span class="line">节头部表位于目标文件的末端，它记录了ELF文件中每个节的大小和位置。</span><br><span class="line"></span><br><span class="line">#### 节</span><br><span class="line"></span><br><span class="line">在ELF头和节头部表之间的部分都是节。一个典型的ELF文件包括如下节：</span><br><span class="line"></span><br><span class="line">- `.text` 已编译程序的机器代码</span><br><span class="line">- `.rodata` 只读数据，包括声明中用到的常量和switch跳转表等</span><br><span class="line">- `.data` 已经初始化的全局变量和静态变量(局部变量在程序栈中)</span><br><span class="line">- `.bss` 未初始化或初始化为0的全局和静态变量，它们不占据任何实际空间。</span><br><span class="line">- `.symtab` 存放着在程序中定义和引用的函数和全局变量信息的符号表</span><br><span class="line">    + __这个符号表只在链接或调试过程中有用__</span><br><span class="line">    + 可以使用`strip`命令去掉目标文件中的符号表</span><br><span class="line">- `.rel.text`和`.rel.data` 分别是函数和全局变量的重定位表，链接器根据其中储存的信息去制作symtab</span><br><span class="line">- `.debug` 一个调试符号表，以-g选项调用编译器才会产生这张表，是调试所需要的</span><br><span class="line">- `.line` 同样以-g选项调用才会产生，用于将行数映射到机器指令</span><br><span class="line">- `.strtab` 一个字符串表，包括.symtab和.debug节中的符号名和各种节头的名字</span><br><span class="line"></span><br><span class="line">除了这些节以外，还有没有列入节头部表的几个 __伪节__ ：</span><br><span class="line"></span><br><span class="line">- `ABS` 不该被重定位的符号</span><br><span class="line">- `UNDEF` 外部符号</span><br><span class="line">- `COMMON` 和.bss类似，COMMON包括未初始化的全局变量，其余归.bss。</span><br><span class="line"></span><br><span class="line">#### 符号表</span><br><span class="line"></span><br><span class="line">在链接器的上下文中有三种不同的符号：</span><br><span class="line"></span><br><span class="line">- 全局符号：由一个模块定义，被其他模块引用的符号，如非静态函数和全局变量。</span><br><span class="line">- 外部符号：由其他模块定义，被本模块引用的符号。</span><br><span class="line">- 局部符号：被一个模块定义且只被其本身引用的符号，包括静态的函数和全局变量。</span><br><span class="line"></span><br><span class="line">__在C中，源文件扮演模块的角色__。用static声明的函数和变量可以视为private的，而不加static的则可以视为pubilc的。</span><br><span class="line"></span><br><span class="line">`.symtab`节中的符号表表项是下面的结构体：</span><br></pre></td></tr></table></figure></p>
<p>struct {<br>    int name;        // 指示表项的名称字符串在.strtab中的位置<br>    char type:4;     // 4bits数据，表示该表项是函数还是变量(或者其它类别)<br>    char binding:4;  // 4bits数据，表示该表项是本地还是全局的(或者其它类别)<br>    long value;      // 指示表项的初始化位置距离初始化节起始位置的偏移量<br>    long size;       // 每个表项指向的量所占的字节数<br>    short section;   // 表项所属的节在节头部表中的位置(或伪节的名称)<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 可执行目标文件</span><br><span class="line"></span><br><span class="line">可执行目标文件的结构与可重定位目标文件大致相同：</span><br><span class="line"></span><br><span class="line">| ELF头 |</span><br><span class="line">|-------|</span><br><span class="line">| 段头部表|</span><br><span class="line">| .init |</span><br><span class="line">| .text |</span><br><span class="line">|.rodata|</span><br><span class="line">| .data |</span><br><span class="line">|  .bss |</span><br><span class="line">|.symtab|</span><br><span class="line">|.debug|</span><br><span class="line">| .line |</span><br><span class="line">|.strtab|</span><br><span class="line">|节头部表|</span><br><span class="line"></span><br><span class="line">ELF头中多出了程序的入口点，即第一条指令地址这一信息。.init节定义了一个初始化函数。由于可执行文件已经完成重定位，它不再需要.rel节。</span><br><span class="line"></span><br><span class="line">从.init到.rodata段是只读段，存放代码段；.data和.bss是读写段，存放数据；剩下的位置不加载到内存，多数情况下用于调试。</span><br><span class="line"></span><br><span class="line">段头部表指示各个代码/数据段的位置。</span><br><span class="line"></span><br><span class="line">#### 可执行目标文件的加载</span><br><span class="line"></span><br><span class="line">加载的过程是由加载器来完成的。加载器首先根据段头部表将各个字节段拷贝到内存的相应位置，然后跳转到程序的入口点，也就是`_start`函数的地址。这个函数是所有C程序的入口点，`_start`函数会调用系统启动函数来初始化执行环境并调用main函数。main函数返回后，它接受并处理返回值。</span><br><span class="line"></span><br><span class="line">## 符号解析</span><br><span class="line"></span><br><span class="line">### 多重定义的全局符号</span><br><span class="line"></span><br><span class="line">Linux将未初始化的全局变量规定为弱符号，而函数和初始化的全局变量是强符号。</span><br><span class="line"></span><br><span class="line">- 当出现同名的强符号时，报错</span><br><span class="line">- 当出现同名的强符号和弱符号时，选择强符号</span><br><span class="line">- 当出现同名的弱符号时，随机选择一个</span><br><span class="line"></span><br><span class="line">后两条规则会导致一些不易察觉的错误。比如，一个文件中定义了一个未初始化的x和一个操作x的函数，而另一个文件中定义了一个初始化过的x，那么函数的执行就可能在另一个文件编写者不知道的情况下改变x的值。</span><br><span class="line"></span><br><span class="line">### 静态库</span><br><span class="line"></span><br><span class="line">编译系统提供一种机制，将所有相关的目标文件打包成为一个单独的文件，称为静态库。当链接器构造出一个目标文件时，它只会拷贝静态库中被引用的部分。</span><br><span class="line"></span><br><span class="line">在编译指令中加上静态库文件的名字可以将这个库作为链接器的输入之一。使用静态库可以减少程序员在源文件中进行include的头文件数。</span><br><span class="line"></span><br><span class="line">静态库以一种称为 __存档(archive)__ 的特殊文件格式存放在磁盘中。存档文件由后缀`.a`标识。</span><br><span class="line"></span><br><span class="line">`ar`工具可以将几个.o文件打包成为一个静态库。</span><br><span class="line"></span><br><span class="line">当将静态库作为gcc的参数时，要注意目标文件和库文件的顺序。一般来说，依赖源放在后面。</span><br><span class="line"></span><br><span class="line">## 重定位</span><br><span class="line"></span><br><span class="line">重定位过程合并输入模块，并为每个符号分配运行时地址。</span><br><span class="line"></span><br><span class="line">重定位分为两步：</span><br><span class="line"></span><br><span class="line">- __重定位节和符号定义__：在这个过程中，链接器将所有相同类型的节进行合并，为它们中的每个条目重新分配运行时内存地址，并更新ELF头和节头部表的信息。完成这一步后，程序中每条 __指令__ 和每个 __全局变量__ 都具有唯一的运行时内存地址。</span><br><span class="line">- __重定位符号引用__：修改代码节和数据节中对每个变量或函数的引用，将它们指向正确的运行时地址。完成这一步需要借助可重定位目标文件中的 __重定位条目__ 。</span><br><span class="line"></span><br><span class="line">### 重定位条目</span><br><span class="line"></span><br><span class="line">汇编器会将每个遇到的引用分别放在等量的重定位条目中，以此告诉链接器如何在目标文件合并时修改这个引用。代码和已初始化数据的重定位条目分别存放在.rel.text和.rel.data中。</span><br><span class="line"></span><br><span class="line">重定位条目的格式如下：</span><br></pre></td></tr></table></figure></p>
<p>struct {<br>    long offset;    // 需要被修改的引用在节中的位置<br>    long type:32;   // 重定位类型<br>    long symbol:32; // 被修改的引用应该指向的符号在符号表中的位置,用于标识引用对象<br>    long addend;    // 对最终重定位位置所做的调整<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">__重定义类型__有32种，其中最常见的有两种：</span><br><span class="line"></span><br><span class="line">- R_X86_64_PC32 重定义一个使用相对寻址的引用</span><br><span class="line">- R_X86_64_32 重定义一个使用绝对寻址的引用</span><br><span class="line"></span><br><span class="line">对于相对寻址来说，由于在重定位过程中所有模块中的节都已经合并，可以知道引用源和引用对象处于同一个`.text`节中。这样一来，只需要知道引用对象的地址，就可以通过offset和addend计算出所需要的相对变址，也就是源和对象代码之间的距离。</span><br><span class="line"></span><br><span class="line">而绝对寻址更加简单，只需要将引用对象的地址和addend的加值作为绝对地址来重定位即可。</span><br><span class="line"></span><br><span class="line">addend项的作用是抵消掉处理器流水线的影响。在相对寻址中，处理器根据当前PC的值和变址来计算应当跳转到的位置。然而当处理器在执行调用指令(比如call)时，此时的PC值其实是下一条指令的地址。因而，此时需要在变址中加入addend值来进行修正，addend值应设置为两条指令之间地址差的相反数。对于绝对寻址，addend一般设置为0.</span><br><span class="line"></span><br><span class="line">## 动态链接库</span><br><span class="line"></span><br><span class="line">动态链接库是一个目标模块，可以加载到任意的内存地址并与内存中的程序链接。这个过程是由 __动态链接器__ 来完成的，称为动态链接。动态链接库在LINUX下以`.so`为后缀，而在windows下则以DLL文件为格式。</span><br><span class="line"></span><br><span class="line">对于使用了动态链接库的目标文件，链接器会额外创建一个`.interp`节来包含动态链接器的路径。在加载器加载和运行可执行目标文件时，它会识别这个节，并加载和运行这个动态链接器。</span><br><span class="line"></span><br><span class="line">动态链接器被加载后，将需要的共享库加载到指定内存段，并建立目标程序与共享库之间的链接，最后将控制传递给目标程序。</span><br><span class="line"></span><br><span class="line">如果要在编写程序时指定共享库，可以使用`&lt;dlfcn.h&gt;`。如果要创建共享库，可以使用gcc参数`gcc -shared -fpic`</span><br><span class="line"></span><br><span class="line">`-fpic`参数会指定生成 __位置无关代码__(Position-Independent Code) 这种代码可以加载而无需重定位，是为了解决动态链接加载问题而设计的。</span><br><span class="line"></span><br><span class="line">### 位置无关代码(PIC)</span><br><span class="line"></span><br><span class="line">动态链接的一个问题在于，进程该如何定位加载到内存中的动态链接库代码。如果为每一个动态链接库分配一块指定的内存，既不方便动态链接库的修改与更新，又会使系统的可用资源减少。</span><br><span class="line"></span><br><span class="line">PIC利用了加载的一个特性，即加载到内存中的数据段和代码段之间的距离是 __运行时常量__ 。它在每个数据段开始的位置创建一个 __全局偏移量表(GOT)__ ，这个表的每一项都与数据段中对全局变量或函数的引用关联。在加载时，动态链接器会重定位GOT的每一项，使其指向本模块或其他模块中的引用对象定义/初始化位置。</span><br><span class="line"></span><br><span class="line">然而，动态链接库中的函数有可能数量巨大，如果所有函数都交由GOT和动态链接器处理，程序的加载过程将会变得极其耗时。为了解决这个问题，GNU采用一种叫做 __延迟绑定__ 的机制，将过程地址的重定位推迟到第一次调用该过程的时间点。</span><br><span class="line"></span><br><span class="line">延迟绑定需要GOT和另一种数据结构 —— __过程链接表(PLT)__ 的辅助。GOT是数据段的一部分，而PLT是代码段的一部分，它的每个表项都是一个16字节代码段，对应一个函数调用。在初始化GOT的时候，所有对函数引用的GOT都指向其函数对应的PLT的第二个指令。</span><br><span class="line"></span><br><span class="line">`PLT[0]`对应动态链接器的入口，用于跳转到动态链接器；`PLT[1]`对应`_start`函数，之后的条目则对应用户所声明的函数。而GOT的前两个条目包含动态链接器的参数信息，其后的条目则依次对应PLT中相应函数的入口。由于数据段与代码段之间的距离是运行时不变量，GOT的每个表项`GOT[i]`与PLT中的`PLT[i-2]`之间的距离是固定的。</span><br><span class="line"></span><br><span class="line">在一个函数第一次被调用时，它的运行时地址被解析：</span><br><span class="line"></span><br><span class="line">- 程序进入这个函数对应的PLT条目</span><br><span class="line">- PLT条目第一指令是跳转指令，跳转目标是该函数对应GOT所指向的地址</span><br><span class="line">- 由于GOT的初始值为PLT第二个指令，此时控制来到PLT第二个指令</span><br><span class="line">- 第二个指令将函数ID压栈，第三个指令跳转到`PLT[0]`</span><br><span class="line">- `PLT[0]`通过`GOT[1]`将动态链接器参数压栈，并通过`GOT[2]`跳转到动态链接器入口</span><br><span class="line">- 动态链接器通过两个参数确定函数所在的动态库模块并找到其加载到的内存位置</span><br><span class="line">- 动态链接器用这个位置重写GOT中该函数表项的值</span><br><span class="line">- 动态链接器将控制转交给这个函数</span><br><span class="line"></span><br><span class="line">而之后的调用就会简单很多，因为GOT中关于这个函数的表项已经被重写为正确的地址了，PLT可以直接通过这个地址跳转到函数入口。</span><br><span class="line"></span><br><span class="line">## 库打桩机制</span><br><span class="line"></span><br><span class="line">Linux链接器支持打桩机制，它允许用户截取对系统函数的调用，取而代之地调用一个与这个函数原型完全相同，但内容自由定义的函数。</span><br><span class="line"></span><br><span class="line">### 编译时打桩</span><br><span class="line"></span><br><span class="line">以对malloc.h文件进行打桩为例：</span><br><span class="line"></span><br><span class="line">- 首先，在调用了malloc函数的源文件所在文件夹下创建一个malloc.h文件，并在其中将对malloc的调用重新定向：</span><br></pre></td></tr></table></figure></p>
<p>#define malloc(size) fake_malloc(size)<br>void *fake_malloc(size_t size);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 自行编写一个.c文件，将你想要让malloc函数做的事情写进去，并用gcc将其编译为.o文件：</span><br></pre></td></tr></table></figure></p>
<p>gcc -c <xxx>.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 用gcc进行编译时打桩</span><br></pre></td></tr></table></figure></xxx></p>
<p>gcc -I. &lt;源文件&gt;.c <xxx>.o<br><code>`</code></xxx></p>
<p>由于指定了<code>-I.</code>参数，C预处理器会优先在当前文件夹中搜索malloc.h文件，于是打桩成功，计划通！</p>
<h3 id="链接时打桩"><a href="#链接时打桩" class="headerlink" title="链接时打桩"></a>链接时打桩</h3><p>gcc的一组参数可以用于打桩：</p>
<ul>
<li><code>-Wl,&lt;option&gt;</code>参数：将option作为参数传给链接器。option中的空格要替换为逗号来写。</li>
<li><code>--wrap &lt;token&gt;</code>参数：链接器参数，将token解析为<code>__wrap_&lt;token&gt;</code>，并将<code>__real_&lt;token&gt;</code>解析为token。</li>
</ul>
<p>利用这两个参数，可以自定义<code>__wrap_&lt;token&gt;</code>函数，在其中定义自己的函数，再使用<code>__real_&lt;token&gt;</code>来调用原本的token函数。最后，使用<code>gcc -Wl,--wrap,&lt;token&gt;</code>参数来编译。</p>
<h3 id="运行时打桩"><a href="#运行时打桩" class="headerlink" title="运行时打桩"></a>运行时打桩</h3><p>通过设置<code>LD_PRELOAD</code>环境变量的值为一个目录，可以使动态链接器在搜索默认目录的动态库之前先搜索指定目录下的动态库。通过这个特性可以轻松地实现运行时打桩。</p>
<h2 id="工具总结"><a href="#工具总结" class="headerlink" title="工具总结"></a>工具总结</h2><ul>
<li>AR 用于创建和修改静态库 </li>
<li>STRINGS 列出一个 <strong>可执行文件</strong> 中所有可以打印的字符串</li>
<li>STRIP 用于删除符号表</li>
<li>NM 列出一个 <strong>可执行文件</strong> 的符号表信息</li>
<li>SIZE 列出可执行文件中节的信息</li>
<li>READELF</li>
<li>OBJDUMP</li>
<li>LDD 列出一个可执行文件需要的共享库</li>
</ul>
<h1 id="Chapter-8-异常控制流"><a href="#Chapter-8-异常控制流" class="headerlink" title="Chapter 8 异常控制流"></a>Chapter 8 异常控制流</h1><p>控制流会在很多种情况下发生变化：跳转，函数调用，返回都属于正常的控制流变化，在源程序的控制之内；但系统状态的变化也会引起一些控制流突变，我们将这些控制流变化统称为 <strong>异常控制流(Exceptional Control Flow)</strong> 。</p>
<p>在硬件层，硬件可能会因为预料外或不合规定的状态变化而抛出异常；在操作系统层，内核经常将控制权在不同进程之间转移；在应用层，进程之间的信号通信可以让程序回避栈规则进行跳转。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><strong>异常(Exception)</strong> 是异常控制流的一种形式。在任何情况下，如果 <strong>处理器</strong> 检测到有反常事件发生，它就会通过一张叫做 <strong>异常表(exception table)</strong> 的跳转表进行一个间接过程调用(也就是异常)，将控制权转交到这个异常所对应的异常处理程序。</p>
<p>异常处理程序完成处理后，有三种情况:</p>
<ul>
<li>控制权回到异常抛出时正在执行的指令</li>
<li>控制权转交给引发异常的下一条指令</li>
<li>终止被中断的程序</li>
</ul>
<p>系统中可能的每种类型的异常都分配了惟一的一个 <strong>异常号</strong> 。硬件层面的异常号由处理器设计者来规定，软件层面的异常号由操作系统内核设计者来规定。异常号是异常表的索引，在触发一个异常时，处理器取出 <strong>异常表基址寄存器</strong> 的值，与(异常号×异常表表项的大小)做加法，得到异常表对应表项的地址。</p>
<p>异常的函数调用和普通函数调用有一些区别：</p>
<ul>
<li>异常调用的返回地址不一定是正在执行指令的下一条指令</li>
<li>处理器会把一些额外的状态量压入栈中</li>
<li>如果控制从用户转到内核，所有项目被压入内核栈而不是程序栈</li>
<li>异常处理程序运行在系统态</li>
</ul>
<h3 id="异常的类别"><a href="#异常的类别" class="headerlink" title="异常的类别"></a>异常的类别</h3><p>异常可以分为如下四类：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>原因</th>
<th>行为</th>
<th>返回</th>
</tr>
</thead>
<tbody>
<tr>
<td>中断(<strong>Interrupt</strong>)</td>
<td>IO设备的信号</td>
<td>异步</td>
<td>返回到下一条指令</td>
</tr>
<tr>
<td>陷阱(<strong>trap</strong>)</td>
<td>有目的地引发</td>
<td>同步</td>
<td>返回到下一条指令</td>
</tr>
<tr>
<td>故障(<strong>fault</strong>)</td>
<td>潜在的可恢复的错误</td>
<td>同步</td>
<td>返回到下一条或当前指令</td>
</tr>
<tr>
<td>终止(<strong>abort</strong>)</td>
<td>不可恢复的错误</td>
<td>同步</td>
<td>不返回</td>
</tr>
</tbody>
</table>
<h4 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h4><p>IO设备在完成某个读取或写入过程后，就会向处理器的一个引脚发出信号，并将异常号放到系统总线。处理器会在执行完一条指令之后发觉引脚电位的变化，读取异常号并调用对应的异常处理程序来进行下一个IO操作。处理程序返回时，控制权交给下一条指令，使源程序的行为不受影响。</p>
<h4 id="Trap"><a href="#Trap" class="headerlink" title="Trap"></a>Trap</h4><p>陷阱通常用来进行 <strong>系统调用</strong> 。在操作系统学习中已经对系统调用过程有了够多的了解，此处不予详述。</p>
<h4 id="Fault"><a href="#Fault" class="headerlink" title="Fault"></a>Fault</h4><p>当一个故障发生时，异常处理程序会首先试图去修复这个故障。如果修复成功，控制权会回到引起故障的指令并重新执行它；否则，异常处理程序会调用内核中的abort例程并终止引起异常的程序。</p>
<h4 id="Abort"><a href="#Abort" class="headerlink" title="Abort"></a>Abort</h4><p>终止是确定无法恢复的错误，因而会直接终止引发异常的程序。</p>
<h3 id="常见的异常"><a href="#常见的异常" class="headerlink" title="常见的异常"></a>常见的异常</h3><ul>
<li><code>0</code>-除法错误：除法发生的错误属于硬件层面故障，但Linux系统不会试图恢复，而是直接abort。</li>
<li><code>13</code>-<strong>段错误</strong>：对未定义内存区域的引用或对只读文本段的写操作引发的故障，是相当常见的故障。Linux系统同样会直接将段错误进行abort处理，产生大家常常看到的<code>Segmentation fault</code>错误。</li>
<li><code>14</code>-<strong>缺页错误</strong>：指令所引用的虚拟地址所对应的物理页面不在内存中。这种情况是惰性加载的产物，在存储技术中相当常见。异常处理程序会将物理页面加载进内存，并返还控制权。</li>
<li><code>18</code>-机器检查：致命的硬件错误，属于abort类型。</li>
</ul>
<h3 id="Linux的系统调用"><a href="#Linux的系统调用" class="headerlink" title="Linux的系统调用"></a>Linux的系统调用</h3><p>在汇编语言中，<code>%rax</code>寄存器包含系统调用号，<code>%rdi</code>，<code>%rsi</code>，<code>%rdx</code>等寄存器包含最多6个参数的情况下，<code>syscall</code>指令会发起一次系统调用。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程提供给应用程序的关键抽象有二：</p>
<ol>
<li>一个独立的逻辑控制流</li>
<li>一个独立的虚拟地址空间</li>
</ol>
<h3 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h3><p>抢占式的任务调度中，所有的进程会轮流获取CPU的使用权。在这种抽象中，若干个进程可以看做是同时在运行，这种现象称为 <strong>并发</strong> 。而如果两个进程真正在不同的处理器核上运行，那么它们则被称为是 <strong>并行</strong> 的。</p>
<h3 id="私有地址空间"><a href="#私有地址空间" class="headerlink" title="私有地址空间"></a>私有地址空间</h3><p>对于每个进程来说，它的地址空间结构是相同的：</p>
<p><img src="./images/Chapter_8/stack.png" alt="stack"></p>
<h3 id="系统态和用户态"><a href="#系统态和用户态" class="headerlink" title="系统态和用户态"></a>系统态和用户态</h3><p>这一部分详见操作系统课程的相关内容</p>
<h2 id="系统调用的错误处理"><a href="#系统调用的错误处理" class="headerlink" title="系统调用的错误处理"></a>系统调用的错误处理</h2><p>这一部分详见《UNIX系统编程》</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>同样详见《UNIX系统编程》</p>
<h3 id="fork指令"><a href="#fork指令" class="headerlink" title="fork指令"></a>fork指令</h3><p><code>fork()</code>系统调用创建当前程序的一个子进程，宏观上来看在这个调用之后子进程会从下一条指令开始与主进程并发运行相同的代码。区分主进程和子进程的方式是fork的返回值——<strong>在父进程中返回值是子进程的pid，在子进程中返回值为0</strong>。</p>
<p>这个指令的特点有：</p>
<ul>
<li>调用一次，返回两次。为了理清多次fork所创建的进程关系，通常需要画进程图。</li>
<li>父进程与子进程并发执行</li>
<li>子进程的地址空间是父进程的副本，但又与父进程相互独立。</li>
</ul>
<h3 id="子进程的回收"><a href="#子进程的回收" class="headerlink" title="子进程的回收"></a>子进程的回收</h3><p>子进程在返回或终止后并不会马上被内核清除，它会一直保持一个已终止的状态直到被它的父进程回收。这种未被回收但已经中止的进程被称为 <strong>僵尸进程</strong> 。父进程回收子进程后，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程。</p>
<p>如果父进程在它的子进程被回收之前终止,init进程会接管子进程,成为它的养父，并最终回收这些僵尸进程。但是，由于僵尸进程也会占用系统内存等资源，每个进程都应当回收它们的子进程，这就要用到<code>waitpid</code>函数了。它会使进程等待目标子进程终止，并马上回收这个子进程。如果当前没有子进程，这个函数返回-1并设置错误码。</p>
<p><code>pid_t waitpid(pid_t pid, int *statusp, int options)</code></p>
<ul>
<li><code>pid</code>:指定要等待的子进程pid。如果这个值为-1,就等待所有子进程。</li>
<li><code>options</code>: 改变函数默认的执行模式，如果为0则不改变。waitpid默认会挂起进程来等待子进程终止，并返回已终止子进程的pid。<ul>
<li><code>WNOHANG</code>: 立即返回而不等待子进程终止，若没有子进程终止则返回值为0</li>
<li><code>WUNTRACED</code>: 不仅返回已终止子进程的PID，还返回被停止子进程的pid。</li>
<li><code>WCONTINUED</code>: 挂起直到子进程终止或一个被停止的子进程收到信号继续执行</li>
</ul>
</li>
<li><code>statusp</code>: 用于存放返回的子进程的状态信息，<code>wait.h</code>中的宏可以解析这些信息。</li>
</ul>
<p><code>waitpid(-1,NULL,0)</code>会回收所有子进程中最先结束的子进程，然后返回。</p>
<h3 id="加载和运行程序"><a href="#加载和运行程序" class="headerlink" title="加载和运行程序"></a>加载和运行程序</h3><p><code>execve</code>函数可以在当前进程的上下文中加载并运行一个程序。</p>
<p><code>int execve(char* filename, char* argv[], char* envp[])</code></p>
<p>其中filename和argv不必解释，envp指向一个环境变量字符串数组，每个字符串都是<code>“name=value”</code>格式的键值对。</p>
<p><code>getenv</code>函数可以根据环境变量中的<code>name</code>在环境变量数组中搜索并返回对应的<code>value</code>字符串指针。如果找不到则返回NULL。<code>setenv</code>和<code>unsetenv</code>则可以修改环境变量。</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号是一种消息，内核使用信号来通知进程系统中发生的事情。可以执行<code>man 7 signal</code>来查看linux系统支持的信号种类。</p>
<p>传递信号由两个步骤组成：</p>
<ol>
<li>内核通过更新目标进程上下文中的某个状态，向一个进程 <strong>发送信号</strong></li>
<li>目标进程对信号做出的反应被称为 <strong>接受信号</strong></li>
</ol>
<p>一个发出但没有接受的信号被称为 <strong>待处理信号</strong> ，每种类型的信号在 <strong>同一时间只能存在一个待处理信号</strong> ，在这个信号被接受之前的同类型新信号会被丢弃。<strong>每个信号只能被接受一次</strong>。</p>
<h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>每个进程都只属于一个进程组，进程组由一个pgid来标识。用户进程可以通过<code>getpgrp</code>函数获取自己所在的进程组ID，通过<code>setpgid</code>改变自己或者其他进程的进程组。在<code>setpgid(pid,pgid)</code>函数中，如果pid为0则指定自身，如果pgid为0则用pid指定的PID作为进程组ID。</p>
<h3 id="信号的发送"><a href="#信号的发送" class="headerlink" title="信号的发送"></a>信号的发送</h3><p>linux系统下的<code>/bin/kill</code>文件可以向其他的进程发送信号。</p>
<p>使用方式：<code>kill -&lt;sig&gt; &lt;pid&gt;</code></p>
<p>其中<code>sig</code>指定发送的信号种类，而<code>pid</code>指定发送目标。负的pid会将信号发送给进程组中的每个进程。</p>
<p>类似地可以发送信号的函数有<code>signal.h</code>库中的<code>kill</code>函数,它的使用规范与<code>/bin/kill</code>相近；<code>unistd</code>中的<code>alarm</code>函数也可以在sec秒后向调用进程发送一个<code>SIGALRM</code>信号。</p>
<p>键盘输入如<code>ctrl-C</code>也会向当前作业的进程组发送信号。</p>
<h3 id="信号的接受"><a href="#信号的接受" class="headerlink" title="信号的接受"></a>信号的接受</h3><p>当一个进程 <strong>从内核模式切换回用户模式</strong> 时，它会检测进程的待处理信号集合，如果集合为空则将控制流转移给下一条指令，否则 <strong>强制</strong> 这个进程接受这个信号。</p>
<p>进程对于每个信号都有一种默认反应，大多是终止，转储内存，挂起或忽略。我们可以通过使用<code>signal.h</code>中的<code>signal</code>函数来修改默认行为。(<strong>SIGKILL和STGSTOP信号是无法更改的</strong>)</p>
<p><code>sighandler_t signal(int signum, sighandler_t handler)</code></p>
<ul>
<li>返回值：如果失败返回<code>SIG_ERR</code>，可以用于检验是否成功</li>
<li><code>signum</code>：指定要监测并处理的信号</li>
<li><code>handler</code>：指定处理信号的函数<ul>
<li><code>SIG_IGN</code>：忽略这个信号</li>
<li><code>SIG_DEL</code>：取消对信号默认行为的更改</li>
<li>自定义的函数</li>
</ul>
</li>
</ul>
<p>调用这个函数会改变当前进程在其剩余生命周期内对某个信号的行为。</p>
<h3 id="信号的阻塞"><a href="#信号的阻塞" class="headerlink" title="信号的阻塞"></a>信号的阻塞</h3><p><code>sigprocmask</code>函数可以显式地阻塞一些信号。</p>
<p><code>int sigprocmask(int how, sigset_t* set, sigset_t* oldset)</code></p>
<ul>
<li><code>how</code>：指定对两个set的操作<ul>
<li><code>SIG_BLOCK</code>：阻塞所有<code>set</code>中的信号</li>
<li><code>SIG_UNBLOCK</code>：解除对所有<code>set</code>中信号的阻塞</li>
<li><code>SIG_SETMASK</code>：将阻塞集合变成<code>set</code></li>
</ul>
</li>
<li><code>oldset</code>：之前的阻塞信号集合会保存在这里</li>
</ul>
<p>sigset的使用方法是，首先声明一个sigset，再使用辅助函数(<code>sigemptyset</code>,<code>sigaddset</code>,<code>sigdelset</code>)进行构造。</p>
<h3 id="信号处理程序的编写"><a href="#信号处理程序的编写" class="headerlink" title="信号处理程序的编写"></a>信号处理程序的编写</h3><p>信号处理程序与主程序并发运行，因而它很容易引起race condition。因此，我们只能在信号处理函数中使用 <strong>异步安全</strong> 的函数，而printf，scanf，malloc和exit等函数都不在此列，因而输出基本靠<code>write</code>。</p>
<p>还有一种精简信号处理程序的方式是只在程序中改变全局变量的值，然后立即返回，将所有的处理过程留给主程序。</p>
<p>除此之外，任何可能被信号处理程序修改的全局变量都应该使用<code>volatile</code>前缀和<code>sig_atomic_t</code>类型，前者保证这个变量不会被缓存，后者保证对这个变量的所有读写都是原子操作。</p>
<p>最后，处理程序有义务保存调用时errno的值，并在返回时将其重置。</p>
<p>另一个需要注意的问题是，由于未被处理的信号同时每种只能存在一个，当我们发现有一个未被处理的信号时很可能有 <strong>不止一个</strong> 信号已经到达。比如，我们在一个模拟shell行为的程序中监听SIGCHLD信号，每接受到一个SIGCHLD就回收相应的子进程。如果在handler处理第一个SIGCHLD的过程中又有两个新的SIGCHLD到达，那么其中的一个就会被丢弃。</p>
<p>为了解决这个问题，我们需要用一个不断执行<code>waitpid</code>直到返回-1的循环来取代对<code>waitpid</code>操作次数的计数。</p>
<h3 id="信号处理的兼容性"><a href="#信号处理的兼容性" class="headerlink" title="信号处理的兼容性"></a>信号处理的兼容性</h3><p>在不同的Unix系统上，<code>signal</code>函数的行为可能不一致。为此，我们可以显式地调用<code>sigaction</code>函数来设定默认行为。</p>
<h3 id="信号处理的常见问题及解决方案"><a href="#信号处理的常见问题及解决方案" class="headerlink" title="信号处理的常见问题及解决方案"></a>信号处理的常见问题及解决方案</h3><h4 id="任务列表管理中的race-condition问题"><a href="#任务列表管理中的race-condition问题" class="headerlink" title="任务列表管理中的race condition问题"></a>任务列表管理中的race condition问题</h4><p>有一个经典的案例：父进程通过fork创建一个子进程并将其添加到任务列表中，并在接受到SIG_CHLD信号之后将其从任务列表中移除。然而由于某些状况，子进程在被创建之后立即退出。在这个案例中，系统的控制流是这样变化的：</p>
<ul>
<li>父进程发出请求创建子进程，控制流陷入内核</li>
<li>内核创建子进程并移交控制权</li>
<li>子进程退出，控制权回到内核，内核向父进程发送一个SIG_CHLD信号</li>
</ul>
<p>需要注意的是这个时候父进程还并没有拿回控制权，因而它并不知道子进程已经终止。但它在接收到SIG_CHLD信号的时候会马上调用对应的handler去从任务列表中移除子进程，而当时任务列表中甚至还没有这个子进程！</p>
<p>为了解决这个问题，处理程序应当在创建子进程之前阻塞SIG_CHLD信号，并在添加完任务之后再取消这个阻塞。这样就实现了并发进程之间的同步。</p>
<h3 id="显式地等待信号"><a href="#显式地等待信号" class="headerlink" title="显式地等待信号"></a>显式地等待信号</h3><p>另一个例子是，父进程在创建一个子进程之后需要等待其返回再进行下一步操作。判断等待何时结束显然要依靠SIG_CHLD信号的接受和处理，但在等待的过程中应该做什么呢？</p>
<p><code>sigsuspend(const sigset_t *mask)</code>函数可以解决这个问题。它包括了用mask取代原有的阻塞集合、等待某个信号到达和恢复原有的阻塞集合三个操作，但不同于分别进行这三个操作的是，这个函数是 <strong>原子的</strong> 。</p>
<p>常见的处理机制是，父进程阻塞SIG_CHLD信号并创建子进程，然后调用<code>sigsuspend</code>函数来取消阻塞并等待SIG_CHLD信号，在接受信号之后恢复阻塞并继续执行之后的指令。</p>
<h2 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h2><p>有一种方式可以让用户程序摆脱一般函数的调用-返回逻辑，直接将控制流跳转到一个指定位置，并设定当时的 <strong>系统环境</strong> (系统环境是指程序计数器，栈指针，通用寄存器的值等信息)。</p>
<p><code>int setjmp(jmp_buf env)</code>函数可以在当前的位置设定一个跳转坐标，并将当前的系统环境保存在env变量中，之后挂起等待跳转。如果用户程序在其他位置调用了<code>longjmp(jmp_buf env, int retval)</code>函数，控制流就会跳转到setjmp的调用位置，恢复env所保存的环境，然后<code>setjmp</code>函数返回，返回值为retval。</p>
<p>需要注意的是，<code>setjmp</code>函数的返回值不能被用来赋值，只能用于判断。</p>
<h2 id="操作进程的工具"><a href="#操作进程的工具" class="headerlink" title="操作进程的工具"></a>操作进程的工具</h2><ul>
<li><code>strace</code>：打印一个正在运行的程序以及它的子进程所做的系统调用轨迹</li>
<li><code>ps</code>：列出所有进程</li>
<li><code>pmap</code>：显示进程的内存映射</li>
<li><code>top/htop</code>：类似于任务管理器</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2018/03/01/借助WSL在Windows下使用gcc/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/03/01/借助WSL在Windows下使用gcc/" itemprop="url">借助WSL在Windows下使用GCC等GNU工具</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-01T20:39:04+08:00">
                2018-03-01
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2018/03/01/借助WSL在Windows下使用gcc/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/03/01/借助WSL在Windows下使用gcc/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="借助WSL在Windows下使用gcc"><a href="#借助WSL在Windows下使用gcc" class="headerlink" title="借助WSL在Windows下使用gcc"></a>借助WSL在Windows下使用gcc</h2><p>虽然大部分时候的编码工作都可以在Linux下进行，但很多时候我们也需要在windows下进行对C语言源代码的编译运行。在被mingw的<code>CreateProcess not found</code>错误搞得心态爆炸之后，我卸载了辣鸡mingw，改为使用WSL(Windows Subsystem for Linux)来作为替代品。</p>
<h3 id="安装WSL"><a href="#安装WSL" class="headerlink" title="安装WSL"></a>安装WSL</h3><p>打开Microsoft App Store搜索WSL，选择适合的发行版进行安装即可。(<del>不得不说Windows的一键式傻瓜安装还是很方便的</del>)</p>
<h3 id="配置WSL环境"><a href="#配置WSL环境" class="headerlink" title="配置WSL环境"></a>配置WSL环境</h3><p>在运行WSL应用之后首先要设置登录名和密码，设置完成后即可进入子系统。(在这里使用的是Ubuntu)</p>
<p>由于系统自带的镜像源下载速度过于缓慢，需要更换镜像源为国内的源。(<strong>在更换之前一定要检查自己使用的Linux发行版的版本，并与镜像源网站上提供的版本号对比，不然很可能会出现依赖冲突</strong>)</p>
<p>执行<code>sudo vim /etc/apt/sources.list</code>命令编辑配置文件，镜像源参见<a href="http://wiki.ubuntu.org.cn" target="_blank" rel="noopener">Ubuntu Wiki</a>。</p>
<p>保存之后，执行<code>sudo apt-get update</code>升级镜像源即可。</p>
<h3 id="安装gcc"><a href="#安装gcc" class="headerlink" title="安装gcc"></a>安装gcc</h3><p>执行<code>sudo apt-get build-essential</code>安装GNU工具。安装完毕后，即可使用GCC来编译C语言源程序。</p>
<h3 id="WSL与Windows文件系统的交流"><a href="#WSL与Windows文件系统的交流" class="headerlink" title="WSL与Windows文件系统的交流"></a>WSL与Windows文件系统的交流</h3><p>Windows系统的所有磁盘分区都会以分区符为其名称保存在WSL的<code>/mnt</code>文件夹下。WSL已经做好了文件系统的转换，因此只需要在<code>/mnt</code>目录下工作即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2018/01/19/VPS-ShadowSocks实现科学上网/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/01/19/VPS-ShadowSocks实现科学上网/" itemprop="url">VPS+ShadowSocks实现科学上网</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-19T22:08:52+08:00">
                2018-01-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Technical/Other/" itemprop="url" rel="index">
                    <span itemprop="name">Other</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2018/01/19/VPS-ShadowSocks实现科学上网/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/01/19/VPS-ShadowSocks实现科学上网/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="使用VPS和ss搭建属于自己的梯子"><a href="#使用VPS和ss搭建属于自己的梯子" class="headerlink" title="使用VPS和ss搭建属于自己的梯子"></a>使用VPS和ss搭建属于自己的梯子</h2><p>如果说购买VPN是把身家性命都托付给服务提供商的话，用VPS自己搭建梯子可谓把命运捏在了自己的手中。就算这一台服务器被封禁了，我们也可以用十几分钟轻松地搭好另一台，从而继续科学上网。为了加快搭建一台服务器的速度，我决定在服务器上放一个傻瓜式教程，以便有意外时能按部就班快速搭好一架梯子。</p>
<h3 id="购买VPS服务器"><a href="#购买VPS服务器" class="headerlink" title="购买VPS服务器"></a>购买VPS服务器</h3><p>VPS的提供商有不少，很多人用的是Vultr，不过这里拿<a href="https://cloud.digitalocean.com" target="_blank" rel="noopener">DigitalOcean</a>做例子。学生党可以在GitHub上申请一个Student Pack，能白嫖一台能使用接近一年的服务器。</p>
<p>用申请了Student Pack的邮箱登录DigitalOcean，创建新的Droplet。配置选最低的即可，系统最好选择<code>Centos 7.x</code>，机房位置个人建议新加坡，速度比较快也不容易被爆破。在创建的时候如果能添加一个sshkey的话之后配置起来会方便很多，不过不添加也无所谓。</p>
<h4 id="添加sshkey的方法"><a href="#添加sshkey的方法" class="headerlink" title="添加sshkey的方法"></a>添加sshkey的方法</h4><p>在主机上直接使用<code>ssh-keygen -t rsa -b 4096 -C &quot;&lt;YourComment&gt;&quot;</code>生成sshkey，将保存位置下的<code>id_rsa.pub</code>文件内容粘贴到点击<code>New SSH key</code>后弹出的框内，并输入一个喜欢的名字即可。</p>
<p>这里必须保持保存位置是<code>~/.ssh/</code>目录本身，否则使用ssh远程登录的时候会出现<code>Permission Denied</code></p>
<h3 id="配置VPS服务器"><a href="#配置VPS服务器" class="headerlink" title="配置VPS服务器"></a>配置VPS服务器</h3><p>点击创建按钮之后稍等片刻，进度条满之后一台主机就创建完成了。使用<code>ssh root@&lt;主机的IP地址&gt;</code>远程登入到VPS系统中，此时假定使用的是<code>Centos 7.x</code>发行版：</p>
<p>先后执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install python-setuptools</span><br><span class="line">easy_install pip</span><br><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure>
<p>安装完成之后编辑<code>/etc/shadowsocks.json</code>文件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"server"</span>:<span class="string">"0.0.0.0"</span>,</span><br><span class="line">  <span class="attr">"port_password"</span>:&#123;</span><br><span class="line">    <span class="attr">"&lt;YourPort&gt;"</span>:<span class="string">"&lt;PortPasswd&gt;"</span>,</span><br><span class="line">    <span class="attr">"&lt;AnotherPort&gt;"</span>:<span class="string">"&lt;AnotherPasswd&gt;"</span></span><br><span class="line">    # ...</span><br><span class="line">  &#125;,   # 连接端口和密码设置</span><br><span class="line">  "timeout":300,  # 超时设置</span><br><span class="line">  "method":"aes-256-cfb"   # 加密方式设置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后执行<code>ssserver -c /etc/shadowsocks.json -d start</code>启动ss服务端即可。</p>
<h3 id="配置ss客户端"><a href="#配置ss客户端" class="headerlink" title="配置ss客户端"></a>配置ss客户端</h3><p>根据自己的系统发行版安装shadowsocks即可。配置文件和服务端类似：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"server"</span>:<span class="string">"&lt;VPS的IP地址&gt;"</span>,</span><br><span class="line">  <span class="attr">"server_port"</span>:&lt;在VPS上设置的端口&gt;,</span><br><span class="line">  <span class="attr">"local_address"</span>:<span class="string">"127.0.0.1"</span>,</span><br><span class="line">  <span class="attr">"local_port"</span>:&lt;对本地开放的代理端口&gt;,</span><br><span class="line">  <span class="attr">"password"</span>:<span class="string">"&lt;和VPS端口对应的密码&gt;"</span>,</span><br><span class="line">  <span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">  "method":"aes-256-cfb",  # 加密方式应与服务端保持一致</span><br><span class="line">  "plugin":"&lt;你所使用的插件，没有则省略这一项&gt;",</span><br><span class="line">  "plugin_opts":"&lt;插件的启动参数，没有则省略这一项&gt;"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>ss-local -c &lt;配置文件绝对路径&gt;</code>打开ss客户端。</p>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>如果是Google/Firefox浏览器的话，直接按照教程安装<code>SwitchyOmega</code>插件即可科学上网。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2018/01/18/GDB用法总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/01/18/GDB用法总结/" itemprop="url">GDB常见用法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-18T09:24:31+08:00">
                2018-01-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Technical/Others/" itemprop="url" rel="index">
                    <span itemprop="name">Others</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2018/01/18/GDB用法总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/01/18/GDB用法总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="GDB常见用法总结"><a href="#GDB常见用法总结" class="headerlink" title="GDB常见用法总结"></a>GDB常见用法总结</h2><p>GDB是Linux系统下一款非常强大的调试工具，熟练掌握的话其功能远远不限于调试。本文总结了一部分GDB的常见用法，以供参考。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul>
<li><code>b &lt;breakpoint&gt;</code> 设置断点<ul>
<li><code>&lt;breakpoint&gt;</code>可以是函数名，可以是行数，也可以是具体地址。使用地址的时候，要在十六进制地址前面加上一个<code>*</code>标记。</li>
</ul>
</li>
<li><code>s</code> 让程序单步执行一条C指令，遇到函数调用则进入(需要编译时带-g参数)<ul>
<li><code>si</code> 让程序单步执行一条asm指令，遇到函数调用则进入(不带-g也可以)</li>
<li><code>si &lt;N&gt;</code> 让程序执行<code>&lt;N&gt;</code>条asm指令，包括函数内的和函数外的。</li>
</ul>
</li>
<li><code>n</code> 让程序单步执行一条C指令，不进入函数调用<ul>
<li><code>ni</code> 让程序单步执行一条asm指令，不进入函数调用</li>
</ul>
</li>
<li><code>c</code> 让程序继续运行直到遇到下一个断点。</li>
<li><code>p</code> 打印目标信息。</li>
</ul>
<h3 id="阅读内存系统内容"><a href="#阅读内存系统内容" class="headerlink" title="阅读内存系统内容"></a>阅读内存系统内容</h3><ul>
<li><code>x/[num][opt][len] &lt;addr&gt;</code><ul>
<li><code>[num]</code>：将要打印出的连续内存单元的数量</li>
<li><code>[opt]</code>：打印出数据的格式<ul>
<li><code>i</code> 指令</li>
<li><code>x</code> 十六进制数据</li>
<li><code>d</code> 十进制数据</li>
<li><code>o</code> 八进制数据</li>
<li><code>t</code> 二进制数据</li>
<li><code>c</code> 字符数据</li>
<li><code>f</code> 浮点数数据</li>
</ul>
</li>
<li><code>[len]</code>：每个内存单元包含的字节数<ul>
<li><code>b</code>：单字节</li>
<li><code>h</code>：双字节</li>
<li><code>w</code>：四字节</li>
<li><code>g</code>：八字节</li>
</ul>
</li>
</ul>
</li>
<li><code>backtrace</code> 查看程序栈中每个栈帧的信息</li>
</ul>
<h3 id="设定输出格式"><a href="#设定输出格式" class="headerlink" title="设定输出格式"></a>设定输出格式</h3><ul>
<li><code>set print pretty</code> 改善数组和结构体的输出格式</li>
<li><code>layout asm</code> 改变输出格式为汇编窗口</li>
</ul>
<h3 id="info系命令"><a href="#info系命令" class="headerlink" title="info系命令"></a>info系命令</h3><ul>
<li><code>info registers</code> 打印出寄存器信息</li>
<li><code>info frame</code> 打印出当前栈帧的详细信息</li>
<li><code>info local</code> 打印出当前栈帧中的局部变量</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2017/12/04/在安装了Windows10系统的基础上安装ArchLinux+KDE桌面环境/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2017/12/04/在安装了Windows10系统的基础上安装ArchLinux+KDE桌面环境/" itemprop="url">在安装了Windows10系统的基础上安装ArchLinux+KDE桌面环境</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-04T13:27:02+08:00">
                2017-12-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Technical/Archlinux/" itemprop="url" rel="index">
                    <span itemprop="name">Archlinux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2017/12/04/在安装了Windows10系统的基础上安装ArchLinux+KDE桌面环境/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/12/04/在安装了Windows10系统的基础上安装ArchLinux+KDE桌面环境/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="在安装了Windows10系统的基础上安装ArchLinux-KDE桌面环境"><a href="#在安装了Windows10系统的基础上安装ArchLinux-KDE桌面环境" class="headerlink" title="在安装了Windows10系统的基础上安装ArchLinux+KDE桌面环境"></a>在安装了Windows10系统的基础上安装ArchLinux+KDE桌面环境</h2><h3 id="安装前在Windows下要做的准备"><a href="#安装前在Windows下要做的准备" class="headerlink" title="安装前在Windows下要做的准备"></a>安装前在Windows下要做的准备</h3><h4 id="为Arch的安装腾出空间"><a href="#为Arch的安装腾出空间" class="headerlink" title="为Arch的安装腾出空间"></a>为Arch的安装腾出空间</h4><p>按<code>win+x</code>组合键后选择<code>磁盘管理</code>，可以浏览目前的磁盘使用状况。通过<code>右键某个分卷-压缩卷</code>的方式可以释放一个分区中未被使用的部分，成为“未使用”的磁盘。</p>
<p>如果在试图压缩卷的时候报错“磁盘剩余的空间不足”，就格式化这个空磁盘，再重新尝试。</p>
<h4 id="关闭Windows的快速启动"><a href="#关闭Windows的快速启动" class="headerlink" title="关闭Windows的快速启动"></a>关闭Windows的快速启动</h4><p>为了能够顺利进入BIOS界面，我们需要关闭windows的快速启动功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 登陆系统，点击左下角开始菜单。</span><br><span class="line">2. 点击设置按钮，进入Windows设置界面。</span><br><span class="line">3. 点击系统按钮，进入系统设置界面。</span><br><span class="line">4. 点击电源和按钮，进入电源和睡眠设置界面。</span><br><span class="line">5. 点击其他电源设置，进入电源选项界面。</span><br><span class="line">6. 点击选择电源按钮的功能，进入电源选项下的系统设置界面。</span><br><span class="line">7. 点击更改当前不可用的设置，使能关机设置的选项。</span><br><span class="line">8. 将启用快速启动前面的勾取消，点击保存修改即可。</span><br></pre></td></tr></table></figure>
<h4 id="下载ArchLinux镜像并制作启动盘"><a href="#下载ArchLinux镜像并制作启动盘" class="headerlink" title="下载ArchLinux镜像并制作启动盘"></a>下载ArchLinux镜像并制作启动盘</h4><p>可以在<a href="https://www.archlinux.org/download/" target="_blank" rel="noopener">ArchLinux</a>的官网下载ArchLinux的最新镜像。下载完成之后，格式化一个空的USB，并将镜像文件解压到USB中即可。</p>
<p><strong>注意</strong>：这里如果使用<code>UltraISO</code>制作启动盘可能会在装机时出现玄学错误，不推荐。</p>
<h3 id="设置BIOS选项"><a href="#设置BIOS选项" class="headerlink" title="设置BIOS选项"></a>设置BIOS选项</h3><p>根据自己的电脑机型进入BIOS界面，进入<code>Boot</code>选项，关掉<code>Secure Boot</code>并将<code>USB Device</code>的启动优先级调到最高。</p>
<h3 id="磁盘分区及挂载"><a href="#磁盘分区及挂载" class="headerlink" title="磁盘分区及挂载"></a>磁盘分区及挂载</h3><p>重启之后选择出现的第一个选项，进入启动盘提供的shell。</p>
<h4 id="检查网络"><a href="#检查网络" class="headerlink" title="检查网络"></a>检查网络</h4><p>此处需要网络链接，连接网络之后执行<code>dhcpcd</code>，看看能否ping通百度。</p>
<h4 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h4><p>先使用<code>lsblk</code>命令查看设备名，一般来说是<code>/dev/sda</code>，因此接下来都将以其作为示范。</p>
<p>执行<code>cgdisk /dev/sda</code>，进入交互式图形界面，在这里可以看到之前腾出来的未使用磁盘。</p>
<ul>
<li>cgdisk使用方法<ul>
<li><code>NEW</code> 划分一个新分区，会依次询问几个关于分区的选项，除了分区大小一概默认即可。<ul>
<li>分区大小格式：<code>xxKiB/MiB/GiB</code></li>
</ul>
</li>
<li><code>WRITE</code> 写入更改到磁盘</li>
<li><code>QUIT</code> 退出</li>
</ul>
</li>
</ul>
<p>在这里我们需要分出一个128MiB的<code>EFI分区</code>和一个大小根据需求决定的<code>根分区</code>。在分好分区之后记住两个分区的设备序号(在分区名左边)，它们对应的device名称就是<code>sda&lt;序号&gt;</code>。<strong>为了方便，在这里我们用<code>sda9</code>代指UEFI分区，用<code>sda8</code>代指根分区。</strong></p>
<p>退出cgdisk之后，执行<code>fdisk /dev/sda</code>进入fdisk交互式命令行。</p>
<ul>
<li>fdisk使用方法<ul>
<li>m：打印所有指令</li>
<li>p：显示目前的所有分区</li>
<li>t：更改分区类型</li>
<li>w：写入更改并退出</li>
<li>q：不保存退出</li>
</ul>
</li>
</ul>
<p>执行 <code>t /dev/sda</code>，输入UEFI分区序号(这里是9)，输入L列出所有分区种类对应的序号，可以发现1对应<code>EFI system</code>。于是输入1,将sda9的分区类型改为EFI分区。可以使用p看一下类型是否成功更改，如果成功就输入w写入更改并退出。</p>
<h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>执行<code>mkfs.vfat -F32 /dev/sda9</code>格式化UEFI分区，执行<code>mkfs.ext4 /dev/sda8</code>格式化根分区。</p>
<h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><p>依次输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda8 /mnt</span><br><span class="line">mkdir /mnt/boot</span><br><span class="line">mount /dev/sda9 /mnt/boot</span><br></pre></td></tr></table></figure>
<h3 id="安装基本软件包"><a href="#安装基本软件包" class="headerlink" title="安装基本软件包"></a>安装基本软件包</h3><h4 id="更改镜像源"><a href="#更改镜像源" class="headerlink" title="更改镜像源"></a>更改镜像源</h4><p>编辑<code>/etc/pacman.d/mirrorlist</code>文件，将标有China的源移到前面以加快下载速度。</p>
<p>保存后使用<code>pacman -Syy</code>刷新。</p>
<h4 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h4><p>执行<code>pacstrap -i /mnt base</code>下载并安装基本软件包。</p>
<h3 id="配置新系统"><a href="#配置新系统" class="headerlink" title="配置新系统"></a>配置新系统</h3><h4 id="生成fstab"><a href="#生成fstab" class="headerlink" title="生成fstab"></a>生成fstab</h4><p>执行<code>genfstab -U -p /mnt &gt;&gt; /mnt/etc/fstab</code>生成fstab。</p>
<h4 id="进入新系统"><a href="#进入新系统" class="headerlink" title="进入新系统"></a>进入新系统</h4><p>执行<code>arch-chroot /mnt /bin/bash</code>进入新系统。</p>
<h4 id="设置Locale"><a href="#设置Locale" class="headerlink" title="设置Locale"></a>设置Locale</h4><p>修改<code>/etc/locale.gen</code>文件，去掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">en_US.UTF-8 UTF-8</span><br><span class="line">zh_CN.UTF-8 UTF-8</span><br><span class="line">zh_TW.UTF-8 UTF-8</span><br></pre></td></tr></table></figure>
<p>三行的注释并保存。</p>
<p>执行<code>locale-gen</code>生成locale文件，然后执行<code>echo LANG=en_US.UTF-8 &gt; /etc/locale.conf</code>将locale配置写入配置文件。</p>
<h4 id="设置时间"><a href="#设置时间" class="headerlink" title="设置时间"></a>设置时间</h4><p>用<code>tzselect</code>设置时区，并执行<code>ln -s /usr/share/zoneinfo/&lt;时区&gt;/&lt;子时区&gt; /etc/localtime</code>建立软连接，执行<code>hwclock --systohc --utc</code>设置硬件时间。</p>
<h4 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h4><p>执行<code>passwd</code>命令可以更改root密码。</p>
<h4 id="安装bootloader"><a href="#安装bootloader" class="headerlink" title="安装bootloader"></a>安装bootloader</h4><p>执行<code>bootctl install</code>命令安装bootloader，并执行<code>cp /usr/share/systemd/bootctl/arch.conf /boot/loader/entries/</code>复制配置文件到boot目录下。</p>
<p>执行<code>blkid -s PARTUUID -o value /dev/sda8</code>生成根分区的<code>PARTUUID</code>，并修改<code>/boot/loader/entries/arch.conf</code>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title          Arch Linux</span><br><span class="line">linux          /vmlinuz-linux</span><br><span class="line">initrd         /initramfs-linux.img</span><br><span class="line">options        root=PARTUUID= &lt;之前生成的PARTUUID&gt; rw</span><br></pre></td></tr></table></figure>
<p>修改<code>/boot/loader/loader.conf</code>文件的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timeout 3</span><br><span class="line">default arch</span><br></pre></td></tr></table></figure>
<h4 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h4><p>执行<code>echo &lt;hostname&gt; &gt; /etc/hostname</code>将你喜欢的hostname写入配置文件。</p>
<p>在<code>/etc/hosts</code>文件中添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   localhost.localdomain   localhost   &lt;hostname&gt;</span><br><span class="line">::1         localhost.localdomain   localhost   &lt;hostname&gt;</span><br></pre></td></tr></table></figure>
<h4 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h4><p>执行<code>wifi-menu</code>可以进入wifi连接图形界面。</p>
<p>用pacman安装<code>iw</code>，执行<code>iw dev</code>可以查看设备的网络Interface，然后执行<code>systemctl enable dhcpcd@&lt;YourInterface&gt;.service</code>启动dhcpcd服务。</p>
<h4 id="结束安装"><a href="#结束安装" class="headerlink" title="结束安装"></a>结束安装</h4><p><code>ctrl+D</code>退出chroot，执行<code>pacman -S linux</code>安装linux镜像文件，用<code>umount</code>命令取消挂载，<code>reboot now</code>重启。</p>
<p>重启时注意先进入BIOS将linux boot manager优先级调到最高。(如果想进入windows系统需要将windows boot manager优先级调到最高)</p>
<h3 id="安装KDE桌面环境"><a href="#安装KDE桌面环境" class="headerlink" title="安装KDE桌面环境"></a>安装KDE桌面环境</h3><p>重启后记得重新使用wifi-menu连接wifi。</p>
<p>执行<code>useradd -m -k  /etc/skel/ -G users,wheel &lt;username&gt;</code>建立新用户，并执行<code>passwd &lt;username&gt;</code>设置密码。</p>
<p>依次执行下列所有指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pacman -S xorg xorg-xinit</span><br><span class="line">pacman -S xf86-input-synaptics</span><br><span class="line">pacman -S xorg-twm  <span class="comment"># 图形化窗口管理工具Tab Window Manager</span></span><br><span class="line">pacman -S xterm  <span class="comment"># 标准虚拟终端</span></span><br><span class="line">pacman -S ttf-dejavu wqy-microhei <span class="comment"># 字体包</span></span><br><span class="line">pacman -S kf5 kf5-aids</span><br><span class="line">pacman -S plasma kdebase  <span class="comment"># KDE Plasma 桌面环境及基础包</span></span><br><span class="line">pacman -S  gwenview <span class="comment"># KDE图片浏览工具</span></span><br><span class="line">pacman -S kdegraphics  <span class="comment"># 图像处理相关工具的软件包</span></span><br><span class="line">pacman -S plasma-mediacenter <span class="comment"># 媒体中心</span></span><br><span class="line">pacman -S sddm sddm-kcm <span class="comment"># 用于X11和wayland视窗系统的显示管理器（图形登录界面）</span></span><br></pre></td></tr></table></figure>
<p>执行<code>systemctl enable sddm</code>开启sddm服务并编辑<code>/etc/sddm.conf</code>文件为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Theme]   </span><br><span class="line">Current=breeze      </span><br><span class="line">CursorTheme=breeze_cursors</span><br></pre></td></tr></table></figure>
<p>执行下列命令安装gnome支持：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -S gtk-engines gtk2 gtk3 <span class="comment"># 跨平台的图形工具包</span></span><br><span class="line">pacman -S gnome-themes-standard gnome-icon-theme <span class="comment"># 显示的主题及图标</span></span><br><span class="line">pacman -S gvfs gamin <span class="comment"># GNOME桌面系统的虚拟文件系统+文件和目录监控系统</span></span><br></pre></td></tr></table></figure>
<p>安装解压缩软件和NTP：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pacman -S p7zip</span><br><span class="line">pacman -S zip</span><br><span class="line">pacman -S unzip</span><br><span class="line">pacman -S unrar</span><br><span class="line">pacman -S ntp</span><br><span class="line">systemctl <span class="built_in">enable</span> ntpd</span><br></pre></td></tr></table></figure>
<p>安装网络管理软件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pacman -S networkmanager</span><br><span class="line">pacman -S net-tools</span><br><span class="line"></span><br><span class="line">systemctl <span class="built_in">enable</span> NetworkManager</span><br><span class="line">systemctl <span class="built_in">enable</span> dhcpcd</span><br></pre></td></tr></table></figure>
<p>安装音频：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pacman -S alsa-utils pulseaudio <span class="comment"># 声卡测试和音频编辑的工具 + 通过网络工作的声音服务</span></span><br><span class="line">pacman -S pulseaudio-alsa</span><br><span class="line">pacman -S libcanberra-pulse</span><br><span class="line">pacman -S libcanberra-gstreamer</span><br><span class="line">pacman -S jack2-dbus</span><br></pre></td></tr></table></figure>
<p>安装NTFS系统识别：<code>pacman -S ntfs-3g</code></p>
<p>使用pacman安装<code>sudo</code>，并更改<code>/etc/sudoers</code>文件，去掉<code>%wheel ALL=(ALL) ALL</code>前面的注释。如果希望sudo不需要输入密码，可以改为<code>%wheel ALL=(ALL) NOPASSWD: ALL</code></p>
<p>安装中文支持：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pacman -S kde-l10n-zh_cn</span><br><span class="line">pacman -S kde-applications</span><br><span class="line">pacman -S fcitx fcitx-rime <span class="comment"># 这里使用的是fcitx输入法</span></span><br><span class="line">pacman -S fcitx-im</span><br><span class="line">pacman -S kcm-fcitx</span><br><span class="line">vim /home/air/.xprofile</span><br><span class="line"><span class="built_in">export</span> LANG=zh_CN.UTF-8  </span><br><span class="line"><span class="built_in">export</span> LC_ALL=zh_CN.UTF-8  </span><br><span class="line"><span class="built_in">export</span> GTK_IM_MODULE=fcitx  </span><br><span class="line"><span class="built_in">export</span> QT_IM_MODULE=fcitx  </span><br><span class="line"><span class="built_in">export</span> XMODIFIERS=<span class="string">"@im=fcitx"</span></span><br></pre></td></tr></table></figure>
<p>执行<code>reboot now</code>，进入桌面环境。</p>
<h2 id="安装桌面环境之后"><a href="#安装桌面环境之后" class="headerlink" title="安装桌面环境之后"></a>安装桌面环境之后</h2><h3 id="配置系统设置"><a href="#配置系统设置" class="headerlink" title="配置系统设置"></a>配置系统设置</h3><h4 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h4><p>绝大部分快捷键可以在<code>系统设置-工作空间-快捷键</code>下设置，也有一部分是在其他地方设置。</p>
<ul>
<li><code>工作空间-桌面行为-虚拟桌面</code> 配置虚拟桌面数量和切换快捷键</li>
<li><code>工作空间-桌面行为-锁屏</code> 配置屏保图片和锁屏快捷键</li>
<li><code>工作空间-快捷键-全局快捷键-系统设置</code> 大部分关于窗口的快捷键</li>
</ul>
<p>当然，如果有特殊的需要，也可以自定义快捷键：</p>
<p>在<code>工作空间-快捷键-自定义快捷键</code>中，使用<code>编辑-新建-全局快捷键-命令/url</code>可以建立一个新的快捷键，通过设置<code>触发器</code>和<code>动作</code>标签可以进行快捷键的定制。</p>
<p>(例如，对于<code>打开终端</code>的快捷键，需要在<code>动作</code>中填入<code>konsole</code>)</p>
<h4 id="界面风格设置"><a href="#界面风格设置" class="headerlink" title="界面风格设置"></a>界面风格设置</h4><p>KDE提供了很多强大的特效，这个按照个人爱好设置即可。</p>
<h3 id="安装必要的应用软件"><a href="#安装必要的应用软件" class="headerlink" title="安装必要的应用软件"></a>安装必要的应用软件</h3><p>像是<code>vim</code>，<code>make</code>，<code>wget</code>这种不可或缺的工具，是一定要事先安装好的。</p>
<h4 id="代码管理工具-git"><a href="#代码管理工具-git" class="headerlink" title="代码管理工具-git"></a>代码管理工具-git</h4><p><code>git</code>可以直接使用pacman安装。重点在于将git与github上的账户建立联系。</p>
<p>用pacman安装<code>openssh</code>软件，执行<code>ssh-keygen -t rsa -b 4096 -C &quot;&lt;YourComment&gt;&quot;</code>生成一组ssh公私钥，路径选择自己喜欢的路径，密码可以不设置。复制保存位置下的<code>id_rsa.pub</code>文件内容并粘贴到GitHub要求的位置即可。</p>
<h4 id="包管理工具-yay"><a href="#包管理工具-yay" class="headerlink" title="包管理工具-yay"></a>包管理工具-yay</h4><p>执行<code>git clone https://aur.archlinux.org/yay.git</code>，拉取yay的repo。进入<code>yay</code>的目录后执行<code>makepkg -si</code>命令，开始安装yay。</p>
<p>中间如果出现依赖软件未安装的问题，就用<code>pacman</code>安装对应的软件即可。</p>
<p>安装结束之后，顺便修改一下yay和pacman的下载工具。</p>
<h4 id="美化终端"><a href="#美化终端" class="headerlink" title="美化终端"></a>美化终端</h4><h5 id="终端自定义"><a href="#终端自定义" class="headerlink" title="终端自定义"></a>终端自定义</h5><p>打开终端菜单栏上的<code>设置-编辑当前方案</code>，即可设置终端风格。使用<code>外观-编辑</code>可以设置背景透明度。</p>
<h5 id="安装和配置zsh"><a href="#安装和配置zsh" class="headerlink" title="安装和配置zsh"></a>安装和配置zsh</h5><p>用pacman安装zsh本体之后，下载<code>Oh-My-Zsh</code>配置文件并安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh</span><br><span class="line">chmod +x install.sh</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure>
<p>如果需要自定义zsh，可以编辑<code>~/.zshrc</code>文件。具体的配置可以参考<a href="https://blog.csdn.net/kingolie/article/details/53066679" target="_blank" rel="noopener">这篇博客</a></p>
<p>如果需要将zsh设置为默认终端，可以打开终端菜单栏上的<code>设置-编辑当前方案</code>，将<code>命令</code>更改为<code>/bin/zsh</code>即可。</p>
<h4 id="浏览器-Chromium"><a href="#浏览器-Chromium" class="headerlink" title="浏览器-Chromium"></a>浏览器-Chromium</h4><p>Arch官方有Chrome的软件包，所以直接使用pacman安装<code>Chromium</code>即可。</p>
<p>可以安装<code>ttf-liberation</code>来防止字符输入出现问题。</p>
<h4 id="文本编辑器-sublime"><a href="#文本编辑器-sublime" class="headerlink" title="文本编辑器-sublime"></a>文本编辑器-sublime</h4><p>可以使用<code>yay sublime</code>列出所有sublime的软件包，可以跟据爱好自行选择安装哪个版本。</p>
<ul>
<li>我的Sublime配置<ul>
<li>Sublime版本：<code>sublime-text-3-imfix</code></li>
<li>插件安装：<ul>
<li>Markdown Editor</li>
<li>Markdown Preview<ul>
<li>快捷键设置(在<code>preferences-key bindings</code>下)：<code>{ &quot;keys&quot;: [&quot;alt+m&quot;], &quot;command&quot;: &quot;markdown_preview&quot;, &quot;args&quot;:   {&quot;target&quot;: &quot;browser&quot;, &quot;parser&quot;:&quot;markdown&quot;} }</code></li>
</ul>
</li>
</ul>
</li>
<li>字体：<code>Fira Code</code></li>
</ul>
</li>
</ul>
<h4 id="代理服务"><a href="#代理服务" class="headerlink" title="代理服务"></a>代理服务</h4><p>使用pacman可以安装<code>shadowsocks</code>。具体的配置此处不详谈。</p>
<p>同样使用pacman安装<code>privoxy</code>。安装完成之后，修改privoxy配置文件<code>/etc/privoxy/config</code>，其中的<code>listen-address</code>代表它监听的地址和端口。将<code>forward-socks5t</code>所在的行取消注释，并将后面的ip地址和端口改为<code>shadowsocks</code>的本地绑定地址和端口。</p>
<p>执行export命令将以下变量加入当前环境：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip地址和端口为privoxy监听的地址和端口</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:8118</span><br><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:8118</span><br></pre></td></tr></table></figure>
<p>执行<code>systemctl start privoxy</code>，<code>curl ip.gs</code>测试当前ip位置，如果在VPS提供商的位置则说明配置成功。</p>
<p>如果要取消代理设置的话，只需要使用<code>unset</code>将这两条全局变量删除即可。</p>
<p>要配置 <strong>全局代理</strong> 可以打开代理设置，然后将127.0.0.1和1080填入IP地址和端口即可。</p>
<h4 id="按个人喜好安装其他软件"><a href="#按个人喜好安装其他软件" class="headerlink" title="按个人喜好安装其他软件"></a>按个人喜好安装其他软件</h4><p>我安装的软件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. community/code</span><br><span class="line">    The Open Source build of Visual Studio Code (vscode) editor</span><br><span class="line">2. aur/netease-cloud-music</span><br><span class="line">    Netease Cloud Music, converted from .deb package</span><br></pre></td></tr></table></figure>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://blog.csdn.net/java_xiaoer/article/details/51457259" target="_blank" rel="noopener">UEFI+GPT安装Win10+Archlinux双系统</a></li>
<li><a href="https://blog.csdn.net/aemonair/article/details/60360526#%E4%B8%83%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">UEFI安装Arch’s KDE桌面全过程</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/blog/images/lyrica.png" alt="Drac Zhang">
            
              <p class="site-author-name" itemprop="name">Drac Zhang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/blog/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/blog/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/dracit7" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Drac Zhang</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://Drac_zhang.disqus.com/count.js" async></script>
    

    

  




	





  














  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
