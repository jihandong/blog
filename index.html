<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Gensokyo">
<meta property="og:url" content="https://dracit7.github.io/blog/index.html">
<meta property="og:site_name" content="Gensokyo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Gensokyo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://dracit7.github.io/blog/">





  <title>Gensokyo</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Gensokyo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Youkai's Mountain</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/blog/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2019/04/11/Verilog/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/04/11/Verilog/" itemprop="url">Verilog语言学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-11T18:51:11+08:00">
                2019-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Academic or Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/Languages/" itemprop="url" rel="index">
                    <span itemprop="name">Languages</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2019/04/11/Verilog/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/04/11/Verilog/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Verilog语言学习笔记"><a href="#Verilog语言学习笔记" class="headerlink" title="Verilog语言学习笔记"></a>Verilog语言学习笔记</h1><h2 id="Verilog的基本特性"><a href="#Verilog的基本特性" class="headerlink" title="Verilog的基本特性"></a>Verilog的基本特性</h2><p>Verilog是一款<strong>大小写敏感</strong>的硬件描述语言。</p>
<h3 id="Verilog程序的组成"><a href="#Verilog程序的组成" class="headerlink" title="Verilog程序的组成"></a>Verilog程序的组成</h3><p>一个Verilog程序由关键字<code>module</code>和<code>endmodule</code>进行定义。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> &lt;name&gt; (&lt;port_list&gt;);</span><br><span class="line">	&lt;port declarations&gt;</span><br><span class="line">	&lt;datatype declarations&gt;</span><br><span class="line">	&lt;functions&gt;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>在Verilog中，一个电路就是一个module。</p>
<h3 id="Verilog的基本元素"><a href="#Verilog的基本元素" class="headerlink" title="Verilog的基本元素"></a>Verilog的基本元素</h3><h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><p>Verilog HDL模型中的所有时延都根据<strong>时间单位</strong>定义。</p>
<p>在<code>assign</code>语句后加<code>#x</code>可以指定这个语句的时延，其中<code>x</code>表示时延的长度。</p>
<p>使用<code></code>timescale`语句可以规定时间单位的长度。</p>
<h4 id="模块的描述方式"><a href="#模块的描述方式" class="headerlink" title="模块的描述方式"></a>模块的描述方式</h4><h5 id="结构描述"><a href="#结构描述" class="headerlink" title="结构描述"></a>结构描述</h5><p>用and，or，not等逻辑函数调用来描述，适用于电路图已知的电路</p>
<h5 id="数据流描述"><a href="#数据流描述" class="headerlink" title="数据流描述"></a>数据流描述</h5><p>利用<code>assign</code>语句后接C风格赋值表达式来进行描述，适用于逻辑表达式已知的电路</p>
<h5 id="行为描述"><a href="#行为描述" class="headerlink" title="行为描述"></a>行为描述</h5><p>用<code>initial</code>或<code>always</code>语句进行描述</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2019/03/21/头条暑期实习面经/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/03/21/头条暑期实习面经/" itemprop="url">字节跳动架构部门暑实面经</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-21T12:10:09+08:00">
                2019-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Experience/" itemprop="url" rel="index">
                    <span itemprop="name">Experience</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2019/03/21/头条暑期实习面经/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/03/21/头条暑期实习面经/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="字节跳动架构部门laaS暑期实习生面经"><a href="#字节跳动架构部门laaS暑期实习生面经" class="headerlink" title="字节跳动架构部门laaS暑期实习生面经"></a>字节跳动架构部门laaS暑期实习生面经</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>面试官很nice，温和好说话，也会给提示。</p>
<h4 id="开始部分"><a href="#开始部分" class="headerlink" title="开始部分"></a>开始部分</h4><p>首先是介绍一些自己做过的项目(自己做的或者跟导师做的)。</p>
<p>我的话就是讲一些简历上写了的项目：</p>
<ul>
<li>视频抓取器Spatium和实现细节</li>
<li>课设C_formatter</li>
<li>跟导师改的一些kubernetes源码</li>
</ul>
<p>说到k8s这部分的时候，面试官很自然地把话题引入计算虚拟化部分。</p>
<h4 id="计算虚拟化部分"><a href="#计算虚拟化部分" class="headerlink" title="计算虚拟化部分"></a>计算虚拟化部分</h4><blockquote>
<p><strong>有关k8s</strong></p>
</blockquote>
<ol>
<li>你知道kubernetes有哪几个主要的模块吗？</li>
</ol>
<p>答：大概有kubelet，kubectl，kubeadm还有coredns等模块。</p>
<ol start="2">
<li>那你知道这些模块里面哪些是功能模块而哪些是工具模块吗？</li>
</ol>
<p>答：主要的功能模块就是kubelet，解释了一下kubelet的各种作用。</p>
<ol start="3">
<li>kubelet在网络中是跟哪个身份的节点相连的？跟哪个进程相连的？</li>
</ol>
<p>答：细节不是很清楚</p>
<blockquote>
<p><strong>对虚拟化的了解</strong></p>
</blockquote>
<ol start="4">
<li>我们岗位就是做虚拟化的，说一下你对虚拟化的认识</li>
</ol>
<p>答：主要答了一些主流虚拟化技术和虚拟机种类，并进行了一些解释</p>
<ul>
<li>三种虚拟化形式：<ul>
<li>虚拟机</li>
<li>容器</li>
<li>库操作系统</li>
</ul>
</li>
<li>三种虚拟机形式：<ul>
<li>运行在裸机上的全虚拟化(最早的虚拟化，讲了原理和劣势)</li>
<li>半虚拟化(修改操作系统内核，讲了原理和劣势，举例Xen)</li>
<li>基于硬件辅助的虚拟化(举了一些例子)</li>
</ul>
</li>
</ul>
<ol start="5">
<li>Intel的处理器有哪些特性支持了第三种虚拟机？</li>
</ol>
<p>答：细节部分没有了解</p>
<ol start="6">
<li>CPU分了哪几个特权级，虚拟机是如何利用它们的？</li>
</ol>
<p>答：一开始口误，把4个特权级说成了0-4，经面试官提醒改为0-3。讲了一下全虚拟化和硬件辅助虚拟化对特权级的利用。</p>
<h4 id="计算机网络部分"><a href="#计算机网络部分" class="headerlink" title="计算机网络部分"></a>计算机网络部分</h4><ol start="7">
<li>假如要写一个基于TCP的Server-Client程序，在S端和C端分别要做哪些工作？从代码的角度讲。</li>
</ol>
<p>答：用python举例，讲了S端的<code>socket</code>，<code>bind</code>，<code>listen</code>，<code>accept</code>的调用时机、参数和一些特性；C端的<code>socket</code>，<code>connect</code>的调用时机、参数；<code>send</code>和<code>recv</code>方法的使用。</p>
<ol start="8">
<li>假设我在<code>bind</code>函数调用时不设定特定IP地址，要用什么端口？</li>
</ol>
<p>答：这个不大清楚</p>
<ol start="9">
<li><code>accept</code>函数返回的<code>fd</code>你是如何处理的？比如是直接处理还是开新线程？</li>
</ol>
<p>答：如果有需求的话一般是给每个accept开一个新线程来处理，以实现高并发性。</p>
<h4 id="算法和编程部分"><a href="#算法和编程部分" class="headerlink" title="算法和编程部分"></a>算法和编程部分</h4><ol start="10">
<li>假设我有一个袋子，里面装着黑白两色的球；每次从袋子里取出两个球并丢掉，如果两个球颜色相同就往袋子里放一个白球，否则放一个黑球，问最终剩下的球和袋子里原本白球和黑球个数的关系。</li>
</ol>
<p>答：智力捉急，一开始没想出来。考官提示跟奇偶有关系，于是试着从简单的状态开始推了一下：</p>
<ul>
<li>初态1：袋子里还剩两白一黑<ul>
<li>这种情况下，穷举法能发现无论怎么取最后都是剩黑球</li>
<li>向这种情况下加入一个白球，发现情况并没有变化</li>
<li>继续加入白球，可以发现规律，似乎白球的初始个数对最后的结果并没有影响</li>
</ul>
</li>
<li>初态2：袋子里还剩两黑一白<ul>
<li>仍然用穷举法，可以发现最后剩下的一定是白球</li>
<li>加入一个黑球，发现剩下的变成了黑球</li>
<li>多举几种情况可以发现，黑球的奇偶决定着最后球的颜色</li>
</ul>
</li>
</ul>
<p>总结规律，就是：白球的数量对结果没有影响，黑球为奇数时剩下的是黑球，否则是白球。</p>
<ol start="11">
<li>给定一个由<code>{}[]()</code>三对括号组成的字符串，写一个函数判断它是否是匹配的。例如，<code>{[()]}</code>是匹配的，<code>{([)]}</code>就是不匹配的。</li>
</ol>
<p>答：算法太菜，想了半天，两种思路都发现有问题。考官看我一直想不出来，提示要用到栈，我才反应过来。大体就是遍历字符串，遇到左括号压栈，遇到右括号就判断是否与栈顶的左括号匹配；如果匹配就将栈顶弹出，不匹配就说明整个字符串不匹配。</p>
<h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>二面的面试官表情相对要严肃一点，不过也非常nice，语气很放松。</p>
<h4 id="开始部分-1"><a href="#开始部分-1" class="headerlink" title="开始部分"></a>开始部分</h4><ol>
<li>先自我介绍一下吧。</li>
</ol>
<p>答：照着简历说……</p>
<ol start="2">
<li>你跟导师都做过什么呀？</li>
</ol>
<p>答：主要是在阅读和修改一些k8s的源码</p>
<h4 id="C语言部分"><a href="#C语言部分" class="headerlink" title="C语言部分"></a>C语言部分</h4><p>面试官似乎对我的C语言水平不很信任，出的题很简单。</p>
<ol start="3">
<li>关于数组指针的考察</li>
</ol>
<p>在开始做之前我问了一下机器是多少位，考官指定了64位。</p>
<p>已知：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = “abcdefg”;</span><br><span class="line"><span class="keyword">char</span> a[] =“abcdefg”;</span><br></pre></td></tr></table></figure></p>
<p>(1)填空：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sizeof(p) = ____，</span><br><span class="line"><span class="keyword">sizeof</span>(*p) = ____,</span><br><span class="line"><span class="keyword">sizeof</span>(p[<span class="number">0</span>]) = ____,</span><br><span class="line"><span class="keyword">sizeof</span>(a) = ____,</span><br><span class="line"><span class="keyword">sizeof</span>(a[<span class="number">0</span>]) = ____,</span><br><span class="line"><span class="keyword">sizeof</span>(&amp;a[<span class="number">0</span>]) = ____.</span><br></pre></td></tr></table></figure></p>
<p>(2)回答问题</p>
<ul>
<li><p>执行<code>p[0] = ‘h’</code>; 会发生什么，为什么？</p>
<p>  答：这个由于p是一个常量字符串指针，所处的内存区域是有读保护的，因而会引发中断（linux下是段错误）</p>
</li>
<li><p>执行<code>a[0] = ‘h’</code>; 会发生什么，为什么？</p>
<p>  答：会将a数组的第一个元素值变成h</p>
</li>
</ul>
<h4 id="编译器相关知识"><a href="#编译器相关知识" class="headerlink" title="编译器相关知识"></a>编译器相关知识</h4><ol start="4">
<li><code>inline</code>的作用？对<code>inline</code>的处理发生在编译过程中的什么阶段？有什么限制条件吗？</li>
</ol>
<p>答：inline是指内联，带有inline的函数会优先使用寄存器而不是将所有的局部变量存放在程序栈中。由于<code>inline</code>涉及到生成的汇编代码对寄存器的使用和对栈的操作，应该是发生在生成汇编代码的阶段。对于限制条件不是很清楚。</p>
<p>这个题是我理解有问题，考官想听到的回答是，inline和define都用于嵌入代码，只不过inline函数的嵌入发生在编译阶段，而define在预处理阶段。inline的限制条件就比较复杂了……我没有了解所以这一题没答好。</p>
<ol start="5">
<li>描述一下编译的基本过程吧。</li>
</ol>
<p>答：把编译器的那几个模块依次列了上去。</p>
<ol start="6">
<li>如果我要查看<code>gcc</code>预处理生成的代码，要怎么做？</li>
</ol>
<p>答：这个不太清楚。</p>
<h4 id="算法部分"><a href="#算法部分" class="headerlink" title="算法部分"></a>算法部分</h4><p>说是算法……感觉这一部分面试官出的题都是离散数学题……</p>
<ol start="7">
<li>两个城市A和B，A城市有80W人，B城市有20W人。任何两个人之间电话对打的概率相同。1天之内，共产生了1000W个电话。那么跨城市对打的电话有多少个？</li>
</ol>
<p>答：用排列组合来做就是<code>C(1,800000)*C(1,200000)/C(2,1000000)*10000000</code>。</p>
<p>考官说我想复杂了，这样算太麻烦。然后就下一题了。</p>
<ol start="8">
<li>6个人一起跑步，结果有多少种结果？A比B的成绩好，同时B比C的成绩好，有多少种结果？</li>
</ol>
<p>答：</p>
<p>1) 第一问就是全排列，720种。<br>2) 第二问我用分类的方式列了一堆，最后算出来是120种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. DEF都在ABC左边，ABC排列的顺序是一定的，这样有P(3,3) = 6种</span><br><span class="line">2. DEF都在右边，同理有6种</span><br><span class="line">3. DEF在AB之间或在BC之间，有2*6=12种</span><br><span class="line">4. DEF中有两个人挨着，另一个被隔开，有P(4,2)*P(3,2) = 72种</span><br><span class="line">5. DEF三个人都被隔开，有P(4,3) = 24种</span><br><span class="line">综上所述，共有6*4+72+24 = 120种</span><br></pre></td></tr></table></figure>
<p>结果考官表示，有更简单的方法，比如，如果只考虑A比B领先，有多少种？</p>
<p>我才发现是我想复杂了，因为ABC三个人的先后次序一共才6种情况，而题中的情况是一种，所以只需要<code>720/6=120</code>即可。</p>
<ol start="9">
<li>上台阶，每次可以一个，也可以每次两个。那么n个台阶，有多少种可能上去呢？</li>
</ol>
<p>这一题要写代码，不过这个算法很简单。写了个带动规的递归函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> stepnum[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">steps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> steps(n<span class="number">-1</span>) + steps(n<span class="number">-2</span>);</span><br><span class="line">&#125; <span class="comment">// 没有优化过的函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stepsNew</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">    stepnum[n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">    stepnum[n] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> steps1 = stepnum[n<span class="number">-1</span>] ? stepnum[n<span class="number">-1</span>] : steps(n<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">int</span> steps2 = stepnum[n<span class="number">-2</span>] ? stepnum[n<span class="number">-2</span>] : steps(n<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">return</span> steps1 + steps2;</span><br><span class="line">&#125; <span class="comment">// 动态规划的函数</span></span><br></pre></td></tr></table></figure>
<ol start="10">
<li>你还有什么想问我的吗？</li>
</ol>
<p>问了一下这个岗位具体一点的工作内容，以及为了符合工作要求应该学习的方向之类的。</p>
<p>面试官的回答：我是在做linux系统内核和KVM相关的。你按照自己的节奏好好学习就可以啦。答的还不错。</p>
<h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><p>二面之后接着有人打电话来约了三面。奇怪的是面试官并没有问多少技术问题，反而面试搞得像hr面：</p>
<ol>
<li>你们学校对实习的态度如何？允不允许？鼓励你们去报什么样的公司？</li>
<li>你最喜欢计算机的哪个方向呢？</li>
<li>据我所知你们大学大二还没有相关课程，你的这些能力是如何积累的呢？</li>
<li>你平时会用什么样的操作系统呢？</li>
</ol>
<h4 id="有关Linux的知识"><a href="#有关Linux的知识" class="headerlink" title="有关Linux的知识"></a>有关Linux的知识</h4><ol start="5">
<li>在Linux下，你主要是用命令行多一些还是图形界面多一些呢？</li>
</ol>
<p>答：除了浏览网页等必须要图形界面的时候，都是命令行。</p>
<ol start="6">
<li>Linux下查看所有进程可以用什么命令？</li>
</ol>
<p>答：<code>ps</code>或者<code>top</code></p>
<ol start="7">
<li>我怎么才能知道某个进程跑在哪个CPU上呢？</li>
</ol>
<p>答：<code>man ps</code>或者<code>man top</code>来查一下</p>
<h4 id="有关并发编程"><a href="#有关并发编程" class="headerlink" title="有关并发编程"></a>有关并发编程</h4><ol start="8">
<li><code>fork</code>函数的返回值有什么意义呢？</li>
</ol>
<p>答：返回0说明是在子进程，返回正整数则代表在父进程，且这个数是子进程的pid。</p>
<ol start="9">
<li>在Go里面，把一些函数用<code>go</code>命令去跑的话，与直接调用有什么不一样的吗？</li>
</ol>
<p>答：讲了一下goroutine的概念和具体实现方式。</p>
<ol start="10">
<li>讲一下你对并发和并行的理解。</li>
</ol>
<p>答：老生常谈了，这里不再赘述。</p>
<ol start="11">
<li>你现在自己在用虚拟机吗？用过哪些？</li>
</ol>
<p>答：之前大一用过VMWARE，最近用了点qemu。</p>
<h4 id="像是hr该问的一些问题"><a href="#像是hr该问的一些问题" class="headerlink" title="像是hr该问的一些问题"></a>像是hr该问的一些问题</h4><ol start="11">
<li>能实习多久？能大概给个范围吗？</li>
<li>你为什么要来头条实习呢？</li>
<li>在就业方面有什么考虑吗？对公司或者工作地点有什么偏向吗？</li>
<li>你有哪些问题想问我的？</li>
<li>你对参与实习之后要做的工作有什么期待吗？</li>
</ol>
<p>这方面我主要是问了一下为了适应岗位我需要进一步学习的东西，以及说了一下我比较想去做虚拟化和内核向的一些工作。这之间面试官跟我讲了很多东西，大概如下：</p>
<p>感觉你现在已经做的挺好了吧，我觉得没必要再给你做什么加法了，从理论上来讲你尽量去把学校的要求掌握的专业课学好就好了，像是数据结构啊，组成原理啊，高数啊概率啊，编译原理啊。在工程上呢去多做一些实践也是很必要的，比如你去使用ArchLinux这种比较典型的现代Linux系统，还有像编程方面，可以去了解一些与传统C控制逻辑不同的并发和并行，尤其是并行这种的领域，等等。理论联系实践地去做吧，毕竟你现在才大二嘛，对吧，已经很不错了。总之就是把知识学好，并多寻找一些实践的机会就挺不错的。</p>
<p>你工作的话到时候可能是在北京的，你这边应该可以过来是吧。其实我们这边在武汉现在好像也有办公室，不过我不是很清楚哈，这些都是后话。</p>
<p>我想跟你说的是，一般来说系统研究这方面是一个非常漫长的过程哈，基本上就像金庸小说一样，可能是说三年略有小成，几十年之后才可能有些成就，这个东西它还是需要很深的积累的。其实呢你几个月的实习时间，虽然你是希望去做一些内核相关的事情，但是从现实角度来看，你可能在这段时间之内只是能够通过一些实践去理解它基本的概念吧。</p>
<p>比如说你要做虚拟化和内核，肯定是要需要很长的准备时间吧。我们这边就算我招一个有经验的工程师进来，也得要三个月到半年的准备才能开始去做一些简单的内核外围的东西的，深层次的可能半年都不止。所以你最好有个心理准备，做系统这方面可不是像解个算法题或者写个软件一样简单，这个要做大量的环境的准备，然后你才能大概知道具体问题在什么地方，找到之后还得然后进一步去了解每个问题的影响范围，再对每个影响范围去进行处理，这是一个非常非常复杂的过程。我建议你就是不要期待能写多少代码，而是在这个上面开始建立一个基本的概念性的东西。我认为你在两个到四个月之间能有个大概的认识，就是一个很不错的结果了哈。还是要有沉的住气的心态的，你了解我说的意思吧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2019/03/10/在ArchLinux下安装和配置LaTex编译环境/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/03/10/在ArchLinux下安装和配置LaTex编译环境/" itemprop="url">在ArchLinux下安装和配置LaTex编译环境</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-10T22:22:37+08:00">
                2019-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Academic or Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/Tools/" itemprop="url" rel="index">
                    <span itemprop="name">Tools</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2019/03/10/在ArchLinux下安装和配置LaTex编译环境/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/03/10/在ArchLinux下安装和配置LaTex编译环境/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="在ArchLinux下安装和配置LaTex编译环境"><a href="#在ArchLinux下安装和配置LaTex编译环境" class="headerlink" title="在ArchLinux下安装和配置LaTex编译环境"></a>在ArchLinux下安装和配置LaTex编译环境</h2><p>之前写文档的时候一直用的是Markdown内置Latex，但这样不如直接编译<code>.tex</code>文件来的灵活，而在安装texlive的时候又遇到了很多坑，因此在这里总结一下安装与配置过程。</p>
<h3 id="安装xeLatex"><a href="#安装xeLatex" class="headerlink" title="安装xeLatex"></a>安装xeLatex</h3><p>用pacman可以安装texlive的许多组件，它们的统一格式是<code>texlive-</code>后跟一个具体的扩展。要安装基本组件只需要其中的<code>bin</code>，<code>core</code>和<code>lang</code>扩展，有特殊需求可以按照文档去安装其他的扩展。</p>
<p>这里我是如下安装：</p>
<p><code>sudo pacman -S texlive-{core,bin,langchinese,latexextra,fontsextra}</code></p>
<h3 id="扩展包的配置"><a href="#扩展包的配置" class="headerlink" title="扩展包的配置"></a>扩展包的配置</h3><h4 id="配置fontawesome"><a href="#配置fontawesome" class="headerlink" title="配置fontawesome"></a>配置fontawesome</h4><p>Fontawesome组件本身是在fontsextra扩展中的，但是由于扩展名问题无法被正常识别，需要在使用了这个组件的tex文件开头加上一句<code>\defaultfontfeatures{Extension = .otf}</code>。</p>
<h4 id="中文字体的问题"><a href="#中文字体的问题" class="headerlink" title="中文字体的问题"></a>中文字体的问题</h4><p>如果系统中没有安装<code>poppler-data</code>包，编译出的pdf文件将会无法显示中文。这个包可以直接使用<code>pacman</code>来安装。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2019/02/24/MIT_6.828/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/02/24/MIT_6.828/" itemprop="url">MIT 6.828 Labs 实验记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-24T20:10:08+08:00">
                2019-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Academic or Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/Operating-System/" itemprop="url" rel="index">
                    <span itemprop="name">Operating System</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2019/02/24/MIT_6.828/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/02/24/MIT_6.828/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="MIT-6-828-Labs-实验记录"><a href="#MIT-6-828-Labs-实验记录" class="headerlink" title="MIT 6.828 Labs 实验记录"></a>MIT 6.828 Labs 实验记录</h2><p>本博客中所有代码所对应的github repo地址：<a href="https://github.com/dracit7/6.828" target="_blank" rel="noopener">6.828</a></p>
<h3 id="Overall"><a href="#Overall" class="headerlink" title="Overall"></a>Overall</h3><ul>
<li>6.828自带了一个打分系统，在Lab文件夹下执行<code>make grade</code>即可运行这个系统来检验自己的解答。</li>
<li><code>make grade</code>执行过程中JOS console的输出会保存在当前文件夹下的<code>jos.out.xxx</code>文件中</li>
</ul>
<h3 id="Build-up-the-environment"><a href="#Build-up-the-environment" class="headerlink" title="Build up the environment"></a>Build up the environment</h3><h4 id="Compiler-Toolchain"><a href="#Compiler-Toolchain" class="headerlink" title="Compiler Toolchain"></a>Compiler Toolchain</h4><p>由于Archlinux中的objdump和gcc均满足Lab的要求，不需要手动搭建编译环境。</p>
<h4 id="QEMU-emulator"><a href="#QEMU-emulator" class="headerlink" title="QEMU emulator"></a>QEMU emulator</h4><p>建议follow一下MIT官网上最新版的6.828课程页面。老的课程页面上的链接可能不可用。此处根据<a href="https://pdos.csail.mit.edu/6.828/2018/tools.html" target="_blank" rel="noopener">Fall 2018的课程页面</a>进行配置。</p>
<p>由于QEMU的调试系统不完善，课程组准备了改进过的QEMU，使它可以与系统中的GDB调试器绑定，并使用GDB来调试。执行以下步骤安装打好补丁的QEMU:</p>
<ol>
<li>执行<code>git clone https://github.com/mit-pdos/6.828-qemu.git qemu</code>拉取源代码</li>
<li>安装各种依赖。在Archlinux下的安装方式如下：<ul>
<li>libdtc：<code>yay DTC</code>，任选一项安装。</li>
<li>python：坑爹的是都8102年了这门课还不支持python3.不过Arch一般自带python2,问题不大</li>
</ul>
</li>
<li>进入源代码文件夹，Configure the source code<ul>
<li>执行<code>./configure --disable-kvm --disable-werror --python= &lt;pathToPython2&gt;</code></li>
</ul>
</li>
<li>执行<code>make &amp;&amp; make install</code>进行安装</li>
</ol>
<p>安装到一半，报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">qga/commands-posix.c: 在函数‘dev_major_minor’中:</span><br><span class="line">qga/commands-posix.c:634:21: 警告：implicit declaration of <span class="keyword">function</span> ‘major’; did you mean ‘_m_por’? [-Wimplicit-function-declaration]</span><br><span class="line">         *devmajor = major(st.st_rdev);</span><br><span class="line">                     ^~~~~</span><br><span class="line">                     _m_por</span><br><span class="line">qga/commands-posix.c:634:21: 警告：对‘major’的嵌套的外部声明 [-Wnested-externs]</span><br><span class="line">qga/commands-posix.c:635:21: 警告：implicit declaration of <span class="keyword">function</span> ‘minor’; did you mean ‘mknod’? [-Wimplicit-function-declaration]</span><br><span class="line">         *devminor = minor(st.st_rdev);</span><br><span class="line">                     ^~~~~</span><br><span class="line">                     mknod</span><br><span class="line">qga/commands-posix.c:635:21: 警告：对‘minor’的嵌套的外部声明 [-Wnested-externs]</span><br></pre></td></tr></table></figure>
<p>很显然是有两个函数major和minor在使用之前并未声明。这是两个库函数，在linux下的<code>&lt;sys/sysmacros.h&gt;</code>头文件中有定义，然而MIT给的代码里并没有包含这个头文件。根据报错信息打开<code>qga/commands-posix.c</code>，添加<code>#include &lt;sys/sysmacros.h&gt;</code>，保存。</p>
<p>再次安装，装到一半又报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: ../hw/9pfs/virtio-9p.o: <span class="keyword">in</span> <span class="keyword">function</span> `stat_to_v9stat<span class="string">':</span></span><br><span class="line"><span class="string">/home/drac_zhang/Downloads/qemu/hw/9pfs/virtio-9p.c:796: undefined reference to `minor'</span></span><br><span class="line">/usr/bin/ld: /home/drac_zhang/Downloads/qemu/hw/9pfs/virtio-9p.c:796: undefined reference to `major<span class="string">'</span></span><br><span class="line"><span class="string">/usr/bin/ld: ../hw/9pfs/virtio-9p.o: in function `v9fs_mknod'</span>:</span><br><span class="line">/home/drac_zhang/Downloads/qemu/hw/9pfs/virtio-9p.c:2803: undefined reference to `makedev<span class="string">'</span></span><br><span class="line"><span class="string">/usr/bin/ld: ../hw/9pfs/virtio-9p.o: in function `v9fs_create'</span>:</span><br><span class="line">/home/drac_zhang/Downloads/qemu/hw/9pfs/virtio-9p.c:2124: undefined reference to `makedev<span class="string">'</span></span><br><span class="line"><span class="string">collect2: 错误：ld 返回 1</span></span><br></pre></td></tr></table></figure>
<p>差不多的理由，还是缺少库函数。也不管重复包含dirty不dirty了，向<code>hw/9pfs/virtio-9p.c</code>中添加<code>#include &lt;sys/sysmacros.h&gt;</code>，保存后再次编译。</p>
<p>因为类似的理由，还需要添加这个头文件的源文件有<code>linux-user/strace.c</code>。</p>
<h4 id="Other-problems"><a href="#Other-problems" class="headerlink" title="Other problems"></a>Other problems</h4><p>这里是其他各种各样可能会出现的玄学错误。</p>
<h5 id="Dependencies-upgraded"><a href="#Dependencies-upgraded" class="headerlink" title="Dependencies upgraded"></a>Dependencies upgraded</h5><p>在我完成这个lab的过程中，<code>libnfs</code>库在我滚arch的时候升级了，结果一运行<code>make</code>就会报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error <span class="keyword">while</span> loading shared libraries: libnfs.so.12: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
<p>执行<code>whereis libnfs.so.12</code>，发现系统的库中只有<code>libnfs.so.13</code>，原来是这个库在升级的时候名字变掉了……</p>
<p>没办法，只好用<code>downgrade</code>命令手动降级到<code>4.0.0-2</code>版本，再执行<code>make</code>的时候就没事了。</p>
<h3 id="Lab-1-Booting-a-PC"><a href="#Lab-1-Booting-a-PC" class="headerlink" title="Lab 1 Booting a PC"></a>Lab 1 Booting a PC</h3><p>Lab1的源码可以从<code>https://pdos.csail.mit.edu/6.828/2018/jos.git</code>处clone到。</p>
<h4 id="Part-1-PC-bootstrap"><a href="#Part-1-PC-bootstrap" class="headerlink" title="Part 1 PC bootstrap"></a>Part 1 PC bootstrap</h4><p>这一部分的目的是让我们熟悉x86汇编语言和PC bootstrap过程，并熟悉QEMU和gdb的操作。</p>
<p>首先在lab目录下执行<code>make</code>命令来编译内核和启动器。编译完成的内核与启动器位于<code>obj/kern/kernel.img</code>镜像文件中，这个镜像文件是一个用于模拟真实硬盘的虚拟磁盘。</p>
<p>执行<code>make qemu</code>可以正式在qemu中运行编译好的操作系统，此时命令行终端会创建一个新的窗口，同时在终端中显示与窗口中同样的内容(并接受同样的输入)。方便起见，这里我们用终端进行接下来的操作。</p>
<p>一开始这个shell只有两条简单的指令：<code>help</code>和<code>kerninfo</code>。后者会打印出目前的内核状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Special kernel symbols:</span><br><span class="line">  _start                  0010000c (phys)</span><br><span class="line">  entry  f010000c (virt)  0010000c (phys)</span><br><span class="line">  etext  f01019df (virt)  001019df (phys)</span><br><span class="line">  edata  f0113060 (virt)  00113060 (phys)</span><br><span class="line">  end    f01136a0 (virt)  001136a0 (phys)</span><br><span class="line">Kernel executable memory footprint: 78KB</span><br></pre></td></tr></table></figure>
<p>要退出qemu可以打出<code>Ctrl+a x</code>。</p>
<h5 id="Layout-of-the-physical-address-space"><a href="#Layout-of-the-physical-address-space" class="headerlink" title="Layout of the physical address space"></a>Layout of the physical address space</h5><table>
<thead>
<tr>
<th style="text-align:center">+——————————+</th>
<th>&lt;- 0xFFFFFFFF(4GB)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\</td>
<td>内存映射的虚拟地址  \</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">+——————————+</td>
<td>&lt;- 取决于RAM的数量</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td>扩展内存           \</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">+——————————+</td>
<td>&lt;- 0x00100000 (1MB)</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td>BIOS所在的ROM    \</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">+——————————+</td>
<td>&lt;- 0x000F0000 (960KB)</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td>16位机使用的扩展ROM\</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">+——————————+</td>
<td>&lt;- 0x000C0000 (768KB)</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td>VGA Display        \</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">+——————————+</td>
<td>&lt;- 0x000A0000 (640KB)</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td>Low Memory       \</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">+——————————+</td>
<td>&lt;- 0x00000000</td>
</tr>
</tbody>
</table>
<p>一开始的16位机只能使用最下面那一共<strong>1MB</strong>的物理存储，而可用的内存只有标识为Low Memory的<strong>640KB</strong>。标注有VGA Display的部分是硬件保留区，用于当作VGA显示屏的缓冲区。</p>
<p>就算是在Intel突破了“1MB的瓶颈”之后，PC设计师也仍然对于最低的1MB地址空间使用原始的架构，这是为了软件的向后兼容性。这样就在LowMemory和扩展内存之间留下了一个<strong>空洞</strong>(IO hole)。在操作系统的内存分配中，这个空洞所对应的地址段不应被虚拟地址系统所使用。</p>
<p>在计算机从32位升级为64位时，BIOS在地址空间的最顶段因为类似的理由留下了第二个空洞，不过由于本实验在32位系统下进行，这个空洞不予考虑。</p>
<h5 id="The-ROM-BIOS"><a href="#The-ROM-BIOS" class="headerlink" title="The ROM BIOS"></a>The ROM BIOS</h5><p>为了单步调试计算机的启动过程，我们需要两个终端，一个用<code>make qemu-gdb</code>来启动qemu虚拟机，一个用<code>make gdb</code>来将gdb调试环境连接到虚拟机上。</p>
<p><code>make qemu-gdb</code>会将处理器暂停在即将执行第一条指令之前并等待gdb的连接，这时在另一个终端中使用<code>make gdb</code>就可以通过gdb来调试操作系统内核。</p>
<p>gdb终端会显示一段结尾如下的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The target architecture is assumed to be i8086</span><br><span class="line">[f000:fff0]    0xffff0: ljmp   $0xf000,$0xe05b</span><br><span class="line">0x0000fff0 in ?? ()</span><br><span class="line">+ symbol-file obj/kern/kernel</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>其中的第二行代表着目前将要执行的指令，也就是虚拟机开启过程的第一条指令。</p>
<p>这条指令的含义是：</p>
<ul>
<li><code>0xffff0:</code>：指令位于的虚拟存储系统地址，对应于上面的架构，这个位置是属于BIOS的ROM区域的最上面，也就是BIOS程序的起始位置。</li>
<li><code>[f000:fff0]</code>：指示当前CS和IP寄存器的值。CS寄存器指示代码所在的数据段，IP则是偏移量。</li>
<li><code>ljmp</code>：跳转指令，跳转到CS和IP为<code>[f000:e05b]</code>的位置，转换成存储地址就是<code>0xfe05b</code>。<ul>
<li>CS和IP寄存器与物理地址的转换规则为<code>ADDR = CS&lt;&lt;4 + IP</code>。</li>
</ul>
</li>
</ul>
<p>保证启动时优先执行BIOS代码是很重要的，因为一开始内存中根本不会有其他可以执行的代码。BIOS会初始化所有启动所需要的重要设备，检查内存和磁盘的挂载情况。最后，就像操作系统课程中所学的那样，它找到磁盘上的boot loader并将控制权转移给它。</p>
<ul>
<li>对GDB使用<code>si</code>命令可以继续单步调试之后的汇编代码，观察BIOS所做的工作。</li>
</ul>
<h4 id="Part-2-The-boot-loader"><a href="#Part-2-The-boot-loader" class="headerlink" title="Part 2 The boot loader"></a>Part 2 The boot loader</h4><p>众所周知，软盘和硬盘都被分成大小为<code>512字节</code>的段，而这些段是系统级IO的最小单位。如果一个磁盘是启动盘，那么它的第一个段就被称为 <strong>boot sector</strong> ，并被存放boot loader的代码。当BIOS找到一个boot sector后，它就会将其加载到内存中，并将控制权转交给boot loader代码段。</p>
<p>(对于CD-ROM来说，它的前2M都属于boot sector，因此可以存放更大的启动镜像)</p>
<p>在6.828文件夹中，boot loader的代码存放于<code>boot/boot.S</code>与<code>boot/main.c</code>中。这些代码主要完成两件事：</p>
<ol>
<li>将处理器模式切换到<code>32位保护模式</code>，这样软件才可以访问大于1MB的物理地址空间。这个工作由<code>boot.S</code>完成。除此之外，<code>boot.S</code>还要建立一个程序栈，让C程序得以运行。</li>
<li>将内核代码从硬盘中加载到内存，并将控制转交给内核代码的入口函数。这个工作由<code>main.c</code>完成。</li>
</ol>
<p>阅读<code>main.c</code>的代码可以发现很多 <del>非常dirty的</del> 细节(<del>包括但不限于：使用goto，while(1)代替sleep，写的很乱的函数指针</del>)，如果对于这个过程的细节感兴趣可以直接阅读源码，注释写的很详细明白。</p>
<p>bootloader的代码会被BIOS加载到<code>0x7c00</code>，这是由<code>boot/Makefrag</code>文件所决定的。修改这个文件中<code>-Ttext</code>参数后面的地址可以让BIOS从其他地址来加载，执行<code>make clean &amp;&amp; make</code>重新编译可以查看这样做会引发什么样的系统错误(事实上系统会停机并进入一个无限循环等待用户的操作)；在GDB调试时可以在这个位置设置断点，以精确地进入bootloader代码段。</p>
<p><code>obj/boot/boot.asm</code>和<code>obj/kern/kernel.asm</code>分别包含着bootloader和kernel的反汇编结果以及注释，可以用于调试和分析。下面就来分析一下BootLoader的代码逻辑。</p>
<ul>
<li>BootLoader代码逻辑研究<ul>
<li>第一阶段：<strong>初始化</strong><ul>
<li><strong>宏常量的设定</strong>：<code>.set CR0_PE_ON 0x1</code> 这个常量是控制32位保护模式开关的指标。</li>
<li><strong>全局设置</strong>：<code>cli</code>指令关闭中断处理，<code>cld</code>指令将串操作的内存地址访问模式设为增序<ul>
<li>这两个指令其实是设置了<code>DF</code>和<code>IF</code>两个标志位的值</li>
</ul>
</li>
<li><strong>寄存器初始化</strong>：用xor和mov指令将几个关键寄存器清零<ul>
<li><code>ds</code>：数据段寄存器，存放全局变量区域的头指针</li>
<li><code>ss</code>：栈段寄存器，存放堆栈段的首地址(<code>esp</code>寄存器存储的是偏移量)</li>
<li><code>es</code>：扩展段寄存器</li>
</ul>
</li>
</ul>
</li>
<li>第二阶段：<strong>打开32位保护模式</strong><ul>
<li><strong>开启A20地址线</strong>：在16位模式下，用于寻址的地址总线只有20根，这种情况下大于1MB的地址空间是全部被置为0的。只有开启20～23号四条地址线，才能对1MB以上的地址空间进行寻址，从而进入32位模式。<ul>
<li>通过一个循环来等待A20设备准备完毕：用<code>in</code>指令从<code>0x64</code>端口接受信息，如果不是代表准备完毕的信息则继续循环。</li>
<li>向<code>0x64</code>和<code>0x60</code>端口发送信号，打开A20地址线。</li>
</ul>
</li>
<li><strong>建立32位段虚拟内存与物理存储器的映射关系表</strong>：<code>lgdt gdtdesc</code>指令。</li>
<li><strong>启动32位保护模式</strong>：用<code>CR0_PE_ON</code>与<code>cr0</code>寄存器的值做或运算，打开32位保护模式。<code>cr0</code>到<code>cr3</code>四个寄存器是系统控制寄存器，它们的值直接决定系统的运行状态。<code>cr0</code>控制的是处理器，因此可以通过修改其值来进入其他运行模式。</li>
<li><strong>跳转到32位代码区的下一条指令</strong>。</li>
</ul>
</li>
<li>第三阶段：修改段寄存器的值为32位区地址，初始化<code>esp</code>寄存器的值，建立C程序栈</li>
<li>第四阶段：进入<code>main.c</code>的bootmain函数，开始读取内核代码。</li>
<li>第五阶段：跳转到内核代码区，交还控制权。</li>
</ul>
</li>
</ul>
<blockquote>
<h5 id="习题解答"><a href="#习题解答" class="headerlink" title="习题解答"></a>习题解答</h5><p>Q: 处理器什么时候开始执行32位代码？哪条指令切换了处理器模式？</p>
<p>A：<code>0x7c2a:  mov    %eax,%cr0</code>指令切换了处理器模式，从随后的跳转指令开始，处理器开始执行32位代码。</p>
<p>Q：Bootloader执行的最后一条指令是什么？kernel执行的第一条指令又是什么?</p>
<p>A：Bootloader执行的最后一条指令是向内核代码段跳转的指令<code>0x7d71:      call   *0x10018</code>，kernel执行的第一条指令是<code>0x10000c:    movw   $0x1234,0x472</code>。</p>
<p>Q：Bootloader是如何决定它要读取多少数据的？它从哪里获取的kernel大小信息？</p>
<p>A：Bootloader首先从内核代码区读取了长度固定的ELF头部，再从头部中获取了这个区域是否为ELF文件、数据段数量、每段的长度、起始地址等信息。</p>
</blockquote>
<p>(课程网页在这一部分讲了一大堆ELF头和指针的知识，如果已经学过CSAPP第7章的话完全可以跳过。需要注意的是，6.828所采用的可执行目标文件代码 <strong>并非是位置无关代码</strong> ，因而 <strong>链接器会将程序将加载到的内存位置写在文件中</strong> 。利用这一点，我们可以执行<code>objdump -f &lt;filename&gt;</code>命令，获取程序在内存中的入口位置。)</p>
<h4 id="Part-3-The-kernel"><a href="#Part-3-The-kernel" class="headerlink" title="Part 3 The kernel"></a>Part 3 The kernel</h4><p>在内核被授予控制权后，它要做如下几件事：</p>
<h5 id="Virtual-memory-address-mapping"><a href="#Virtual-memory-address-mapping" class="headerlink" title="Virtual memory address mapping"></a>Virtual memory address mapping</h5><p>当我们观察bootloader程序的时候，我们可以发现它的 <strong>链接地址</strong>(指用<code>objdump -h</code>打印出来的ELF节头部信息中的<code>LMA</code>，linked memory address) 和 <strong>虚拟地址</strong>(指用<code>objdump -h</code>打印出来的ELF节头部信息中的<code>VMA</code>，virtual memory address) 是完全一致的；然而对于kernel，这两个地址却有着不小的差距。</p>
<p>操作系统内核常常会在非常高的虚拟地址空间(例如0xf0100000)运行，这是为了把比较低的虚拟地址空间留给用户进程使用。然而大部分机器没有这么多的内存，于是它们将虚拟地址0xf0100000映射到物理地址0x00100000。这样一来虽然内核所在的加载地址很高，它的实际加载地址却是位于RAM区域的最底端，挨着BIOS所在的ROM地址区域。</p>
<p>虚拟地址映射操作是由专门的硬件来完成的，要打开虚拟地址映射只需要对<code>cr0</code>寄存器设置<code>CR0_PG</code>标志，就像之前打开32位保护模式所做的那样。除此之外，为了能让虚拟地址映射正常工作，我们需要将页表的首地址装入<code>cr3</code>寄存器。</p>
<p>kernel被加载的地址为0x100000,因此它从此处开始运行。它所做的第一项工作就是打开虚拟地址映射，然后跳转到虚拟地址<code>0xf010002f</code>的位置，恰好对应于物理地址中下一条指令所在的位置。这样，内核就自然地实现了从物理地址到虚拟地址的转换。</p>
<h5 id="Formatted-printing-to-the-console"><a href="#Formatted-printing-to-the-console" class="headerlink" title="Formatted printing to the console"></a>Formatted printing to the console</h5><p>在完成虚拟地址映射之后，下一步是对终端进行格式化输入输出以创建交互式操作界面。</p>
<p><code>lib/printfmt.c</code>中提供了输出函数的原型，<code>kern/printf.c</code>和<code>kern/console.c</code>则提供了有关内核输出和交互的函数。</p>
<blockquote>
<p><strong>Answer to Exercise 8</strong></p>
<p>本题要求补全printfmt函数对于<code>%o</code>(8进制输出)的处理机制，只需要仿照下面十六进制的机制即可。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">  num = getuint(&amp;ap, lflag);</span><br><span class="line">  base = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">goto</span> number;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>习题解答</strong></p>
<p>Q：解释printf.c和console.c之间的接口，尤其是console.c中的哪个函数被如何用于printf.c。</p>
<p>A：console.c向printf.c提供了cputchar函数,它希望在调用printf.c中的输出函数时可以利用cputchar函数来输出每一个字符。printf.c遵守这个约定,以包含cputchar的外壳函数调用printfmt.c中的输出函数,保证了所有输出都按照console.c所规定的标准来输出。</p>
<p>Q：解释console.c中的这一段代码:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">  <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">    crt_buf[i] = <span class="number">0x0700</span> | <span class="string">' '</span>;</span><br><span class="line">    crt_pos -= CRT_COLS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>A：</p>
<p>这段代码来自cga_putc函数,这个函数是在CGA显示屏图形卡上打印字符的函数。crt_pos是一个整形全局变量,它的含义是目前光标在屏幕上的位置。阅读<code>console.h</code>的内容可以发现CRT_SIZE被定义为屏幕上能够容纳的字符个数,而CRT_COLS则是屏幕的宽度。</p>
<p>条件判断是为了确认当前光标的位置是否已经超出了屏幕底端。如果超出了，就把屏幕上第二行到最后一行的内容全部上移一行，并将空出来的位置用<code>0x0700 | &#39; &#39;</code>填满。</p>
<p>总而言之，这段代码是为了实现屏幕满了之后向上滚动的功能。</p>
<p>Q：单步调试如下代码：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</span><br><span class="line">cprintf(<span class="string">"x %d, y %x, z %d\n"</span>, x, y, z);</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>在对cprintf的调用中，fmt对应的实参是什么？ap呢？</li>
<li>列出对<code>cons_putc</code>, <code>va_arg</code>和<code>vcprintf</code>的每一次调用，以及<code>cons_putc</code>的参数,<code>va_arg</code>中ap的指向和<code>vcprintf</code>的参数值。</li>
</ol>
<p>A：</p>
<ol>
<li>fmt对应的实参是<code>&quot;x %d, y %x, z %d\n&quot;</code>，ap指向带有x，y和z的参数数组。</li>
<li>甚至不需要单步调试，自己阅读<code>lib/printfmt.c</code>就足够了。</li>
</ol>
<p>Q：运行如下代码：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line">cprintf(<span class="string">"H%x Wo%s"</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释输出结果。如果这段代码运行在大端序机器上而非小端序机器上，你会如何修改它来得到同样的结果？</p>
<p>A：输出结果是<code>He110 World</code>。前面的e110是57616在十六进制下的表示(因为使用了<code>%x</code>)，后面的rld是字符串输出的结果。int占4个字节而每个字符占一个字节，因而i所占的内存空间与一个长度为4的字符数组是相同的。这样一来，如果用i的地址去输出字符串，就会从i的地址开始按字符去读取内存中的数据，直到读到0为止。由于运行在小端序机器，0x72排在最前面一个字节，被解析成ASCII码值为0x72的<code>r</code>；接下来0x6c和0x64分别被解释为<code>l</code>和<code>d</code>。最后一个字节是0x00,正好是字符串终结符。</p>
<p>如果机器是大端序，只需要将i修改为<code>0x726c6400</code>即可，57616不需要改变。</p>
<p>Q：被<code>cprintf(&quot;x=%d y=%d&quot;, 3);</code>打印出的y值会是多少？为什么？</p>
<p>A：会是一个随机的整形数。因为cprintf解析到了两个<code>%d</code>符号，但<code>ap</code>的长度只有1,这导致第二个<code>%d</code>读到了一片未赋值的内存地址，其值自然是随机的。</p>
</blockquote>
<h5 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h5><p>(仔细读过CSAPP第三章的话汇编语言和程序栈这一块应该没问题了，就不说了)</p>
<blockquote>
<p><strong>Answer to Exercise 9</strong></p>
<p>Q：确定内核在什么时候初始化程序栈及程序栈的初始位置。内核是如何为栈保存空间的？</p>
<p>A：<code>f010034: mov $0xf0110000, %esp</code>：这一条指令初始化了栈指针，将程序栈建立于虚拟地址<code>0xf0110000</code>位置。从这个地址开始，程序栈随着程序运行向下增长。</p>
</blockquote>
<p><code>ebp</code>指针被称为“基指针”，它的作用是追踪每个函数的栈帧位置。每个被调用的C函数都要进行如下操作：将ebp寄存器的值压栈、将当前esp指针值拷贝到ebp寄存器。在返回之前，这个函数从栈中取出并恢复ebp寄存器的值。通过这种机制，<strong>任何时候ebp寄存器的值都指向正在执行的函数的栈帧头部，而栈帧头部的前一个数据节的值指向该函数调用者的栈帧头部</strong>，于是可以通过ebp链来还原函数调用链。</p>
<blockquote>
<p><strong>Answer to Exercise 10</strong></p>
<p>这个Exercise的目的是让学生熟悉backtrace的操作和C的程序栈结构。在kernel中有一个自我递归的<code>test_backtrace</code>函数,通过对这个函数打上断点可以使用<code>p $ebp</code>获取每次调用的栈帧起始位置.</p>
<p>第一次调用:栈帧的起始位置为<code>0xf010ffd8</code><br>第二次调用:栈帧的起始位置为<code>0xf010ffb8</code></p>
<p>可以看出这个函数的每个栈帧大小都是<code>0x20</code>,也就是32个字节，对于32位系统来说是八个数据。</p>
<p>使用<code>x/xw</code>命令查看从<code>0xf010ffe0</code>开始整个栈帧的结构。(因为32位系统每个数据是四个字节，所以使用<code>x/xw</code>来查看)</p>
<p><code>x/xw 0xf010ffe0</code>：<code>0x00000005</code> 按照栈帧的结构，这个位置应该是调用者压入栈内的参数。第一次对<code>test_backtrace</code>的调用的确只有一个实参5。</p>
<p><code>x/xw 0xf010ffdc</code>：<code>0xf01000f4</code> 由于栈帧是向下的，这条指令其实查看的是上一个栈帧的最后一部分，也就是函数的返回地址，经验证的确指向调用者的下一条指令。</p>
<p><code>x/xw 0xf010ffd8</code>：<code>0xf010fff8</code> 当前函数栈帧的第一部分，保存着上一个函数的基指针值(<code>%ebp</code>的值)，由于上一个函数已经是整个程序栈底部的函数了，这个地址向上就没有数据了，上个函数的基指针指向的是物理内存区的函数。</p>
<p><code>x/xw 0xf010ffd4</code>：<code>0x000100b4</code> 被调用者保存的<code>%esi</code>寄存器的值 </p>
<p><code>x/xw 0xf010ffd0</code>：<code>0xf011304c</code> 被调用者保存的<code>%ebx</code>寄存器的值</p>
<p><code>x/xw 0xf010ffcc</code>：<code>0xf010004a</code> 是<code>test_backtrace</code>中一行代码的地址</p>
<p><code>x/xw 0xf010ffc8</code>：<code>0x00000000</code> 空的，没有数据</p>
<p><code>x/xw 0xf010ffc4</code>：<code>0x00000005</code> 局部变量5</p>
<p><code>x/xw 0xf010ffc0</code>：<code>0x00000004</code> 即将进行下一次递归调用，这是压入的参数4</p>
<p>再往下就是返回地址，然后就是下一个栈帧。总的来说，<code>test_backtrace</code>函数的栈帧结构就是这样。</p>
</blockquote>
<p>完成了对栈帧结构的观察后，就可以利用观察结果去做一下任务了。Exercise 11要求我们实现一个<code>mon_backtrace</code>函数，它记录并打印出栈帧信息。<code>inc/x86.h</code>中提供了<code>read_ebp()</code>函数可以直接返回ebp寄存器的值。</p>
<p>输出格式规定如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack backtrace:</span><br><span class="line">  ebp f0109e58  eip f0100a62  args 00000001 f0109e80 f0109e98 f0100ed2 00000031</span><br><span class="line">  ebp f0109ed8  eip f01000d6  args 00000000 00000000 f0100058 f0109f28 00000061</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Answer to Exercise 11</strong></p>
<p>本题要求是按上面的要求修改<code>kern/monitor.c</code>中的<code>mon_backtrace</code>函数，并将其添加到指令集中。</p>
<p>对代码的修改如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一处修改</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Command</span> <span class="title">commands</span>[] = &#123;</span></span><br><span class="line">        &#123; <span class="string">"help"</span>, <span class="string">"Display this list of commands"</span>, mon_help &#125;,</span><br><span class="line">        &#123; <span class="string">"kerninfo"</span>, <span class="string">"Display information about the kernel"</span>, mon_kerninfo &#125;,</span><br><span class="line">        &#123; <span class="string">"backtrace"</span>, <span class="string">"Display the structure of the stack"</span>, mon_backtrace &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第二处修改</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Your code here.</span></span><br><span class="line">        cprintf(<span class="string">"Stack backtrace:\n"</span>);</span><br><span class="line">        <span class="keyword">int</span> ebp = read_ebp();</span><br><span class="line">        <span class="keyword">int</span> eip = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">int</span> args[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                args[i] = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>*i + <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,ebp,eip,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],args[<span class="number">3</span>],args[<span class="number">4</span>]);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                ebp = *(<span class="keyword">int</span> *)ebp;</span><br><span class="line">                <span class="keyword">if</span> (!ebp) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> eip = *(<span class="keyword">int</span> *)(ebp+<span class="number">4</span>);</span><br><span class="line">                <span class="keyword">int</span> args[<span class="number">5</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                        args[i] = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>*i + <span class="number">8</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,ebp,eip,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],args[<span class="number">3</span>],args[<span class="number">4</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Exercise 12要求我们升级这个函数，使其支持如下的输出格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stack backtrace:</span><br><span class="line">  ebp f010ff78  eip f01008ae  args 00000001 f010ff8c 00000000 f0110580 00000000</span><br><span class="line">         kern/monitor.c:143: monitor+106</span><br><span class="line">  ebp f010ffd8  eip f0100193  args 00000000 00001aac 00000660 00000000 00000000</span><br><span class="line">         kern/init.c:49: i386_init+59</span><br><span class="line">  ebp f010fff8  eip f010003d  args 00000000 00000000 0000ffff 10cf9a00 0000ffff</span><br><span class="line">         kern/entry.S:70: &lt;unknown&gt;+0</span><br></pre></td></tr></table></figure>
<p>为了根据eip找到函数名，行数和文件名等一系列信息，<code>kern/kdebug.c</code>中提供了<code>debuginfo_eip()</code>函数，我们需要完整地实现<code>debuginfo_eip()</code>函数，并在<code>mon_backtrace</code>中调用这个函数来获得信息。</p>
<blockquote>
<p><strong>Answer to Exercise 12</strong></p>
<p>在<code>debuginfo_eip</code>函数中有一些以<code>__STAB_</code>开头的宏常量,它们所代表的是ELF文件中<code>.stab</code>(在CSAPP中是<code>.symtab</code>)区的开头和结尾位置,以及<code>.stabstr</code>(在CSAPP中是<code>.strtab</code>)区的开头和结尾位置,它们是在链接过程中由<code>kernel.ld</code>定义的。</p>
<p>以下是修改内容：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kern/monitor.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Your code here.</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">        cprintf(<span class="string">"Stack backtrace:\n"</span>);</span><br><span class="line">        <span class="comment">// Parse the structure of the stack</span></span><br><span class="line">        <span class="keyword">int</span> ebp = read_ebp();</span><br><span class="line">        <span class="keyword">int</span> eip = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">int</span> args[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                args[i] = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>*i + <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Print some information in restricted format.</span></span><br><span class="line">        cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,ebp,eip,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],args[<span class="number">3</span>],args[<span class="number">4</span>]);</span><br><span class="line">        <span class="comment">// Exercise 12, get the debuginfo by eip</span></span><br><span class="line">        debuginfo_eip(eip, &amp;info);</span><br><span class="line">        cprintf(<span class="string">"         %s:%d: "</span>,info.eip_file, info.eip_line);</span><br><span class="line">        <span class="comment">// info.eip_fn_name is a non-null-terminated string</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;info.eip_fn_namelen;i++) cprintf(<span class="string">"%c"</span>,*(info.eip_fn_name+i));</span><br><span class="line">        cprintf(<span class="string">"+%d\n"</span>,eip - info.eip_fn_addr);</span><br><span class="line">        <span class="comment">// Backtracing</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                ebp = *(<span class="keyword">int</span> *)ebp;</span><br><span class="line">                <span class="keyword">if</span> (!ebp) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> eip = *(<span class="keyword">int</span> *)(ebp+<span class="number">4</span>);</span><br><span class="line">                <span class="keyword">int</span> args[<span class="number">5</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                        args[i] = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>*i + <span class="number">8</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,ebp,eip,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],args[<span class="number">3</span>],args[<span class="number">4</span>]);</span><br><span class="line">                debuginfo_eip(eip, &amp;info);</span><br><span class="line">                cprintf(<span class="string">"         %s:%d: "</span>,info.eip_file, info.eip_line);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;info.eip_fn_namelen;i++) cprintf(<span class="string">"%c"</span>,*(info.eip_fn_name+i));</span><br><span class="line">                cprintf(<span class="string">"+%d\n"</span>,eip - info.eip_fn_addr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kern/kdebug.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">debuginfo_eip(<span class="keyword">uintptr_t</span> addr, struct Eipdebuginfo *info)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line">    stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</span><br><span class="line">    <span class="keyword">if</span> (lline &lt;= rline) info-&gt;eip_line = stabs[lline].n_desc;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此Lab1结束。运行<code>make grade</code>，<code>50/50</code>大成功。</p>
<h3 id="Lab2-Memory-Management"><a href="#Lab2-Memory-Management" class="headerlink" title="Lab2 Memory Management"></a>Lab2 Memory Management</h3><p>在这个Lab中，我们需要实现操作系统的内存管理系统。内存管理系统包括两个部分：</p>
<ul>
<li>物理内存调度：我们要实现一个以4096个字节大小的页为单位的内存分配器，它将空闲的内存分配给内核和用户，并释放使用完的内存。</li>
<li>虚拟内存映射</li>
</ul>
<p>执行<code>git checkout -b lab2 origin/lab2</code>命令切换到lab2分支，执行<code>git merge lab1</code>合并在lab1所做的更改。</p>
<p>Lab2增加的文件有：</p>
<ul>
<li><code>inc/memlayout.h</code>：定义描述虚拟内存空间的布局的函数，定义PageInfo结构体</li>
<li><code>kern/pmap.c</code>和<code>kern/pmap.h</code>：实现<code>inc/memlayout.h</code>中定义的函数</li>
<li><code>kern/kclock.c</code>和<code>kern/kclock.h</code>：与CMOS硬件沟通，读取PC的硬件信息</li>
</ul>
<p><code>inc/mmu.h</code>中记录了应当烧录于MMU<br>单元中的逻辑代码，同样可能对这个lab有所帮助。</p>
<h4 id="Background-knowledge"><a href="#Background-knowledge" class="headerlink" title="Background knowledge"></a>Background knowledge</h4><p>由于虚拟内存是将很小的物理内存映射到很大的虚拟内存空间，这个映射关系需要一个输入地址和一个输出地址才能作用。<strong>物理地址</strong>是物理内存中真实的地址，可以直接由硬件寻址得到；<strong>虚拟地址/线性地址</strong>是物理地址通过转换得到的，用于虚拟内存空间索引的地址。</p>
<p><code>mmu.h</code>中详细地介绍了线性地址的结构。大体上讲，线性地址分为三段：</p>
<ul>
<li><code>Page directory index</code>：页目录的序号(10位)</li>
<li><code>Page table index</code>：页表的序号(10位)</li>
<li><code>Page offset</code>：地址在页内的偏移(12位)</li>
</ul>
<p>从线性地址的三段式结构可以看出，每个页表包括<code>1024</code>(2的10次方)个页，每个页目录包括<code>1024</code>个页表，而每一页的大小是<code>4096</code>个字节(也就是<code>4KB</code>)。</p>
<p>3段加起来的总长度是<code>32 bits</code>，也就是<code>4个字节</code>，这代表着线性地址可以用一个<code>int32</code>变量表示。</p>
<p>我们可以使用宏命令来取出线性地址的各个段，或将线性地址映射为物理地址。在本lab中，虚拟地址似乎是特指<code>物理地址+固定偏置值</code>所映射到的地址。</p>
<p>在<code>memlayout.h</code>中可以查看到整个虚拟内存地址空间的分配，在此列出并加以解释：</p>
<p><img src="memlayout.png" alt="memlayout"></p>
<ul>
<li><code>0xf0000000</code>以上：<code>Remapped physical memory</code>，物理内存的原样映射，这一部分为虚拟地址</li>
<li><code>0xefc00000</code>以上：内核栈区域，存放各个CPU的内核栈。<ul>
<li><code>0xef800000</code>：内核内存区和用户内存区的分界线，这以上用户不可读写</li>
</ul>
</li>
<li><code>0xef400000</code>以上：页表区域</li>
<li><code>0xef000000</code>以上：页区域</li>
<li><code>0xeec00000</code>以上：当前进程的环境变量区域<ul>
<li><code>0xeec00000</code>：用户只读区和读写区的分界线，这以上用户只有读权限</li>
</ul>
</li>
<li><code>1 PGSIZE</code>：用户的异常栈</li>
<li><code>1 PGSIZE</code>：用户栈，可以增长</li>
<li><code>一段留空内存</code></li>
<li><code>0x00800000</code>以上：用户的堆区域和程序数据</li>
<li>以下：用户的符号表区域和空内存</li>
</ul>
<h4 id="Definitions-guide"><a href="#Definitions-guide" class="headerlink" title="Definitions guide"></a>Definitions guide</h4><p>6.828的代码充满了缩写这种使人不明所以的命名,且有些地方码风诡异,因而将一些可能用到的概念和缩写列举如下:</p>
<ol>
<li><code>V</code>和<code>P</code>:带V的标识符指<code>virtual</code>,与内核虚拟内存有关；而带P的标识符往往指<code>physical</code>,与物理存储有关。如：<ul>
<li><code>kva</code>:<code>kernel virtual address</code>的简写</li>
<li><code>pa</code>:<code>physical address</code>的简写</li>
<li><code>la</code>:<code>linear address</code>的简写</li>
</ul>
</li>
<li><code>PT</code>和<code>PD</code>：分别指<code>page table</code>和<code>page directory</code>。</li>
<li><code>U</code>和<code>K</code>:带U的标识符指<code>User</code>，而带K的标识符指<code>Kernel</code>。如：<ul>
<li><code>UVPT</code>：<code>User virtual page table</code>的缩写，是用户页表的开始地址。</li>
<li><code>UTOP</code>：用户地址空间的上限</li>
</ul>
</li>
</ol>
<p>为了实现目标功能的代码，我们需要调用许多定义好的函数或者宏，为了方便查看和使用将一些可能需要使用的函数和宏列举如下：</p>
<ul>
<li><code>pmap.h</code>:<ul>
<li><code>PADDR(addr)</code>:将虚拟地址addr转换为物理地址返回</li>
<li><code>KADDR(addr)</code>:将物理地址addr转换为虚拟地址返回</li>
<li><code>PTE_ADDR(addr)</code>:将物理地址addr中的权限位去掉</li>
<li><code>page2pa(PageInfo*)</code>:将PageInfo结构体转换为对应Page的物理地址</li>
<li><code>pa2page(addr)</code>:将物理地址转换为pages数组中的PageInfo</li>
<li><code>page2kva(PageInfo*)</code>:将PageInfo结构体转换为对应Page的虚拟地址</li>
</ul>
</li>
<li><code>mmu.h</code>:<ul>
<li><code>PDX(la)</code>:将线性地址转换为页目录(page directory)的索引</li>
<li><code>PTX(la)</code>:将线性地址转换为页表的索引</li>
</ul>
</li>
</ul>
<h4 id="Part-1-Physical-page-management"><a href="#Part-1-Physical-page-management" class="headerlink" title="Part 1 Physical page management"></a>Part 1 Physical page management</h4><p>在这个部分我们需要实现物理内存管理器。这个函数追踪一个由<code>PageInfo</code>结构体组成的链表(这个链表的节点代表着一页未分配的内存)，并负责物理内存的分配和回收。</p>
<p>要想完成这部分的任务，必须要提前了解虚拟内存系统的概念(可以参考操作系统专业教材或者计算机系统教材)，才能看懂并运用各种神奇的操作。</p>
<blockquote>
<p><strong>boot_alloc</strong></p>
</blockquote>
<p>这个函数是在建立虚拟内存系统过程中用来为数据结构分配内存空间的，在虚拟内存系统建立之后就会废弃。因而，其功能比较简单。</p>
<p>值得注意的是，这个函数首次调用的时候，会从内核区bss段的结束处开始分配内存块，具体的位置是通过<code>extern</code>从链接器那里得知的。首次调用情况下的代码已经被完成了，我们只需要照葫芦画瓢地完成之后调用时的代码即可。</p>
<p>这里所谓“内核区bss段的结束处”是指内核区中没有分配代码段和数据段的第一个位置，它在虚拟地址空间中的位置在<code>0xf0000000</code>以上的部分，也就是物理内存的映射区。从这里开始，我们开始建立用于管理虚拟内存的内核数据结构。</p>
<ul>
<li><em>panic函数可以被当作printf的一个能够引发中断的版本。灵活利用它可以方便地调试系统。</em></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a chunk large enough to hold 'n' bytes, then update</span></span><br><span class="line">	<span class="comment">// nextfree.  Make sure nextfree is kept aligned</span></span><br><span class="line">	<span class="comment">// to a multiple of PGSIZE.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// LAB 2: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!n)	<span class="keyword">return</span> nextfree;</span><br><span class="line">	result = nextfree;</span><br><span class="line">	nextfree = ROUNDUP((<span class="keyword">char</span> *) (nextfree+n), PGSIZE);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>mem_init</strong></p>
</blockquote>
<p>这个函数首先用之前实现好的<code>boot_alloc</code>函数分配了 <strong>一页</strong> 空闲内存，初始化之，并用一个<code>kern_pgdir</code>指针指向了这片内存的起始位置。这一片区域用来存放<code>page directory</code>。</p>
<p>接下来是我们的工作：为一个页数组<code>pages</code>分配内存。</p>
<p><code>pages</code>数组存储了每个分页的信息，其索引和页的物理地址可以用函数相互转换。可以说，<code>pages</code>的每一个元素都唯一对应着一个物理页面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pages = (struct PageInfo *) boot_alloc(<span class="keyword">sizeof</span>(struct PageInfo) * npages);</span><br><span class="line"><span class="built_in">memset</span>(pages, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct PageInfo) * npages);</span><br></pre></td></tr></table></figure>
<p>这样我们就已经为内存分配相关的内核数据结构分配好了空间。接下来，<code>mem_init</code>函数调用<code>page_init</code>函数，去初始化所有物理内存分页。这个步骤结束之后，所有内存相关操作都可以通过<code>page</code>开头的函数来完成。</p>
<blockquote>
<p><strong>page_init</strong></p>
</blockquote>
<p>Lab中已经给出了示例代码，但是这段代码是不严谨的(它将所有物理内存页都标记为是free的)，有几处问题没有考虑到：</p>
<ul>
<li><strong>物理页面0应该标记为used</strong>。这是因为这一部分保存着BIOS数据结构和IDT(中断描述符表)，我们以后可能会用到这些结构。</li>
<li>之前讲到过的由于考虑到向后兼容性而留下的<code>IO hole</code>不应该被分配。</li>
<li>在<code>IO hole</code>之后就是extended memory部分，这一部分中的有些位置存放了内核代码和内核数据结构，因而这些位置不能标记为free。</li>
</ul>
<p>我们的任务是修改代码，使其只将那些该标记为free的放进<code>page_free_list</code>。</p>
<p>考察<code>memlayout.h</code>中的<code>PageInfo</code>结构体，可以发现其属性<code>pp_ref</code>用于指示引用这一页的进程数量,而<code>pp_link</code>指向空闲链表中下一项的地址。对于要放入<code>page_free_list</code>的pages，我们将其<code>pp_ref</code>设定为0，并利用<code>pp_link</code>将其插入空闲链表。</p>
<p><strong>本任务的难点在于如何确定Extended Memory中的哪一部分已经被Kernel所占用</strong>。观察之前的代码可以发现，<code>boot_alloc</code>是从kernel代码和数据段的结束位置开始分配内存的，而kernel代码段的起始位置是<code>IO hole</code>的结束位置(<code>0x100000</code>,参考Lab 1)，这意味着从<code>IO hole</code>到<code>boot_alloc</code>分配的最后一块内存末尾之间的所有内存都是被占用的。</p>
<p>而根据之前的两个函数，<code>boot_alloc</code>分配的最后一块内存应该就是页表的最后一块内存(也就是<code>pages</code>数组的末尾)，因此我们从<code>pages</code>的头地址开始向后应该就可以找到kernel占用内存区的末尾位置。</p>
<p>根据这些信息，可以修改代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">size_t</span> i;</span><br><span class="line">	<span class="comment">// 1) First page, ignore it</span></span><br><span class="line">	<span class="comment">// 2) Base memory</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; npages_basemem; i++) &#123;</span><br><span class="line">		pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">		pages[i].pp_link = page_free_list;</span><br><span class="line">		page_free_list = &amp;pages[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3) IO hole</span></span><br><span class="line">	<span class="comment">// Mention that npages_basemem = IOPHYSMEM / PGSIZE</span></span><br><span class="line">	<span class="comment">// IOPHYSMEM and EXTPHYSMEM is represented by B instead of KB, so div it by PGSIZE.</span></span><br><span class="line">	<span class="comment">// (Here is no operation, because we do not need to deal with occupied pages.)</span></span><br><span class="line">	;</span><br><span class="line">	<span class="comment">// 4) Extended memory</span></span><br><span class="line">	<span class="comment">// The question is where is the end of kernel segment.</span></span><br><span class="line">	<span class="keyword">char</span>* end_addr = (<span class="keyword">char</span> *)envs + <span class="keyword">sizeof</span>(struct Env) * NENV - KERNBASE;</span><br><span class="line">	<span class="keyword">int</span> end_index = (<span class="keyword">int</span>)(ROUNDUP(end_addr, PGSIZE)) / PGSIZE;</span><br><span class="line">	<span class="keyword">for</span> (i = end_index; i &lt; npages; i++) &#123;</span><br><span class="line">		pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">		pages[i].pp_link = page_free_list;</span><br><span class="line">		page_free_list = &amp;pages[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>page_alloc</strong></p>
</blockquote>
<p>这个函数就是很简单的链表操作，仔细阅读注释的内容即可正确实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *</span></span><br><span class="line"><span class="class"><span class="title">page_alloc</span>(<span class="title">int</span> <span class="title">alloc_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Returns NULL if out of free memory</span></span><br><span class="line">	<span class="keyword">if</span> (page_free_list == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// Get a free page from page_free_list</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">free_page</span> = <span class="title">page_free_list</span>;</span></span><br><span class="line">	page_free_list = free_page-&gt;pp_link;</span><br><span class="line">	<span class="comment">// Init the free page</span></span><br><span class="line">	free_page-&gt;pp_link = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (alloc_flags &amp; ALLOC_ZERO)</span><br><span class="line">		<span class="built_in">memset</span>(page2kva(free_page), <span class="number">0</span>, PGSIZE);</span><br><span class="line">	<span class="comment">// Return the free page to caller</span></span><br><span class="line">	<span class="keyword">return</span> free_page;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>page_free</strong></p>
</blockquote>
<p>同样没有什么难度，直接贴出代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_free(struct PageInfo *pp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></span><br><span class="line">	<span class="comment">// pp-&gt;pp_link is not NULL.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pp-&gt;pp_ref) panic(<span class="string">"This page is still occupied by other processes."</span>);</span><br><span class="line">	<span class="keyword">if</span> (pp-&gt;pp_link) panic(<span class="string">"You can't free a freed page."</span>);</span><br><span class="line">	pp-&gt;pp_link = page_free_list;</span><br><span class="line">	page_free_list = pp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Part-2-Virtual-Memory"><a href="#Part-2-Virtual-Memory" class="headerlink" title="Part 2 Virtual Memory"></a>Part 2 Virtual Memory</h4><p>在开始这一部分之前，先要对几个地址之间的转换有一个大概的了解。</p>
<h5 id="Segments"><a href="#Segments" class="headerlink" title="Segments"></a>Segments</h5><p>在保护模式下，有关段的信息是非常复杂的。对于一个段来说，除了段基地址之外，还有段的大小，特权级，类型，是否被执行过，读写权限等等多种信息要保存。用于描述这些信息的数据项称为 <strong>描述符(Descirptor)</strong> 。</p>
<p>描述符一般用<code>4个字</code>来表述所有信息，具体的描述符结构如下图所示：</p>
<p><img src="descriptor.png" alt="descriptor"></p>
<p>其中各个部分的作用：</p>
<ul>
<li>第一个字：<strong>段的界限</strong>，也就是这个段的长度。需要注意的是一个段的长度是用20位来表示的，因此这个字表示的段界限是不完整的，需要和描述符中另一段数据拼接起来才是完整的段界限。</li>
<li>第二个字：<strong>段的基址</strong>，段在虚拟地址空间内的起始位置。由于虚拟空间地址是32位的，这个字同样无法表示完整的段基址，需要与另外两段数据进行拼接。</li>
<li>第三个字：<ul>
<li>高字节分为如下几个字段：<ul>
<li><code>P</code>：<strong>存在位</strong>，表示该描述符对应的段是否已经读入内存。</li>
<li><code>DPL</code>：长度为两位，表示该段所属的特权级</li>
<li><code>1</code>或<code>0</code>：记录段的类型是存储段还是系统段</li>
<li><code>TYPE</code>：记录段的属性<ul>
<li>如果是存储段，那么是代码段还是数据段</li>
<li>段的读写权限如何</li>
</ul>
</li>
<li><code>A</code>：访问位，记录段是否被访问过</li>
</ul>
</li>
<li>低字节为段基址的16-23位。</li>
</ul>
</li>
<li>第四个字：<ul>
<li>高字节为段基址的24-31位。</li>
<li>低字节分为如下几个字段：<ul>
<li><code>G</code>：<strong>粒度位</strong>，G=0说明段长度的单位是<code>Byte</code>，而G=1说明单位是<code>page</code>。</li>
<li><code>X</code>：用于区分32位和16位访问方式。</li>
<li><code>O</code>和<code>AVL</code>：保留位和系统专用位</li>
<li><code>LIMIT</code>：段界限的16-19位</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>所有的描述符都储存在 <strong>描述符表</strong> 中。描述符表分为以下三类：</p>
<ul>
<li><code>LDT</code>：局部描述符表。每个进程都有它自己的局部描述符表，存放在一个特定的系统段内。LDT中存放着对应进程的代码和数据段位置等信息。</li>
<li><code>GDT</code>：全局描述符表。只有一个，存放着操作系统内核使用的描述符和所有系统段的描述符。通过GDT可以去索引所有的LDT。</li>
<li><code>IDT</code>：中断描述符表。用于定位所有的中断处理程序。</li>
</ul>
<p>在这个Lab中，我们暂时不涉及内存的分段机制，因而GDT中每个描述符的base为0而limit为0xffffffff。在kernel代码段中我们已经建立了一个简单的页表(能够映射4MB大小的内存),现在我们需要做的是拓展这个页表以映射整个虚拟内存。</p>
<h5 id="Pages"><a href="#Pages" class="headerlink" title="Pages"></a>Pages</h5><p>在Background knowledge里面我们已经讲了线性地址的构成，现在为了能够完成下面的实验，需要进一步了解一些关于页目录和页表的知识。</p>
<p>在MMU取到一个线性地址la时，它会首先取出la中的 <strong>页目录索引部分</strong> ，并用其与<code>cr3</code>中存放的页目录首地址结合去找到la所在的 <strong>页表首地址</strong> 。在此之后，MMU取出la中的 <strong>页表索引部分</strong> ，与之前找到的页表首地址结合来找到la所对应的具体 <strong>页表项</strong> 。</p>
<p>在这个过程中，la所在的页目录表项被称为 <strong>DIR entry</strong> ，而它所在的页表表项被称为 <strong>Page table entry</strong>。Directory entry中存放的物理地址与la的页表索引部分的结合是Page table entry的地址，而page table entry中存放的物理地址与la的偏移部分的结合是la所对应物理页的地址。</p>
<p>每个PDE或者PTE的内容都是<code>phyaddr</code>和 <strong>权限位</strong> 的组合。因为PDE和PTE的内容都指向一个物理页的首地址，它们的最后12位是用不到的。这12位被内存管理系统用作权限位，每一位都代表一个特定的权限，管理系统通过将这些位置0或置1来设定这一页的权限。</p>
<h5 id="Addresses"><a href="#Addresses" class="headerlink" title="Addresses"></a>Addresses</h5><blockquote>
<p><strong>Exercise 3</strong></p>
<p>你可以在<code>qemu-gdb</code>中键入<code>ctrl-a c</code>来进入qemu的monitor。在这里，你可以用<code>xp</code>命令来查询指定物理地址的数据(<code>xp</code>指令的用法与gdb的<code>x</code>指令类似)。与此同时，在<code>gdb</code>中用<code>x</code>指令可以查询指定虚拟地址的数据。将存在映射关系的虚拟地址与物理地址存放的内容作对比，看看是否是一致的。</p>
</blockquote>
<p>JOS的源代码定义了<code>uintptr_t</code>来存放虚拟地址，而<code>physaddr_t</code>用来存放物理地址。</p>
<blockquote>
<p><strong>Question</strong></p>
<p>Q:如果下面的代码是正确的,变量x的类型应当是uintptr_t还是physaddr_t?</p>
<p>A:uintptr_t,因为C中的指针都是指向虚拟地址的.</p>
</blockquote>
<p>JOS内核有时需要读取或修改只知道物理地址的内存。例如，向页表添加映射可能需要分配物理内存来存储页目录，然后初始化该内存。但是，内核不能绕过虚拟地址转换，因此不能直接修改物理地址。这就是为什么我们要把物理内存用一个线性函数映射到虚拟内存中<code>0xf0000000</code>以上的区域:这方便了内核直接操作物理内存。<code>PADDR</code>和<code>KADDR</code>两个宏定义让我们可以很方便地实现物理地址和虚拟地址之间的转换。</p>
<h5 id="page-management"><a href="#page-management" class="headerlink" title="page management"></a>page management</h5><p>我们知道，同一个物理页面可能会被映射到数个不同虚拟空间的数个虚拟页面，我们通过修改<code>PageInfo</code>结构体中的<code>pp_ref</code>属性来反映这一点。每当我们分配一个UTOP以下的页面，我们让该物理页面的<code>pp_ref</code>属性+1。(UTOP以上的页面属于内核，它们永远不应该被free，因而无需更改这个属性)</p>
<p>需要注意的是，我们在实现<code>page_alloc</code>函数时并没有让它去增加<code>pp_ref</code>属性值，因此调用<code>page_alloc</code>的函数需要 <strong>自行增加这个属性的值</strong> 。</p>
<blockquote>
<p><strong>pgdir_walk</strong></p>
</blockquote>
<p>这个函数接受一个线性地址和一个页目录，返回线性地址对应的页面所在页表的物理地址。为了达成这个目的，我们可以通过线性地址中的页目录索引部分去找到页目录中的对应页表地址。如果这个页表还没有被创建，且create参数为真，那就创建一个新的页表并返回它的物理地址。</p>
<p>根据函数前面的注释，<strong>MMU会同时检查页目录表项和页表表项中的权限位</strong>，因而我们对于页目录中新页表物理地址的权限可以把要求放宽松一点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pte_t</span> *</span><br><span class="line">pgdir_walk(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">int</span> create)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find the page table where va locates.</span></span><br><span class="line">	<span class="keyword">physaddr_t</span> pgtab = pgdir[PDX(va)];</span><br><span class="line">	<span class="keyword">if</span> (!pgtab) &#123;</span><br><span class="line">		<span class="keyword">if</span> (create) &#123;</span><br><span class="line">			<span class="comment">// Allocate a new page table.</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">new_pt</span> = <span class="title">page_alloc</span>(<span class="title">ALLOC_ZERO</span>);</span></span><br><span class="line">			<span class="keyword">if</span> (new_pt == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				new_pt-&gt;pp_ref++;</span><br><span class="line">				<span class="comment">// Leave permissions of pt more permissive</span></span><br><span class="line">				<span class="comment">// We allow users to read this page</span></span><br><span class="line">				pgdir[PDX(va)] = page2pa(new_pt) | PTE_P | PTE_U | PTE_W;</span><br><span class="line">				<span class="keyword">return</span> KADDR(PTE_ADDR(pgdir[PDX(va)])+PTX(va)*<span class="keyword">sizeof</span>(<span class="keyword">pte_t</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// We need to return the address of page table **entry**</span></span><br><span class="line">		<span class="comment">// PTE_ADDR: get rid of the permission bits in `pgtab`</span></span><br><span class="line">		<span class="comment">// PTX(va)*sizeof(pte_t): find the 'PTX(va)'th element in a `pte_t` array.</span></span><br><span class="line">		<span class="keyword">return</span> KADDR(PTE_ADDR(pgtab)+PTX(va)*<span class="keyword">sizeof</span>(<span class="keyword">pte_t</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>boot_map_region</strong></p>
</blockquote>
<p>这个函数将一段指定的虚拟地址映射到同样长度的指定的物理地址。因为映射以页为单位，我们可以依次映射这段地址中的每一页：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">boot_map_region(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> va, <span class="keyword">size_t</span> size, <span class="keyword">physaddr_t</span> pa, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> page_num = size / PGSIZE;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; page_num; i++) &#123;</span><br><span class="line">		<span class="keyword">pte_t</span>* pgtab = pgdir_walk(pgdir,(<span class="keyword">void</span>*)(va+i*PGSIZE),<span class="number">1</span>);</span><br><span class="line">		*pgtab = (pa+i*PGSIZE) | perm | PTE_P;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>page_lookup</strong></p>
</blockquote>
<p>这个函数寻找va在pgdir中的页表地址和物理地址。依照注释完成,没有多大难度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *</span></span><br><span class="line"><span class="class"><span class="title">page_lookup</span>(<span class="title">pde_t</span> *<span class="title">pgdir</span>, <span class="title">void</span> *<span class="title">va</span>, <span class="title">pte_t</span> **<span class="title">pte_store</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">pte_t</span>* pgtab = pgdir_walk(pgdir, va, <span class="number">0</span>); <span class="comment">// Page table address</span></span><br><span class="line">	<span class="keyword">if</span> (pgtab == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (pte_store != <span class="literal">NULL</span>)</span><br><span class="line">			*pte_store = pgtab;</span><br><span class="line">		<span class="keyword">return</span> pa2page(PTE_ADDR(*pgtab));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>page_remove</strong></p>
</blockquote>
<p>这个函数移除va指定的页。基本上都是在调用函数，只要认真阅读了注释即很简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_remove(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">pte_t</span> *pg_pte;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pgtab</span> = <span class="title">page_lookup</span>(<span class="title">pgdir</span>, <span class="title">va</span>, &amp;<span class="title">pg_pte</span>);</span></span><br><span class="line">	<span class="keyword">if</span> (!pgtab) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// This function frees the page automatically if refcount reaches 0.</span></span><br><span class="line">	page_decref(pgtab);</span><br><span class="line">	*pg_pte = <span class="number">0</span>;</span><br><span class="line">	tlb_invalidate(pgdir, va);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>page_insert</strong></p>
</blockquote>
<p>这个函数将虚拟地址va所对应的页设定为pp。这个函数的一个很容易出错的边界条件是将一个 <strong>原本空闲的</strong> page <strong>连续插入两次</strong> ，按正常的逻辑第二次插入应该不会有任何影响，但实现不当的话会出现问题。</p>
<p>如果先进行<code>page_remove</code>再增加引用数的话，首先在调用<code>page_remove</code>的时候这个page已经进入了<code>page_free_list</code>，但接下来我们接着又要用到这个page且没有经过<code>page_alloc</code>，这样一来这个page既在空闲链表中引用数又不为0，会成为一个bug。</p>
<p>根据注释的提示，有一种优雅的无需条件判断的方式可以解决这个问题。这种方式就是 <strong>将增加引用数的步骤提前</strong> ，这样这个页面在<code>page_remove</code>之前引用数就是2，就不会在<code>page_remove</code>中被回收到<code>page_free_list</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">page_insert(<span class="keyword">pde_t</span> *pgdir, struct PageInfo *pp, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">pte_t</span>* pgtab = pgdir_walk(pgdir, va, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (pgtab == <span class="literal">NULL</span>) <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	pp-&gt;pp_ref++;</span><br><span class="line">	<span class="keyword">if</span> (*pgtab &amp; PTE_P)</span><br><span class="line">		page_remove(pgdir, va);</span><br><span class="line">	*pgtab = page2pa(pp) | perm | PTE_P;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Part-3-Kernel-address-space"><a href="#Part-3-Kernel-address-space" class="headerlink" title="Part 3 Kernel address space"></a>Part 3 Kernel address space</h4><p>JOS的地址空间被<code>ULIM</code>划分为两个部分：<strong>用户地址空间</strong> 和 <strong>内核地址空间</strong> 。后者大概拥有256MB的剩余空间可以使用。</p>
<p>由于用户区和内核区同在一个地址空间内，我们需要使用页表管理中的 <strong>权限位</strong> 来保证用户只能访问用户区的页。</p>
<ul>
<li>常用的权限位：<ul>
<li><code>PTE_P</code>: 页面存在</li>
<li><code>PTE_W</code>: 该页是可写的</li>
<li><code>PTE_U</code>: 该页可以由用户访问</li>
</ul>
</li>
</ul>
<p>用户不应有访问任何<code>ULIM</code>以上内存的权限,而内核应当能读写这一块区域。在<code>UTOP</code>和<code>ULIM</code>之间的区域是 <strong>只读区</strong>(对用户和内核都是) 。低于<code>UTOP</code>的内存区域权限由用户自行设置。</p>
<h5 id="Initializing-the-Kernel-Address-Space"><a href="#Initializing-the-Kernel-Address-Space" class="headerlink" title="Initializing the Kernel Address Space"></a>Initializing the Kernel Address Space</h5><blockquote>
<p><strong>Exercise 5</strong></p>
</blockquote>
<p>这个任务要求我们补全<code>mem_init</code>函数。</p>
<p>第一段要求我们把整个<code>pages</code>数组映射到<code>UPAGE</code>地址以上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cautious: we map the phyaddr of pages instead of their content</span></span><br><span class="line"><span class="comment">// So we use PADDR here, not page2pa.</span></span><br><span class="line">boot_map_region(kern_pgdir, UPAGES, npages*<span class="keyword">sizeof</span>(struct PageInfo), PADDR(pages), PTE_U);</span><br></pre></td></tr></table></figure>
<p>第二段要求我们把内核栈映射到<code>KSTACKTOP-KSTKSIZE</code>到<code>KSTACKTOP</code>区域。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boot_map_region(kern_pgdir, (KSTACKTOP-KSTKSIZE), KSTKSIZE, PADDR(bootstack), PTE_P | PTE_W);</span><br></pre></td></tr></table></figure>
<p>第三段要求我们映射整个内核区域。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> kern_size = (<span class="keyword">unsigned</span>)~<span class="number">0</span> - KERNBASE;</span><br><span class="line">boot_map_region(kern_pgdir, KERNBASE, kern_size, <span class="number">0</span>, PTE_P | PTE_W);</span><br></pre></td></tr></table></figure>
<p>三段都是看着注释调函数即可，没有很大难度。不得不说6.828的注释仔细研究可以省去很多精力。</p>
<blockquote>
<p><strong>Questions</strong></p>
<p>Q：在这个过程中哪些PDE被填入了信息？它们对应哪些线性地址，又指向哪些物理地址？</p>
<p>A：被填入的PDE索引：</p>
<ul>
<li>956-UPAGES，线性地址0xef000000,指向pages数组在物理内存中的首地址</li>
<li>957-UVPT，线性地址0xef400000,指向kern_pgdir在物理内存中的地址</li>
<li>959-KSTACK，线性地址0xefc00000,指向bootstack数组在物理内存中的首地址</li>
<li>960～1023-内核内存区，线性地址0xf0000000以上，指向物理内存地址0。</li>
</ul>
<p>Q：既然我们把用户和内核的内存区域放在同一个地址空间中，到底是什么机制保护了内核内存不能被用户访问？</p>
<p>A：权限位<code>PTE_U</code>决定了一页能否被用户访问。</p>
<p>Q：这个操作系统能够支持多大的物理内存？为什么？</p>
<p>A：内存空间内能存放pages的空间是一个PTSIZE，也就是最多能够映射PTSIZE/sizeof(struct PageInfo)个页面，每页大小为4KB，因此总共能映射的物理内存大小为2GB。</p>
<p>Q：如果我们拥有能支持的最大的物理内存，管理这些内存需要多少空间开销？如何减少这些开销？</p>
<p>A：管理满载的512K个页面需要512个页表，每个页表占内存空间都是一个PGSIZE，总共就会有4MB左右内存用于页表储存。加上用于存放pages的4MB和页目录的4KB，总共会有8MB左右空间开销。如果把PGSIZE取大一点，这种开销就可以稍微减小。</p>
<p>Q：在我们刚打开分页机制的时候，程序还运行在低地址，控制流在什么时候跳转到KERNBASE以上？为什么在打开分页机制之后我们仍能够运行在一个低地址？</p>
<p>A：在打开分页的下一步，控制流就用jmp指令跳转到了KERNBASE以上的高地址。打开分页机制后仍能在低地址运行的原因是低地址和KERNBASE以上的高地址都被映射到同一片物理内存，这是为了保持兼容性。</p>
</blockquote>
<p>完成上面的所有代码之后，运行<code>make grade</code>，<code>70/70</code>大成功。</p>
<blockquote>
<p><strong>Challenge</strong></p>
</blockquote>
<p>这个挑战的内容主要是为JOS的monitor加入一些实用的指令，以方便之后的调试过程，具体的指令细节可以自己调整和定制。增加指令后，要记得在<code>monitor.h</code>中添加声明。</p>
<p>我主要做了以下几条指令(下面是修改后的Commands数组)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>pageinfo</strong></li>
</ol>
<p>这个指令接受一个命令行参数。</p>
<p><code>pageinfo addr</code>：打印出虚拟地址addr所在的页目录，页表，以及所在的物理页面，物理地址。</p>
<p>如果addr使用十六进制地址，必须在数字前面加上<code>0x</code>。</p>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Must include pmap.h in monitor.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;kern/pmap.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_pageinfo(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cannot declare vars in switch-case statement.</span></span><br><span class="line">    <span class="keyword">physaddr_t</span> addr;</span><br><span class="line">    <span class="keyword">pte_t</span>* pte;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (argc) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            cprintf(<span class="string">"Error: too few arguments.\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            addr = str2int(argv[<span class="number">1</span>]);</span><br><span class="line">            pte = pgdir_walk(kern_pgdir, (<span class="keyword">void</span> *)addr, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!pte) &#123;</span><br><span class="line">                cprintf(<span class="string">"This address has not been mapped yet.\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!(*pte &amp; PTE_P)) &#123;</span><br><span class="line">                cprintf(<span class="string">"Exception: Page does not exist.\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cprintf(<span class="string">"Mapping information of address %x:\n"</span>, addr);</span><br><span class="line">            cprintf(<span class="string">"  Page directory entry: %d\n"</span>, PDX(addr));</span><br><span class="line">            cprintf(<span class="string">"  Page table entry: %d\n"</span>, PTX(addr));</span><br><span class="line">            cprintf(<span class="string">"  Page physical address: %x\n"</span>, PTE_ADDR(*pte));</span><br><span class="line">            cprintf(<span class="string">"  Physical address: %x\n"</span>, PTE_ADDR(*pte) + PGOFF(addr));</span><br><span class="line">            cprintf(<span class="string">"  Page permission:\n"</span>);</span><br><span class="line">            <span class="keyword">if</span> ((*pte &amp; PTE_U) &amp;&amp; (*pte &amp; PTE_W)) &#123;</span><br><span class="line">                cprintf(<span class="string">"    Readable and writeable by user and kernel\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((*pte &amp; PTE_U)) &#123;</span><br><span class="line">                cprintf(<span class="string">"    Readable by user and kernel\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((*pte &amp; PTE_W)) &#123;</span><br><span class="line">                cprintf(<span class="string">"    Readable and writeable by kernel\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cprintf(<span class="string">"    Readable by kernel\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cprintf(<span class="string">"Error: too many arguments.\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">str2int(<span class="keyword">char</span>* str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">'0'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(++str) != <span class="string">'x'</span>)</span><br><span class="line">            base = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            base = <span class="number">16</span>;</span><br><span class="line">            str++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> (base == <span class="number">10</span> || base == <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">while</span> (*str) &#123;</span><br><span class="line">            num = num * base + *str - <span class="string">'0'</span>;</span><br><span class="line">            str++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">while</span> (*str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*str &gt;= <span class="string">'a'</span> &amp;&amp; *str &lt;= <span class="string">'f'</span>)</span><br><span class="line">            num = num * base + *str - <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*str &gt;= <span class="string">'A'</span> &amp;&amp; *str &lt;= <span class="string">'F'</span>)</span><br><span class="line">            num = num * base + *str - <span class="string">'A'</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            num = num * base + *str - <span class="string">'0'</span>;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>chperm</strong></li>
</ol>
<p>这个指令接受三个命令行参数。</p>
<p><code>chperm &lt;PDX&gt; &lt;PTX&gt; &lt;perm&gt;</code>：修改<code>&lt;PDX&gt;</code>和<code>&lt;PTX&gt;</code>对应页面的权限。</p>
<p><code>&lt;perm&gt;</code>的使用方法：</p>
<ul>
<li><code>+</code>：增加一种权限</li>
<li><code>-</code>：消除一种权限</li>
<li><code>w</code>：对应于<code>PTE_W</code></li>
<li><code>u</code>：对应于<code>PTE_U</code></li>
<li><code>p</code>：对应于<code>PTE_P</code></li>
</ul>
<p>使用样例：<code>chperm 960 256 -w</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Change the permittions of a certain page.</span></span><br><span class="line"><span class="comment">// chperm &lt;PDX&gt; &lt;PTX&gt; &lt;perm&gt;</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_chperm(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pdx, ptx, perm = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>* ptr;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">// 0 represents '-', 1 represents '+'</span></span><br><span class="line">    <span class="keyword">pte_t</span>* pgaddr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (argc) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"></span><br><span class="line">            pdx = str2int(argv[<span class="number">1</span>]);</span><br><span class="line">            ptx = str2int(argv[<span class="number">2</span>]);</span><br><span class="line">            ptr = argv[<span class="number">3</span>];</span><br><span class="line">            pgaddr = pgdir_walk(kern_pgdir, (<span class="keyword">void</span> *)(PGADDR(pdx,ptx,<span class="number">0</span>)), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (*ptr) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>: flag = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>: flag = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    cprintf(<span class="string">"Error: Illegal operation \'%c\'.\n"</span>, *ptr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (*(ptr+<span class="number">1</span>))   &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'w'</span>:</span><br><span class="line">                    <span class="keyword">if</span> (flag) *pgaddr = *pgaddr | PTE_W;</span><br><span class="line">                    <span class="keyword">else</span> *pgaddr = *pgaddr &amp; (~PTE_W);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">                    <span class="keyword">if</span> (flag) *pgaddr = *pgaddr | PTE_U;</span><br><span class="line">                    <span class="keyword">else</span> *pgaddr = *pgaddr &amp; (~PTE_U);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'p'</span>:</span><br><span class="line">                    <span class="keyword">if</span> (flag) *pgaddr = *pgaddr | PTE_P;</span><br><span class="line">                    <span class="keyword">else</span> *pgaddr = *pgaddr &amp; (~PTE_P);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    cprintf(<span class="string">"Error: Illegal operation \'%c\'.\n"</span>, *(ptr+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cprintf(<span class="string">"Error: bad usage.\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>man</strong></li>
</ol>
<p>虽然命名为man，但是其实这个命令的行为更像<code>--help</code>。</p>
<p>需要注意的是，每增加一条新的命令就要增加<code>command_usage</code>数组的内容。并且，这个数组中的元素顺序必须与<code>commands</code>数组中的顺序一致。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* command_usage[] = &#123;</span><br><span class="line">    <span class="string">"help\nDisplay the list of commands"</span>,</span><br><span class="line">    <span class="string">"exit\nLeave the monitor and shutdown"</span>,</span><br><span class="line">    <span class="string">"kerninfo\nDisplay information about the kernel"</span>,</span><br><span class="line">    <span class="string">"backtrace\nDisplay the structure of the stack"</span>,</span><br><span class="line">    <span class="string">"pageinfo &lt;addr&gt;\nDisplay the information of the page virtual address &lt;addr&gt; locates"</span>,</span><br><span class="line">    <span class="string">"chperm &lt;PDX&gt; &lt;PTX&gt; &lt;perm&gt;\nChange the permittion of the page with index &lt;PDX&gt; and &lt;PTX&gt;\n  \</span></span><br><span class="line"><span class="string">&lt;perm&gt; is the combination of a symbol('+' or '-') and a permittion code. \</span></span><br><span class="line"><span class="string">In particular, '+' is for permittion addition and '-' is for permittion erasure.\n\</span></span><br><span class="line"><span class="string">Possible permittion codes:\n  u: PTE_U\n  p: PTE_P\n  w: PTE_W\n"</span>,</span><br><span class="line">    <span class="string">"man\nDisplay the usage of a command"</span>,  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Display the usage of a command.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_man(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        cprintf(<span class="string">"Usage: man &lt;command&gt;\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE(commands); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], commands[i].name) == <span class="number">0</span>) &#123;</span><br><span class="line">            cprintf(<span class="string">"Usage: %s\n"</span>, command_usage[i]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">"Error: no such command.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这一章的最后还有几个挑战，一个是实现一种不同的分页机制使用户可以不受限制地使用整个4GB内存空间，由于并没有什么主流操作系统使用这种模式就没写。另一个是实现一个类似于<code>malloc/free</code>堆内存分配的分配机制，过于麻烦，等有空再写这个吧。</p>
<h4 id="Summarize"><a href="#Summarize" class="headerlink" title="Summarize"></a>Summarize</h4><p>总结一下JOS使用的内存管理机制：</p>
<p>目前整个操作系统由一个页目录——<strong>内核页目录</strong>(<code>kern_pgdir</code>)来维持，页目录的大小为一页，包括<em>1024</em>个条目。每个条目都是一个4字节的物理地址，指向对应的页表所在的物理内存地址。每个页表大小也是一页，同样包括<em>1024</em>个条目，每个条目指向对应的页所在的物理内存地址。</p>
<p>每个物理地址与一个线性地址唯一对应。线性地址的前10位和中间10位分别是这个地址所在物理页面的<strong>页目录索引</strong>和<strong>页表索引</strong>，最后12位代表这个地址在物理页面内的<strong>偏移量</strong>。</p>
<p>除此之外，内核还维护着一个<code>pages</code>数组。真正的page每个<strong>4KB</strong>，由整个物理地址空间平分；pages数组中的元素<code>PageInfo</code>大小<strong>8字节</strong>，记录着这个page的引用数和空闲链表中它的下一个元素的地址。<strong>pages数组中元素的索引可以线性地换算出对应page在物理内存中的首地址</strong>。</p>
<p><code>page_free_list</code>指针是空闲链表的头指针。它指向pages数组中第一个空闲的元素。空闲链表中的其他元素可以由<code>PageInfo</code>中的指针来索引。</p>
<p>这个内存管理机制被外界调用的接口函数有：</p>
<ul>
<li><code>page_alloc</code>：分配一块空闲的物理页，并将其对应的<code>PageInfo</code>结构体指针返回。注意调用者需要自行增加<code>pp_ref</code>的值。</li>
<li><code>page_free</code>：释放一块被占用的物理页。</li>
<li><code>page_insert</code>：将一块已分配的物理页与一个虚拟地址建立关系</li>
</ul>
<h3 id="Lab-3-User-Environments"><a href="#Lab-3-User-Environments" class="headerlink" title="Lab 3 User Environments"></a>Lab 3 User Environments</h3><p>在前两个Lab中，我们成功加载并运行了JOS内核，还建立了整个内核虚拟地址空间的内存映射，但这些都只是对内核的操作。在这个Lab里，我们要开始建立一个用户环境。换句话说，我们要建立一个用户进程，并使其受内核的监管。内核应当接受并处理所有用户进程发起的系统调用和引发的异常。</p>
<p>执行<code>git checkout -b lab3 origin/lab3</code>命令切换到lab3分支，执行<code>git merge lab2</code>合并在lab2所做的更改。这一步可能会出现conflict，解决之后重新commit即可。</p>
<p>Lab3增加的文件有：</p>
<table>
<thead>
<tr>
<th></th>
<th>文件名</th>
<th>文件功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>inc/</code></td>
<td><code>env.h</code></td>
<td>有关用户环境的一些声明和定义</td>
</tr>
<tr>
<td></td>
<td><code>trap.h</code></td>
<td>关于trap类异常处理的声明和定义(有关四种异常可以参考CSAPP第八章)</td>
</tr>
<tr>
<td></td>
<td><code>syscall.h</code></td>
<td>关于系统调用处理的声明和定义</td>
</tr>
<tr>
<td></td>
<td><code>lib.h</code></td>
<td>用户使用的系统库</td>
</tr>
<tr>
<td><code>kern/</code></td>
<td><code>env.h</code>/<code>env.c</code></td>
<td>内核维持用户环境所需要的声明和定义</td>
</tr>
<tr>
<td></td>
<td><code>trap.h</code>/<code>trap.c</code></td>
<td>内核对trap类异常的接受和处理</td>
</tr>
<tr>
<td></td>
<td><code>trapentry.S</code></td>
<td>汇编语言编写的trap异常处理程序入口</td>
</tr>
<tr>
<td></td>
<td><code>syscall.h</code>/<code>syscall.c</code></td>
<td>内核对系统调用的接受和处理</td>
</tr>
<tr>
<td><code>lib/</code></td>
<td><code>Makefrag</code></td>
<td>用来构建<code>obj/lib/libjos.a</code>的makefile</td>
</tr>
<tr>
<td></td>
<td><code>entry.S</code></td>
<td>汇编语言编写的用户进程入口</td>
</tr>
<tr>
<td></td>
<td><code>libmain.c</code></td>
<td><code>entry.S</code>调用的用于初始化用户环境的代码</td>
</tr>
<tr>
<td></td>
<td><code>syscall.c</code></td>
<td>用户环境的系统调用函数</td>
</tr>
<tr>
<td></td>
<td><code>console.c</code></td>
<td>用户模式下的 <code>putchar</code> 和 <code>getchar</code>实现, 用于提供console的I/O</td>
</tr>
<tr>
<td></td>
<td><code>exit.c</code></td>
<td>用户模式下的 <code>exit</code></td>
</tr>
<tr>
<td></td>
<td><code>panic.c</code></td>
<td>用户模式下的<code>panic</code></td>
</tr>
<tr>
<td><code>user/</code></td>
<td><code>*</code></td>
<td>测试程序</td>
</tr>
</tbody>
</table>
<p>除此之外，lab3更改了不少lab2中的文件。可以执行<code>git diff lab2</code>来查看具体的改动。</p>
<p>在这个Lab中，GCC提供的<strong>内联汇编</strong>特性非常有帮助。内联汇编的格式可以参考<a href="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html" target="_blank" rel="noopener">6.828提供的教程</a>，也可以参考<a href="https://dracit7.github.io/blog/2018/11/23/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/">中文的博客</a>。</p>
<h4 id="Part-1-User-Environments-and-Exception-Handling"><a href="#Part-1-User-Environments-and-Exception-Handling" class="headerlink" title="Part 1 User Environments and Exception Handling"></a>Part 1 User Environments and Exception Handling</h4><p><code>inc/env.h</code>包含着对<code>Env</code>结构的定义。<code>Env</code>结构类似于<code>PageInfo</code>结构，只不过后者储存的是页面的信息而前者储存的是用户环境的信息。内核利用这些结构来管理所有用户环境。在这个Lab中我们只需要实现一个用户环境，但我们也要完成管理多个用户环境的机制，以支持以后的Lab功能。</p>
<p>在<code>kern/inv.c</code>中定义有三个变量:</p>
<ul>
<li><code>struct Env *envs</code>：所有用户环境信息链表头指针</li>
<li><code>struct Env *curenv</code>：当前的用户环境</li>
<li><code>static struct Env *env_free_list</code>：空闲的用户环境链表头指针</li>
</ul>
<p>JOS系统最多能够支持<code>NENV</code>个用户环境，这个常量的定义在<code>inc/kern.h</code>中，默认的值是10。在初始化时，<code>envs</code>数组会被初始化为<code>NENV</code>长度的链表。</p>
<p><strong>注</strong>：在这个Lab中，<strong>用户环境和进程是指的同一个东西</strong>。</p>
<h5 id="Environment-State"><a href="#Environment-State" class="headerlink" title="Environment State"></a>Environment State</h5><p>我们可以分析一下<code>Env</code>结构的内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span>	<span class="comment">// Saved registers</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span>		<span class="comment">// Next free Env</span></span><br><span class="line">	<span class="keyword">envid_t</span> env_id;			<span class="comment">// Unique environment identifier</span></span><br><span class="line">	<span class="keyword">envid_t</span> env_parent_id;		<span class="comment">// env_id of this env's parent</span></span><br><span class="line">	<span class="keyword">enum</span> EnvType env_type;		<span class="comment">// Indicates special system environments</span></span><br><span class="line">	<span class="keyword">unsigned</span> env_status;		<span class="comment">// Status of the environment</span></span><br><span class="line">	<span class="keyword">uint32_t</span> env_runs;		<span class="comment">// Number of times environment has run</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Address space</span></span><br><span class="line">	<span class="keyword">pde_t</span> *env_pgdir;		<span class="comment">// Kernel virtual address of page dir</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>env_tf</code>：这是一个<code>Trapframe</code>结构体，它负责在这个用户环境挂起的时候<strong>保存其所有寄存器值</strong>。可以观察一下<code>Trapframe</code>结构体的<span id="trapframe">定义</span>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">	<span class="keyword">uint16_t</span> tf_es;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_padding1;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_ds;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_padding2;</span><br><span class="line">	<span class="keyword">uint32_t</span> tf_trapno;</span><br><span class="line">	<span class="comment">/* below here defined by x86 hardware */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> tf_err;</span><br><span class="line">	<span class="keyword">uintptr_t</span> tf_eip;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_cs;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_padding3;</span><br><span class="line">	<span class="keyword">uint32_t</span> tf_eflags;</span><br><span class="line">	<span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> tf_esp;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_ss;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_padding4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，所有x86的关键寄存器的值在这里都有保存(通用寄存器的值都保存在<code>PushRegs</code>结构内)。</p>
<ul>
<li><code>env_link</code>：指向空闲用户环境链表中的下一个元素</li>
<li><code>env_id</code>：内核用于<strong>唯一地标识</strong>这个用户环境的描述符，也就是进程的pid。当用户环境被回收时这个id也会被回收，也就是说id和这个<code>Env</code>在链表中的位置是无关的。</li>
<li><code>env_parent_id</code>：这个进程的父进程的id。</li>
<li><code>env_type</code>：用于区分进程的类型(用户进程还是系统服务进程)</li>
<li><p><code>env_status</code>：当前用户环境的状态</p>
<ul>
<li><code>ENV_FREE</code>：位于<code>env_free_list</code>中</li>
<li><code>ENV_RUNNABLE</code>：该进程可以运行，正在等待CPU的调度</li>
<li><code>ENV_RUNNING</code>：该进程正在CPU上运行</li>
<li><code>ENV_NOT_RUNNABLE</code>：该进程是活动的，但由于某些原因无法运行</li>
<li><code>ENV_DYING</code>：该进程目前是僵尸进程</li>
</ul>
</li>
<li><p><code>env_pgdir</code>：当前用户环境使用的页目录地址</p>
</li>
</ul>
<h5 id="Allocating-the-Environments-Array"><a href="#Allocating-the-Environments-Array" class="headerlink" title="Allocating the Environments Array"></a>Allocating the Environments Array</h5><blockquote>
<p><strong>Exercise 1</strong></p>
<p>你需要向<code>mem_init</code>函数中添加初始化<code>envs</code>数组的代码，就像之前初始化<code>pages</code>那样。此外，你还需要将初始化后的<code>envs</code>数组映射到<code>UENVS</code>地址以使用户能够查看它。</p>
</blockquote>
<p>由于有了之前初始化pages的经验，这里使用相同的方法可以轻松完成任务：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">envs = (struct Env *) boot_alloc(<span class="keyword">sizeof</span>(struct Env) * NENV);</span><br><span class="line"><span class="built_in">memset</span>(envs, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct Env) * NENV);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boot_map_region(kern_pgdir, UENVS, NENV*<span class="keyword">sizeof</span>(struct Env), PADDR(envs), PTE_U);</span><br></pre></td></tr></table></figure>
<p>运行后一看，为什么本来过了的<code>check_page_free_list()</code>失败了呢？百思不得其解，逆着逻辑流往前找，最终发现是因为之前在<code>page_init</code>函数中在计算内核空闲地址空间的起始位置时用到了<code>pages</code>，而现在我们在<code>pages</code>数组后面又分配了更多的空间给<code>envs</code>，原本空闲的内存变得不空闲了，但<code>page_init</code>的逻辑没有变，于是本来正确的函数出现了错误。改正方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// char* end_addr = (char *)pages + sizeof(struct PageInfo) * npages - KERNBASE;</span></span><br><span class="line"><span class="keyword">char</span>* end_addr = (<span class="keyword">char</span> *)envs + <span class="keyword">sizeof</span>(struct Env) * NENV - KERNBASE;</span><br></pre></td></tr></table></figure>
<h5 id="Creating-and-Running-Environments"><a href="#Creating-and-Running-Environments" class="headerlink" title="Creating and Running Environments"></a>Creating and Running Environments</h5><p>我们现在需要完善<code>kern/env.c</code>中的代码来运行一个用户环境。由于我们现在还没有构建文件系统，我们会让内核加载一个静态的二进制镜像(这个镜像是以ELF格式嵌在内核中的)。</p>
<p>Lab3的<code>GNUMakefile</code>在<code>obj/user</code>目录中生成了很多二进制镜像。<code>kern</code>目录中的<code>Makefrag</code>文件将它们利用linker的<code>-b</code>参数直接嵌入内核的可执行文件当中(不是以可重定位文件<code>.o</code>的形式，是将整个二进制文件原样嵌入)，内核可以在运行时索引并运行这些镜像。</p>
<blockquote>
<p><strong>Exercise 2</strong></p>
<p>完成下列函数来初始化用户环境：</p>
<ul>
<li><code>env_init()</code>：初始化所有<code>envs</code>数组中的元素并将它们加入<code>env_free_list</code>链表中。这个函数还应该调用<code>env_init_percpu</code>来配置关于分段机制的硬件。</li>
<li><code>env_setup_vm()</code>：为新的用户环境初始化一个<strong>页目录</strong>并初始化这个用户环境的内核部分内存</li>
<li><code>region_alloc()</code>：用于为用户环境分配物理内存</li>
<li><code>load_icode()</code>：解析用户进程要跑的任务文件的ELF头，并将二进制文件加载到虚拟地址空间</li>
<li><code>env_create()</code>：调用上面两个函数来为一个任务建立一个新的用户环境</li>
<li><code>env_run()</code>：运行一个用户环境</li>
</ul>
</blockquote>
<p>这一部分编码涉及到比较多的错误码处理，在这里可以活用<code>cprintf</code>的<code>%e</code>转义字符：它可以打印出一个errorcode对应的错误信息。</p>
<p>首先是<code>env_init</code>函数。只要认真阅读过函数前面的注释，按部就班地来就没有什么难度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Set up envs array</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		envs[i].env_id = <span class="number">0</span>;</span><br><span class="line">		envs[i].env_status = ENV_FREE;</span><br><span class="line">		envs[i].env_link = env_free_list;</span><br><span class="line">		env_free_list = &amp;envs[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">	env_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后是<code>env_setup_vm</code>函数。这个函数的作用是为这个用户环境建立整个虚拟内存系统。看上去很吓人，但注释中提示我们，所有用户环境在UTOP以上的虚拟内存空间都是内核虚拟内存空间中这一部分的副本，而UTOP以下的部分在初始化过程中全都可以置0，因此我们可以直接以<code>kern_pgdir</code>为模板来初始化<code>e-&gt;env_pgdir</code>的表项：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the page directory</span></span><br><span class="line">p-&gt;pp_ref++;</span><br><span class="line">e-&gt;env_pgdir = page2kva(p);</span><br><span class="line"><span class="comment">// Set up the virtual memory space</span></span><br><span class="line"><span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</span><br></pre></td></tr></table></figure>
<p>接下来是<code>region_alloc</code>函数，这个函数其实不写也行，主要是为了简化物理内存的分配过程。在<code>load_icode</code>函数中我们要频繁地为一段虚拟内存分配物理内存，这个函数就是为了简化这一过程而生的。</p>
<p>如果我们对之前Lab2中自己实现过的函数的功能和调用关系很熟悉的话，这个函数的实现会很简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">region_alloc(struct Env *e, <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">uintptr_t</span> start_addr = ROUNDDOWN((<span class="keyword">uintptr_t</span>)va, PGSIZE);</span><br><span class="line">	<span class="keyword">uintptr_t</span> end_addr = ROUNDUP((<span class="keyword">uintptr_t</span>)(va + len), PGSIZE);</span><br><span class="line">	<span class="keyword">for</span> ( ; start_addr &lt; end_addr; start_addr += PGSIZE) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">rawpg</span> = <span class="title">page_alloc</span>(<span class="title">ALLOC_ZERO</span>);</span></span><br><span class="line">		<span class="keyword">if</span> (!rawpg) panic(<span class="string">"region_alloc: %e"</span>,-E_NO_MEM);</span><br><span class="line">		page_insert(e-&gt;env_pgdir, rawpg, (<span class="keyword">void</span> *)start_addr, PTE_U | PTE_W);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一个函数<code>load_icode</code>的实现难度就比较大了，它会<strong>将目标ELF镜像文件加载到内存中</strong>，为此它需要解析ELF头的内容，这一步与bootloader所做的比较相似，可以参考<code>boot/main.c</code>中的实现；它还会为这个已经加载的二进制文件<strong>建立一个程序栈</strong>。</p>
<p>在<code>inc/elf.h</code>中已经定义好了ELF头和段头的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> e_magic;	<span class="comment">// must equal ELF_MAGIC</span></span><br><span class="line">	<span class="keyword">uint8_t</span> e_elf[<span class="number">12</span>];</span><br><span class="line">	<span class="keyword">uint16_t</span> e_type;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_machine;</span><br><span class="line">	<span class="keyword">uint32_t</span> e_version;</span><br><span class="line">	<span class="keyword">uint32_t</span> e_entry;</span><br><span class="line">	<span class="keyword">uint32_t</span> e_phoff;</span><br><span class="line">	<span class="keyword">uint32_t</span> e_shoff;</span><br><span class="line">	<span class="keyword">uint32_t</span> e_flags;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_ehsize;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_phentsize;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_phnum;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_shentsize;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_shnum;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_shstrndx;</span><br><span class="line">&#125;; <span class="comment">// ELF头的结构</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> p_type;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_offset;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_va;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_pa;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_filesz;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_memsz;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_flags;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_align;</span><br><span class="line">&#125;; <span class="comment">// 段头部的结构</span></span><br></pre></td></tr></table></figure>
<p>关于ELF文件结构的详细知识可以参考CSAPP的第7章链接部分知识，我们现在只需要知道，<strong>ELF头</strong>位于一个二进制文件的开头部分，而且通过解析ELF头的信息可以得到<strong>段头部表</strong>的位置和大小。通过解析每个段头部，我们又可以得知所有段的信息，从而将它们有选择性地加载到内存中。</p>
<p>这里可能需要解释一下6.828的诡异命名的含义：<code>ph</code>是指二进制文件中各个段的段头部结构体指针，其类型为<code>struct Proghdr*</code>。只要理解了这一层，按照注释就可以按部就班地完成这个函数了。</p>
<p>比较需要注意的一点是<code>cr3</code>寄存器值的切换。在这个函数执行之前当前运行的环境是kernel，因此<code>cr3</code>的值是<code>kern_pgdir</code>，如果我们直接用<code>memcpy</code>函数去加载binary就会将binary加载到<strong>内核地址空间</strong>而非<strong>用户环境地址空间</strong>。所以我们需要在加载binary之前先用<code>lcr3</code>函数切换<code>cr3</code>寄存器的值，在加载完之后再切换回<code>kern_pgdir</code>。</p>
<p>另一个问题是如何设置加载进内存的二进制程序的<strong>入口点</strong>。根据注释中的提示观察<code>env_pop_tf</code>函数可以发现，这个函数从<code>env_tf</code>结构中恢复了所有上下文寄存器的值，其中就包括<code>tf_eip</code>这个决定着下一条命令位置的寄存器，随后就执行<code>iret</code>汇编指令切换用户环境。这样一来，只要我们将<code>(e-&gt;env_tf).tf_eip</code>的值修改为二进制程序入口点的值，就可以让控制流自然地跳转到那个位置了。</p>
<p>但是二进制程序入口点的值是什么呢？这个值其实存放在ELF头中，就是<code>e_entry</code>这个结构体元素的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">load_icode(struct Env *e, <span class="keyword">uint8_t</span> *binary)</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Elf</span>* <span class="title">elf_ptr</span> = <span class="title">binary</span>;</span> <span class="comment">// The pointer to the binary's elf header</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check the type of the binary</span></span><br><span class="line">	<span class="keyword">if</span> (elf_ptr-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">		panic(<span class="string">"This binary is not a valid ELF file!"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Load each program segment</span></span><br><span class="line">	ph = (struct Proghdr *)(binary + elf_ptr-&gt;e_phoff);</span><br><span class="line">	eph = ph + elf_ptr-&gt;e_phnum;</span><br><span class="line">	<span class="comment">// As we need to load the binary into e's virtual memory,</span></span><br><span class="line">	<span class="comment">// we should change cr3 to e's page directory (or the binary</span></span><br><span class="line">	<span class="comment">// would be loaded to kernel's virtual memory).</span></span><br><span class="line">	lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">	<span class="keyword">for</span> (; ph &lt; eph; ph++) &#123;</span><br><span class="line">		<span class="comment">// Do what the hint told us to</span></span><br><span class="line">		<span class="keyword">if</span> (ph-&gt;p_type == ELF_PROG_LOAD) &#123;</span><br><span class="line">			region_alloc(e, ph-&gt;p_va, ph-&gt;p_memsz);</span><br><span class="line">			<span class="built_in">memcpy</span>(ph-&gt;p_va, binary + ph-&gt;p_offset, ph-&gt;p_filesz);</span><br><span class="line">			<span class="built_in">memset</span>(binary + ph-&gt;p_va + ph-&gt;p_filesz, <span class="number">0</span>, ph-&gt;p_memsz - ph-&gt;p_filesz);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Change cr3 back to kern_pgdir.</span></span><br><span class="line">	lcr3(PADDR(kern_pgdir));</span><br><span class="line">	<span class="comment">// Set the entry point of the binary</span></span><br><span class="line">	(e-&gt;env_tf).tf_eip = elf_ptr-&gt;e_entry;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now map one page for the program's initial stack</span></span><br><span class="line">	<span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	region_alloc(e, USTACKTOP - PGSIZE, PGSIZE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数完成之后，剩下的两个函数就比较简单了。<code>env_create</code>函数直接按照注释中的要求调用函数即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_create(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">new_env</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err = env_alloc(&amp;new_env, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		panic(<span class="string">"env_create: %e"</span>, err);</span><br><span class="line">	load_icode(new_env, binary);</span><br><span class="line">	new_env-&gt;env_type = type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的<code>env_run</code>也按照注释的要求完成即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_run(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1</span></span><br><span class="line">	<span class="keyword">if</span> (curenv != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (curenv-&gt;env_status == ENV_RUNNING)</span><br><span class="line">			curenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">		<span class="keyword">else</span> panic(<span class="string">"env_run: The current process's status is not ENV_RUNNING."</span>);</span><br><span class="line">	&#125;	<span class="comment">// 1.</span></span><br><span class="line">	curenv = e; <span class="comment">// 2.</span></span><br><span class="line">	curenv-&gt;env_status = ENV_RUNNING; <span class="comment">// 3.</span></span><br><span class="line">	curenv-&gt;env_runs++; <span class="comment">// 4.</span></span><br><span class="line">	lcr3(PADDR(e-&gt;env_pgdir)); <span class="comment">// 5.</span></span><br><span class="line">	<span class="comment">// Step 2</span></span><br><span class="line">	env_pop_tf(&amp;curenv-&gt;env_tf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们还没有完成系统调用相关的处理代码，加载完成的binary并无法正常工作。在binary执行到系统调用那一步之后，CPU会发现它还不能处理这个中断，于是抛出一个<strong>一般保护错误</strong>(general protection fault)。然而这个保护错误目前不能被处理，于是CPU再抛出一个<code>double fault</code>异常，并发现这也不能被处理，最终放弃治疗并抛出<code>triple fault</code>异常，也就是我们之前在调试过程中常见的那个<code>triple fault</code>。</p>
<p>一个<code>triple fault</code>异常通常会引起系统重启，但为了方便debug，6.828修改了qemu使得它在<code>triple fault</code>的时候打印出所有寄存器的值和内存状态。</p>
<p>为了检验我们的工作是否正确完成，我们可以用<code>qemu-gdb</code>和<code>gdb</code>来进行调试。首先在<code>env_pop_tf</code>函数处打上断点并<code>c</code>到这个函数，<code>si</code>单步调试直到<code>iret</code>将控制流跳转到用户地址空间，这时可以发现<code>gdb</code>中的地址信息显示从<code>0xf0000000</code>以上变成了<code>0x00800000</code>以上，能进行到这一步说明我们对于用户地址空间创建的实现没有问题。</p>
<p>在<code>0x800101</code>处(系统调用的前一句指令)打一个断点，执行到这一句汇编指令。如果在执行到这里的过程中始终没有触发错误，说明我们Exercise 2的实现是没有问题的。</p>
<h5 id="Handling-Interrupts-and-Exceptions"><a href="#Handling-Interrupts-and-Exceptions" class="headerlink" title="Handling Interrupts and Exceptions"></a>Handling Interrupts and Exceptions</h5><p>现在的情况是，一旦用户环境执行了系统调用，控制流是无法从内核返回给用户环境的。我们现在需要实现的是内核对于<strong>基本的异常和系统调用的处理</strong>，首先我们要熟悉x86的中断和异常机制。</p>
<blockquote>
<p><strong>Exercise 3</strong></p>
<p>阅读<a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/c09.htm" target="_blank" rel="noopener">80386 Programmer’s Manual中有关异常和中断处理的部分</a>。</p>
</blockquote>
<p>(如果已经阅读过CSAPP第八章异常控制流，有关这部分的内容会变得很易于理解。)</p>
<p>中断和异常都是<strong>受保护的控制流转移</strong>，也就是说这两个过程是受内核控制的。内核通过中断或异常来切换到内核态，以使得用户代码没有干预内核运行的机会。</p>
<p>Intel是这样定义<strong>异常</strong>和<strong>中断</strong>的：</p>
<ul>
<li>中断(Interrupt)是<strong>处理器外部</strong>的设备向处理器发出的<strong>异步</strong>(<em>asynchronous</em>)信号引起的(典型的例子是IO)。</li>
<li>异常(Exception)是<strong>处理器本身</strong>执行的代码所触发的<strong>同步</strong>(<em>synchronous</em>)信号引起的，系统调用和错误都算做异常。</li>
</ul>
<p>从这个定义我们可以看出，Intel对中断的定义和CSAPP一致，但异常的定义其实是包括了CSAPP中定义的<strong>陷阱</strong>(trap)，<strong>错误</strong>(fault)和<strong>终止</strong>(abort)。</p>
<p>为了保证这种控制流转移是<strong>受保护的</strong>，intel使用了两种机制：</p>
<ul>
<li><strong>中断描述符表</strong>(IDT)：处理器保证了当异常或中断触发时，控制流的转移位置是由<strong>内核</strong>而非<strong>触发异常的代码</strong>定义的。intel定义了256种异常，每一种异常有一个独一无二的<strong>异常号</strong>(直译是异常向量，但将一个数称为向量感觉会引起误解)，CPU以异常号为索引去中断描述符表中寻找对应的表项，从而进行对特定中断的处理。CPU可以从中断描述符表中获得：<ul>
<li>指向中断处理程序首地址的eip值</li>
<li>用于处理中断的特权级所对应的CS寄存器值(能处理中断的只有0级和1级，在JOS中均为0级)</li>
</ul>
</li>
<li><strong>任务状态段</strong>(TSS)：在跳转到中断处理程序之前，CPU需要保存它的状态以便在处理完之后将控制权交还。但是这个保存状态的位置必须是用户特权级所不能访问的，否则恶意的用户代码就能够去干预内核的行为。为此CPU为异常处理程序建立了一个<strong>独立于用户栈之外的栈</strong>，在这个栈中处理器压入SS，ESP，EFLAGS，CS，IP等关键信息，并重新设置SS和ESP以将这个栈作为新的程序栈。</li>
</ul>
<p>所有异常都使用<strong>0-31之间</strong>的32个异常号，而剩下的异常号通常对应于软件或硬件引发的中断。</p>
<p>现在我们来看一个例子：假设一个用户环境在执行一条代码的时候试图进行除零运算。</p>
<ul>
<li>处理器根据TSS所定义的SS0和ESP0来切换程序栈，在JOS中它们分别对应着<code>GD_KD</code>和<code>KSTACKTOP</code>。</li>
<li>处理器将需要保护的上下文信息压入新的栈(先后是SS，ESP，EFLAGS，CS，EIP，有些时候还会压入errorcode)。</li>
<li>处理器根据除法异常的异常号(0)找到<code>IDT[0]</code>，并根据其内容设定新的CS：EIP</li>
<li>异常处理程序接管控制流并进行异常处理</li>
</ul>
<p>值得注意的是，<strong>只有当从用户态进入内核态时CPU才会进行程序栈切换</strong>，如果在内核态下发生了中断或异常，CPU不会建立一个新栈，而是在已有的内核栈中先后压入<code>EFLAGS</code>，<code>CS</code>和<code>EIP</code>(有时压入errorcode)，然后进行控制流跳转，这为异常的嵌套提供了一种优雅的解决方式。</p>
<h5 id="Setting-Up-the-IDT"><a href="#Setting-Up-the-IDT" class="headerlink" title="Setting Up the IDT"></a>Setting Up the IDT</h5><p>在这个Lab中我们会建立能够处理异常和系统调用的IDT，<code>inc/trap.h</code>和<code>kern/trap.h</code>可以为我们的工作提供很多帮助，其中后者提供的定义只能由内核访问，前者的定义则可以由内核和用户共同访问。</p>
<p><strong>注意：</strong>有些异常是被intel保留的，这意味着你不需要处理它们。</p>
<p>在<code>trapentry.S</code>中定义了每个中断或异常的处理程序，<code>trap_init()</code>函数应当用它们的地址来初始化IDT。每个处理程序都应当在栈上建立一个<code>struct Trapframe</code>，并以这个结构的指针为参数调用<code>trap.c</code>中的<code>trap()</code>函数。</p>
<blockquote>
<p><strong>Exercise 4</strong></p>
<p>修改<code>trapentry.S</code>和<code>trap.c</code>来实现上面描述的功能。可能有帮助的宏定义有：</p>
<ul>
<li><code>trapentry.S</code>中的<code>TRAPHANDLER</code>和<code>TRAPHANDLER_NOEC</code></li>
<li><code>inc/trap.h</code>中的<code>T_*</code>宏定义们</li>
</ul>
<p>你需要用这些宏为<code>inc/trap.h</code>中定义的每一个trap增加一个入口点。由于每个异常处理函数都会<code>jmp</code>到<code>_alltraps</code>，你还需要完成这段代码的实现。你的<code>_alltraps</code>需要完成这些工作：</p>
<ul>
<li>向栈中压入数据，使栈的结构看起来像<code>struct Trapframe</code>(可以使用<code>pushal</code>指令)</li>
<li>将<code>GD_KD</code>加载到<code>%ds</code>和<code>%es</code></li>
<li><code>pushl %esp</code>作为<code>trap</code>函数的参数</li>
<li>调用<code>trap</code>函数</li>
</ul>
<p>你还需要修改<code>trap_init()</code>函数来初始化IDT，让它的每个表项指向<code>trapentry.S</code>中定义的一个入口点，在这个过程中<code>SETGATE</code>函数可能会有用。</p>
</blockquote>
<p>首先观察<code>trapentry.S</code>中对两个宏的定义和注释，理解它们的作用。<code>TRAPHANDLER</code>接受两个参数<code>name</code>和<code>num</code>，定义一个名为<code>name</code>的<strong>全局的</strong>处理<code>num</code>所对应异常的异常处理函数；而<code>TRAPHANDLER_NOEC</code>与其唯一的区别就是后者会在压入<strong>异常号</strong>之前多压入一个32位的<code>0</code>。这个操作的用意是什么呢？</p>
<p><code>_alltraps</code>定义了所有异常处理函数的公共部分，我们可以从要求中得知它的第一步就是要将一个<code>Trapframe</code>结构压入程序栈。这个结构的定义<a href="#trapframe">在之前遇到过</a>，现在我们来仔细研究一下它的结构：</p>
<p><img src="trapframe.png" alt=""></p>
<p>在之前的描述中我们已经知道在异常触发的时候处理器会帮我们切换好程序栈并压入一些必要信息，其中对于<code>errorcode</code>这一项，有些异常会压入，但有些异常不会压入。如果我们对所有异常一概使用<code>TRAPHANDLER</code>宏去处理，没有压入<code>errorcode</code>的异常的<code>Trapframe</code>就会向上“塌陷”，致使从trap number往下的所有数据错位。为了保持结构的完整性，我们需要对已经压入<code>errorcode</code>的异常使用<code>TRAPHANDLER</code>宏，而对没有压入的异常使用<code>TRAPHANDLER_NOEC</code>宏。</p>
<p>哪些异常压入过<code>errorcode</code>呢？通过查阅<a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/s09_10.htm" target="_blank" rel="noopener">80380 Programmer’s Manual</a>，可以发现一个<code>Error-Code Summary</code>，可以根据这个表给出的信息来选择应该用哪个宏。</p>
<p>在我们成功构造好<code>Trapframe</code>之后，下一步是修改<code>ds</code>和<code>es</code>的值，压入<code>esp</code>的值，最后<code>call trap</code>。只要熟悉AT&amp;T标准的语法和规范，这几步应该不算难。</p>
<p><code>trapentry.S</code>的代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Lab 3: Your code here for generating entry points for the different traps.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">TRAPHANDLER_NOEC(_divide, T_DIVIDE)</span><br><span class="line">TRAPHANDLER_NOEC(_debug, T_DEBUG)</span><br><span class="line">TRAPHANDLER_NOEC(_nmi, T_NMI)</span><br><span class="line">TRAPHANDLER_NOEC(_brkpt, T_BRKPT)</span><br><span class="line">TRAPHANDLER_NOEC(_oflow, T_OFLOW)</span><br><span class="line">TRAPHANDLER_NOEC(_bound, T_BOUND)</span><br><span class="line">TRAPHANDLER_NOEC(_illop, T_ILLOP)</span><br><span class="line">TRAPHANDLER_NOEC(_device, T_DEVICE)</span><br><span class="line">TRAPHANDLER_NOEC(_dblflt, T_DBLFLT)</span><br><span class="line">TRAPHANDLER(_tss, T_TSS)</span><br><span class="line">TRAPHANDLER(_segnp, T_SEGNP)</span><br><span class="line">TRAPHANDLER(_stack, T_STACK)</span><br><span class="line">TRAPHANDLER(_gpflt, T_GPFLT)</span><br><span class="line">TRAPHANDLER(_pgflt, T_PGFLT)</span><br><span class="line">TRAPHANDLER_NOEC(_fperr, T_FPERR)</span><br><span class="line">TRAPHANDLER_NOEC(_align, T_ALIGN)</span><br><span class="line">TRAPHANDLER_NOEC(_mchk, T_MCHK)</span><br><span class="line">TRAPHANDLER_NOEC(_simderr, T_SIMDERR)</span><br><span class="line">TRAPHANDLER_NOEC(_syscall, T_SYSCALL)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Lab 3: Your code here for _alltraps</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">_alltraps:</span><br><span class="line"></span><br><span class="line">	pushw $0x0</span><br><span class="line">	pushw %ds</span><br><span class="line">	pushw $0x0</span><br><span class="line">	pushw %es</span><br><span class="line">	pushal</span><br><span class="line">	movw $(GD_KD), %ax ; Note that ds and es can not be assigned straightly by immediates</span><br><span class="line">	movw %ax, %ds</span><br><span class="line">	movw %ax, %es</span><br><span class="line">	pushl %esp</span><br><span class="line">	call trap</span><br></pre></td></tr></table></figure>
<p>在<code>trap.c</code>中的部分就比较简单了，只需要阅读一下<code>SETGATE</code>这个宏的具体定义(位于<code>inc/mmu.h</code>)，明确各个参数的作用就可以做了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETGATE(gate, istrap, sel, off, dpl)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>gate</code>：这个异常在IDT中的异常描述符</li>
<li><code>istrap</code>：如果是异常则为1，中断则为0</li>
<li><code>sel</code>：异常处理函数的数据段，这里显然是内核代码段<code>GD_KT</code>(各个段选择符的定义在<code>inc/memlayout.h</code>中有)</li>
<li><code>off</code>：异常处理函数首地址的偏移，这里可以使用对应的函数指针</li>
<li><code>dpl</code>：异常处理函数的权限级，在JOS中一律为<code>0</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarations</span></span><br><span class="line"><span class="keyword">void</span> _divide();</span><br><span class="line"><span class="keyword">void</span> _debug();</span><br><span class="line"><span class="keyword">void</span> _nmi();</span><br><span class="line"><span class="keyword">void</span> _brkpt();</span><br><span class="line"><span class="keyword">void</span> _oflow();</span><br><span class="line"><span class="keyword">void</span> _bound();</span><br><span class="line"><span class="keyword">void</span> _illop();</span><br><span class="line"><span class="keyword">void</span> _device();</span><br><span class="line"><span class="keyword">void</span> _dblflt();</span><br><span class="line"><span class="keyword">void</span> _tss();</span><br><span class="line"><span class="keyword">void</span> _segnp(); </span><br><span class="line"><span class="keyword">void</span> _stack(); </span><br><span class="line"><span class="keyword">void</span> _gpflt(); </span><br><span class="line"><span class="keyword">void</span> _pgflt(); </span><br><span class="line"><span class="keyword">void</span> _fperr(); </span><br><span class="line"><span class="keyword">void</span> _align(); </span><br><span class="line"><span class="keyword">void</span> _mchk();</span><br><span class="line"><span class="keyword">void</span> _simderr();</span><br><span class="line"><span class="keyword">void</span> _syscall();</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Segdesc</span> <span class="title">gdt</span>[];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	SETGATE(idt[<span class="number">0</span>], <span class="number">1</span>, GD_KT, _divide, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">1</span>], <span class="number">1</span>, GD_KT, _debug, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">2</span>], <span class="number">1</span>, GD_KT, _nmi, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">3</span>], <span class="number">1</span>, GD_KT, _brkpt, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">4</span>], <span class="number">1</span>, GD_KT, _oflow, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">5</span>], <span class="number">1</span>, GD_KT, _bound, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">6</span>], <span class="number">1</span>, GD_KT, _illop, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">7</span>], <span class="number">1</span>, GD_KT, _device, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">8</span>], <span class="number">1</span>, GD_KT, _dblflt, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">10</span>], <span class="number">1</span>, GD_KT, _tss, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">11</span>], <span class="number">1</span>, GD_KT, _segnp, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">12</span>], <span class="number">1</span>, GD_KT, _stack, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">13</span>], <span class="number">1</span>, GD_KT, _gpflt, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">14</span>], <span class="number">1</span>, GD_KT, _pgflt, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">16</span>], <span class="number">1</span>, GD_KT, _fperr, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">17</span>], <span class="number">1</span>, GD_KT, _align, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">18</span>], <span class="number">1</span>, GD_KT, _mchk, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">19</span>], <span class="number">1</span>, GD_KT, _simderr, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">48</span>], <span class="number">1</span>, GD_KT, _syscall, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Per-CPU setup </span></span><br><span class="line">	trap_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Questions</strong></p>
<p>Q：为什么我们要对每一个中断或异常使用一个单独的函数，而不是用一个函数处理所有中断？</p>
<p>A：CPU对于不同异常在错误码是否压入方面的处理是不一样且不可见的。</p>
<p>Q：评测系统希望softint生成一个异常13(一般保护)，但<code>user/softint.c</code>中的代码触发的是异常14(缺页异常)，为什么错误的代码能够得到正确的结果？如果<code>user/softint.c</code>真的触发了缺页异常，又会发生什么？</p>
<p>A：查看<code>softint.c</code>，可以发现它直接用内联汇编执行了<code>int $14</code>，强行触发一个缺页错误。根据缺页中断的定义和处理方式，缺页中断一旦触发，操作系统就会去根据触发中断的指令判断它所访问的内存位置，但这个缺页中断并非由访存指令引起，因而操作系统无法处理这个异常并抛出一个一般保护异常。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2018/11/24/用自己建造的DockerImage创建k8s容器/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/24/用自己建造的DockerImage创建k8s容器/" itemprop="url">用自己建造的DockerImage创建k8s容器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-24T14:40:37+08:00">
                2018-11-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Academic or Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/Computation-Virtualization/" itemprop="url" rel="index">
                    <span itemprop="name">Computation Virtualization</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2018/11/24/用自己建造的DockerImage创建k8s容器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/11/24/用自己建造的DockerImage创建k8s容器/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="用自己建造的DockerImage创建k8s容器"><a href="#用自己建造的DockerImage创建k8s容器" class="headerlink" title="用自己建造的DockerImage创建k8s容器"></a>用自己建造的DockerImage创建k8s容器</h2><p>本篇文章记载了定制k8s容器以满足实验需要的具体方法，以供参考。</p>
<h3 id="构建需要的DockerFile"><a href="#构建需要的DockerFile" class="headerlink" title="构建需要的DockerFile"></a>构建需要的DockerFile</h3><p>kubernetes的Pod是以docker容器为基础的，因此每个pod在创建时都需要提供一个基础的容器镜像。因此，要定制一个符合我们需求的Pod，就需要先定制容器镜像。</p>
<p>Docker提供的定制镜像的方式是 <strong>Dockerfile</strong> 。关于Dockerfile的具体写法参见<a href="https://docs.docker.com/v17.09/engine/reference/builder/" target="_blank" rel="noopener">Reference</a></p>
<p>「示例」这是一个简单的CounterImage的DockerFile：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu                     # 每个DockerFile必须在开头用FROM语句指明其母镜像</span><br><span class="line">COPY counter.sh /etc/           # COPY指令可以将目标文件拷贝到镜像内的目标目录中</span><br><span class="line">RUN chmod +x /etc/counter.sh    # RUN指令让目标镜像执行指定指令</span><br></pre></td></tr></table></figure>
<h3 id="用DockerFile建造DockerImage"><a href="#用DockerFile建造DockerImage" class="headerlink" title="用DockerFile建造DockerImage"></a>用DockerFile建造DockerImage</h3><p>写好DockerFile之后，执行<code>docker build</code>指令来构建镜像。</p>
<ul>
<li>关于<code>docker build</code>的参数问题<ul>
<li><code>-f &lt;filepath&gt;</code> 指定DokcerFile的位置，默认在当前目录下寻找DockerFile</li>
<li><code>-t &lt;tag&gt;</code> 为创建的镜像指定tag，tag格式一般是<code>&lt;repo&gt;/&lt;imagename&gt;:&lt;version&gt;</code></li>
</ul>
</li>
</ul>
<p>执行完毕之后，构建好的DockerImage可以用<code>docker images</code>查看到。</p>
<h3 id="用kubectl创建pod"><a href="#用kubectl创建pod" class="headerlink" title="用kubectl创建pod"></a>用kubectl创建pod</h3><p>用kubectl构建pod需要用yaml或json文件指定pod的属性。</p>
<p>「示例」这是用于运行CounterImage实例的Pod配置文件</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> <span class="comment"># 指定k8s版本，一般是v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>      <span class="comment"># 指定要创建的对象的类型，这里是Pod</span></span><br><span class="line"><span class="attr">metadata:</span>      <span class="comment"># 元数据，指定Pod信息</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">testpod</span>   <span class="comment"># 指定Pod的名称</span></span><br><span class="line"><span class="attr">  annotations:</span>    <span class="comment"># 一些必要的注释，可以用于传递信息</span></span><br><span class="line"><span class="attr">spec:</span>          <span class="comment"># 一些其他信息</span></span><br><span class="line"><span class="attr">  containers:</span>     <span class="comment"># 指定Pod使用的基础镜像</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">testcontainer</span>               <span class="comment"># 指定将要创建的容器名称，这个不重要</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">drac/counter:v1</span>            <span class="comment"># 指定使用的镜像名称，这里使用刚刚创建的镜像名</span></span><br><span class="line"><span class="attr">      imagePullPolicy:</span> <span class="string">"IfNotPresent"</span>   </span><br><span class="line">      <span class="comment"># 由于刚刚的镜像并没有上传到远程仓库中，这里需要指定镜像拉取策略为优先使用本地镜像</span></span><br><span class="line"><span class="attr">      command:</span>                          <span class="comment"># 指定容器要运行的指令</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">"etc/counter.sh"</span></span><br><span class="line"><span class="attr">      ports:</span>                            <span class="comment"># 指定容器对外开放的端口</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">8086</span></span><br><span class="line"><span class="attr">          hostPort:</span> <span class="number">8086</span></span><br><span class="line"><span class="attr">  tolerations:</span>    </span><br><span class="line">  <span class="comment"># 这个属性与node的taints有关，由于master节点默认不能调度pods，这里要设置一些tolerations</span></span><br><span class="line"><span class="attr">    - key:</span> <span class="string">"node.kubernetes.io/not-ready"</span></span><br><span class="line"><span class="attr">      operator:</span> <span class="string">"Exists"</span></span><br><span class="line"><span class="attr">      effect:</span> <span class="string">"NoSchedule"</span></span><br><span class="line"><span class="attr">    - key:</span> <span class="string">"node-role.kubernetes.io/master"</span></span><br><span class="line"><span class="attr">      operator:</span> <span class="string">"Exists"</span></span><br><span class="line"><span class="attr">      effect:</span> <span class="string">"NoSchedule"</span></span><br></pre></td></tr></table></figure>
<p>写好配置文件之后，就可以用<code>kubectl create -f &lt;配置文件名&gt;</code>来创建pod了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2018/11/23/内联汇编/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/23/内联汇编/" itemprop="url">用GCC的内联汇编特性在C语言代码中嵌入汇编语句</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-23T10:32:51+08:00">
                2018-11-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Academic or Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/Operating-System/" itemprop="url" rel="index">
                    <span itemprop="name">Operating System</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2018/11/23/内联汇编/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/11/23/内联汇编/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="用GCC的内联汇编特性在C语言代码中嵌入汇编语句"><a href="#用GCC的内联汇编特性在C语言代码中嵌入汇编语句" class="headerlink" title="用GCC的内联汇编特性在C语言代码中嵌入汇编语句"></a>用GCC的内联汇编特性在C语言代码中嵌入汇编语句</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2018/11/04/在archlinux上单机搭建kubernetes/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/04/在archlinux上单机搭建kubernetes/" itemprop="url">在archlinux上单机搭建kubernetes</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-04T21:38:22+08:00">
                2018-11-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Academic or Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/Computation-Virtualization/" itemprop="url" rel="index">
                    <span itemprop="name">Computation Virtualization</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2018/11/04/在archlinux上单机搭建kubernetes/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/11/04/在archlinux上单机搭建kubernetes/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="kubernetes单机搭建流程"><a href="#kubernetes单机搭建流程" class="headerlink" title="kubernetes单机搭建流程"></a>kubernetes单机搭建流程</h2><p>由于工作需要，今天试着在archlinux主机上搭建了k8s。网上完全没有针对archlinux系统的配置教程，因此踩了很多坑，现将archlinux下的搭建流程记录如下。</p>
<h4 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h4><h5 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h5><ul>
<li><code>docker</code>：k8s中担任container职责的依赖，必须安装</li>
<li><code>sudo swapoff -a</code>：k8s的运行不支持内存交换，所以要关掉swap分区</li>
<li><code>ss</code>和<code>privoxy</code>：提供代理环境(k8s的镜像源多是google，而google相关网站大部分被GFW墙掉了)<ul>
<li><strong>注意：</strong>privoxy的监听端口应配置为8008(kubeadm的默认端口)</li>
</ul>
</li>
</ul>
<h5 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h5><p>手动编译kubernetes对内存要求过高，<del>OOM了3次</del>，只好另寻他途。</p>
<p>幸运的是，<code>kubeadm</code>,<code>kubectl</code>,<code>kubelet</code>,<code>kubernetes-cni</code>四项依赖的bin文件都有AUR包，可以用<code>yaourt</code>或者<code>yay</code>来下载。在下载时注意选择二进制文件(即<code>&lt;name&gt;-bin</code>)并提前打开privoxy代理映射。</p>
<p>(注意：这几个包的镜像源服务器都不支持axel，所以请将yay的下载工具换为wget)</p>
<h5 id="初始化集群"><a href="#初始化集群" class="headerlink" title="初始化集群"></a>初始化集群</h5><p>首先要设置docker的代理(这里的代理端口设置与privoxy的设置保持一致)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建conf文件</span></span><br><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line">sudo vim /etc/systemd/system/docker.service.d/http-proxy.conf</span><br><span class="line"><span class="comment"># 在新建的conf文件中加入如下内容</span></span><br><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">"HTTP_PROXY=http://127.0.0.1:8008/"</span></span><br><span class="line"><span class="comment"># 创建conf文件</span></span><br><span class="line">sudo vim /etc/systemd/system/docker.service.d/https-proxy.conf</span><br><span class="line"><span class="comment"># 在新建的conf文件中加入如下内容</span></span><br><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">"HTTPS_PROXY=http://127.0.0.1:8008/"</span></span><br><span class="line"><span class="comment"># 重启service</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>执行<code>sudo kubeadm init --pod-network-cidr=10.244.0.0/16</code>，根据显示的提示信息补全依赖，启动service后再次执行。</p>
<p>在init成功后根据显示的提示信息创建config文件。</p>
<p>执行<code>kubectl get pods --all-namespaces</code>，如果正常显示pods信息则说明正常。</p>
<p>接下来安装网络模块(这里使用的是<code>flannel</code>，当然其他模块也可以，只是要在init的时候指定相应的<code>pod-network-cidr</code>)，执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/bc79dd1505b0c8681ece4de4c0d86c5cd2643275/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>
<p>安装好flannel模块之后，如果<code>/etc/cni</code>文件夹没有被创建，coredns无法正常创建容器，可以在root身份下执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/cni/net.d/</span><br><span class="line">cat &lt;&lt;EOF&gt; /etc/cni/net.d/10-flannel.conf</span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"cbr0"</span>,<span class="string">"type"</span>:<span class="string">"flannel"</span>,<span class="string">"delegate"</span>: &#123;<span class="string">"isDefaultGateway"</span>: <span class="literal">true</span>&#125;&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>来进行配置。</p>
<p>这里如果出现问题可以参考<a href="https://blog.csdn.net/qq_34857250/article/details/82562514" target="_blank" rel="noopener">这篇博客</a></p>
<p>执行<code>watch kubectl get pods --all-namespaces</code>，等待一到两分钟，所有pods状态都为running则说明安装成功。(期间各种crash都是有可能的，耐心等待它自己重启即可)</p>
<h5 id="部署服务"><a href="#部署服务" class="headerlink" title="部署服务"></a>部署服务</h5><p>搭建大成功，接下来只要部署具体的service就可以了。</p>
<h4 id="常见问题及解决方案"><a href="#常见问题及解决方案" class="headerlink" title="常见问题及解决方案"></a>常见问题及解决方案</h4><ul>
<li><p>非root用户使用kubectl时出现错误</p>
<ul>
<li><p>错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unable to connect to the server: net/http: TLS handshake timeout</span><br></pre></td></tr></table></figure>
</li>
<li><p>状态：暂未解决</p>
</li>
<li>折中方案：将config文件放在root目录的<code>.kube</code>目录下，用sudo运行kubectl</li>
</ul>
</li>
<li><p>flannel网络模块安装之后coredns无法正常创建容器</p>
<ul>
<li><p>错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed create pod sandbox: rpc error: code = Unknown desc = [failed to set up sandbox container &quot;dd087d2655e98a25040f7b041e23dffa59aa52206b921e481ad20781d1de4320&quot; network for pod &quot;coredns-86c58d9df4-gtrt4&quot;: NetworkPlugin cni failed to set up pod &quot;coredns-86c58d9df4-gtrt4_kube-system&quot; network: failed to find plugin &quot;portmap&quot; in path [/opt/cni/bin], failed to clean up sandbox container &quot;dd087d2655e98a25040f7b041e23dffa59aa52206b921e481ad20781d1de4320&quot; network for pod &quot;coredns-86c58d9df4-gtrt4&quot;: NetworkPlugin cni failed to teardown pod &quot;coredns-86c58d9df4-gtrt4_kube-system&quot; network: failed to find plugin &quot;portmap&quot; in path [/opt/cni/bin]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">su</span><br><span class="line">mkdir -p /etc/cni/net.d/</span><br><span class="line">cat &lt;&lt;EOF&gt; /etc/cni/net.d/10-flannel.conf</span><br><span class="line">&#123;&quot;name&quot;:&quot;cbr0&quot;,&quot;type&quot;:&quot;flannel&quot;,&quot;delegate&quot;: &#123;&quot;isDefaultGateway&quot;: true&#125;&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Pod无法正常创建Container，出现netplugin error</p>
<ul>
<li><p>错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed create pod sandbox: rpc error: code = Unknown desc = failed to set up sandbox container &quot;81e89630eeb39a5c7b24e330082af265d3cd4480c83664316df3bd92fcfaaa91&quot; network for pod &quot;testpod&quot;: NetworkPlugin cni failed to set up pod &quot;testpod_default&quot; network: &quot;cni0&quot; already has an IP address different from 10.244.0.1/24</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决方案：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubeadm reset 过程</span></span><br><span class="line">systemctl stop kubelet</span><br><span class="line">systemctl stop docker</span><br><span class="line">rm -rf /var/lib/cni/</span><br><span class="line">rm -rf /var/lib/kubelet/*</span><br><span class="line">rm -rf /etc/cni/</span><br><span class="line">ifconfig cni0 down</span><br><span class="line">ifconfig flannel.1 down</span><br><span class="line">ifconfig docker0 down</span><br><span class="line">ip link delete cni0</span><br><span class="line">ip link delete flannel.1</span><br><span class="line">systemctl start kubelet</span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="comment"># kubeadm init 过程</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2018/10/01/LilyPond/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/10/01/LilyPond/" itemprop="url">LilyPond制谱教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-01T12:53:29+08:00">
                2018-10-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Academic or Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/Tools/" itemprop="url" rel="index">
                    <span itemprop="name">Tools</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2018/10/01/LilyPond/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/10/01/LilyPond/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="代码写谱-LilyPond教程"><a href="#代码写谱-LilyPond教程" class="headerlink" title="代码写谱 - LilyPond教程"></a>代码写谱 - LilyPond教程</h1><p>说到五线谱制作，大多数人最先想到的一定会是界面简洁，功能强大的<strong>Overture</strong>。然而，作为一个使用键盘的工作效率大于鼠标的人，我更希望使用一款以写码的方式制谱的软件，而<strong>lilyPond</strong>完美地满足了我的要求。它的功能之强大比起<strong>Overture</strong>更胜一筹，制谱效率也让人十分满意。</p>
<p>为了方便自己日后查阅并向更多人推广这个工具，特此将我的学习过程整理成教程留存。教程大部分的内容都是来自<a href="http://lilypond.org/doc/v2.18/Documentation/" target="_blank" rel="noopener">lilyPond的官方文档</a>，如果更愿意阅读英文可以直接查阅官方的文档。</p>
<h2 id="环境配置与使用方法"><a href="#环境配置与使用方法" class="headerlink" title="环境配置与使用方法"></a>环境配置与使用方法</h2><h3 id="安装lilyPond编译环境"><a href="#安装lilyPond编译环境" class="headerlink" title="安装lilyPond编译环境"></a>安装lilyPond编译环境</h3><p>lilyPond隶属于<strong>GNU项目</strong>，所以不出意外的话使用所有Linux发行版的官方包管理程序都可以下载到。比如，在Archlinux下，只需要执行<code>pacman -S lilypond</code>。Windows版本则可以到lilyPond的官网下载。</p>
<h3 id="渲染出乐谱"><a href="#渲染出乐谱" class="headerlink" title="渲染出乐谱"></a>渲染出乐谱</h3><p>lilyPond项目中有数个不同功能的二进制文件，其中<code>lilypond</code>专门用来将<code>.ly</code>文件渲染为乐谱文件。在作谱的时候，我们首先按照lilypond的语法来编辑<code>.ly</code>文件，再使用<code>lilypond &lt;file&gt;</code>来渲染乐谱。</p>
<p>lilypond默认渲染出的乐谱文件格式为<code>pdf</code>，可以通过调整参数来自定义输出格式。</p>
<h3 id="配置MIDI播放环境"><a href="#配置MIDI播放环境" class="headerlink" title="配置MIDI播放环境"></a>配置MIDI播放环境</h3><p>Linux下的midi播放器可以使用<code>timidity++</code>(Archlinux的aur仓库中有)，不过由于一般linux系统下不会自带音源，我们需要自己下载并配置midi音源才能播放lilypond输出的midi文件。</p>
<p><em>AUR仓库</em>中有几款不错的音源，比如<code>Freepats</code>或<code>soundfont-fluid</code>，我个人倾向于后者。执行<code>yay soundfont-fluid</code>可以直接将这个音源安装到本机，安装完成之后修改<code>/etc/timidity++/timidity.cfg</code>，取消其中的<code>soundfont</code>一行的注释，将其内容改为<code>soundfont /usr/share/soundfonts/FluidR3_GM.sf2</code>，保存即可完成对音源的配置。</p>
<h2 id="Part-1-基本记号"><a href="#Part-1-基本记号" class="headerlink" title="Part 1 基本记号"></a>Part 1 基本记号</h2><h3 id="乐句"><a href="#乐句" class="headerlink" title="乐句"></a>乐句</h3><p>在lilyPond语法中，每一段乐谱都被称为一个<code>musicexpr</code>，也就是”音乐表达式”。每个<code>musicexpr</code>都是由<strong>一对大括号</strong>括起来的一组音符声明，在大括号前可以增加一些对这个<code>musicexpr</code>的描述。</p>
<p>在之后的部分，为了方便书写，我将<code>musicexpr</code>统一翻译为<strong>乐句</strong>。</p>
<h4 id="乐句的嵌套"><a href="#乐句的嵌套" class="headerlink" title="乐句的嵌套"></a>乐句的嵌套</h4><p>每个乐句都可以对其内容进行一定的设定，如果要将几种设定同时施加到一个乐句上就需要进行乐句的嵌套了。乐句的嵌套本质上可以看成是对数个乐句施加了一层新的属性。</p>
<h4 id="乐句的赋值"><a href="#乐句的赋值" class="headerlink" title="乐句的赋值"></a>乐句的赋值</h4><p>我们可以在lilypond中声明一些变量，并用<code>\变量名</code>的方式去引用它们。变量的声明格式为<code>变量名 = 乐句</code>。在我们引用一个变量时，它所指向的乐句将会在引用位置展开。</p>
<h3 id="音高"><a href="#音高" class="headerlink" title="音高"></a>音高</h3><h4 id="音高声明"><a href="#音高声明" class="headerlink" title="音高声明"></a>音高声明</h4><p>lilypond语法中的音高以<strong>小写英文字母</strong>为基准音高，由后缀来决定音高的调整。常用的后缀有：</p>
<ul>
<li>每多一个<code>,</code>表示在基准音的基础上低一个八度，<code>&#39;</code>则表示高一个八度。</li>
<li><code>is</code>后缀表示<strong>升号</strong>(sharp)，<code>es</code>后缀表示<strong>降号</strong>(flat)。对于<strong>重升</strong>和<strong>重降</strong>，只需要重复这两个后缀即可。</li>
<li>表示节奏的后缀，几分音符就是数字几。</li>
</ul>
<p>例如，<code>cis&#39;&#39;4</code>表示一个四分音符时值的高音C-sharp。</p>
<h4 id="在乐句中使用音高声明"><a href="#在乐句中使用音高声明" class="headerlink" title="在乐句中使用音高声明"></a>在乐句中使用音高声明</h4><p>在乐句中，每一个音高声明都唯一对应着一个音符。每个乐句都是由一连串音高声明和一些描述性声明所组成的，lilypond会自动按照这个乐句的<strong>拍号</strong>(默认为4/4拍)划分小节。我们建议将每一个小节写为乐句中的一行，这样更方便我们日后读谱。</p>
<h4 id="和弦"><a href="#和弦" class="headerlink" title="和弦"></a>和弦</h4><p>如果要声明一个和声或和弦，只需要用<strong>尖括号</strong>括起和弦中的各个音符即可。<code>q</code>声明代表<strong>复制</strong>前一个和弦声明。</p>
<h4 id="绝对音高和相对音高"><a href="#绝对音高和相对音高" class="headerlink" title="绝对音高和相对音高"></a>绝对音高和相对音高</h4><p>控制<strong>绝对音高</strong>和<strong>相对音高</strong>的描述分别是<code>\absolute</code>和<code>\relative</code>。<code>\absolute &lt;musicexpr&gt;</code>所声明的乐段中所有音高标记都以<strong>低音C</strong>为基准音，这也是没有音高声明的乐段所默认采用的校准方式。<code>\relative &lt;basepitch&gt; &lt;musicexpr&gt;</code>所声明的乐段中音高的计算方式则比较复杂：</p>
<ul>
<li>如果一个音符后没有<em>八度改变后缀</em>，它所在的八度会被选为一个能<strong>使它与上一个音符的音程小于五度</strong>的八度。</li>
<li><em>八度改变后缀</em>会将音符的音高在第一条规则计算出的音高基础上提高或降低一个八度。</li>
<li>第一个音符的音高按照第一条规则与<code>&lt;basepitch&gt;</code>音高相关。</li>
<li>涉及到和弦后的计算方式更加复杂，这边不予详述，可以参考<a href="http://lilypond.org/doc/v2.18/Documentation/notation/writing-pitches" target="_blank" rel="noopener">官方文档中的描述</a>。</li>
</ul>
<p>虽然相对音高的计算比较复杂，但如果熟练之后应用相对音高会非常便利。我们在之后</p>
<h4 id="高音和低音谱号"><a href="#高音和低音谱号" class="headerlink" title="高音和低音谱号"></a>高音和低音谱号</h4><p>描述性语句<code>\clef</code>可以用于指定和切换谱号。在一个小节的声明之前插入一句<code>\clef</code>声明可以指定从这个小节开始往后的小节所在的谱号。<code>\clef bass</code>会将谱号设定为低音谱，而<code>\clef treble</code>则会设置为高音谱。没有<code>\clef</code>声明的小节默认采用高音谱号。</p>
<p>另外两种谱号，中音和次中音谱号分别对应于<code>\clef alto</code>和<code>\clef tenor</code>。更多的谱号可以参考官方文档的1.1.3节。</p>
<h4 id="升号与降号"><a href="#升号与降号" class="headerlink" title="升号与降号"></a>升号与降号</h4><p>在之前已经讲过升降号的声明，但没有涉及到还原号，这是因为<strong>还原号是不需要特殊声明的</strong>。在lilypond中，没有进行升降号声明的音符都会被处理为标准音高，也就是说<code>cis c</code>会被渲染为一个升C后接一个还原C，而不是两个升C，这和五线谱中升降号保持的法则是不同的。不过，渲染出的乐谱仍按五线谱标准显示。</p>
<p>如果想要在不需要还原号的位置强行显示还原号，可以在对应的音符后加<code>!</code>符号。如果要为变音记号加上括号，可以在对应的音符后加<code>?</code>符号。</p>
<h4 id="设置调号"><a href="#设置调号" class="headerlink" title="设置调号"></a>设置调号</h4><p>在一个小节前使用<code>\key</code>声明可以决定从这个小节开始往后部分的调号。调号由一个音高声明和一个大小调声明组成。大小调声明可以是<code>\major</code>(大调)或者<code>\minor</code>(小调)。</p>
<p>一个调号声明的例子：<code>\key bes \major</code>声明一个降B大调调号。</p>
<p>需要注意的是调号声明仅会打印出一个调号，并不会有其他的作用。</p>
<h4 id="转调声明"><a href="#转调声明" class="headerlink" title="转调声明"></a>转调声明</h4><p>有些时候我们需要将一段乐谱进行转调，如果一个个音符去修改未免工作量过大。乐句声明<code>\transpose</code>为我们提供了一种便利的转调方式。嵌套在带有<code>\transpose</code>声明的乐句内的所有乐句都会按照这个声明规定的转调方式进行转调。</p>
<p><code>\transpose</code>声明的格式为<code>\transpose &lt;basepitch&gt; &lt;nextpitch&gt;</code>，渲染器会计算<code>&lt;basepitch&gt;</code>和<code>&lt;nextpitch&gt;</code>之间的音程，并将整个乐句中嵌套的所有乐句中的所有音符向上移一个等长的音程，同时改变这些乐句中的调号(如果声明过)。</p>
<h4 id="高八度和低八度记号"><a href="#高八度和低八度记号" class="headerlink" title="高八度和低八度记号"></a>高八度和低八度记号</h4><p><code>\ottava &lt;scale&gt;</code>声明可以用于添加高八度和低八度记号。<code>&lt;scale&gt;</code>的取值为<code>#x</code>，其中<code>x</code>为升高或降低的八度个数。如果x为正整数则表示升高，否则表示降低，为0表示还原到原来的高度。</p>
<p>需要注意的是，<strong>这个记号并不会改变音符的实际音高</strong>，因此如果在应用记号后不手动调整音高，音符就会在谱面上做相应的调整以适应原来的音高。</p>
<p>下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\relative c&apos; &#123;</span><br><span class="line">  \key d \minor</span><br><span class="line">  d4 a&apos; g2</span><br><span class="line">  \ottava #1</span><br><span class="line">  f&apos;4 g a c8 a</span><br><span class="line">  \ottava #0</span><br><span class="line">  g,4 f e2 ~</span><br><span class="line">  e4 f2 ~ f4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>渲染出的谱面是这样的：</p>
<p><img src="/home/drac_zhang/Workplace/PersonalWebsite/Blog/source/_posts/LilyPond/ottava.png" alt="谱面"></p>
<h3 id="节奏"><a href="#节奏" class="headerlink" title="节奏"></a>节奏</h3><h4 id="音符时值"><a href="#音符时值" class="headerlink" title="音符时值"></a>音符时值</h4><p>正如之前说过的，在音符声明后加数字可以声明一个对应时值的音符，如<code>b4</code>声明四分音符，<code>g32</code>声明三十二分音符等等。在数字后面加<code>.</code>可以在音符后加<strong>浮点</strong>，其时值增加规则和乐理知识中相同。</p>
<p>如果未加声明，后面的音符会自动继承前面音符的时值。如，<code>c4 d e f</code>会渲染出四个连续的四分音符。</p>
<p><code>\autoBeamOn</code>和<code>\autoBeamOff</code>可以打开或关闭切分音之间的自动连线。自动连线机制默认是打开的。</p>
<h4 id="三连音"><a href="#三连音" class="headerlink" title="三连音"></a>三连音</h4><p>声明三连音或多连音均可以使用<code>\tuplet</code>声明。其格式为<code>\tuplet &lt;fraction&gt; { &lt;notes&gt; }</code>，其中<code>&lt;fraction&gt;</code>是一个分式，分母为整个tuplet的总时值，分子为等分的份数。例如，<code>5/4</code>声明一个平分四分音符的五连音。</p>
<p>需要注意的是，<code>&lt;note&gt;</code>中的音符一定要标定对应的时值。如果要声明一个平分四分音符的三连音，就必须将<code>&lt;note&gt;</code>中的音符声明为8分音符，否则渲染会出现偏差。</p>
<h4 id="拍号的声明"><a href="#拍号的声明" class="headerlink" title="拍号的声明"></a>拍号的声明</h4><p>一个乐句的默认拍号是<code>4/4拍</code>，但我们可以使用<code>\time</code>声明显式地修改拍号。<code>\time N/M</code>可以将乐句的拍号修改为N-M拍(有基本乐理知识的人应该都明白N-M拍是什么意思，这边不予详述)。</p>
<p><code>\defaultTimeSignature</code>和<code>\numericTimeSignature</code>可以用于两种拍号表示方式的切换。</p>
<p>如果我们声明了一个比较奇怪的节奏型(比如《哈德曼的妖怪少女》的<code>7/8</code>拍)，lilypond默认的符尾连接方式会失效，需要我们手动设置，否则所有时值小于等于八分音符的音符符尾全都不会相连，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\relative c&apos; &#123;</span><br><span class="line">  \time 7/8</span><br><span class="line">  a&apos;8 f d \tuplet 3/2 &#123;c&apos;4 bes c&#125;</span><br><span class="line">  a8 f d gis e cis gis&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/home/drac_zhang/Workplace/PersonalWebsite/Blog/source/_posts/LilyPond/time.png" alt="koishi"></p>
<p>手动设置的方式是在<code>\time</code>后面加一个<code>#&#39;(&lt;pattern&gt;)</code>记号。<code>&lt;pattern&gt;</code>是一连串数字，这些数字将每个小节中的音符依次分为大小等于每个数字的组，同组间的音符会有符尾连接，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\relative c&apos; &#123;</span><br><span class="line">  \time #&apos;(3 4) 7/8</span><br><span class="line">  a&apos;8 f d \tuplet 3/2 &#123;c&apos;4 bes c&#125;</span><br><span class="line">  a8 f d gis e cis gis&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/home/drac_zhang/Workplace/PersonalWebsite/Blog/source/_posts/LilyPond/timeplus.png" alt="koishi_plus"></p>
<h4 id="隐式地改变音符的时值"><a href="#隐式地改变音符的时值" class="headerlink" title="隐式地改变音符的时值"></a>隐式地改变音符的时值</h4><p>有些时候我们希望在改变音符时值的同时不影响乐谱的外观，这时我们可以在一个音符声明的后面加一个<code>*x/y</code>后缀，其中<code>x/y</code>是一个分数，代表改变后的时值(<code>/y</code>部分可以缺省)。</p>
<h4 id="连音线"><a href="#连音线" class="headerlink" title="连音线"></a>连音线</h4><p><strong>连音线只能连接两个相同音高的音符</strong>。在两个这样的音符之间加一个<code>~</code>即可为它们加上连音线。</p>
<p>如果需要给被小节线分隔的两个音打上连音线，我们可以利用lilypond的<strong>自动切割功能</strong>，即在第一个音符处声明一个时值等于两个音符时值之和的音符，lilypond会自动将其切割为两个被连音线连接的跨小节音符。</p>
<p>当两个<strong>和弦声明</strong>被连音线连接时，和弦中所有等音高的音符会被连音线连接，而不同音高的不会。</p>
<p>更多关于连音线的线条形式或曲线属性的设置可以参考<a href="http://lilypond.org/doc/v2.18/Documentation/notation/writing-rhythms#ties" target="_blank" rel="noopener">官方文档中的说明</a>。</p>
<h4 id="休止符"><a href="#休止符" class="headerlink" title="休止符"></a>休止符</h4><p>一般的休止符由字母<code>r</code>和表示时值的后缀组成。如果用<code>s</code>取代<code>r</code>，则可以声明一个<strong>不可见的</strong>休止符。</p>
<h4 id="速度标志"><a href="#速度标志" class="headerlink" title="速度标志"></a>速度标志</h4><p>一般的乐谱开始位置都会有一个标志来表示乐谱的演奏速度，这种标志可以用于设定节拍器，因而称为<code>Metronome mark</code>。<code>\tempo</code>声明可以用于声明这种标志。</p>
<p><code>\tempo</code>最常见的用法是后跟<code>&lt;duration&gt; = &lt;speed&gt;</code>，其中<code>&lt;duration&gt;</code>是一个表示速度标记中左边那个音符时值的数字，<code>&lt;speed&gt;</code>是速度标记中右边那个数字。另一种没有那么精确的用法是<code>\tempo &quot;&lt;text&gt;&quot;</code>，其中<code>&lt;text&gt;</code>可以是各种用于描述速度的标记，如<code>Allegreto</code>(快板)。<strong>这两种用法可以混用</strong>，混用时速度标记会被小括号括起来。</p>
<h4 id="弱起小节"><a href="#弱起小节" class="headerlink" title="弱起小节"></a>弱起小节</h4><p>在一些乐曲中第一个小节是不完整的：我们使用弱拍作为乐曲的开始而非惯用的强拍。在这种情况下，需要使用<code>\partial &lt;duration&gt;</code>来声明这个不完整的小节，其中<code>&lt;duration&gt;</code>是小节更改后的长度。</p>
<h4 id="特殊的小节线"><a href="#特殊的小节线" class="headerlink" title="特殊的小节线"></a>特殊的小节线</h4><p>我们可以通过<code>\bar &quot;&lt;symbols&gt;&quot;</code>声明来<strong>显式地</strong>声明一个小节线。这个小节线不受自动小节划分的限制，可以安放在任何位置。我们可以通过<code>&lt;symbols&gt;</code>来显式定义小节线的样式，<code>&lt;symbol&gt;</code>由几种字符组成：</p>
<ul>
<li><code>:</code> 代表小节线中的冒号，一般与重复小节线有关</li>
<li><code>.</code> 代表粗小节线，与重复小节线和终止线有关</li>
<li><code>|</code> 代表普通小节线</li>
</ul>
<p>大部分小节线都可以用这三种符号的排列来表示。</p>
<h4 id="装饰音"><a href="#装饰音" class="headerlink" title="装饰音"></a>装饰音</h4><p>在一个音符声明前加上<code>\grace</code>标记可以让这个音符成为装饰音。如果要声明多个连续的装饰音，可以用<strong>大括号</strong>将这些音符括起，在大括号前加<code>\grace</code>。</p>
<h3 id="增强表现力的符号"><a href="#增强表现力的符号" class="headerlink" title="增强表现力的符号"></a>增强表现力的符号</h3><p>增强表现力的符号一般绑定在某个音符上，其声明形式为<code>&lt;note&gt;\&lt;symbol&gt;</code>，其中<code>&lt;note&gt;</code>是一个音符声明，<code>&lt;symbol&gt;</code>是特定的标号。</p>
<h4 id="表示处理方式"><a href="#表示处理方式" class="headerlink" title="表示处理方式"></a>表示处理方式</h4><p>常用的加在单个音符上的标号有<code>\staccato</code>(跳音符)，<code>\fermata</code>(延音符)，<code>\accent</code>(重音符)，<code>\trill</code>(颤音符)等。完整的符号表可以参照<a href="http://lilypond.org/doc/v2.18/Documentation/notation/list-of-articulations" target="_blank" rel="noopener">官方文档</a>。</p>
<p>除了标准声明形式之外，还有一些常用的简写来减轻我们的工作量，比如<code>-&gt;</code>与<code>\accent</code>等效，<code>-.</code>与<code>\staccato</code>等效。</p>
<h4 id="表示音符强弱"><a href="#表示音符强弱" class="headerlink" title="表示音符强弱"></a>表示音符强弱</h4><p>与音符绑定的强弱符也可以用这个形式来声明，其对应的symbol与强弱符在谱面上的标号一致，如<code>\pp</code>或<code>\sf</code>。渐强渐弱符需要一个起点音符和一个终点音符：起点音符与<code>\&gt;</code>或<code>\&lt;</code>绑定，终点音符与<code>\!</code>绑定。另一种形式的渐强渐弱符只需要在起点绑定一个<code>\cresc</code>或<code>\dim</code>标号即可。</p>
<h4 id="连唱线"><a href="#连唱线" class="headerlink" title="连唱线"></a>连唱线</h4><p>连唱线开始位置的音符需要加一个<code>(</code>后缀，而结束位置的音符需要加一个<code>)</code>后缀。连唱线可以嵌套。</p>
<h4 id="琶音"><a href="#琶音" class="headerlink" title="琶音"></a>琶音</h4><p>琶音的声明用于和弦。在一个和弦后绑定<code>\arpeggio</code>记号可以在这个和弦上加琶音线。</p>
<h4 id="颤音"><a href="#颤音" class="headerlink" title="颤音"></a>颤音</h4><p>之前提到过的<code>\trill</code>记号用于声明在单个音符上方的颤音符<code>tr</code>，另一种有起止位置的颤音符可以以开始音符绑定<code>\startTrillSpan</code>，结束音符绑定<code>stopTrillSpan</code>的方式声明。</p>
<h3 id="复调"><a href="#复调" class="headerlink" title="复调"></a>复调</h3><p>用<code>&lt;&lt; &gt;&gt;</code>括起来的两个或以上的乐句可以并行演奏，这种记谱方式称为<code>polyphony</code>(复调)。</p>
<p>如果不加显式的标记，这些乐句会被<strong>默认地放入同一个声部中</strong>，这通常会导致音符在乐谱中的碰撞，从而使某些音符渲染失败或不正常渲染。通常在进行复调作谱时，会用这几种方式将几个乐句安排到不同的声部中：</p>
<ul>
<li>在每个乐句的内部开始位置加一个<code>\voiceOne</code>～<code>\voiceFour</code>的声明以指明这个乐句属于哪个声部，同时在每个乐句的前面增加<code>\new Voice</code>声明，为它们分别创造新的声部。</li>
<li>在乐句之间加入<code>\\</code>记号，这样lilypond会自动为这些乐句分配不同的声部。</li>
</ul>
<h3 id="乐器记号"><a href="#乐器记号" class="headerlink" title="乐器记号"></a>乐器记号</h3><p><code>\new</code>或<code>\context</code>声明被用于声明一组乐谱。</p>
<p>最基本的乐器是<code>Staff</code>，<code>\new Staff</code>可以声明一组最简单的钢琴五线谱。除了普通的<code>Staff</code>之外，还有<code>DrumStaff</code>，<code>RhythmicStaff</code>等乐谱格式可以使用。</p>
<h4 id="乐谱组"><a href="#乐谱组" class="headerlink" title="乐谱组"></a>乐谱组</h4><p>绝大部分器乐乐谱都需要乐谱的分组，比如钢琴谱的左右手，交响乐谱的各种乐器。用之前提到过的复调记号就可以实现乐谱的分组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;</span><br><span class="line">\new Staff &#123;...&#125;</span><br><span class="line">\new Staff &#123;...&#125;</span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>效果如图：</p>
<p><img src="/home/drac_zhang/Workplace/PersonalWebsite/Blog/source/_posts/LilyPond/Staff.png" alt=""></p>
<p>可以在复调记号之前使用乐谱组声明来改变乐谱的外观：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\new StaffGroup &lt;&lt;</span><br><span class="line">  \new Staff &#123;...&#125;</span><br><span class="line">  \new Staff &#123;...&#125;</span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>效果如图：</p>
<p><img src="/home/drac_zhang/Workplace/PersonalWebsite/Blog/source/_posts/LilyPond/StaffGroup.png" alt=""></p>
<p>也可以使用钢琴谱声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\new GrandStaff &lt;&lt;</span><br><span class="line">  \new Staff &#123;...&#125;</span><br><span class="line">  \new Staff &#123;...&#125;</span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>效果如图：</p>
<p><img src="/home/drac_zhang/Workplace/PersonalWebsite/Blog/source/_posts/LilyPond/GrandStaff.png" alt=""></p>
<h4 id="乐器属性"><a href="#乐器属性" class="headerlink" title="乐器属性"></a>乐器属性</h4><p>可以在<code>\new Staff</code>声明之后紧跟一个<code>\with {}</code>声明块来描述这个乐器的属性。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\new Staff\with &#123;</span><br><span class="line">  instrumentName = #&quot;Piano &quot;</span><br><span class="line">&#125; &#123; c d e f &#125;</span><br></pre></td></tr></table></figure>
<p>可以在乐谱前显示Piano字样。</p>
<h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><h4 id="在音符上下方添加文本"><a href="#在音符上下方添加文本" class="headerlink" title="在音符上下方添加文本"></a>在音符上下方添加文本</h4><p>在一个音符声明上方添加文本可以使用<code>^&lt;text&gt;</code>，如果是下方则为<code>_&lt;text&gt;</code>，这和LateX的语法是相同的。<code>&lt;text&gt;</code>可以是简单的文本常量<code>&quot;aslkdj&quot;</code>，也可以是一些复杂的表达式，比如<code>\markup</code>语句块。</p>
<p>也可以用<code>\mark &lt;text&gt;</code>声明在音符之间的位置上方添加文本。</p>
<h4 id="Markup语句块"><a href="#Markup语句块" class="headerlink" title="Markup语句块"></a>Markup语句块</h4><p><code>\markup {...}</code> 可以声明一个Markup语句块。你可以在Markup语句块中用各种LaTeX语法来格式化文本。常用的标记大致有：</p>
<ul>
<li>改变字体格式<ul>
<li><code>\bold</code></li>
<li><code>\italic</code></li>
<li><code>\underline</code></li>
<li><code>\super</code> (上标)</li>
<li><code>\sub</code>  (下标)</li>
<li><code>\smallCaps</code></li>
</ul>
</li>
<li>改变字号<ul>
<li><code>\huge</code></li>
<li><code>\teeny</code></li>
<li><code>\normalsize</code></li>
<li><code>\fontsize #&lt;num&gt;</code></li>
</ul>
</li>
<li>排版<ul>
<li><code>\column {}</code>：其中的元素只能是<code>\line {}</code><ul>
<li><code>\center-column</code></li>
</ul>
</li>
<li><code>\line {}</code>：其中放置一行文本</li>
</ul>
</li>
<li>字体<ul>
<li><code>\sans</code></li>
<li><code>\typewriter</code></li>
<li><code>\roman</code></li>
</ul>
</li>
</ul>
<p>更多标记可以参考<a href="http://lilypond.org/doc/v2.18/Documentation/notation/formatting-text" target="_blank" rel="noopener">官方文档</a>。</p>
<h2 id="Part-2-特殊记号"><a href="#Part-2-特殊记号" class="headerlink" title="Part 2 特殊记号"></a>Part 2 特殊记号</h2><h3 id="踏板"><a href="#踏板" class="headerlink" title="踏板"></a>踏板</h3><p><code>\sustainOn</code>和<code>\sustainOff</code>声明可以用来控制钢琴的踏板。</p>
<h2 id="Part-3-IO"><a href="#Part-3-IO" class="headerlink" title="Part 3 IO"></a>Part 3 IO</h2><h3 id="乐谱的输出"><a href="#乐谱的输出" class="headerlink" title="乐谱的输出"></a>乐谱的输出</h3><p>每段乐谱在输出时必须被包装在一个<code>\score {}</code>块中。除了乐谱部分，我们还可能需要一个<code>\header {}</code>块，在这个块中我们可以指定<code>title = &quot;...&quot;</code>，<code>composer = &quot;...&quot;</code>以及<code>subtitle = &quot;...&quot;</code>等。</p>
<p>一个<code>\bookpart {}</code>块代表乐谱本中的一部分，每个这种块中必须包含一个<code>\header</code>和一个<code>\score</code>块。</p>
<h2 id="Appendix-乐理名词翻译"><a href="#Appendix-乐理名词翻译" class="headerlink" title="Appendix 乐理名词翻译"></a>Appendix 乐理名词翻译</h2><h3 id="Pitch-音高"><a href="#Pitch-音高" class="headerlink" title="Pitch 音高"></a>Pitch 音高</h3><ul>
<li>octave 八度</li>
<li>bass 低音</li>
<li>treble 高音</li>
<li>chord 和弦</li>
<li>accidental 变音记号<ul>
<li>sharp 升</li>
<li>flat 降</li>
<li>natural 还原</li>
</ul>
</li>
<li>interval 音程<ul>
<li>major 大音程</li>
<li>minor 小音程</li>
<li>augmented 增音程</li>
<li>diminished 减音程</li>
</ul>
</li>
</ul>
<h3 id="Rhythm-节奏"><a href="#Rhythm-节奏" class="headerlink" title="Rhythm 节奏"></a>Rhythm 节奏</h3><ul>
<li>duration 时值</li>
<li>tuplet <code>x</code>连音</li>
<li>tie 连音线</li>
<li>measure 小节</li>
<li>bar 小节线</li>
<li>metronome 节拍器</li>
<li>rest 休止符</li>
<li>grace 装饰音</li>
</ul>
<h3 id="Expression-表现"><a href="#Expression-表现" class="headerlink" title="Expression 表现"></a>Expression 表现</h3><ul>
<li>dynamic 强弱符</li>
<li>slur 连唱线</li>
<li>Arpeggio 琶音</li>
<li>trill 颤音</li>
<li>polyphony 复调</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2018/07/11/ArchLinux下的软件安装/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/07/11/ArchLinux下的软件安装/" itemprop="url">ArchLinux下的软件安装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-11T09:39:48+08:00">
                2018-07-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Academic or Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/ArchLinux-and-Shell/" itemprop="url" rel="index">
                    <span itemprop="name">ArchLinux and Shell</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2018/07/11/ArchLinux下的软件安装/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/07/11/ArchLinux下的软件安装/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Archlinux下的软件安装方式总结"><a href="#Archlinux下的软件安装方式总结" class="headerlink" title="Archlinux下的软件安装方式总结"></a>Archlinux下的软件安装方式总结</h2><p>虽然Archlinux既有稳定的官方镜像源又有完善的aur社区，仍然有一些软件是我们通过这两种方式无法安装的。今天就来总结一下Archlinux下所有的安装方式，让我们能方便舒适地使用所有软件。</p>
<h3 id="pacman"><a href="#pacman" class="headerlink" title="pacman"></a>pacman</h3><p><code>pacman</code>是Arch官方的包管理工具。这里能下载到的都是Arch官方支持的软件，因此很多软件是无法从这种途径获取的。</p>
<h4 id="找到需要的软件包"><a href="#找到需要的软件包" class="headerlink" title="找到需要的软件包"></a>找到需要的软件包</h4><p>有些时候我们会发现有的软件依赖的二进制文件并没有被安装，导致软件无法运行。想要查找一个二进制文件所在的pacman软件包，可以使用<code>pkgfile</code>工具。使用方法是<code>pkgfile &lt;文件名&gt;</code>。它会输出这个文件所在的软件包名。</p>
<h4 id="pacman的使用方式"><a href="#pacman的使用方式" class="headerlink" title="pacman的使用方式"></a>pacman的使用方式</h4><ul>
<li>常用参数<ul>
<li><code>-S</code> 后面跟软件包名，与镜像源同步，一般使用这个参数安装新的软件包或升级旧的软件包。</li>
<li><code>-U</code> 后面跟一个文件名，通过下载到本地的安装包安装软件</li>
<li><code>-R</code> 后面跟软件包名，卸载这个软件并删除软件包</li>
<li><code>-Syu</code> 俗称 <em>滚Arch</em> ，进行全面的系统更新</li>
</ul>
</li>
</ul>
<h4 id="定制pacman下载工具"><a href="#定制pacman下载工具" class="headerlink" title="定制pacman下载工具"></a>定制pacman下载工具</h4><p><code>pacman</code>的配置文件是<code>/etc/pacman.conf</code>。在这个文件中我们可以对<code>pacman</code>的行为进行自定义。</p>
<ul>
<li>常用的自定义项<ul>
<li>改变<code>pacman</code>的镜像源：修改<code>/etc/pacman.d/mirrorlist</code>文件内容</li>
<li>改变<code>pacman</code>使用的下载工具：修改<code>XferCommand</code>变量的值<ul>
<li><code>/usr/bin/curl -C - -f %u &gt; %o</code> pacman默认使用<code>curl</code>作为下载工具</li>
<li><code>/usr/bin/wget --passive-ftp -c -O %o %u</code> <code>wget</code>是一款非常优秀的单线程下载工具，功能比<code>curl</code>更为强大</li>
<li><code>/usr/bin/axel -o %o %u</code> <code>axel</code>是一款多线程下载工具，速度比前两者要快，推荐设置它为<code>pacman</code>的默认工具。</li>
<li><strong>注意</strong>：<code>wget</code>和<code>axel</code>需要提前用pacman安装。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="yaourt-yay"><a href="#yaourt-yay" class="headerlink" title="yaourt/yay"></a>yaourt/yay</h3><p>官方支持的软件毕竟是有限的，很多我们需要的第三方软件并没有官方提供的支持。在这种时候，Archlinux丰富而强大的aur社区就体现出其威力了——我们可以很方便地从aur社区下载别人制作好的应用软件包或二进制文件，还可以将自己制作的软件包发布在这个社区上(关于发布方式的细节不在这里讨论)。</p>
<p>从aur社区下载软件包所需要的工具是<code>yaourt</code>(现在yaourt已经停止更新了，取而代之的是<code>yay</code>)。使用<code>pacman</code>可以安装<code>yaourt</code>，使用<code>yaourt</code>可以安装<code>yay</code>。</p>
<h4 id="yaourt-yay的使用方式"><a href="#yaourt-yay的使用方式" class="headerlink" title="yaourt/yay的使用方式"></a>yaourt/yay的使用方式</h4><p>与<code>pacman</code>类似，yaourt可以用<code>-S</code>参数来下载并安装软件包。如果不加参数，yaourt会在aur库中搜索所有名字与给出的名字相近的软件包或二进制文件，并以表的形式列出，供用户选择。下载到的二进制文件会默认保存在当前目录中。</p>
<h4 id="定制yaourt-yay下载工具"><a href="#定制yaourt-yay下载工具" class="headerlink" title="定制yaourt/yay下载工具"></a>定制yaourt/yay下载工具</h4><p><code>yaourt</code>和<code>yay</code>的配置文件都是<code>/etc/makepkg.conf</code>。</p>
<p>修改下载工具的方式与pacman类似，只不过修改的是DLAGENTS变量。修改时可以直接删除这个变量原来的所有值，改为<code>DLAGENTS = (&#39;http::/usr/bin/wget --passive-ftp -c -O %o %u&#39;,&#39;https::/usr/bin/wget --passive-ftp -c -O %o %u&#39;)</code></p>
<h4 id="AUR的其他使用方式"><a href="#AUR的其他使用方式" class="headerlink" title="AUR的其他使用方式"></a>AUR的其他使用方式</h4><p>有些时候yay会出现玄学问题，即明明远端的aur包是存在的，在试图拉取的时候却报404。这种时候，我们可以在<a href="https://aur.archlinux.org/packages/" target="_blank" rel="noopener">AUR仓库</a>中搜索这个包的名字，找到其git地址，并使用<code>git clone</code>直接将其拉取到本地。</p>
<p>拉取完成之后，可以在PKGBUILD文件所在的位置执行<code>makepkg</code>命令来安装这个包。如果仍然出现下载错误，就复制PKGBUILD中source变量指明的下载地址并用wget去手动下载，并在下载完成之后修改source变量的值为这个包在本地的路径，再次执行<code>makepkg</code>就可以了。</p>
<h3 id="通过下载好的软件包安装"><a href="#通过下载好的软件包安装" class="headerlink" title="通过下载好的软件包安装"></a>通过下载好的软件包安装</h3><p>如果一个软件既无法通过<code>pacman</code>下载又无法通过aur库得到，那就只能手动安装了。首先我们要通过各种渠道获取软件的安装包(<code>GitHub</code>/<code>wget</code>/软件官网/其他)，随后的操作要视软件包而定。</p>
<h4 id="软件是单文件-二进制文件"><a href="#软件是单文件-二进制文件" class="headerlink" title="软件是单文件(二进制文件)"></a>软件是单文件(二进制文件)</h4><p>这种情况最简单，没有软件包，直接把二进制文件移动到<code>/usr/bin</code>文件夹下即可(注意要加<code>sudo</code>)。</p>
<h4 id="软件包中有安装脚本"><a href="#软件包中有安装脚本" class="headerlink" title="软件包中有安装脚本"></a>软件包中有安装脚本</h4><p>大多软件会在软件包中放一个命名为<code>install.sh</code>(或其他名字)的安装脚本。在这种情况下，可以直接执行<code>sh install.sh</code>或<code>./install.sh</code>来安装软件。(最好结合软件的READ.ME或官方说明安装)</p>
<h4 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h4><p>如果安装脚本不能在Arch下正常运行，那就只好手动拆包安装了。这种时候可以搜索一下各种后缀的软件包的格式，然后手动将二进制文件，lib文件和其他配置文件cp到需要的位置完成安装。</p>
<h3 id="downgrade"><a href="#downgrade" class="headerlink" title="downgrade"></a>downgrade</h3><p>和前面几种方式不同，downgrade是一种给软件包<strong>降级</strong>的方式。使用这个工具可以很方便地回滚软件包等级，从而解决一些可能存在的依赖问题。</p>
<p>执行<code>yay downgrade</code>命令可以直接从aur仓库安装downgrade工具。</p>
<p>使用downgrade工具需要root权限。使用方式：<code>sudo downgrade &lt;软件包&gt;</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2018/04/12/Note of CSAPP/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/04/12/Note of CSAPP/" itemprop="url">CSAPP学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-12T08:22:15+08:00">
                2018-04-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Academic or Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/Operating-System/" itemprop="url" rel="index">
                    <span itemprop="name">Operating System</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2018/04/12/Note of CSAPP/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/04/12/Note of CSAPP/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>CSAPP Note Taking</strong></p>
</blockquote>
<p>这是阅读《深入理解计算机系统》一书时所做的学习笔记。</p>
<hr>
<h1 id="Chapter-1-计算机系统漫游"><a href="#Chapter-1-计算机系统漫游" class="headerlink" title="Chapter 1 计算机系统漫游"></a>Chapter 1 计算机系统漫游</h1><p>首先从“hello.c”文件开始讲起。</p>
<p>Unix-like系统下有两个重要概念：</p>
<ul>
<li>只由ASCII字符构成的文件为文本文件，其余皆为二进制文件</li>
<li>系统中所有信息都是由一串bits构成的。<br>区分它们的不同方式在于它们的上下文。</li>
</ul>
<h2 id="有关C语言"><a href="#有关C语言" class="headerlink" title="有关C语言"></a>有关C语言</h2><ol>
<li>C语言是贝尔实验室的研究员在1969-1973年间创建的。</li>
<li>ASCI标准在1989年由美国国家标准学会颁布。</li>
<li>C语言是为了开发UNIX而设计的，由是，它是系统级编程的首选。但它缺乏对一些抽象的显式实现（如异常，类，对象），因此在应用级编程方面弱于C++与JAVA等语言。</li>
</ol>
<h2 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello.c -预处理-&gt; hello.i -编译-&gt; hello.s -汇编-&gt; hello.o -链接-&gt; hello</span><br></pre></td></tr></table></figure>
<ul>
<li>执行这四个阶段的程序（预处理器，编译器，汇编器，连接器）共同构成了 <strong>编译系统</strong> 。<ul>
<li>预处理 ：对源程序中所有 <em>#</em> 打头的语句进行处理</li>
<li>编译 ： 将处理过的源程序翻译为汇编程序</li>
<li>汇编 ： 将汇编程序翻译为机器语言，并打包成为 <em>可重定位目标程序</em></li>
<li>链接 ： 将标准库函数所在的 <em>.o文件</em> 链接到hello.o并生成 <em>可执行目标文件</em></li>
</ul>
</li>
</ul>
<h3 id="有关GNU项目"><a href="#有关GNU项目" class="headerlink" title="有关GNU项目"></a>有关GNU项目</h3><ol>
<li>GNU（GNU‘s not UNIX）是一个免税慈善项目，它的目标是开发一个完整的开源系统。</li>
<li>GNU环境包括 <em>EMACS</em>,<em>GCC</em>,<em>GDB</em>,编器，链接器，处理二进制文件的一些工具以及其他部件<pre><code>（~~然而不包括内核，内核是LINUX独立发展的~~）
</code></pre></li>
<li>它是现代 <strong>开放源码运动</strong> 的思想起源。</li>
</ol>
<h2 id="计算机系统的硬件组成"><a href="#计算机系统的硬件组成" class="headerlink" title="计算机系统的硬件组成"></a>计算机系统的硬件组成</h2><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>总线是在系统的各个部件之间传递信息的渠道，通常被设计为传送定长的字节块。</p>
<ul>
<li>xx位系统的含义:<ul>
<li>xx代表的是这个系统的基本属性：<strong>字长</strong> ,即总线一次传送信息的最小单位。比如，64位系统代表字长是64个位，也就是8个字节。</li>
<li>字长不仅是总线传送信息的最小单位，还是内存中数据单元的一种单位。</li>
</ul>
</li>
</ul>
<h3 id="I-O-设备"><a href="#I-O-设备" class="headerlink" title="I/O 设备"></a>I/O 设备</h3><p>I/O设备通过适配器或控制器与I/O总线相连。</p>
<ul>
<li>控制器与适配器的区别<ul>
<li>控制器是设备本身或者系统主板上的芯片组;</li>
<li>适配器是插在主板插槽上的卡。</li>
</ul>
</li>
</ul>
<h3 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h3><p>主存由一组 <strong><em>动态随机存取存储器</em></strong> 芯片组成。</p>
<h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><p>中央处理单元，简称处理器，是解释执行储存在主存中指令的引擎。</p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>处理器的核心是一个大小为一个字的存储设备 - <strong>程序计数器</strong>，它保存主存中某条指令的地址。处理器读出主存中的指令，执行指令，再更新程序计数器使其指向下一个指令。</p>
<h4 id="算数逻辑单元"><a href="#算数逻辑单元" class="headerlink" title="算数逻辑单元"></a>算数逻辑单元</h4><p>算数逻辑单元（ALU）用于计算数据和地址值。</p>
<h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><p>系统将信息在磁盘，I/O，主存，处理器间来回移动的时间开销过大，一种解决方式是高速缓存。</p>
<p>高速缓存：作为暂时的集结区域，存放处理器近期可能需要的信息。</p>
<p>高速缓存的分级：</p>
<pre><code>* 一级高速缓存：访问速度与大小和寄存器相当
* 二级高速缓存：大小要大很多，但是速度也要慢一些
* ...以此类推
</code></pre><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="操作系统的基本功能："><a href="#操作系统的基本功能：" class="headerlink" title="操作系统的基本功能："></a>操作系统的基本功能：</h3><ol>
<li>防止硬件被失控的应用程序滥用</li>
<li>向应用程序提供简单一致的机制来控制复杂的硬件设备</li>
</ol>
<h4 id="有关Unix"><a href="#有关Unix" class="headerlink" title="有关Unix"></a>有关Unix</h4><p>20世纪60年代末，由于当时开发的Multics操作系统过于复杂，贝尔实验室的研究员用 <strong>机器语言</strong> 写了一个简单易用的操作系统，并在1970年将其命名为“UNIX”。</p>
<ul>
<li>1973年，UNIX内核被用C重新构建</li>
<li>1974年，UNIX正式对外发布</li>
<li>80年代中期，为了防止Unix厂商所加入的新特性导致的不兼容问题，IEEE研发了 <em>POSIX标准</em>。</li>
</ul>
<h3 id="操作系统提供的抽象表示"><a href="#操作系统提供的抽象表示" class="headerlink" title="操作系统提供的抽象表示"></a>操作系统提供的抽象表示</h3><h4 id="1-进程"><a href="#1-进程" class="headerlink" title="1.进程"></a>1.进程</h4><p><strong>进程</strong>是操作系统对一个正在运行的程序的一种抽象。</p>
<p>无论是在单核还是多核系统，操作系统看起来并发地执行多个进程，是通过在进程间切换实现的。<br>这种切换称为 <strong>上下文切换</strong> 。</p>
<ul>
<li>关于 <em>上下文切换</em> ：<ul>
<li>操作系统保持跟踪进程运行所需的所有状态信息。这种信息称为 <strong>上下文</strong> 。</li>
<li>上下文包括程序计数器（PC）和寄存器的当前值，以及主存的内容。</li>
<li>上下文切换就是保存当前进程的上下文并恢复新进程的上下文，然后递交控制权。</li>
</ul>
</li>
</ul>
<p>进程的切换是由操作系统的 <strong>内核</strong>（kernel） 管理的。</p>
<ol>
<li>在应用程序进行系统调用时，控制权移交给内核</li>
<li>内核执行被请求的操作并将控制权返还给应用程序。</li>
</ol>
<h4 id="2-线程"><a href="#2-线程" class="headerlink" title="2.线程"></a>2.线程</h4><p>每个 _进程_ 由许多个更小的执行单元 <strong>线程</strong> 组成，它们共享进程代码和全局数据。</p>
<ul>
<li>多线程的优势所在：<ol>
<li>多线程比多进程更容易共享数据</li>
<li>线程一般比进程更为高效（开销更小）        </li>
</ol>
</li>
</ul>
<h4 id="3-虚拟内存"><a href="#3-虚拟内存" class="headerlink" title="3.虚拟内存"></a>3.虚拟内存</h4><p>虚拟内存提供了一个假象：每个进程都在独立地使用主存。<br>对每个进程来说，它们所看到的主存是一样的，它们所看到的主存称为 <strong>虚拟地址空间</strong> 。</p>
<p>虚拟地址空间的结构：（<strong>地址由高到低</strong>）</p>
<table>
<thead>
<tr>
<th>内核所用的虚拟内存</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户栈（向下增长）</td>
</tr>
<tr>
<td>「预留区域」</td>
</tr>
<tr>
<td>动态链接库映射到内存中的区域（向上增长）</td>
</tr>
<tr>
<td>「预留区域」</td>
</tr>
<tr>
<td>malloc申请的堆内存（向上增长）</td>
</tr>
<tr>
<td>读/写数据</td>
</tr>
<tr>
<td>只读数据和代码</td>
</tr>
</tbody>
</table>
<h4 id="4-文件"><a href="#4-文件" class="headerlink" title="4.文件"></a>4.文件</h4><p><strong>文件</strong> 就是字节序列。在UNIX系统中万物皆文件，包括各种I/O设备。</p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>从一个单独的系统来看，网络可以视为一个I/O设备。</p>
<h1 id="Chapter-2-信息的表示与处理"><a href="#Chapter-2-信息的表示与处理" class="headerlink" title="Chapter 2 信息的表示与处理"></a>Chapter 2 信息的表示与处理</h1><p>数字革命的基础之一就是 <strong>二进制表示法</strong> 。当我们把位组合在一起，我们就可以表示任何一个有限集内的元素。</p>
<p>对于二进制表示数字来讲，三种表示最为重要:</p>
<ol>
<li>Unsigned code ：传统的二进制表示法，表示大于等于零的数字</li>
<li>two’s-complement code ：补码，可以表示有符号的整数</li>
<li>floating-point code ：浮点数编码，可以（近似地）表示所有实数</li>
</ol>
<p>由于编码的位数有限，当结果超出表示范围时就会发生 <strong>溢出</strong> 。</p>
<ul>
<li>对于整数来说，溢出并不影响运算的性质。<ul>
<li>举个例子：以不同的先后顺序计算200×300×400×500,溢出结果是一样的。</li>
</ul>
</li>
<li>但对于浮点数来讲，其数学性质截然不同。<ul>
<li>再举个例子：计算 （0.1+1e20）-1e20 得出的结果是0.0,但先计算1e20-1e20则会得出正确结果</li>
<li>这说明浮点数的表示只是近似的。</li>
</ul>
</li>
</ul>
<p>了解计算机上数字的运算对于提高程序的可移植性和减少漏洞都是有帮助的。</p>
<ul>
<li>C语言标准的发展<ol>
<li>在C语言被开发出来之后，各种标准化组织在为C语言标准化作出努力。1989年，ASCI C标准推出。</li>
<li>1990年，国际标准化组织从美国国家标准协会手中 <del>接锅</del>，开发了ISO C90标准，跟ASCI C的内容基本一致。</li>
<li>1999年，ISO C99标准发布，引入了一些新的数据类型。</li>
<li>在2011年的C11标准中，增加了更多的数据类型和特性。</li>
</ol>
</li>
</ul>
<h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><p>一般来讲，计算机 <strong>可寻址</strong> 的最小单位就是字节。<br>要进行位操作，需要一些其他特殊的手段。</p>
<h3 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h3><p>1 × 十六进制数 == 4 × 二进制数 == 4 × bits == 0.5 × byte</p>
<p>这个换算一定要搞清楚。（不同进制之间是次方关系而非乘法关系）</p>
<ul>
<li>熟练掌握二进制数和十六进制数之间的转换<ul>
<li>对于十六进制对应的四个二进制位来说，一个十六进制数就是1,2,4,8的有机组合。</li>
<li>对于位串来说，每四个二进制数组成一个十六进制数。</li>
</ul>
</li>
</ul>
<h3 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a><strong>字数据大小</strong></h3><p>之前讲到过 <strong>虚拟地址空间</strong> ，每个程序运行时都会从主存分配一个地址从零开始的虚拟地址空间，这个空间（一般来说）就是它们能够使用的最大主存。</p>
<p>之前还讲到过 <strong>字长</strong> ，它的含义是 <strong>ALU</strong>（CPU中的算数逻辑单元） 一次运算能够处理的最大位数，所以也是总线一次能够传递的最大位数。</p>
<p>那么由于操作系统一般是用指针去进行虚拟地址空间中的寻址的， <strong>一个指针的最大大小</strong> 也就决定了 <strong>虚拟地址空间的最大大小</strong> 。而指针身为数据类型的一种，它的大小是受ALU算力的限制的。</p>
<p>也就是说， <strong>计算机字长</strong> 决定 <strong>指针数据的标称大小</strong> ，从而决定 <strong>虚拟地址空间的最大大小</strong> 。由于每一个指针值都对应着虚拟地址空间中的一个字节，一个 <strong>w位</strong> 的机器的虚拟地址空间最大为 <strong>2^w-1</strong> 。</p>
<ul>
<li>为避免程序在不同位系统间切换时数据类型默认大小不同带来的问题，C99标准加入了固定大小的数据类型，比如 <code>int32_t</code> 和 <code>int64_t</code> 。</li>
</ul>
<h3 id="寻址和字节序"><a href="#寻址和字节序" class="headerlink" title="寻址和字节序"></a>寻址和字节序</h3><p><strong>大端序</strong> 和 <strong>小端序</strong> ：最低有效字节（一个数中最右边的）在前为小端序，反之为大端序。</p>
<ul>
<li>大部分Intel兼容机都采用小端序。</li>
<li>这两个名词起源于 <em>格列佛游记</em> 中小人国的大端派和小端派。</li>
</ul>
<p>在一些特定的情景（如网络数据传输，字节级操作）中，大小端序的区别可能会导致错误，需要注意。</p>
<h3 id="表示字符串"><a href="#表示字符串" class="headerlink" title="表示字符串"></a>表示字符串</h3><ul>
<li><p>由于char型变量使用的是单字节，文本型数据在跨平台方面要强于二进制数据 ：它不受字大小和字节序区别的干扰。</p>
</li>
<li><p>字符编码缘起（参考知乎<a href="https://www.zhihu.com/question/23374078" target="_blank" rel="noopener">于洋的回答</a>）：</p>
<ul>
<li>最开始的 <strong>ASCII编码</strong> 标准涵盖了 <strong>控制码</strong>（0x00-0x20） 与用于显示的字符，共128个，每个字节对应一个ASCII码。</li>
<li><p>由于一个字节最多可以表示256种状态，人们添加了 <strong>扩展字符集</strong> ，用来表示一些特殊字符（如某些非英文国家的字母，数学和制表符号等）</p>
</li>
<li><p>由于中文汉字过多，中国采用了两个字节对应一个字符的编码方式-GB2312，一个字节的值不大于127则仍是ASCII码（称为 <strong>半角字符</strong> ），大于127则与后一个字节共同表示一个字符（称为 <strong>全角字符</strong> ）。</p>
</li>
<li><p>后来该协议又有扩展，不再要求后一个字节的值大于127,此次更新的方案称为 <strong>GBK标准</strong>。</p>
</li>
<li><p>再之后ISO出手了，制定了 <strong>UNICODE标准</strong> ，规定用所有字符都用两个字节表示。</p>
</li>
<li>为了网络数据传输的方便，一系列 <strong>UTF编码规则</strong> 被制定出来（UTF-8代表一次传输一个字节）。UTF标准规定可以用1～4个字节来表示一个字符</li>
</ul>
</li>
</ul>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>C标准并没有规定在位右移时是采用 <strong>算术右移</strong> （也就是高位补有效位）还是 <strong>逻辑右移</strong> （也就是高位一律补0），所以导致了一系列可移植性问题（不过一般来说，编译器一律采用算术右移）；但是java用&gt;&gt;和&gt;&gt;&gt;的区别很好地区分了两种移位的判定。</p>
<h2 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h2><p>无非就是两种主要表示形式：signed和unsigned，signed又一般用补码表示。</p>
<h3 id="补码的计算原理"><a href="#补码的计算原理" class="headerlink" title="补码的计算原理"></a>补码的计算原理</h3><p>补码的最左边一位是负权位，如果该整数占w位，那么它的值是-2^(w-1)。补码的计算就是非补码位表示的正值加上补码位负权表示的负值。</p>
<h3 id="补码的符号扩展"><a href="#补码的符号扩展" class="headerlink" title="补码的符号扩展"></a>补码的符号扩展</h3><p>为了保持补码表示的数值不变，补码在扩展时在左边补’1’，原码则是补’0’。因此，一个补码在左边加任意x个1,正如十进制数左边加零一样，其值不变。</p>
<h3 id="补码的截断"><a href="#补码的截断" class="headerlink" title="补码的截断"></a>补码的截断</h3><p>和原码一样，都是去高位留低位，然后根据低位表示的值求出截断后的值。</p>
<h3 id="非补码的数据表示"><a href="#非补码的数据表示" class="headerlink" title="非补码的数据表示"></a>非补码的数据表示</h3><p>在系统级编程和网络编程当中，经常会需要用一个变量代表一串没有数学意义的位。这种时候，补码特殊的负权位会带来一些不必要的麻烦，于是我们可以使用unsigned值来代替。</p>
<p>这里介绍signed和unsigned间隐式类型转换可能带来的漏洞：</p>
<ul>
<li>现在有一个读出缓冲区中信息的函数，这个缓冲区中有些信息是隐私信息，不允许阅读。</li>
<li>为防止这个函数被用来读出不该读的东西，该函数被设置为从可读信息的开始处开始阅读，阅读长度为一个int参数，函数会实现判定其大小是否超出了可读范围。</li>
<li>然而，这个函数调用的用来复制缓冲区中一段信息的系统函数中长度参数的类型为size_t(它被定义为unsigned int)</li>
<li>那么如果有人心怀不轨，将-1作为参数传入，作为int它能通过函数的检验，但在这个函数调用系统函数来复制缓冲区中的信息时，-1就会被隐式类型转换换为unsigned int类型，由于-1的二进制位最左边为1,此时它的值就会变成一个特别大的整数。</li>
<li>这样，这个人就成功读到了本来不应该被他读到的信息。</li>
</ul>
<h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><p>整数运算所产生的大部分漏洞都是溢出所导致的。<br>因此，要格外注意可能引发溢出的情形。</p>
<h3 id="unsigned-int的运算"><a href="#unsigned-int的运算" class="headerlink" title="unsigned int的运算"></a>unsigned int的运算</h3><ul>
<li>无符号数加法的溢出<ul>
<li>溢出的处理规则：舍弃最高位</li>
<li>溢出的判定方法：如果加法得数小于两个加数中的任意一个，则该结果是溢出的。</li>
<li>溢出的应用：阿贝尔群<ul>
<li>概念：任取一个无符号数a，必定存在另一个无符号数b使a+b的结果为0。</li>
<li>原理：a+b的值正好为2^w</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="补码的运算"><a href="#补码的运算" class="headerlink" title="补码的运算"></a>补码的运算</h3><ul>
<li>补码加法的溢出<ul>
<li>如果是正溢出，得数为 <strong><em>原得数 - 2^w</em></strong> 。</li>
<li>如果是负溢出，得数为 <strong><em>原得数 - 2^w</em></strong> 。</li>
<li>溢出的判定方法：如果两个负数相加得到了正数，则发生了负溢出；反之，则为正溢出。</li>
</ul>
</li>
</ul>
<ul>
<li>补码的非<ul>
<li>注意：非和补不是一个东西，非是-，补是～</li>
<li>补码取非就是简单的求反加一</li>
<li>还有一种方法就是找到二进制表示中 <em>从右到左第一个值为‘1’的位</em> ，然后对 <em>这一位左边的所有位</em> 取反。</li>
</ul>
</li>
</ul>
<ul>
<li>补码的乘法<ul>
<li>先直接计算乘积，将其截断后由无符号数转换为补码形式。</li>
<li><strong>这里比较难，之后可以翻回来看一下</strong></li>
</ul>
</li>
</ul>
<h3 id="对于整数乘法的优化"><a href="#对于整数乘法的优化" class="headerlink" title="对于整数乘法的优化"></a>对于整数乘法的优化</h3><p>一般的整数运算（如加减，移位）只需要一个时钟周期，但整数乘法比它们慢的多，需要数个时钟周期来完成。为了提高计算效率，编译器采用了一项重要的优化：用 <strong>移位和加法运算的组合</strong> 来代替。</p>
<ol>
<li>易得， <em>对一个数乘以2的n次方</em> 相当于 <em>将这个数进行n位左移</em> （这两种方式在溢出时得到的结果也是等价的）。</li>
<li>而任意一个整数都可以由 <em>数个2的k次方的和</em> 表示。</li>
<li>于是，由乘法分配律，一个数乘一个常数因子就等价于将若干个它的左移结果相加。</li>
<li>更好的是，有时可以用减法进一步减小计算量。</li>
</ol>
<h3 id="对于整数除法的优化"><a href="#对于整数除法的优化" class="headerlink" title="对于整数除法的优化"></a>对于整数除法的优化</h3><p>在大多数机器上，整数除法比乘法还要慢，大概需要30多个时钟周期。<br>因此，采用与乘法的优化相似的思路来进行优化。</p>
<p>但与乘法不同的是， <strong>移位优化</strong> 只能适用于 $x|(2^k)$ 的情形。(<code>|</code>是离散数学中的符号，意思是能够整除)</p>
<h4 id="整数除法的舍入问题"><a href="#整数除法的舍入问题" class="headerlink" title="整数除法的舍入问题"></a>整数除法的舍入问题</h4><p>我们知道，整数的除法结果应该是 <strong>向零取整</strong> 的（无论正数还是负数），然而直接采用移位法进行除法运算会导致 <strong>向下取整</strong> 的舍入结果。这个问题需要得到解决。</p>
<p>为了解决这个问题，需要引入 <strong>偏置数</strong> 作为修正。</p>
<ul>
<li>对于正数的除法，直接移位即可</li>
<li>对于负数的除法，先进行偏置，再移位。</li>
</ul>
<p>偏置的方式：<strong>将原来的数加上</strong> $(1&lt;&lt;k)-1$ <strong>后再移位，k是将要移动的位数。</strong></p>
<ul>
<li>解析：以除以16来说明。<ul>
<li>当除以16时，应该右移4位，因此k=4</li>
<li>$(1&lt;&lt;k)-1$ = 0b1111</li>
<li>如果将要右移的四位全为0,说明可以整除，则加上0b1111后不进位，移位后结果不变</li>
<li>如果将要右移的四位不全为0,说明有小数部分，则一旦加上0b1111一定会进位，于是结果比向下取整大1,也就实现了向零取整的效果。</li>
</ul>
</li>
</ul>
<p>因此，采用如下表达式来计算 $\frac x {(2^k)}$ :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( x &lt; <span class="number">0</span> ? x + (<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span> : x) &gt;&gt; k</span><br></pre></td></tr></table></figure>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>现在被普遍采用的一种浮点数表示方式为 <strong>IEEE浮点格式</strong> 。<br>它在1985年前后由IEEE（电气和电子工程师协会）推出。</p>
<h3 id="IEEE小数的结构"><a href="#IEEE小数的结构" class="headerlink" title="IEEE小数的结构"></a>IEEE小数的结构</h3><p>IEEE标准表示的小数由以下几部分组成：</p>
<ol>
<li>符号：用一个二进制位来表示小数的正负</li>
<li>尾数：用小数字段frac编码一个范围为 <em>1~2-epsilon</em> 的二进制小数</li>
<li>阶码：用阶码字段exp对这个浮点数加权，权重为2的E次幂</li>
</ol>
<p>对于单精度浮点数而言，exp占8位，frac占23位；对于双精度浮点数而言，exp占11位，frac占52位</p>
<h4 id="三类浮点数"><a href="#三类浮点数" class="headerlink" title="三类浮点数"></a>三类浮点数</h4><p>根据exp的值的情况可以将浮点数分为三类（以float为例）：</p>
<h5 id="当exp不为0且不为255时"><a href="#当exp不为0且不为255时" class="headerlink" title="当exp不为0且不为255时"></a>当exp不为0且不为255时</h5><p>这是最普遍的情况。</p>
<p>在这种情况下，阶码字段是以偏置形式表示的无符号数。其偏置值为 <strong>2^(k-1)-1</strong> ，从而将 <strong><em>1～2^k-2</em></strong> 的无符号正数映射到了 <strong><em>-2^(k-1)+2</em></strong> ~ <strong><em>2^(k-1)-1</em></strong> (对于单精度浮点数而言，这个映射区间就是 -126～127 )。</p>
<p>而小数字段frac表示小数点后的位，也就是说小数点（等价地）位于整个小数字段的左边，小数点的左边则 <strong>默认为1</strong> 。这样，frac表示的就是一个大小为1.xxxxxx……的小数。</p>
<h5 id="当exp为0时"><a href="#当exp为0时" class="headerlink" title="当exp为0时"></a>当exp为0时</h5><p>这种数称为 <strong>非规格化形式</strong> 的数。</p>
<p>此时阶码字段的值为 <strong>1-偏置值</strong> ，而小数字段小数点左边改为 <strong>默认为0</strong> 。</p>
<ul>
<li>非规格化数的用途：<ol>
<li>表示+0.0与-0.0</li>
<li>表示极为接近0.0的值</li>
</ol>
</li>
</ul>
<h5 id="当exp-255-也就是阶码字段全为1时："><a href="#当exp-255-也就是阶码字段全为1时：" class="headerlink" title="当exp=255,也就是阶码字段全为1时："></a>当exp=255,也就是阶码字段全为1时：</h5><p>此时该浮点数表示的是一个特殊值。</p>
<ol>
<li>frac字段全为0时：表示无穷，无穷的符号由符号位决定。</li>
<li>frac字段不为0时：表示 <strong>NaN</strong>(Not a Number)<ul>
<li>当运算结果既不是实数又不是无穷时使用NaN来代替。（如：sqrt(-1)，∞-∞等）</li>
<li>有些时候用以表示未初始化的数据</li>
</ul>
</li>
</ol>
<ul>
<li><p>这种设计的优点</p>
<p>  经过精心设计，这种表示方法使得浮点数在增大时其位级表示的变化规律和整数增大时是一样的。<br>  这对于排序工作的优化起到了相当大的作用，因为比较的时候不需要进行浮点运算。</p>
</li>
</ul>
<h3 id="浮点数的运算"><a href="#浮点数的运算" class="headerlink" title="浮点数的运算"></a>浮点数的运算</h3><h4 id="浮点数的舍入运算"><a href="#浮点数的舍入运算" class="headerlink" title="浮点数的舍入运算"></a>浮点数的舍入运算</h4><p>IEEE标准定义了四种不同的舍入方式。</p>
<ol>
<li>向偶数舍入（也就是向最近的数舍入）<ul>
<li>这是最通用的方法，也就是人们常说的“四舍五入”。</li>
<li>对二进制数来讲，一个数的奇偶由最右边的二进制位决定，我们倾向于在舍入后让最低位为0。</li>
</ul>
</li>
<li>向零舍入</li>
<li>向上舍入</li>
<li>向下舍入</li>
</ol>
<h4 id="浮点数的算术运算"><a href="#浮点数的算术运算" class="headerlink" title="浮点数的算术运算"></a>浮点数的算术运算</h4><p>与整数的运算相似，浮点数算术运算也构成了 <strong>阿贝尔群</strong> 。但要特别注意的是，就像之前所说的， <strong>浮点数运算不满足结合律和分配律</strong> ，这是舍入所造成的。</p>
<p>缺少这两个运算基本属性让浮点运算给编程者们带来了很多麻烦，它使得很多判定变得十分麻烦。</p>
<p>然而，由于浮点数特殊的溢出判定，它具有补码运算和无符号数运算不具有的 <strong>单调性</strong> 。</p>
<h3 id="浮点数与其他数据类型的转换"><a href="#浮点数与其他数据类型的转换" class="headerlink" title="浮点数与其他数据类型的转换"></a>浮点数与其他数据类型的转换</h3><ol>
<li>int -&gt; float：不会溢出，但是可能会被舍入</li>
<li>int/float -&gt; double：可以完整保留精确数值</li>
<li>double -&gt; float：可能溢出也可能会舍入</li>
<li>float/double -&gt; int：不出意外值会向零舍入，但有可能发生 <strong>浮点溢出</strong> ，产生 <strong>整数不确定值</strong> （对于Intel兼容机，它被定义为0b10000……0）</li>
</ol>
<h1 id="Chapter-3-程序的机器级表示"><a href="#Chapter-3-程序的机器级表示" class="headerlink" title="Chapter 3 程序的机器级表示"></a>Chapter 3 程序的机器级表示</h1><p>在高级语言如此发达和完善的今天，为什么还要学习汇编语言?</p>
<ol>
<li>通过阅读汇编代码，我们能够理解编译器优化代码的原理，从而找出代码中隐含的低效率。</li>
<li>有些时候，高级语言的抽象层会隐藏我们想要了解的程序运行时行为。</li>
<li>了解漏洞的产生与防御恶意攻击需要了解机器级代码表示。</li>
</ol>
<p><strong>x86-64</strong>：Intel兼容机使用的机器语言</p>
<h2 id="x86-64缘起"><a href="#x86-64缘起" class="headerlink" title="x86-64缘起"></a>x86-64缘起</h2><p>Intel系列处理器俗称x86，经历了一个漫长的发展过程。<br>其中，后面的处理器可以兼容前面的机器程序。</p>
<ul>
<li><strong>8086</strong>（1978）：它是第一代单芯片16位处理器之一，它的变种8088是第一代IBM兼容机的心脏</li>
<li><strong>8087</strong>（1980）：浮点协处理器，与8086或8088一同工作，进行浮点运算</li>
<li><strong>80286</strong>（1982）：增加了更多寻址模式，是MS Windows最初的使用平台</li>
<li><strong>i386</strong>（1985）：体系结构升级到32位，这是Intel第一台全面支持Unix操作系统的处理器。它所增加的 <strong>平坦寻址模式</strong> 至今仍被大部分Linux和Windows机型使用。</li>
<li><strong>i486</strong>（1989）：将浮点单元集成到了处理器芯片</li>
<li><strong>Pentium系列</strong>（1993-2004）：不断扩展指令集，引入了SSE：增加了新的处理整数和浮点数向量的指令，增加了新的数据类型。在04年的Pentium 4E实现了超线程。增加了EM64T，它是对AMD提出的 <strong>IA32</strong> 的64位扩展的实现，被人们称为x86-64.</li>
<li><strong>Core 2</strong>（2006）：Intel第一个 <strong>多核微处理器</strong> ，但是不支持超线程。</li>
<li><strong>Core i7</strong>（2008）：同时支持多核处理和超线程，引入了SSE的扩展AVX，增加了更多的指令和指令格式。</li>
</ul>
<h2 id="研究汇编程序编码"><a href="#研究汇编程序编码" class="headerlink" title="研究汇编程序编码"></a>研究汇编程序编码</h2><ul>
<li><p>对于机器级编程来讲尤为重要的两种抽象</p>
<ul>
<li><strong>指令集架构</strong>（ISA）<ul>
<li>它定义了处理器状态，指令的格式，以及每条指令对状态的影响</li>
<li>大多数ISA（包括x86-64）将指令的执行抽象为顺序执行，但其硬件实现其实是并发的，只不过有措施保证其执行顺序与ISA规制的相同。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>+ __虚拟地址空间__
    * 存储器系统的实际实现是将多个存储器和操作系统结合起来。
</code></pre><p>汇编代码的表示很接近于机器语言，但是它使用了文本这种更适合人类阅读的表示方法。</p>
<p>x86的代码和原始C代码差别很大，一些在C语言中不显示的硬件状态都会体现出来：</p>
<ul>
<li>程序计数器：用 <strong>%rip</strong> 表示，给出内存中要执行的下一条指令的地址。</li>
<li>整数寄存器：包含16个位置，分别储存64位的值。<ul>
<li>记录重要的程序状态</li>
<li>保存临时数据，如过程参数，局部变量，函数返回值</li>
</ul>
</li>
<li>条件寄存器：用来实现控制或数据流中的条件变化</li>
</ul>
<h3 id="需要用到的调试工具"><a href="#需要用到的调试工具" class="headerlink" title="需要用到的调试工具"></a>需要用到的调试工具</h3><ol>
<li>GCC编译器<ul>
<li>gcc：执行GCC的bash命令</li>
<li><strong>-Og</strong>：指定优化方式，以防过于高级的优化使源代码和汇编代码差距过大不便于研究。</li>
<li><strong>-S</strong>：只进行预处理和编译过程，生成汇编代码 <strong>.s文件</strong> 。</li>
<li><strong>-c</strong>：只进行预处理，编译，汇编过程，生成二进制文件 <strong>.o文件</strong> 。</li>
<li><strong>-masm = &lt; format &gt;</strong>：指定生成汇编代码的格式。</li>
</ul>
</li>
<li>GDB调试器</li>
<li>objdump -d &lt; file name &gt;：反汇编器，根据机器代码生成对应的汇编代码</li>
</ol>
<h3 id="x86-64机器代码的特性"><a href="#x86-64机器代码的特性" class="headerlink" title="x86-64机器代码的特性"></a>x86-64机器代码的特性</h3><ol>
<li>x86-64的指令长度为1-15个字节不等。其中，常用或操作数少的指令占字节数较少，反之较多。</li>
<li>从某个给定位置开始，可以唯一地将字节解码成为机器指令。</li>
</ol>
<h3 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h3><p>以内容如下的 test.c 文件为例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mult2</span><span class="params">(<span class="keyword">long</span>,<span class="keyword">long</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multstore</span><span class="params">(<span class="keyword">long</span> x,<span class="keyword">long</span> y,<span class="keyword">long</span>* dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> t=mult2(x,y);</span><br><span class="line">    *dest=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将其编译之后产生的 test.s 文件内容如下所示：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.file</span>   <span class="string">"test.c"</span></span><br><span class="line"><span class="meta">        .text</span></span><br><span class="line"><span class="meta">        .globl</span>  multstore</span><br><span class="line"><span class="meta">        .type</span>   multstore, @function</span><br><span class="line"><span class="symbol">multstore:</span></span><br><span class="line"><span class="symbol">.LFB0:</span></span><br><span class="line"><span class="meta">        .cfi_startproc</span></span><br><span class="line">        pushq   %rbx</span><br><span class="line"><span class="meta">        .cfi_def_cfa_offset</span> <span class="number">16</span></span><br><span class="line"><span class="meta">        .cfi_offset</span> <span class="number">3</span>, -<span class="number">16</span></span><br><span class="line">        <span class="keyword">movq</span>    %rdx, %rbx</span><br><span class="line">        <span class="keyword">call</span>    mult2@PLT</span><br><span class="line">        <span class="keyword">movq</span>    %rax, (%rbx)</span><br><span class="line">        popq    %rbx</span><br><span class="line"><span class="meta">        .cfi_def_cfa_offset</span> <span class="number">8</span></span><br><span class="line">        <span class="keyword">ret</span></span><br><span class="line"><span class="meta">        .cfi_endproc</span></span><br><span class="line"><span class="symbol">.LFE0:</span></span><br><span class="line"><span class="meta">        .size</span>   multstore, .-multstore</span><br><span class="line"><span class="meta">        .ident</span>  <span class="string">"GCC: (GNU) 8.1.0"</span></span><br><span class="line"><span class="meta">        .section</span>        .note.GNU-stack,<span class="string">""</span>,@progbits</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>所有以 <strong>‘.’</strong> 开头的行都是指导 <strong>汇编器</strong> 和 <strong>链接器</strong> 工作的伪指令</p>
</li>
<li><p>具体语句的作用：</p>
<ul>
<li>pushq %rbx：将rbx寄存器中保存的值压入程序栈</li>
<li>movq %rdx，%rbx：将rdx中的值(dest指针)传递给rbx</li>
<li>call：调用函数，函数的返回值保存在寄存器rax中</li>
<li>movq %rax，（%rbx）：将返回值赋给dest指针</li>
<li>popq %rbx：恢复rbx寄存器中原有的值</li>
<li>ret：该函数返回</li>
</ul>
</li>
</ul>
<h4 id="两种不同的汇编代码格式"><a href="#两种不同的汇编代码格式" class="headerlink" title="两种不同的汇编代码格式"></a>两种不同的汇编代码格式</h4><ul>
<li><strong>ATT格式</strong>：这是根据 <strong>AT&amp;T公司</strong> 命名的汇编格式，是GCC，OBJDUMP等工具的默认格式</li>
<li><strong>Intel格式</strong>：Intel文档和Microsoft的工具使用的都是Intel格式。</li>
</ul>
<p>两种格式的主要区别有：</p>
<ol>
<li>Intel格式省略了操作指令后指定大小的”q”字符与寄存器名前面的”%”。</li>
<li>Intel用不同的方式来描述内存中的位置。</li>
<li>两者列出操作数的顺序相反。</li>
</ol>
<h4 id="在C程序中插入汇编代码"><a href="#在C程序中插入汇编代码" class="headerlink" title="在C程序中插入汇编代码"></a>在C程序中插入汇编代码</h4><p>C语言缺乏一些特定API或操作符来访问一些机器特性。</p>
<p>比如：在x86-64处理器每一次执行算术或逻辑运算时，都会设置一个表示奇偶的称为 <strong>PF</strong> 的1位条件码的值，从而储存这个结果的奇偶性信息。而C语言要想得到这个信息需要至少7次移位、掩码和逻辑运算。</p>
<p>在C程序中插入汇编代码有两种方式:</p>
<ul>
<li>将一个完整的函数单独编写到一个汇编文件中，再用GCC将它和另一个C代码生成的.s文件合并</li>
<li>利用GCC的内联汇编（asm指令）在C代码中插入少量汇编代码。</li>
</ul>
<h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>由于是从16位系统扩展成32位的，Intel将16位数据类型称为“字”。<br>因此，32位数据类型就称为“双字”，64位就是“四字”。</p>
<p>x86-64对于基础数据类型的大小如下定义（括号内为汇编代码中的后缀）：</p>
<ul>
<li><p>普通类型（后缀仅表示操作数大小）：</p>
<ul>
<li>char（b）：1字节</li>
<li>short（w）：2字节</li>
<li>int（l）：4字节</li>
<li>long（q）：8字节</li>
<li>pointer（q）：8字节</li>
</ul>
</li>
<li><p>浮点类型：</p>
<ul>
<li>float（s）：4字节</li>
<li>double（l）：8字节</li>
</ul>
</li>
</ul>
<p>两种类型使用的指令和寄存器完全不同，所以后缀相同也无妨。</p>
<h2 id="访问信息操作"><a href="#访问信息操作" class="headerlink" title="访问信息操作"></a>访问信息操作</h2><p>一个x86-64的CPU包含一组（16个）储存64位值的 <strong>通用目的寄存器</strong> 。<br>每个寄存器都有特殊的用途，它们的名字便反映出这些不同的用途。</p>
<ul>
<li><p>16个寄存器的用途（从左到右分别是8字节，4字节，2字节，1字节对应的寄存器名）</p>
<ul>
<li>%rax %eax %ax %al Accumulator，常用于置放返回值</li>
<li>%rbx %ebx %bx %bl Base，常用于存放地址</li>
<li>%rcx %ecx %cx %cl Count，常用于计数</li>
<li>%rdx %edx %dx %dl Data，常用于存放数据</li>
<li>%rsi %esi %si %sil 源变址寄存器</li>
<li>%rdi %edi %di %dil 目的变址寄存器</li>
<li>%rbp %ebp %bp %bpl 栈帧头指针</li>
<li>%rsp %esp %sp %spl 栈指针</li>
<li>%r8,%r9 %r8d,%r9d %r8w,%r9w %r8b,%r9b 扩展寄存器</li>
<li>%r10，%r11 同理 同理 同理 扩展寄存器</li>
<li>%r12～%r15 同理 同理 同理 扩展寄存器</li>
</ul>
</li>
<li><p>当寄存器中被存入新的变量时的约定：</p>
<ul>
<li>若存入的是1,2字节的值，则不改变寄存器中剩余字节</li>
<li>若存入的是4字节的值，则将剩余字节置为0</li>
</ul>
</li>
</ul>
<h3 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h3><p><strong>操作数</strong>指示出指令需要的原数据值，以及放置结果的位置。</p>
<ul>
<li>操作数可以被分为三种类型：<ul>
<li><strong>立即数</strong>（immediate）：通过 <strong>$Imm</strong> 的格式表示常数，Imm为任意C-style数</li>
<li><strong>寄存器</strong>（register）：直接用寄存器名将寄存器中的部分位作为操作数</li>
<li><strong>内存引用</strong> ：根据计算出的地址访问内存中的某个位置，格式为 <strong>[Imm]（[rb]，[ri]，[s]）</strong><ul>
<li>Imm：立即数表示的偏移量，缺省表示不偏移</li>
<li>rb：基址寄存器，缺省则无基址</li>
<li>ri：变址寄存器，缺省表示无变址寻址</li>
<li>s：比例因子，必须为1,2,4或8，缺省默认为1</li>
<li><strong>计算规则</strong>：最终的内存地址为 <strong>rb + s*ri + Imm</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p><strong><em>MOV S,D</em></strong></p>
<ul>
<li><p>效果：将S中的储存值移动到D</p>
<ul>
<li>S（源操作数）：指定一个寄存器或者内存地址中的立即数</li>
<li>D（目的操作数）：指定一个寄存器或内存地址</li>
<li>注：<strong>x86-64规定两者不能同时为内存地址</strong></li>
</ul>
</li>
<li><p>可能的操作数组合：</p>
<ul>
<li>movl $0x4050,%eax — 立即数-&gt;寄存器 移动4个字节</li>
<li>movw %bp，%sp — 寄存器-&gt;寄存器 移动2个字节</li>
<li>movb （%rdi，%rcx），%al — 内存-&gt;寄存器 移动1个字节</li>
<li>movb %-17,（%rsp） — 立即数-&gt;内存 移动1个字节</li>
<li>movq %rax，-12（%rbp） — 寄存器-&gt;内存 移动8个字节</li>
</ul>
</li>
<li><p>特殊指令：movabsq</p>
<ul>
<li>常规的movq指令只能以 <strong>32位补码</strong> 形式作为源操作数，然后将其扩展成为64位的值放入目的位置</li>
<li>而movabsq指令能以任意的 <strong>64位立即数值</strong> 作为源操作数，但 <strong>只能以寄存器作为目的位置</strong></li>
</ul>
</li>
<li><p>其他的数据传送指令</p>
<ul>
<li><strong>MOVZ</strong>：有两个后缀，分别指定源大小和目的大小。缺少的位用0填充。<ul>
<li>movzlq指令并不存在，因为它完全可以被更简单的movl所取代。（想想4字节的填充特性）</li>
</ul>
</li>
<li><strong>MOVS</strong>：和上面相似，但缺少的位用源操作数的最高位填充。<ul>
<li>cltq指令：将%eax中的值符号扩展到%rax中，没有操作数。</li>
</ul>
</li>
</ul>
</li>
<li><p>一些常见的错误</p>
<ul>
<li>movb %0xF,(%ebx)<ul>
<li>Since address in 64-bits os should be 8-bytes, use %ebx(a 4-bytes register)’s value to index is dangerous and should not be allowed.</li>
</ul>
</li>
<li>movl %rax,(%rsp) <ul>
<li>movl 必须以四字节大小的寄存器号作为其源操作数。</li>
</ul>
</li>
<li>movl %eax,%rdx<ul>
<li>movl 必须以四字节大小的寄存器号作为其目的操作数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="入栈出栈指令"><a href="#入栈出栈指令" class="headerlink" title="入栈出栈指令"></a>入栈出栈指令</h3><p><strong>PUSH &lt; register &gt;</strong>: 将一个寄存器中的值压入程序栈。</p>
<p><strong>POP &lt; register &gt;</strong>: 弹出程序栈顶元素并移入指定寄存器。</p>
<p>出入栈指令的实现（以四字后缀为例）:</p>
<ul>
<li>pushq:<ul>
<li>subq $8,%rsp<ul>
<li>含义：<strong>%rsp</strong>(程序栈指针寄存器)<strong>的值减小8</strong>(因为程序栈从上往下增长)。</li>
</ul>
</li>
<li>movq &lt; register &gt;,(%rsp)</li>
</ul>
</li>
<li>popq:<ul>
<li>movq (%rsp),&lt; register &gt;</li>
<li>addq $8,%rsp<ul>
<li><strong>%rsp的值增大8</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>对于用户程序来说，栈内元素的地址是透明的，也就是说可以直接以 <strong>%rsp</strong> 为基准指针去访问栈内的第n个元素。</p>
<h2 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h2><h3 id="加载有效地址"><a href="#加载有效地址" class="headerlink" title="加载有效地址"></a>加载有效地址</h3><p><strong>LEA</strong>(load effective address)指令：将一个有效地址记录到一个寄存器中。</p>
<ul>
<li>使用方法：<ul>
<li>基本用法(以四字为例)：<strong>leaq &lt; effective address &gt; &lt; target register &gt;</strong></li>
<li>可以用于简单的算术操作：利用内存地址的计算法则来实现简单计算。如：<ul>
<li>寄存器%rdx的值为x</li>
<li>命令 leaq 7(%rdx,%rdx,4), %rax 即是计算5x+7.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="一元算术运算"><a href="#一元算术运算" class="headerlink" title="一元算术运算"></a>一元算术运算</h3><ul>
<li>INC 自增</li>
<li>DEC 自减</li>
<li>NEG 取负</li>
<li>NOT 取补</li>
</ul>
<p>一元算术运算的操作数可以是 <strong>寄存器</strong> 或 <strong>内存位置</strong> 。运算符后缀决定了进行该运算的位数。如：incq就是四字自增，notb就是低字节取补。</p>
<h3 id="二元算术运算"><a href="#二元算术运算" class="headerlink" title="二元算术运算"></a>二元算术运算</h3><ul>
<li>ADD 加</li>
<li>SUB 减</li>
<li>IMUL 乘</li>
<li>XOR 异或</li>
<li>OR 或</li>
<li>AND 与</li>
</ul>
<p>二元算术运算相当于是C语言中的 <strong>～=运算</strong> (～代表一个运算符)。如：SUB S,D 相当于 D-=S</p>
<p>这些运算的第一个操作数可以是 <strong>立即数、寄存器或内存位置</strong>，而第二个操作数只能是 <strong>寄存器或内存位置</strong></p>
<h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><ul>
<li>SAL，SHL 左移</li>
<li>SAR 算术右移</li>
<li><p>SHR 逻辑右移</p>
</li>
<li><p><strong>注意</strong></p>
<ul>
<li>移位运算在运算符后先后给出两个操作数，分别代表移位量和要移位的数</li>
<li>移位量可以是一个 <strong>立即数</strong> ，也可以是 <strong>单字节寄存器%cl</strong> 的值</li>
<li>运算符后缀决定的是取%cl的后几位作为移位量。</li>
</ul>
</li>
</ul>
<h3 id="特殊算术操作"><a href="#特殊算术操作" class="headerlink" title="特殊算术操作"></a>特殊算术操作</h3><ul>
<li><p>imulq指令和mulq指令</p>
<ul>
<li><p>imulq指令有两种含义。</p>
<ul>
<li>作二元操作符：将两个64位操作数相乘得到一个 <strong>64位</strong> 的值，并寄存在后一个操作数的位置。</li>
<li>作一元操作符：将操作数与%rax储存的值相乘得到一个 <strong>128位</strong> 的值，并储存在%rdx(高64位)和%rax(低64位)中。</li>
<li><strong>这两种含义中乘法均为补码乘法</strong>。</li>
</ul>
</li>
<li><p>mulq指令和imulq的第二种含义相似，只不过它做的是无符号乘法。</p>
</li>
</ul>
</li>
<li><p>idivq和divq指令</p>
<ul>
<li>这两种指令与上面的两种用法类似，只不过是除法加取模运算。</li>
<li>idivq指令将%rdx(高64位)和%rax(低64位)表示的128位有符号数作为被除数，而操作数作为除数，得到的 <strong>整数商</strong> 储存在%rax中，<strong>余数</strong>储存在%rdx中。</li>
<li>由于一般来说被除数是64位的，所以可以 <strong>将被除数放在%rax中</strong> ，再使用 <strong>cqto</strong> 指令将符号位扩展。<ul>
<li>cqto指令没有操作数，它自动读出%rax的符号位并将符号位扩展覆盖到%rdx。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="控制操作"><a href="#控制操作" class="headerlink" title="控制操作"></a>控制操作</h2><h3 id="条件操作"><a href="#条件操作" class="headerlink" title="条件操作"></a>条件操作</h3><h4 id="条件码寄存器"><a href="#条件码寄存器" class="headerlink" title="条件码寄存器"></a>条件码寄存器</h4><p>除整数寄存器之外，CPU还维护一组 <strong>条件码寄存器</strong> 。它们描述 <strong>最近一次</strong> 算术或逻辑操作的属性。常用的条件码有：</p>
<ul>
<li>CF 进位标志 显示操作有没有造成操作数最高位发生进位</li>
<li>ZF 零标志   显示操作的结果是不是0</li>
<li>SF 符号标志 显示操作的结果是不是负数</li>
<li>OF 溢出标志 显示补码操作有没有造成正溢出或负溢出</li>
</ul>
<p>只有 <strong>lea指令</strong> 不会改变条件码寄存器。</p>
<p>有两种指令只设置条件码而不改变其他寄存器的值：</p>
<ul>
<li>CMP 求出两个操作数之差(ATT格式是右减左)，并以此为结果设置条件码</li>
<li>TEST 以两个操作数按位与的结果设置条件码</li>
</ul>
<h4 id="对条件码的访问"><a href="#对条件码的访问" class="headerlink" title="对条件码的访问"></a>对条件码的访问</h4><p>x86-64通过 <strong>SET指令</strong> 实现对条件码的直接设置。</p>
<p>set指令是一个单元操作指令集，每条指令的功能取决于set的后缀。所有set指令共同的功能是将某一个 <strong>条件码寄存器</strong> 的值(或某些值的组合)储存到操作数表示的 <strong>单字节寄存器</strong> 中</p>
<ul>
<li>set指令共有(含义解释按上一次操作为a-b):<ul>
<li>sete(setz) - ZF</li>
<li>setne(setnz) - ~ZF</li>
<li>sets,setns - SF,~SF</li>
<li>setl(setnge) - SF^OF</li>
<li>setle(setng) - (SF^OF)|ZF</li>
<li>setg(setnle) - ~(SF^OF)&amp;~ZF</li>
<li>setge(setnl) - ~(SF^OF)</li>
<li>setb(setnae) - CF</li>
<li>setbe(setna) - CF | ZF</li>
<li>seta(setnbe) - ~CF &amp; ~ZF   </li>
<li>setae(setnb) - ~CF</li>
</ul>
</li>
</ul>
<h4 id="用条件控制来实现条件分支"><a href="#用条件控制来实现条件分支" class="headerlink" title="用条件控制来实现条件分支"></a>用条件控制来实现条件分支</h4><p><strong>控制</strong>的条件转移：传统方式，先判断条件是否满足，而后根据判断结果将控制流转移到代码段的某个位置继续执行。</p>
<h5 id="JMP指令"><a href="#JMP指令" class="headerlink" title="JMP指令"></a>JMP指令</h5><ul>
<li>直接使用：操作数是一个label，在代码段中有标记。</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">movq</span> <span class="number">$2333</span> %rax</span><br><span class="line">  <span class="keyword">jmp</span> .L1</span><br><span class="line">  leaq <span class="number">8</span>(%rdx,%rax)     # 这一句被跳过了</span><br><span class="line"><span class="symbol">.L1:</span>                    # L1是label</span><br><span class="line">  <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
<p>还有一种使用方式是间接跳转：jmp *&lt;寄存器或内存地址&gt; 取出小括号内储存的值作为label。</p>
<ul>
<li>条件使用：以j+后缀构成，后缀的使用规则和set指令集类似。<ul>
<li>跳转指令的编码方式<ul>
<li><strong>PC-relative</strong>：将目标指令的地址与jmp指令后一句指令地址的差编码，可以为1,2,4个字节</li>
<li>绝对地址：直接将目标指令的绝对地址编码，用4个字节指定。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="CMOV指令"><a href="#CMOV指令" class="headerlink" title="CMOV指令"></a>CMOV指令</h5><p>先将条件满足和不满足的两种情况下的操作都做完，随后判断条件是否满足，并根据判断结果采用两种情况下操作得出的结果中的一种。</p>
<p>与SET，JMP相似，CMOV指令也是带有指定后缀的指令集。每条CMOV指令都有两个操作数，当后缀所指定的条件满足时，CMOV指令会执行与MOV指令相同的功能。</p>
<p>源和目的值支持单字节以外的任意大小，这个大小可以由寄存器的型号看出，指令本身不给出。</p>
<h5 id="两种条件控制方式的比较"><a href="#两种条件控制方式的比较" class="headerlink" title="两种条件控制方式的比较"></a>两种条件控制方式的比较</h5><p>现代处理器使用的是 <strong>流水线策略</strong> ，即将要执行的指令序列填充进流水线，并同时做一条流水线上的所有工作。当遇到条件分支时，处理器只能预测控制流的走向而去完成那一个分支的工作，而这就意味着一旦预测失误，处理器就必须放弃之前对那一个分支做出的所有工作，并重新填充流水线。这会浪费非常多的时间。而数据条件转移就不存在这个问题。</p>
<p>然而，不是所有条件表达式都可以用条件传送来编译。更重要的是，由于这种处理方式会事先进行两种情况下的操作，如果其中某一种在某种条件下会产生副作用或者错误，那就会导致非法的行为。与此同时，如果两种条件下的计算量都比较大的话，无论怎样编译器都会白白浪费很多资源。</p>
<h3 id="循环操作"><a href="#循环操作" class="headerlink" title="循环操作"></a>循环操作</h3><ul>
<li>对于dowhile循环的实现：</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">func:</span></span><br><span class="line">  ...         # ...</span><br><span class="line"><span class="symbol">.Loop:</span>        # <span class="built_in">do</span> &#123;</span><br><span class="line">  ...         # ...</span><br><span class="line">  &lt;judging&gt;   # &#125;while</span><br><span class="line">  j** .Loop   # (condition)</span><br></pre></td></tr></table></figure>
<ul>
<li>对于while循环的实现：</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">func:</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">jmp</span> .Test   # 一上来先跳到后面的条件判断部分</span><br><span class="line"><span class="symbol">.Loop:</span>        # 循环体</span><br><span class="line">  ...</span><br><span class="line"><span class="meta">.Test</span>         # 条件判断部分</span><br><span class="line">  &lt;judging&gt;</span><br><span class="line">  j** .Loop   # 如果满足条件则回到循环体</span><br></pre></td></tr></table></figure>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">func:</span></span><br><span class="line">  ...</span><br><span class="line">  &lt;judging&gt;   # 先判断是否不符合条件</span><br><span class="line">  j** .Done   # 如果不符合，直接结束循环</span><br><span class="line"><span class="symbol">.Loop:</span></span><br><span class="line">  ...         # 循环体</span><br><span class="line">  &lt;judging&gt;</span><br><span class="line">  j** .Loop   # 如果符合条件则回到循环体</span><br></pre></td></tr></table></figure>
<ul>
<li>对于for循环的实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (init;judge;iteration) &#123;</span><br><span class="line">    body_statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以等效为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">init;</span><br><span class="line"><span class="keyword">while</span>(judge) &#123;</span><br><span class="line">    body_statement;</span><br><span class="line">    iteration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="switch操作"><a href="#switch操作" class="headerlink" title="switch操作"></a>switch操作</h3><p>这边要用到跳转表，等学了表再回来看</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>过程提供了一种封装代码的方式，用一组指定的参数和返回值实现某种功能。常见的过程有函数，方法，子例程，处理函数等等。</p>
<p>在过程调用中，需要牵涉到以下机制：</p>
<ul>
<li>传递控制：调用者要将程序计数器设置为被调用者的起始地址，待调用结束后被调用者又要交还控制权。</li>
<li>传递数据：参数和返回值需要在两块代码间进行交流。</li>
<li>分配内存：局部变量需要临时分配内存，在返回前又要释放这些内存。</li>
</ul>
<h3 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h3><p>C语言调用机制的一个关键特性在于使用了栈提供的 <strong>后进先出</strong> 内存管理原则。</p>
<p>对于局部变量而言，这种机制保证了它可以在作用范围内始终有效，在作用范围外被安全回收：某个过程在入栈时申请了局部变量，则它所调用的所有其他过程都在它之后入栈，在它之前出栈，而它申请的变量在它自身出栈时才销毁。</p>
<ul>
<li>运行时栈的调度机制<ul>
<li>当某一个过程所需要的空间超出了寄存器能提供的范围，就会在栈上分配空间。这一部分空间称为 <strong>过程的栈帧</strong> 。</li>
<li>在这个过程被调用时，它的栈帧会被事先分配好。在这个空间内它可以申请局部变量，设置它所调用的其他过程的参数，保存寄存器的值。有些情况下栈帧的长度会变化，但大部分时候帧的长度是固定的。</li>
<li>一个过程在调用另一个过程时，它会先在寄存器内分配参数；如果六个参数寄存器不够用，多出的参数会被保存在栈帧内。在被调用者分配栈帧之前，调用者会将返回地址压入自己的栈，以指明被调用者返回时调用者的继续执行位置。</li>
<li>如果所有局部变量都可以保存在寄存器中，且这个过程不会调用任何其他过程，这个过程便不会分配栈帧。</li>
</ul>
</li>
</ul>
<h3 id="转移控制"><a href="#转移控制" class="headerlink" title="转移控制"></a>转移控制</h3><ul>
<li>控制的转移使用的指令是 <strong>call</strong> 指令和 <strong>ret</strong> 指令。<ul>
<li>call 的使用方式与 jmp 类似，可以直接接&lt;<strong>Label</strong>&gt;也可以接&lt;<strong>*被调用者的起始地址</strong>&gt;来间接调用。</li>
<li>call指令会将后一条指令的地址压栈，并将PC(%rip)设置为被调用者的起始地址。</li>
<li>ret指令会保存弹出栈的值，并将PC(%rip)设置为这个值。</li>
</ul>
</li>
</ul>
<h3 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h3><ul>
<li>当参数的数目小于等于六个时，全部参数通过寄存器传递。调用者在执行call指令之前需要将实参填充到对应的寄存器中，被调用者需要使用参数时则只需从寄存器中取数据。</li>
<li>若参数的数目大于六个，多余的数据压入运行时栈。<ul>
<li>所有数据的以八字节(四字)为最小单位存储。</li>
<li>参数的顺序是越靠近栈顶的参数越靠后。被调用者可以通过栈顶指针运算来访问这些参数。</li>
<li>参数区域在返回地址区域之前，所以访问时要从 %rsp+8 开始访问。</li>
</ul>
</li>
</ul>
<h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>有些时候，寄存器不足以满足过程的需要，因此需要在运行时栈上位局部变量分配内存：</p>
<ol>
<li>寄存器不够用</li>
<li>对一个局部变量进行取地址操作，此时这个局部变量必须有内存地址</li>
<li>局部变量是数组或结构体</li>
</ol>
<ul>
<li>分配局部内存的方式<ol>
<li>减小栈顶指针%rsp的值</li>
<li>将局部变量的值填充入因为栈顶指针减小而多出来的栈空间内</li>
<li>通过栈顶指针运算访问局部变量</li>
<li>在ret执行之前增大栈顶指针的值，释放内存</li>
</ol>
</li>
</ul>
<h3 id="寄存器使用"><a href="#寄存器使用" class="headerlink" title="寄存器使用"></a>寄存器使用</h3><p>为了避免不同过程中新的寄存器值覆盖旧的寄存器值带来损失，x86-64有一套寄存器使用规范。</p>
<ul>
<li>被调用者保存寄存器：%rbx,%rbp,%r12~%r15<ul>
<li>被调用者有义务在自身返回时保证这些寄存器的值与被调用时相同。</li>
<li>被调用者可以选择不改变这些寄存器中的值。</li>
<li>如果必须改变，可以先将其值压栈，在返回前再将旧值从栈中取回寄存器中。</li>
<li>压栈的寄存器值所处的部分称为“保存的寄存器”部分，位于局部变量区域之前。</li>
</ul>
</li>
<li>调用者保存寄存器：除%rsp以外的其他寄存器<ul>
<li>任何过程都可以修改这些寄存器的值。</li>
</ul>
</li>
</ul>
<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><p>由于函数栈的性质，递归调用自身和调用其他函数并没有什么区别，递归的实现可谓水到渠成。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>C语言的数组实现与汇编语言相当接近，因此可以使用头指针和内存运算方便地实现数组。</p>
<ul>
<li>数组元素a[i+j]的汇编形式：j(a,i,q)<ul>
<li>a为储存着数组头指针的寄存器或内存位置</li>
<li>i为变量，可以是循环变量</li>
<li>q是数组元素的数据类型大小，可以用sizeof得出</li>
<li>j是常数，用于定址索引</li>
</ul>
</li>
<li>高维数组的储存<ul>
<li>C语言对高维数组采取行优先的线性存储。</li>
<li>对于大小为R行C列的数组a来说，a[i][j]的地址应该是(i<em>C+j)</em>size + a</li>
</ul>
</li>
<li>对变长数组的处理<ul>
<li>由于数组存储的线性性，不事先知道数组的列数就无法表达第二行开始的数组元素。</li>
<li>因此需要将数组的大小n也作为参数传入才能处理</li>
</ul>
</li>
</ul>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构的各个字段通过结构的头指针和字段大小构成的偏移量来访问。机器代码不包含关于字段名字或者字段声明的信息。</p>
<p>联合同理，只不过结构在访问字段时其指针偏移量需要加上该字段前面所有字段的偏移量，而联合每个字段都以联合的头指针为起点。</p>
<p>.align &lt; num &gt; 这个指令可以保证指令后的数据都以num个字节为单位进行数据对齐。</p>
<h2 id="内存越界引用和缓冲区溢出"><a href="#内存越界引用和缓冲区溢出" class="headerlink" title="内存越界引用和缓冲区溢出"></a>内存越界引用和缓冲区溢出</h2><p>为了对抗Buffer attack，内存系统的设计者使用了这样几种机制：</p>
<h3 id="地址空间布局随机化"><a href="#地址空间布局随机化" class="headerlink" title="地址空间布局随机化"></a>地址空间布局随机化</h3><p>采用这种方式，每次运行时程序所使用的运行时栈，堆内存，全局变量区以及代码段都会随机被储存在内存的不同区域，这样就避免了一些简单而重复的攻击</p>
<p>针对这种机制，黑客可以在攻击代码之前插入一段很长的nop操作，这样只要随机化过的栈地址与这段nop操作有重合，程序的执行就会沿着这一系列的nop滑到攻击代码。</p>
<h3 id="栈破坏检测"><a href="#栈破坏检测" class="headerlink" title="栈破坏检测"></a>栈破坏检测</h3><p>程序在每次运行时首先随机产生一个canary值，并储存在栈帧中一个空余的位置(一般在变量区之后)。在返回之前，程序会取出并检查这个canary有没有被改变。如果被改变了，那么程序会异常中止。</p>
<p>GCC会根据一个函数是否容易被进行栈溢出攻击来决定是否要进行这种检测。如果不想使用这种检测，可以在编译时加上-fno-stack-protector选项。</p>
<h3 id="限制可执行代码区域"><a href="#限制可执行代码区域" class="headerlink" title="限制可执行代码区域"></a>限制可执行代码区域</h3><p>将只需要读写的内存区和可执行的内存区分开，可以有效避免注入攻击。</p>
<h2 id="浮点数操作"><a href="#浮点数操作" class="headerlink" title="浮点数操作"></a>浮点数操作</h2><h3 id="浮点数使用的寄存器"><a href="#浮点数使用的寄存器" class="headerlink" title="浮点数使用的寄存器"></a>浮点数使用的寄存器</h3><p>AVX浮点体系结构允许浮点数储存在16个YMM浮点数寄存器中。</p>
<ul>
<li>16个寄存器的名称分别为ymm0-ymm15，长度均为32个字节。但是float只使用最低的四个字节，double只使用最低的八个字节。</li>
<li>汇编代码通常用xmm0-15来引用这些寄存器。xmm是ymm的后16个字节。</li>
</ul>
<h3 id="浮点数的操作命令"><a href="#浮点数的操作命令" class="headerlink" title="浮点数的操作命令"></a>浮点数的操作命令</h3><ul>
<li>移动操作<ul>
<li>vmovss - 移动单精度数</li>
<li>vmovsd - 移动双精度数</li>
<li>vmovaps，vmovapd - 移动封装好的已经对齐的单精度（双精度）数，一般用于寄存器之间的传送</li>
</ul>
</li>
<li>转换操作<ul>
<li>vcvttss2si - 单精度数转整数</li>
<li>vcvttsd2si - 双精度数转整数<ul>
<li>第一个操作数是储存浮点数的寄存器，第二个操作数是储存结果整数的寄存器。</li>
<li>这两个操作会进行自动的 <strong>截断</strong> 而非四舍五入。</li>
<li>转成四字整数只需要在指令后面加后缀q即可</li>
</ul>
</li>
<li>vcvtsi2ss - 整数转单精度数</li>
<li>vcvtsi2sd - 整数转双精度数<ul>
<li>这两个操作是三操作数操作，前一个是整数寄存器，后两个一般写同一个浮点寄存器。</li>
</ul>
</li>
<li>vunpcklps，vmovddup - 交叉存放两个寄存器中的字</li>
<li>vcvtpd2psx，vcvtps2pd - 单双精度之间的转换</li>
</ul>
</li>
<li>算术运算<ul>
<li>算术运算是由运算名和后缀组成的。<ul>
<li>运算名代表运算的种类：<ul>
<li>vadd：加法</li>
<li>vdiv：减法</li>
<li>vmul：乘法</li>
<li>vdiv：除法</li>
<li>vmax：最大</li>
<li>vmin：最小</li>
<li>sqrt：开方</li>
</ul>
</li>
<li>后缀：ss表示单精度操作，sd表示双精度操作</li>
</ul>
</li>
<li>操作数的数量视操作而定。除了开方之外，所有操作都有三个操作数：前两个进行运算，结果存在第三个中。</li>
</ul>
</li>
<li>位运算<ul>
<li>vxorps，vxorpd 位级异或</li>
<li>vandps，vandpd 位级与</li>
<li>位级操作是同时对两个寄存器中的所有128位同时进行进行操作，并将结果储存在第三个操作数中</li>
</ul>
</li>
<li>比较操作<ul>
<li>vucomiss 单精度比较操作，结果是S2-S1</li>
<li>vucomisd 双精度比较操作，结果一样</li>
<li>jp 当比较的对象不可以比较时跳转</li>
</ul>
</li>
</ul>
<h3 id="过程中的浮点数"><a href="#过程中的浮点数" class="headerlink" title="过程中的浮点数"></a>过程中的浮点数</h3><ul>
<li>浮点数使用 <strong>%xmm0</strong> 来储存返回值</li>
<li>浮点数的传参最大数量是 <strong>八</strong> 个，多出的参数要出存在栈中</li>
<li>所有xmm寄存器都是调用者保存的</li>
<li><strong>浮点常数</strong>的定义和使用<ul>
<li>编译器必须为所有的浮点数常量值分配内存空间，然后代码从内存空间读入。</li>
</ul>
</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Doubletest:</span></span><br><span class="line">    <span class="keyword">vmulsd</span> .LC0(%rip),%xmm0,%xmm0 </span><br><span class="line">    # 通过程序计数器和标号的结合去引用内存中的浮点数常量</span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line"><span class="symbol">.LC0:</span></span><br><span class="line"><span class="meta">    .long</span> <span class="number">3435973837</span>                    # double低位<span class="number">4</span>字节的十进制表示</span><br><span class="line"><span class="meta">    .long</span> <span class="number">1073532108</span>                    # double高位<span class="number">4</span>字节的十进制表示</span><br><span class="line"><span class="symbol">Floattest:</span></span><br><span class="line">    <span class="keyword">vmulss</span> .LC1(%rip),%xmm1,%xmm0</span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line"><span class="symbol">.LC1:</span></span><br><span class="line"><span class="meta">    .long</span> <span class="number">1065353216</span>                    # <span class="meta">float</span>编码的十进制表示</span><br></pre></td></tr></table></figure>
<h1 id="Chapter-4-处理器体系结构"><a href="#Chapter-4-处理器体系结构" class="headerlink" title="Chapter 4 处理器体系结构"></a>Chapter 4 处理器体系结构</h1><p>处理器要处理的指令被编码为由一个或者多个字节序列组成的二进制格式。一个处理器支持的 <strong>指令集和指令的编码方式</strong> 称为这个处理器的 <strong>指令集体系结构(ISA)</strong> 。</p>
<p>不同的处理器家族所使用的ISA是不兼容的，但是同一家族内的各型号处理器一般使用同种ISA。</p>
<p>在本教材中，我们使用一种比较简单的指令集，称为Y86-64.</p>
<h2 id="Y86-64-ISA"><a href="#Y86-64-ISA" class="headerlink" title="Y86-64 ISA"></a>Y86-64 ISA</h2><h3 id="程序员可见的状态"><a href="#程序员可见的状态" class="headerlink" title="程序员可见的状态"></a>程序员可见的状态</h3><p>指令集能够修改与读取的那些处理器组成部分称为 <strong>程序员可见状态</strong> 。</p>
<ul>
<li>Y86-64的状态包括以下部分：<ul>
<li><strong>15个64位寄存器</strong>：比x86-64少了一个%r15</li>
<li><strong>程序计数器PC</strong>：存放当前指令的地址</li>
<li><strong>条件码CC</strong>：有三个条件码，比x86-64少了进位符CF</li>
<li><strong>内存</strong>：用 <strong>虚拟地址</strong> 引用内存位置，它是物理地址的一组字节映像。</li>
<li><strong>程序状态码</strong>：用来处理程序异常以防系统崩溃</li>
</ul>
</li>
</ul>
<h3 id="Y86-64指令集"><a href="#Y86-64指令集" class="headerlink" title="Y86-64指令集"></a>Y86-64指令集</h3><p>由于Y86-64是简化版的x86-64指令集，因此有很多限制。</p>
<ul>
<li>只能操作 <strong>八字节大小的整数</strong></li>
<li>寻址方式：基址+偏移量，不支持变址寻址，更不支持变址伸缩</li>
<li>不允许在内存地址之间移动数据，不允许将立即数直接写入内存</li>
<li>x86-64的限制它也一样具有</li>
</ul>
<p>我们需要实现以下指令：</p>
<ul>
<li>移动指令(movq被分成了四个单独的指令)<ul>
<li>irmovq 获取一个立即数(立即数移动到寄存器)</li>
<li>rrmovq 寄存器间的值传递</li>
<li>mrmovq 从内存中读数据</li>
<li>rmmovq 向内存中写数据</li>
</ul>
</li>
<li>条件和运算指令：操作数只能是寄存器，不能是内存寻址<ul>
<li>addq</li>
<li>subq</li>
<li>andq</li>
<li>xorq</li>
</ul>
</li>
<li>跳转指令(由于条件码少了一个CF，无符号数的比较无法实现)<ul>
<li>jmp 直接跳转</li>
<li>jle &lt;=</li>
<li>jl &lt;</li>
<li>je =</li>
<li>jne !=</li>
<li>jge &gt;=</li>
<li>jg &gt;</li>
</ul>
</li>
<li>条件传送指令(同样不支持无符号数)</li>
<li>函数调用指令<ul>
<li>call 返回地址入栈并将PC的值设为目标地址</li>
<li>ret 返回地址出栈并将PC的值设为返回地址</li>
</ul>
</li>
<li>程序栈操作指令<ul>
<li>pushq</li>
<li>popq</li>
</ul>
</li>
<li>停止指令：停止指令的执行<ul>
<li>halt 处理器停止，状态码设置为HLT</li>
</ul>
</li>
</ul>
<h3 id="指令集编码"><a href="#指令集编码" class="headerlink" title="指令集编码"></a>指令集编码</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> 指令名 操作数 操作数<span class="number">2</span>    指令编码</span><br><span class="line">halt                    <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">nop</span>                     <span class="number">1</span> <span class="number">0</span></span><br><span class="line">rrmovq  rA    rB        <span class="number">2</span> <span class="number">0</span>    rA   rB</span><br><span class="line">irmovq  V     rB        <span class="number">3</span> <span class="number">0</span>    <span class="number">0xF</span>  rB      V</span><br><span class="line">rmmovq  rA    D(rB)     <span class="number">4</span> <span class="number">0</span>    rA   rB      D</span><br><span class="line">mrmovq  D(rA) rB        <span class="number">5</span> <span class="number">0</span>    rA   rB      D</span><br><span class="line">OPq     rA    rB        <span class="number">6</span> fn   rA   rB</span><br><span class="line">jXX     Dir             <span class="number">7</span> fn   Dir</span><br><span class="line">cmovXX  rA    rB        <span class="number">2</span> fn   rA   rB</span><br><span class="line"><span class="keyword">call</span>    Dir             <span class="number">8</span> <span class="number">0</span>    Dir</span><br><span class="line"><span class="keyword">ret</span>                     <span class="number">9</span> <span class="number">0</span></span><br><span class="line">pushq   rA              A <span class="number">0</span>    rA   <span class="number">0xF</span></span><br><span class="line">popq    rA              B <span class="number">0</span>    rA   <span class="number">0xF</span></span><br><span class="line"></span><br><span class="line">附注</span><br><span class="line">fn：编码的功能部分(见附表：指令集功能码表)</span><br><span class="line">rA，rB：寄存器(见下面的寄存器码)</span><br><span class="line">Dir：<span class="keyword">jmp</span>类和<span class="keyword">call</span>指令的目标地址</span><br><span class="line">D：偏移量</span><br><span class="line">V：立即数</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">指令集功能码表</span><br><span class="line">OPq类</span><br><span class="line">  addq      60</span><br><span class="line">  subq      61</span><br><span class="line">  andq      62</span><br><span class="line">  xorq      63</span><br><span class="line">jXX类</span><br><span class="line">  jmp       70</span><br><span class="line">  jle       71</span><br><span class="line">  jl        72</span><br><span class="line">  je        73</span><br><span class="line">  jne       74</span><br><span class="line">  jge       75</span><br><span class="line">  jg        76</span><br><span class="line">cmov类</span><br><span class="line">  rrmovq    20</span><br><span class="line">  cmovle    21</span><br><span class="line">  cmovl     22</span><br><span class="line">  cmove     23</span><br><span class="line">  cmovne    24</span><br><span class="line">  cmovge    25</span><br><span class="line">  cmovg     26</span><br></pre></td></tr></table></figure>
<h4 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h4><ul>
<li>每条指令的第一个字节表明指令的具体类型<ul>
<li>前四位是 <strong>代码部分</strong> ，表示指令的种类</li>
<li>后四位是 <strong>功能部分</strong> ，表示指令是大类中的哪一个</li>
</ul>
</li>
<li>rA和rB都是寄存器，用一个范围在0到E之间的 <strong>寄存器标识符</strong> 表示。<ul>
<li>%rax—0</li>
<li>%rcx—1</li>
<li>%rdx—2</li>
<li>%rbx—3</li>
<li>%rsp—4</li>
<li>%rbp—5</li>
<li>%rsi—6</li>
<li>%rdi—7</li>
<li>%r8—-8</li>
<li>%r9—-9</li>
<li>%r10—A</li>
<li>%r11—B</li>
<li>%12—-C</li>
<li>%r13—D</li>
<li>%r14—E</li>
<li>不需要–F</li>
</ul>
</li>
<li>由于小端序的问题，八字节长的立即数，偏移量和地址都要反序书写。也就是说一个指令(以rmmovq $0x12345678,%rax为例)的完整编码是 40 F0 78 56 34 12 00 00 00 00.</li>
</ul>
<h4 id="RISC与CISC"><a href="#RISC与CISC" class="headerlink" title="RISC与CISC"></a>RISC与CISC</h4><p>CISC，也就是复杂指令集计算机，是比较早发展起来的一种计算机。它们的指令集比较庞大，指令类型多样，功能强大，对硬件的要求和复杂度都很高。为了开发一种能用较少硬件实现的指令集，RISC(精简指令集计算机)成为了人们的研究对象。</p>
<p>RISC的主要特点是指令少而简单，编码方式固定(所有指令都用4字节编码)，寻址方式简单，因而执行速度很快，对硬件要求很小。但因为本来应该由条件码和内存引用承担的一部分工作现在要全部让寄存器来承担，所以这种指令集需要很多性能优良的寄存器，最多有32个。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul>
<li>状态码可能的值<ul>
<li>AOK—1：表示程序运行正常</li>
<li>HLT—2：执行了halt指令</li>
<li>ADR—3：遇到了非法地址</li>
<li>INS—4：执行了非法指令</li>
</ul>
</li>
</ul>
<p>在遇到异常的时候，完善的架构会调用一个异常处理函数来处理特定的异常。但在Y86-64这里，我们只简单地让程序停止运行。</p>
<h3 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h3><p>以“.”开头的词是汇编器伪指令。它们用来告知汇编器调整地址。</p>
<ul>
<li>标号的作用<ul>
<li>在汇编语言程序中，不缩进而后跟冒号的 <strong>标号</strong> 用以指定一个内存地址。通过引用这个标号，指令可以获得这个标号所在代码段位置的内存地址。</li>
</ul>
</li>
<li>汇编器伪指令<ul>
<li>.pos &lt; addr &gt; 指定一个地址，这条指令之后的代码从这个地址开始存放。</li>
<li>.align &lt; num &gt; 指定对齐方式</li>
</ul>
</li>
</ul>
<h2 id="硬件控制语言HCL"><a href="#硬件控制语言HCL" class="headerlink" title="硬件控制语言HCL"></a>硬件控制语言HCL</h2><p>要实现一个数字系统，需要三个主要的组成部分：<strong>位运算函数的组合逻辑</strong>，<strong>存储位的存储器单元</strong>，<strong>以及更新存储位信息的时钟信号</strong>。</p>
<p><strong>HDL</strong> 是描述硬件的一种文本表示，典型的例子是Verilog语言，其语法类似于C。而 <strong>HCL</strong> 只表达硬件的控制部分，需要翻译成Verilog之后结合一些其他Verilog代码来产生HDL描述，从而生成对应的硬件。</p>
<h3 id="逻辑门和组合电路"><a href="#逻辑门和组合电路" class="headerlink" title="逻辑门和组合电路"></a>逻辑门和组合电路</h3><p>将很多逻辑门组合在一起，就可以构成 <strong>计算块</strong> ，称为 <strong>组合电路</strong> 。</p>
<ul>
<li>构建这样的电路有几个限制：<ul>
<li>每个逻辑门的输入必须连接到以下选项之一：<ul>
<li>系统输入</li>
<li>某个存储单元的输出</li>
<li>某个逻辑门的输出</li>
</ul>
</li>
<li>逻辑门的输出不能连接在一起，否则可能造成信号紊乱。</li>
<li>这个网必须是无环的。</li>
</ul>
</li>
</ul>
<p>我们可以通过构造HCL表达式的方式来设计这样的组合电路。例如：</p>
<ul>
<li>位相等判断器：(a&amp;&amp;b)||(!a&amp;&amp;!b)</li>
<li>多路复用器(选择器):(s&amp;&amp;a)||(!s&amp;&amp;b)</li>
</ul>
<p>HCL表达式与C表达式的区别：</p>
<ul>
<li>HCL表达式只对单个位进行操作，可能的值只有0和1,可能的操作只有与或非，因此情况简单，需要进行的操作比较少；而C中的True可以是任一个非0的数，且同时操作一整个字，这样要达到相同的功能就会更加复杂(见datalab中的多路复用器位实现)</li>
<li>HCL表达式的变量和值都是动态更新的</li>
<li>C表达式有部分求值的特性，而HCL没有。</li>
</ul>
<h3 id="字级别的组合电路"><a href="#字级别的组合电路" class="headerlink" title="字级别的组合电路"></a>字级别的组合电路</h3><p>在HCL语言中，我们把表达式定义为 <strong><em>bool</em></strong> 型，而字级的 <strong>信号</strong> 不论大小都为 <strong><em>int</em></strong> 型。</p>
<p>在画字级电路时，用虚线表示布尔信号结果，而用中等粗度的线表示携带字的每个位的线路。</p>
<p><strong>多路复用函数</strong>是用 <strong>情况表达式</strong> 来描述的。其通用格式如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">word Out = [</span><br><span class="line">    select_1 : expr_1;</span><br><span class="line">    select_2 : expr_2;</span><br><span class="line">    ...</span><br><span class="line">    select_k : expr_k;</span><br><span class="line">    <span class="number">1</span>        : expr_default     <span class="comment"># 如果前面的都没选中则执行这个</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>与C中的多路复用不同的是，这里只要有一个条件满足就会跳过剩下的。</p>
<p><strong>算术逻辑单元</strong>(ALU)是一种很重要的组合电路。它有一组控制输入和一组参数输入，根据控制输入的不同，ALU会对参数做不同的操作，然后输出结果。</p>
<h3 id="集合关系"><a href="#集合关系" class="headerlink" title="集合关系"></a>集合关系</h3><p>判断集合关系的通用格式是: <strong>iexpr in {expr1,…exprn}</strong></p>
<p>如果iexpr在集合内有出现，则表达式的值为真，否则为假。</p>
<h3 id="存储器与时钟"><a href="#存储器与时钟" class="headerlink" title="存储器与时钟"></a>存储器与时钟</h3><p>组合电路只会接受输入，传送输出而不会存储任何信息。因此，为了产生 <strong>时序电路</strong> ，必须引入按位存储信息的设备。</p>
<ul>
<li>存储器设备<ul>
<li>寄存器(这里指硬件上的物理寄存器) ：是CPU的一部分，存储单个位或者单个字。<ul>
<li>寄存器的值随着时钟周期更新。</li>
</ul>
</li>
<li>随机访问存储器 ：存储多个字，用地址来决定读写哪个字。具体的例子包括：<ul>
<li>处理器的 <strong>虚拟内存系统</strong> (也就是我们通常讲的内存):操作系统辅助硬件使CPU能够访问一个很大地址空间中的任意一个字。<ul>
<li>在需要读得时候，将write位输入设为0，将address字设置好，等一个时钟周期，在时钟发信号之后就可以在data字接收到输出。如果出现错误，error位会设为1,否则为0.</li>
<li>在需要写的时候，将write位输入设为1，同样地设置address值，并设置输入值到data，等一个时钟周期，再查看error位有没有出现错误。</li>
</ul>
</li>
<li><strong>寄存器文件</strong>(就是我们通常说的寄存器的总和)：由所有物理寄存器组成的寄存器阵列构成。<ul>
<li>寄存器文件被划分为数个 <strong>程序寄存器</strong> 。这些程序寄存器的 <strong>标识符</strong> 就代表着它们在寄存器文件中的地址。</li>
<li>寄存器文件有两个 <strong>读端口</strong> 和一个 <strong>写端口</strong> 。每个端口都有一个地址输入(用来指定程序寄存器)，另外读端口还有一个读数据输出，写端口还有一个写数据输入。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Y86-64的顺序实现"><a href="#Y86-64的顺序实现" class="headerlink" title="Y86-64的顺序实现"></a>Y86-64的顺序实现</h2><p><strong>顺序实现处理器</strong>(<strong>SEQ</strong>)是非常低效的，因为它要在一个时钟周期内完成一条指令的全部步骤。但是，SEQ是开发流水线化处理器必不可少的一个中间过程。</p>
<h3 id="将指令划分阶段"><a href="#将指令划分阶段" class="headerlink" title="将指令划分阶段"></a>将指令划分阶段</h3><p>绝大部分指令都遵循以下的操作序列：</p>
<ul>
<li><strong>取指令</strong>(fetch)：根据程序计数器的值从内存中读取指令内容。<ul>
<li>首先读取代表指令种类的两个四位部分，辨别指令类型</li>
<li>根据指令类型决定的数据长度读取剩下的数据。</li>
</ul>
</li>
<li><strong>译码</strong>(decode)：这个阶段从寄存器文件读入至多两个操作数。</li>
<li><strong>执行</strong>(execute)：<strong>算术逻辑单元</strong>执行指令，进行数学和逻辑运算，改变栈指针，设置或检验条件码。</li>
<li><strong>访存</strong>(memory)：将运算结果写入内存或从内存读出数据。</li>
<li><strong>回写</strong>(writeback)：写入最多两个数据到寄存器文件</li>
<li><strong>更新PC</strong>(update)：更新程序寄存器的值</li>
</ul>
<h3 id="SEQ硬件结构"><a href="#SEQ硬件结构" class="headerlink" title="SEQ硬件结构"></a>SEQ硬件结构</h3><p>采用SEQ顺序式设计，时基发生器需要将一条指令整个完成的时间作为时钟周期。</p>
<h4 id="硬件对指令六个步骤的配合"><a href="#硬件对指令六个步骤的配合" class="headerlink" title="硬件对指令六个步骤的配合"></a>硬件对指令六个步骤的配合</h4><ul>
<li>取指令：<ul>
<li>读程序计数器的值，以其为地址取内存中保存的指令。</li>
<li>PC增加器同时计算下一条指令的地址valP并保存。</li>
</ul>
</li>
<li>译码：寄存器文件有两个读端口，从这两个端口分别读入两个寄存器的值<ul>
<li>两个端口的设计保证了这一步骤能够在一个时钟周期内完成</li>
</ul>
</li>
<li>执行：ALU接受输入，进行操作，传递输出<ul>
<li>由于Y86-64的计算命令过于简单，所有操作能在一个时钟周期内完成。</li>
</ul>
</li>
<li>访存：从数据内存读入或者写出一个内存字</li>
<li>写回：寄存器文件有两个写端口<ul>
<li>一个用来写入ALU的计算结果</li>
<li>一个用来写入从内存中读出的值</li>
</ul>
</li>
<li>PC更新：程序计数器的新值可能是：<ul>
<li>下一条指令的地址valP(一般情况)</li>
<li>jXX或call指令指定的指令地址(指令是call或jXX时)</li>
<li>从内存读入的返回地址(指令是ret时)</li>
</ul>
</li>
</ul>
<h4 id="SEQ时序控制"><a href="#SEQ时序控制" class="headerlink" title="SEQ时序控制"></a>SEQ时序控制</h4><p>SEQ的实现包括 <strong>组合逻辑</strong> 和 <strong>两种存储器</strong>(时钟寄存器和随机访问存储器)。</p>
<p>组合逻辑不需要时序控制，只要输入产生变化，变化会以光速通过逻辑网进行传播。在小型电路中，对指令内存的访问可以看成和组合逻辑一样的操作；而大型电路可以使用特殊的时基发生器来达到类似的效果。</p>
<p>而对于程序计数器，条件码寄存器，数据内存和寄存器文件，它们通过一个时钟信号来控制，这个信号会触发向寄存器和数据内存的写操作。</p>
<p>组织计算有一个原则：<strong>从不回读</strong>，也就是处理器不需要为了完成一条指令而去读因为这条指令更新过的状态。</p>
<p>如pushq指令，它既要使用%rsp的值又要更新%rsp的值，这种情况下为了这个原则要把使用这个步骤放在更新前面。分步来看，首先在执行阶段指令计算%rsp+8并保存，然后访存阶段用%rsp的值去写内存，写回阶段再将%rsp+8的值写回%rsp中。</p>
<p>另外的一个例子是CC的更新。没有指令会同时改变CC的值和使用CC的值，因此任何指令试图读CC的之后它的值都是已经更新的。</p>
<h4 id="SEQ的HCL实现"><a href="#SEQ的HCL实现" class="headerlink" title="SEQ的HCL实现"></a>SEQ的HCL实现</h4><ul>
<li>用作HCL参数的常数预定义<ul>
<li>指令代码<ul>
<li>IHALT</li>
<li>INOP</li>
<li>IRRMOVQ</li>
<li>IIRMOVQ</li>
<li>IRMMOVQ</li>
<li>IMRMOVQ</li>
<li>IOPL</li>
<li>IJXX</li>
<li>ICALL</li>
<li>IRET</li>
<li>IPUSHQ</li>
<li>IPOPQ</li>
</ul>
</li>
<li>FNONE 默认功能码</li>
<li>寄存器<ul>
<li>RRSP %rsp的寄存器ID</li>
<li>RNONE 表示无寄存器参与</li>
</ul>
</li>
<li>ALUADD 加法运算的功能</li>
<li>状态码<ul>
<li>SAOK 正常</li>
<li>SADR 地址异常</li>
<li>SINS 操作异常</li>
<li>SHLT Halt</li>
</ul>
</li>
</ul>
</li>
<li>取指令<ul>
<li>以PC为起始地址，从内存中读出10个字节<ul>
<li>如果地址不合法，就舍弃后9个字节，并将第一个字节设置为nop指令，同时产生一个 <strong>imem_error信号</strong> ，传递到下一步骤</li>
</ul>
</li>
<li>从第一个字节中取得icode与ifun值，并进行一系列逻辑判断，判断结果传递至下一步骤<ul>
<li><strong>instr_valid</strong>：该指令是否为合法的Y86-64指令</li>
<li><strong>need_regids</strong>：该指令是否包含寄存器字节</li>
<li><strong>need_valC</strong>：该指令是否包含常数字</li>
<li>这三个判断使用一个HCL中的 <strong>集合关系判断</strong> 就可以实现。</li>
</ul>
</li>
<li>根据icode与ifun值产生 <strong>alufun</strong> 信号并传递到执行阶段</li>
<li>标号为“<strong>Align</strong>”的硬件单元处理后面的九个字节<ul>
<li>if need_regids : 将第二个字节分开分别放入 <strong>rA</strong> 和 <strong>rB</strong> 指示符，后八个字节作为常数字</li>
<li>else : 将第二个到第九个字节作为常数字</li>
</ul>
</li>
<li><strong>PC增加器</strong>计算生成valP<ul>
<li>PC值为p，need_rigids值为r，need_valC值为c</li>
<li>则valP = p + r + 8c + 1</li>
</ul>
</li>
</ul>
</li>
<li>译码和写回阶段<ul>
<li>寄存器文件的两个读端口和两个写端口都各有两个输入(或一个输入一个输出)：一个地址输入表示寄存器的编号，一个数据输入输出表示读写的数据。两个读端口的地址输入是 <strong>srcA</strong> 和 <strong>srcB</strong> ，两个写端口则是 <strong>dstE</strong> 和 <strong>dstM</strong> (分别存放计算结果和内存中取出的值)。</li>
<li>根据icode值，通过逻辑控制填入两个读端口(或者写端口)的地址输入</li>
<li>当遇到popq %rsp指令时，两个写端口的目标将会是同一个寄存器。这时需要在两个写端口之间确定一个优先级。为了让从内存中读出的值能存到%rsp，让 <strong>dstM优先级更高</strong> ，也就是冲突的时候不写入dstE。</li>
</ul>
</li>
<li>执行阶段<ul>
<li>将两个操作数填入ALU<ul>
<li>前一个操作数填valB</li>
<li>后一个操作数根据情况填valA或常数C或8，-8</li>
</ul>
</li>
<li>产生一个信号 <strong>set_cc</strong> 判断操作是否为OPq，不是则没必要更新条件码寄存器。</li>
<li>标号为“<strong>cond</strong>”的硬件单元根据条件码CC和icode，ifun值判断是否需要跳转或条件传送。判断结果作为一个 <strong>Cnd信号</strong> 传递给下一个步骤</li>
<li>ALU进行计算，计算结果是 <strong>valE</strong></li>
</ul>
</li>
<li>访存阶段<ul>
<li>读写控制模块根据icode的值判断是应该读还是应该写。</li>
<li>地址控制模块根据icode的值判断内存地址是valA还是valE</li>
<li>数据控制模块根据icode的值判断数据是valA还是valP(返回地址)</li>
<li>进行读写操作，读出的值为 <strong>valM</strong></li>
<li>根据数据内存产生的 <strong>dmem_error</strong> 信号及之前产生的三种信号设置程序的stat状态码</li>
</ul>
</li>
<li>更新PC阶段<ul>
<li>控制模块根据Cnd信号和icode值判断采用valC，valM，valP中的哪一个作为新的PC值</li>
</ul>
</li>
</ul>
<p>SEQ的HCL实现：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于HCL语言不像HDL那样有着对硬件本身的封装，这里使用一些类似于类的语法来表示硬件</span></span><br><span class="line"><span class="comment"># 程序开始运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取指令</span></span><br><span class="line"></span><br><span class="line">word p = PC.read(); <span class="comment"># 读出PC中的值</span></span><br><span class="line"><span class="keyword">if</span> p == SADR：</span><br><span class="line">    word ins = INOP;</span><br><span class="line">    bool imem_error = <span class="number">1</span>;</span><br><span class="line">    <span class="comment"># 如果PC中储存的地址不合法，产生imem_error信号并将指令设置为nop</span></span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">    word ins = MEM.read(baseptr=p,size=<span class="number">10</span>); <span class="comment"># 以p为基址在内存中读出10个字节</span></span><br><span class="line">    int icode,int ifun = SPLIT.split(ins[<span class="number">0</span>]); <span class="comment"># 指令的第一个字节被split硬件单元解析</span></span><br><span class="line">    bool instr_valid = ***;</span><br><span class="line">    <span class="comment"># 这个判断就是依次判断每个可能的icode对应的ifun是否符合，过于长这里不写了</span></span><br><span class="line">    bool need_regids = </span><br><span class="line">        icode <span class="keyword">in</span> &#123;IRRMOVQ,IIRMOVQ,IMRMOVQ,IRMMOVQ,IOPQ,IPUSHQ,IPOPQ&#125;;</span><br><span class="line">    bool need_valC = </span><br><span class="line">        icode <span class="keyword">in</span> &#123;IIRMOVQ,IMRMOVQ,IRMMOVQ,IJXX,ICALL&#125;;</span><br><span class="line">    <span class="comment"># 这两个判断看一下哪些指令需要常数字段和寄存器字段就好了</span></span><br><span class="line">    <span class="keyword">if</span> need_regids：</span><br><span class="line">        int rA,int rB = ALIGN.align(ins[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> need_valC：</span><br><span class="line">            word valC = ALIGN.align(ins[<span class="number">2</span>:<span class="number">10</span>]);</span><br><span class="line">        <span class="comment"># 如果指令需要寄存器就从第二个字节中读出</span></span><br><span class="line">        <span class="comment"># valC同理，都由align硬件单元读出</span></span><br><span class="line">    <span class="keyword">else</span>：</span><br><span class="line">        int rA = <span class="number">0xF</span>;</span><br><span class="line">        int rB = <span class="number">0xF</span>;</span><br><span class="line">        <span class="keyword">if</span> need_valC：</span><br><span class="line">            word valC = ALIGN.align(ins[<span class="number">1</span>:<span class="number">9</span>]);</span><br><span class="line">        <span class="comment"># 反之，如果不需要寄存器就将两个寄存器值都设为0xF，即无寄存器</span></span><br><span class="line">        <span class="comment"># 这样valC就会存放在指令的2到9字节。</span></span><br><span class="line">    word valP = p + need_regids + <span class="number">8</span>*need_valC;</span><br><span class="line">    <span class="comment"># valP代表下一条指令的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 译码</span></span><br><span class="line"></span><br><span class="line">word srcA = [</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IRRMOVQ,IMRMOVQ,IOPQ,IPUSHQ&#125; : rA;</span><br><span class="line">    <span class="comment"># 需要读rA寄存器的值时</span></span><br><span class="line">    icode <span class="keyword">in</span> &#123;IPOPQ,IRET&#125; : RRSP;</span><br><span class="line">    <span class="comment"># 这里与后面访存阶段的访问联系</span></span><br><span class="line">    <span class="number">1</span> : RNONE;</span><br><span class="line">    <span class="comment"># 默认情况是没有寄存器需求</span></span><br><span class="line">]; <span class="comment"># srcA一般用来提供运算的第二个参数</span></span><br><span class="line"></span><br><span class="line">word srcB = [</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IRMMOVQ,IOPQ&#125; : rB;</span><br><span class="line">    <span class="comment"># 需要读rB寄存器的值时</span></span><br><span class="line">    icode <span class="keyword">in</span> &#123;IPUSHQ,IPOPQ,ICALL,IRET&#125; : RRSP;</span><br><span class="line">    <span class="number">1</span> : RNONE;</span><br><span class="line">]; <span class="comment"># srcB提供运算的主参数与rsp地址信息</span></span><br><span class="line"></span><br><span class="line">word valA = REG.read(srcA);</span><br><span class="line">word valB = REG.read(srcB);</span><br><span class="line"><span class="comment"># 从寄存器文件中读出对应的值并保存为valA和valB</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line"></span><br><span class="line">word aluA = [</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IRRMOVQ,IOPQ&#125; : valA;</span><br><span class="line">    <span class="comment"># 寄存器rA的值直接作操作数</span></span><br><span class="line">    icode <span class="keyword">in</span> &#123;IIRMOVQ,IMRMOVQ,IRMMOVQ&#125; : valC;</span><br><span class="line">    <span class="comment"># 内存与寄存器之间的移动需要计算地址加偏移量，所以将valC作操作数</span></span><br><span class="line">    icode <span class="keyword">in</span> &#123;ICALL,IPUSHQ&#125; : <span class="number">-8</span>;</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IRET,IPOPQ&#125; : <span class="number">8</span>;</span><br><span class="line">    <span class="comment"># 这几个指令涉及对栈地址的计算，以8为单位进行增减，需要用到ALU计算</span></span><br><span class="line">]; <span class="comment"># 辅助操作数</span></span><br><span class="line"></span><br><span class="line">word aluB = [</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IRMMOVQ,IOPQ&#125; : valB;</span><br><span class="line">    <span class="comment"># 寄存器rB的值直接做操作数或需要做地址运算</span></span><br><span class="line">    icode <span class="keyword">in</span> &#123;IMRMOVQ&#125; : valA;</span><br><span class="line">    <span class="comment"># 寄存器rA的值需要做地址运算</span></span><br><span class="line">    icode <span class="keyword">in</span> &#123;ICALL,IRET,IPUSHQ,IPOPQ&#125; : valB;</span><br><span class="line">    <span class="comment"># 这些时候valB的值是%rsp寄存器的值，作为栈基址操作数</span></span><br><span class="line">    icode <span class="keyword">in</span> &#123;IIRMOVQ,IRRMOVQ&#125; : <span class="number">0</span>;</span><br><span class="line">    <span class="comment"># 保留aluA的值不受操作影响</span></span><br><span class="line">]; <span class="comment"># 主操作数</span></span><br><span class="line"></span><br><span class="line">word alufun = [</span><br><span class="line">    icode == IOPQ : ifun;</span><br><span class="line">    <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="comment"># 除了在使用IPOQ指令时，所有时候ALU都是当加法器用的，其对应的alufun值为1</span></span><br><span class="line">]; <span class="comment"># 操作类型</span></span><br><span class="line"></span><br><span class="line">bool set_cc = icode <span class="keyword">in</span> &#123;IOPQ&#125;;</span><br><span class="line"><span class="comment"># 如果指令是IOPQ，还要设置条件码</span></span><br><span class="line"></span><br><span class="line">int cc = ALU.calculate(aluA,aluB,func=alufun);</span><br><span class="line"><span class="comment"># ALU进行运算并返回条件码</span></span><br><span class="line"><span class="keyword">if</span> set_cc:</span><br><span class="line">    CC.set(cc);</span><br><span class="line">    <span class="comment"># 设置条件码</span></span><br><span class="line">bool Cnd = COND.gencnd(CC.get())</span><br><span class="line"><span class="comment"># 生成Cnd信号，传输给写回阶段</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访存</span></span><br><span class="line"></span><br><span class="line">word mem_addr = [</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IRMMOVQ,IMRMOVQ,ICALL,IMRMOVQ&#125; : valE;</span><br><span class="line">    <span class="comment"># 正常状态的地址都要经过ALU的计算成为valE</span></span><br><span class="line">    icode <span class="keyword">in</span> &#123;IRET,IPOPQ&#125; : valA;</span><br><span class="line">    <span class="comment"># 这边是与译码部分联系</span></span><br><span class="line">]; <span class="comment"># 确定内存访问的地址</span></span><br><span class="line"></span><br><span class="line">bool mem_read = icode <span class="keyword">in</span> &#123;IMRMOVQ,IPOPQ,IRET&#125;;</span><br><span class="line">bool mem_write = icode <span class="keyword">in</span> &#123;IRMMOVQ,IPUSHQ,ICALL&#125;;</span><br><span class="line"><span class="comment"># 确定指令要求的访存方式是读还是写</span></span><br><span class="line"></span><br><span class="line">word mem_data = [</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IRMMOVQ,IPUSHQ&#125; : valA;</span><br><span class="line">    <span class="comment"># 从寄存器中获取写入值</span></span><br><span class="line">    icode == ICALL : valP;</span><br><span class="line">    <span class="comment"># CALL指令要写入的是返回地址，也就是下一条指令的地址valP。</span></span><br><span class="line">]; <span class="comment"># 确定读写的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> mem_read:</span><br><span class="line">        valM = MEM.read(baseptr=mem_addr,size=<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> mem_write:</span><br><span class="line">        MEM.write(baseptr=mem_addr,data=mem_data);</span><br><span class="line">    <span class="comment"># 读写数据</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    bool dmem_error = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">word stat = [</span><br><span class="line">    imem_error || dmem_error : SADR;</span><br><span class="line">    !instr_valid : SINS;</span><br><span class="line">    icode == IHALT : SHLT;</span><br><span class="line">    <span class="number">1</span> : SAOK;</span><br><span class="line">];</span><br><span class="line">STAT.set(stat);</span><br><span class="line"><span class="comment"># 判断程序运行状态并更新状态码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写回</span></span><br><span class="line"></span><br><span class="line">word dstE = [</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IIRMOVQ,IOPQ&#125; : rB</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IRRMOVQ&#125; &amp;&amp; Cnd : rB</span><br><span class="line">    <span class="comment"># 这里要包含一下条件传送的情况</span></span><br><span class="line">    icode <span class="keyword">in</span> &#123;IPUSHQ,IPOPQ,ICALL,IRET&#125; : RRSP</span><br><span class="line">    <span class="number">1</span> : RNONE</span><br><span class="line">] <span class="comment"># 需要写入计算结果时</span></span><br><span class="line"></span><br><span class="line">word dstM = [</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IMRMOVQ&#125; : rB</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IPOPQ&#125; : rA</span><br><span class="line">    <span class="number">1</span> : RNONE</span><br><span class="line">] <span class="comment"># 需要写入访存结果时</span></span><br><span class="line"></span><br><span class="line">REG.write(dstE,data=valE);</span><br><span class="line">REG.write(dstM,data=valM);</span><br><span class="line"><span class="comment"># 进行写回</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新PC</span></span><br><span class="line"></span><br><span class="line">word new_pc = [</span><br><span class="line">    icode == ICALL : valC;</span><br><span class="line">    <span class="comment"># 调用函数则直接跳到函数起始地址</span></span><br><span class="line">    icode == IJXX &amp;&amp; Cnd : valC;</span><br><span class="line">    <span class="comment"># 条件跳转需要判断条件</span></span><br><span class="line">    icode == IRET : valM;</span><br><span class="line">    <span class="comment"># 读取返回地址</span></span><br><span class="line">    <span class="number">1</span> : valP;</span><br><span class="line">    <span class="comment"># 正常情况下就到下一句指令</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">PC.set(new_pc);</span><br><span class="line"><span class="comment"># 更新PC</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指令执行完毕，回到开头，开始执行下一条指令...</span></span><br></pre></td></tr></table></figure></p>
<h2 id="流水线化原理"><a href="#流水线化原理" class="headerlink" title="流水线化原理"></a>流水线化原理</h2><p>流水线化的重要优点就是增加了系统的 <strong>吞吐量</strong> ，也就是单位时间内能够服务顾客的数量；但缺点是会稍稍增加对单独顾客的 <strong>延迟(处理某一阶段需要的时间)</strong> ，因为每个顾客都要经历每个步骤，不管它需不需要某些步骤。</p>
<p>在硬件设计中，只需要将整个过程划分为数个步骤，在每两个步骤之间插入储存中间结果的寄存器，就可以实现SEQ的流水线化。</p>
<h3 id="流水线化的局限性"><a href="#流水线化的局限性" class="headerlink" title="流水线化的局限性"></a>流水线化的局限性</h3><ul>
<li>不一致的划分<ul>
<li>如果流水线上的几个步骤所需要的延迟差距较大，由于流水线的时钟周期必须适应延迟最长的那个步骤，整个流水线的效率都会被拖慢，造成很大的资源浪费。</li>
<li>对硬件设计来说，划分延迟相差不大的阶段是一件比较难的事。</li>
</ul>
</li>
<li>流水线过深的惩罚<ul>
<li>比起顺序执行，流水线化执行需要在它划分的每两个阶段之间插入一组流水线寄存器，以储存中间结果。在这组寄存器上的读写也会产生延迟，而当流水线过深(也就是划分阶段过多)时，这些延迟会拖慢整体的吞吐量。</li>
<li>为了减轻这个惩罚，现在的流水线寄存器延迟已经很小。</li>
</ul>
</li>
</ul>
<h3 id="带反馈的流水线化系统"><a href="#带反馈的流水线化系统" class="headerlink" title="带反馈的流水线化系统"></a>带反馈的流水线化系统</h3><p>对于条件控制的条件码处理，以及PC的更新和寄存器的更新，这些都属于 <strong>反馈路径</strong> ，每一条指令产生的变化都会反馈给下一条指令。</p>
<p>然而在流水线系统中，这个处理会带来危险。我们知道由于流水线化的进行，每个阶段执行的时候与它同时执行的前一个阶段就不是它所在指令的阶段，而是后一个指令的阶段了。这样如果仍然使用原来的反馈机制，就会导致一个指令的反馈信息反馈到了之后的指令那里。</p>
<h3 id="设计流水线化的Y86-64处理器"><a href="#设计流水线化的Y86-64处理器" class="headerlink" title="设计流水线化的Y86-64处理器"></a>设计流水线化的Y86-64处理器</h3><ul>
<li>重新安排计算阶段<ul>
<li>为了避免反馈机制被流水线化干扰，有必要调整一下各个阶段的内容与顺序。</li>
<li>一个可能的改进是移动计算PC阶段，使其在一个时钟周期的开始时作用而不是在时钟周期结束。在每个时钟周期开始时，根据状态寄存器中的值动态地计算PC值。<br><img src="Chapter_4/SEQ+.png" alt="SEQ+示意图"></li>
<li>这种策略称为 <strong>电路重定时</strong> ，它是指在不改变电路逻辑的情况下调整一个系统的状态表示。电路重定时通常用来平衡流水线各阶段之间的延迟。</li>
</ul>
</li>
<li>插入流水线寄存器<ul>
<li>在各个阶段之间插入流水线寄存器并对信号重新排列，得到PIPE-处理器结构。<br><img src="Chapter_4/PIPE-.png" alt="PIPE-示意图"></li>
<li>五个流水线寄存器的职能<ul>
<li>F 保存程序计数器的预测值</li>
<li>D 保存icode,ifun,rA,rB,valC,valP等指令信息</li>
<li>E 保存从寄存器文件中读出的值及计算得出的srcA、srcB、dstE、dstM信息，传递icode,ifun,valC信息</li>
<li>M 保存计算结果valE与状态码Cnd，传递icode，dstE，dstM信息</li>
<li>W 保存将要写回寄存器的valE和valM以及写回地址dstE和dstM<ul>
<li>将dstE和dstM一直传递到这一步的目的是保证写回地址和写回数据匹配。</li>
</ul>
</li>
</ul>
</li>
<li>在流水线化系统的一个时钟周期中，状态码的值stat是随时会变化的。这要求我们仔细地处理stat的值。对于寄存器中储存的stat值，我们使用D_stat,E_stat,M_stat,W_stat来表示；对于阶段中的stat值，我们改用小写字母前缀表示。</li>
</ul>
</li>
<li>PC值的预测<ul>
<li>除了条件转移类指令和ret指令，我们都可以在解析一条指令的同时准确地得知PC的下一个值，从而在下一个阶段PC读入新一条指令之前更新PC的值。因此，通过预测PC值，大部分指令都可以做到每个时钟周期发射一条指令。<ul>
<li>对于条件转移类指令，根据条件码PC既有可能是valC(跳转),又有可能是valP(不跳转)。因此，如果预测发生错误，我们需要设计完善的修正错误的机制。</li>
<li>猜测分支的方向并根据猜测取指的技术称为 <strong>分支预测</strong> 。PIPE-简化了预测过程，即我们总是预测将要将valC作为PC的新值。<ul>
<li>由于分支预测发生错误会极大影响程序性能，<strong>条件传送</strong> 一般比 <strong>条件跳转</strong> 要更好一些。</li>
</ul>
</li>
<li>对于ret指令，由于PC的新值有近乎无限种可能性，我们放弃预测，转而暂停流水线的运行直到PC的值有确定的结果。<ul>
<li>在一些硬件设计中，会有一个程序员不可见的硬件栈，它在每次函数call的时候将返回地址压栈，而在每次ret指令时从栈顶弹出一个地址作为新的PC值。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Streamline Hazard<ul>
<li>根据相邻指令之间的反馈方式，Hazard可以分为Data Hazard和Control Hazard两类。</li>
<li>Data Hazard<ul>
<li>Data Hazard的类型<ul>
<li>寄存器：一条指令要改变某个寄存器，但在写回阶段之前另一条指令读取了该寄存器的值。</li>
<li>程序计数器：错误的预测和ret的影响</li>
<li>内存：如果程序在访存阶段修改代码部分内存，会引起之后的指令取指出错。我们简单地禁止程序修改自身代码段来避免这种情况。除此之外，由于内存读写发生在同一阶段，不同指令之间不会发生冲突。</li>
<li>条件码寄存器：不会发生Hazard。</li>
<li>状态寄存器stat：采用多状态码机制。</li>
</ul>
</li>
<li>如何避免Data Hazard的发生<ul>
<li>Stalling(暂停)：暂停一条或多条指令(通过插入bubble)，直到Hazard的条件不再满足。</li>
<li>Forwarding(转发)：对于某些情况，可以直接将将要写回寄存器的结果转发至另一条指令的读寄存器端口。这样可以大幅减少需要的暂停时间。</li>
<li>load interlock：将暂停和转发技术合理地结合起来，基本可以实现高吞吐量。<br><img src="Chapter_4/PIPE.png" alt="PIPE示意图"></li>
</ul>
</li>
</ul>
</li>
<li>Control Hazard<ul>
<li>当处理器无法通过取指阶段的指令去预测下一个指令的地址时会发生控制冒险。</li>
<li>Control Hazard的处理措施<ul>
<li>ret：使用Stalling策略</li>
<li>jxx：使用Cancel策略。设当前指令为指令1,则它在执行阶段就可以通过状态码CC的设置判断之前的预测是否发生了失误。如果发生失误，由于指令2和指令3还分别在译码和取指阶段而没有进行任何数据写操作，它们对程序状态其实是没有影响的。于是，我们重新设定PC值，并用bubble取代指令2和指令3剩余的阶段，以消除错误带来的影响。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h3><ul>
<li>在Y86-64处理器模型中，我们主要处理三种内部异常：<ul>
<li>halt指令</li>
<li>由非法指令和有非法功能码组合的指令引起的异常</li>
<li>取指和数据读写使用了非法地址</li>
</ul>
</li>
</ul>
<p>引起异常的指令称为 <strong>异常指令</strong> 。在异常触发之后，一个完整设计过的操作系统会调用异常处理程序，但在简化模型中处理器会直接停止并设置状态码。</p>
<p>对于优先级问题，在流水线中位置最深的指令引发的异常优先级最高。</p>
<p>当处于访存或者写回阶段的指令引发异常时，流水线控制逻辑应当立即禁止处理器或内存的更新。</p>
<h3 id="控制逻辑"><a href="#控制逻辑" class="headerlink" title="控制逻辑"></a>控制逻辑</h3><p>处理器的控制逻辑处理其他机制无法处理的四种情况：</p>
<ul>
<li>Data Hazard</li>
<li>ret语句</li>
<li>预测失误</li>
<li>异常</li>
</ul>
<p>处理它们的主要方式是插入气泡(bubble)，也就是将某些步骤的icode设置为INOP，并用RNONE填充流水线寄存器；以及暂停(stalling)，就是禁止流水线寄存器更新状态以将指令阻塞在某个阶段。</p>
<p>控制逻辑机制</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>条件</th>
<th>F</th>
<th>D</th>
<th>E</th>
<th>M</th>
<th>W</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>处理ret语句</td>
<td>Stall</td>
<td>Bubble</td>
<td>-&gt;</td>
<td>-&gt;</td>
<td>-&gt;</td>
</tr>
<tr>
<td>2</td>
<td>Regid/Memory Hazard</td>
<td>Stall</td>
<td>Stall</td>
<td>Bubble</td>
<td>-&gt;</td>
<td>-&gt;</td>
</tr>
<tr>
<td>3</td>
<td>预测错误的分支(E中发现)</td>
<td>-&gt;</td>
<td>Bubble</td>
<td>Bubble</td>
<td>-&gt;</td>
<td>-&gt;</td>
</tr>
<tr>
<td>4</td>
<td>1,3的组合情况(同时)</td>
<td>Stall</td>
<td>Bubble</td>
<td>Bubble</td>
<td>-&gt;</td>
<td>-&gt;</td>
</tr>
</tbody>
</table>
<h2 id="完整的Y86-64流水线化处理器"><a href="#完整的Y86-64流水线化处理器" class="headerlink" title="完整的Y86-64流水线化处理器"></a>完整的Y86-64流水线化处理器</h2><h3 id="PIPE的HCL实现"><a href="#PIPE的HCL实现" class="headerlink" title="PIPE的HCL实现"></a>PIPE的HCL实现</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以发现PIPE的实现与SEQ是大部分一致的，只是在信号前加入了前缀</span></span><br><span class="line"><span class="comment"># 大写的前缀代表寄存器中的值，小写的前缀代表产生的信号</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>取指和PC Selection</span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制逻辑，对于F阶段只有Stall的可能</span></span><br><span class="line"></span><br><span class="line">bool F_stall = </span><br><span class="line">    <span class="comment"># 寄存器/内存 Hazard</span></span><br><span class="line">    E_icode <span class="keyword">in</span> &#123;IMRMOVQ,IPOPQ&#125; &amp;&amp; E_dstM <span class="keyword">in</span> &#123;d_srcA,d_srcB&#125; || </span><br><span class="line">    IRET    <span class="keyword">in</span> &#123;D_icode,E_icode,M_icode&#125;; <span class="comment"># RET指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析阶段，与SEQ基本没有区别</span></span><br><span class="line"></span><br><span class="line">word p = PC.read(); <span class="comment"># 读出PC中的值</span></span><br><span class="line"><span class="keyword">if</span> p == SADR：</span><br><span class="line">    word f_ins = INOP;</span><br><span class="line">    bool imem_error = <span class="number">1</span>;</span><br><span class="line">    <span class="comment"># 如果PC中储存的地址不合法，产生imem_error信号并将指令设置为nop</span></span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">    word f_ins = MEM.read(baseptr=p,size=<span class="number">10</span>); <span class="comment"># 以p为基址在内存中读出10个字节</span></span><br><span class="line">    int f_icode,f_ifun = SPLIT.split(ins[<span class="number">0</span>]); <span class="comment"># 指令的第一个字节被split硬件单元解析</span></span><br><span class="line">    bool instr_valid = ***;</span><br><span class="line">    <span class="comment"># 这个判断就是依次判断每个可能的icode对应的ifun是否符合，过于长这里不写了</span></span><br><span class="line">    bool need_regids = </span><br><span class="line">        icode <span class="keyword">in</span> &#123;IRRMOVQ,IIRMOVQ,IMRMOVQ,IRMMOVQ,IOPQ,IPUSHQ,IPOPQ&#125;;</span><br><span class="line">    bool need_valC = </span><br><span class="line">        icode <span class="keyword">in</span> &#123;IIRMOVQ,IMRMOVQ,IRMMOVQ,IJXX,ICALL&#125;;</span><br><span class="line">    <span class="comment"># 这两个判断看一下哪些指令需要常数字段和寄存器字段就好了</span></span><br><span class="line">    <span class="keyword">if</span> need_regids：</span><br><span class="line">        int f_rA,f_rB = ALIGN.align(ins[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> need_valC：</span><br><span class="line">            word f_valC = ALIGN.align(ins[<span class="number">2</span>:<span class="number">10</span>]);</span><br><span class="line">        <span class="comment"># 如果指令需要寄存器就从第二个字节中读出</span></span><br><span class="line">        <span class="comment"># valC同理，都由align硬件单元读出</span></span><br><span class="line">    <span class="keyword">else</span>：</span><br><span class="line">        int f_rA = <span class="number">0xF</span>;</span><br><span class="line">        int f_rB = <span class="number">0xF</span>;</span><br><span class="line">        <span class="keyword">if</span> need_valC：</span><br><span class="line">            word f_valC = ALIGN.align(ins[<span class="number">1</span>:<span class="number">9</span>]);</span><br><span class="line">        <span class="comment"># 反之，如果不需要寄存器就将两个寄存器值都设为0xF，即无寄存器</span></span><br><span class="line">        <span class="comment"># 这样valC就会存放在指令的2到9字节。</span></span><br><span class="line">    word f_valP = p + need_regids + <span class="number">8</span>*need_valC;</span><br><span class="line">    <span class="comment"># valP代表下一条指令的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于PC值的运算</span></span><br><span class="line"></span><br><span class="line">word f_predPC = [</span><br><span class="line">    f_icode <span class="keyword">in</span> &#123;ICALL,IJXX&#125; : f_valC</span><br><span class="line">    <span class="number">1</span> : f_valP</span><br><span class="line">]; <span class="comment"># 预测PC的值</span></span><br><span class="line"></span><br><span class="line">f_predPC =&gt; F_predPC # 将预测结果存入流水线寄存器F</span><br><span class="line"></span><br><span class="line">word f_pc = [</span><br><span class="line">    M_icode == IJXX &amp;&amp; !M_Cnd : M_valA; <span class="comment"># 预测发生错误的情况，根据M寄存器储存的值判断</span></span><br><span class="line">    W_icode == IRET : W_valM; <span class="comment"># ret指令</span></span><br><span class="line">    <span class="number">1</span> : F_predPC <span class="comment"># 大多数情况，预测模块给出的值都是正确的</span></span><br><span class="line">]; <span class="comment"># 确定PC的值，为取出下一条指令作准备</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 信号的传递</span></span><br><span class="line"></span><br><span class="line">f_icode =&gt; D_icode</span><br><span class="line">f_ifun =&gt; D_ifun</span><br><span class="line">F_stat += (imem_error,instr_valid) =&gt; D_stat</span><br><span class="line">f_rA =&gt; D_rA</span><br><span class="line">f_rB =&gt; D_rB</span><br><span class="line">f_valC =&gt; D_valC</span><br><span class="line">f_valP =&gt; D_valP</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>译码和写回</span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制逻辑，这里可能会发生Stall或Bubble</span></span><br><span class="line"></span><br><span class="line">bool D_stall = E_icode <span class="keyword">in</span> &#123;IMRMOVQ,IPOPQ&#125; &amp;&amp; E_dstM <span class="keyword">in</span> &#123;d_srcA,d_srcB&#125;;</span><br><span class="line"></span><br><span class="line">bool D_bubble = (E_icode == IJXX &amp;&amp; !e_Cnd) || <span class="comment"># 预测出现失误的情况</span></span><br><span class="line">               !(E_icode <span class="keyword">in</span> &#123;IMRMOVQ,IPOPQ&#125; &amp;&amp; E_dstM <span class="keyword">in</span> &#123;d_srcA,d_srcB&#125;) &amp;&amp; IRET <span class="keyword">in</span> &#123;D_icode,E_icode,M_icode&#125;; <span class="comment"># 处理RET指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 译码部分与SEQ大部分一致</span></span><br><span class="line"></span><br><span class="line">word d_srcA = [</span><br><span class="line">    D_icode <span class="keyword">in</span> &#123;IRRMOVQ,IRMMOVQ,IOPQ,IPUSHQ&#125; : D_rA;</span><br><span class="line">    D_icode <span class="keyword">in</span> &#123;IPOPQ,IRET&#125; : RRSP;</span><br><span class="line">    <span class="number">1</span> : RNONE;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">word d_srcB = [</span><br><span class="line">    D_icode <span class="keyword">in</span> &#123;IRMMOVQ,IOPQ&#125; : D_rB;</span><br><span class="line">    D_icode <span class="keyword">in</span> &#123;IPUSHQ,IPOPQ,ICALL,IRET&#125; : RRSP;</span><br><span class="line">    <span class="number">1</span> : RNONE;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">word d_dstE = [</span><br><span class="line">    D_icode <span class="keyword">in</span> &#123;IIRMOVQ,IOPQ,IRRMOVQ&#125; : D_rB;</span><br><span class="line">    D_icode <span class="keyword">in</span> &#123;IPUSHQ,IPOPQ,ICALL,IRET&#125; : RRSP</span><br><span class="line">    <span class="number">1</span> : RNONE</span><br><span class="line">]; <span class="comment"># 写回阶段的地址计算放在了译码阶段</span></span><br><span class="line"></span><br><span class="line">word d_dstM = [</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IMRMOVQ&#125; : D_rB</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IPOPQ&#125; : D_rA</span><br><span class="line">    <span class="number">1</span> : RNONE</span><br><span class="line">]; <span class="comment"># 初步的地址计算</span></span><br><span class="line"></span><br><span class="line">word d_rvalA = REG.read(d_srcA);</span><br><span class="line">word d_rvalB = REG.read(d_srcB);</span><br><span class="line"><span class="comment"># 由于PIPE对valA和valP有个合并机制，这里读出的并不是最终的valA</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并信号valA和valP的依据是，只有call和跳转指令需要valP的值，而它们都不会需要valA</span></span><br><span class="line"><span class="comment"># 在这个阶段要处理数据转发，转发源有五个，需要分情况讨论</span></span><br><span class="line"></span><br><span class="line">word d_valA = [</span><br><span class="line">    D_icode <span class="keyword">in</span> &#123;IJXX,ICALL&#125; : D_valP;</span><br><span class="line">    d_srcA == e_dstE : e_valE;</span><br><span class="line">    <span class="comment"># Forwarding，直接接受上一条指令execute阶段的计算结果</span></span><br><span class="line">    d_srcA == M_dstM : m_valM;</span><br><span class="line">    <span class="comment"># Forwarding，接受上上条指令memory阶段的读内存结果</span></span><br><span class="line">    d_srcA == M_dstE : M_valE;</span><br><span class="line">    <span class="comment"># Forwarding，接受上上条指令memory阶段进行前还未写回的计算结果</span></span><br><span class="line">    d_srcA == W_dstM : W_valM;</span><br><span class="line">    d_srcA == W_dstE : W_valE;</span><br><span class="line">    <span class="comment"># Forwarding，接受上上上条指令在写回之前W寄存器中储存的访存和计算结果</span></span><br><span class="line">    <span class="number">1</span> : d_rvalA;</span><br><span class="line">    <span class="comment"># 没有Forwarding，直接采取寄存器中读出的valA</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">word d_valB = [</span><br><span class="line">    d_srcB == e_dstE : e_valE;</span><br><span class="line">    <span class="comment"># Forwarding，直接接受上一条指令execute阶段的计算结果</span></span><br><span class="line">    d_srcB == M_dstM : m_valM;</span><br><span class="line">    <span class="comment"># Forwarding，接受上上条指令memory阶段的读内存结果</span></span><br><span class="line">    d_srcB == M_dstE : M_valE;</span><br><span class="line">    <span class="comment"># Forwarding，接受上上条指令memory阶段进行前还未写回的计算结果</span></span><br><span class="line">    d_srcB == W_dstM : W_valM;</span><br><span class="line">    d_srcB == W_dstE : W_valE;</span><br><span class="line">    <span class="comment"># Forwarding，接受上上上条指令在写回之前W寄存器中储存的访存和计算结果</span></span><br><span class="line">    <span class="number">1</span> : d_rvalB;</span><br><span class="line">    <span class="comment"># 没有Forwarding，直接采取寄存器中读出的valA</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment"># 信号传递</span></span><br><span class="line"></span><br><span class="line">D_stat =&gt; E_stat</span><br><span class="line">d_icode =&gt; E_icode</span><br><span class="line">d_ifun =&gt; E_ifun</span><br><span class="line">d_valC =&gt; E_valC</span><br><span class="line">d_valA =&gt; E_valA</span><br><span class="line">d_valB =&gt; E_valB</span><br><span class="line">d_srcA,d_srcB,d_dstE,d_dstM =&gt; E_srcA,E_srcB,E_dstE,E_dstM</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>执行</span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制逻辑，只会出现Bubble</span></span><br><span class="line"></span><br><span class="line">bool E_bubble = E_icode <span class="keyword">in</span> &#123;IMRMOVQ,IPOPQ&#125; &amp;&amp; E_dstM <span class="keyword">in</span> &#123;d_srcA,d_srcB&#125; ||</span><br><span class="line">                (E_icode == IJXX &amp;&amp; !e_Cnd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这部分实现基本与SEQ无异</span></span><br><span class="line"></span><br><span class="line">word e_aluA = [</span><br><span class="line">    E_icode <span class="keyword">in</span> &#123;IRRMOVQ,IOPQ&#125; : E_valA;</span><br><span class="line">    <span class="comment"># 寄存器rA的值直接作操作数</span></span><br><span class="line">    E_icode <span class="keyword">in</span> &#123;IIRMOVQ,IMRMOVQ,IRMMOVQ&#125; : E_valC;</span><br><span class="line">    <span class="comment"># 内存与寄存器之间的移动需要计算地址加偏移量，所以将valC作操作数</span></span><br><span class="line">    E_icode <span class="keyword">in</span> &#123;ICALL,IPUSHQ&#125; : <span class="number">-8</span>;</span><br><span class="line">    E_icode <span class="keyword">in</span> &#123;IRET,IPOPQ&#125; : <span class="number">8</span>;</span><br><span class="line">    <span class="comment"># 这几个指令涉及对栈地址的计算，以8为单位进行增减，需要用到ALU计算</span></span><br><span class="line">]; <span class="comment"># 辅助操作数</span></span><br><span class="line"></span><br><span class="line">word e_aluB = [</span><br><span class="line">    E_icode <span class="keyword">in</span> &#123;IRMMOVQ,IOPQ&#125; : E_valB;</span><br><span class="line">    <span class="comment"># 寄存器rB的值直接做操作数或需要做地址运算</span></span><br><span class="line">    E_icode <span class="keyword">in</span> &#123;IMRMOVQ&#125; : E_valA;</span><br><span class="line">    <span class="comment"># 寄存器rA的值需要做地址运算</span></span><br><span class="line">    E_icode <span class="keyword">in</span> &#123;ICALL,IRET,IPUSHQ,IPOPQ&#125; : E_valB;</span><br><span class="line">    <span class="comment"># 这些时候valB的值是%rsp寄存器的值，作为栈基址操作数</span></span><br><span class="line">    E_icode <span class="keyword">in</span> &#123;IIRMOVQ,IRRMOVQ&#125; : <span class="number">0</span>;</span><br><span class="line">    <span class="comment"># 保留aluA的值不受操作影响</span></span><br><span class="line">]; <span class="comment"># 主操作数</span></span><br><span class="line"></span><br><span class="line">word e_alufun = [</span><br><span class="line">    E_icode == IOPQ : E_ifun;</span><br><span class="line">    <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="comment"># 除了在使用IPOQ指令时，所有时候ALU都是当加法器用的，其对应的alufun值为1</span></span><br><span class="line">]; <span class="comment"># 操作类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置条件码，这里要小心异常触发的情况</span></span><br><span class="line"></span><br><span class="line">bool set_CC = </span><br><span class="line">    !(m_stat <span class="keyword">in</span> &#123;SADR,SINS,SHLT&#125;) &amp;&amp;</span><br><span class="line">    !(W_stat <span class="keyword">in</span> &#123;SADR,SINS,SHLT&#125;) &amp;&amp;</span><br><span class="line">    E_icode == IOPQ ;</span><br><span class="line"><span class="comment"># 如果memory和writeback阶段的指令触发了异常，任何对条件码的修改都应该中止。</span></span><br><span class="line"></span><br><span class="line">word e_valE, int cc = ALU.calculate(e_aluA,e_aluB,func=e_alufun);</span><br><span class="line"><span class="keyword">if</span> set_cc:</span><br><span class="line">    CC.set(cc);</span><br><span class="line">bool e_Cnd = COND.gencnd(CC.get());</span><br><span class="line"><span class="comment"># 进行计算，设置条件码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 信号传输</span></span><br><span class="line"></span><br><span class="line">E_stat =&gt; M_stat</span><br><span class="line">e_icode =&gt; M_icode</span><br><span class="line">e_Cnd =&gt; M_Cnd</span><br><span class="line">e_valE =&gt; M_valE</span><br><span class="line">E_valA =&gt; M_valA</span><br><span class="line">e_dstE =&gt; M_dstE</span><br><span class="line">E_dstM =&gt; M_dstM</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>访存</span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制逻辑，这部分需要处理异常</span></span><br><span class="line"></span><br><span class="line">bool M_bubble = m_stat <span class="keyword">in</span> &#123;SADR,SINS,SHLT&#125; || W_stat <span class="keyword">in</span> &#123;SADR,SINS,SHLT&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这一部分与SEQ相同</span></span><br><span class="line"></span><br><span class="line">word mem_addr = [</span><br><span class="line">    M_icode <span class="keyword">in</span> &#123;IRMMOVQ,IMRMOVQ,ICALL,IMRMOVQ&#125; : M_valE;</span><br><span class="line">    M_icode <span class="keyword">in</span> &#123;IRET,IPOPQ&#125; : M_valA;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bool mem_read = M_icode <span class="keyword">in</span> &#123;IMRMOVQ,IPOPQ,IRET&#125;;</span><br><span class="line">bool mem_write = M_icode <span class="keyword">in</span> &#123;IRMMOVQ,IPUSHQ,ICALL&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确定读写数据的步骤被省略了，因为之前已经将valA和valP进行了merge操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> mem_read:</span><br><span class="line">        m_valM = MEM.read(baseptr=mem_addr,size=<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> mem_write:</span><br><span class="line">        MEM.write(baseptr=mem_addr,data=M_valA);</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    bool dmem_error = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 信号传输</span></span><br><span class="line"></span><br><span class="line">m_stat += dmem_eroor =&gt; W_stat</span><br><span class="line">M_icode =&gt; W_icode</span><br><span class="line">M_valE =&gt; W_valE</span><br><span class="line">m_valM =&gt; W_valM</span><br><span class="line">M_dstE =&gt; W_dstE</span><br><span class="line">M_dstM =&gt; W_dstM</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>写回</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在下一个时钟周期开始之前，handle一下异常</span></span><br><span class="line"></span><br><span class="line">bool W_stall = W_stat <span class="keyword">in</span> &#123;SADR,SINS,SHLT&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h3><p><img src="Chapter_4/memory.png" alt="memory"><br><img src="Chapter_4/execute.png" alt="execute"><br><img src="Chapter_4/decode.png" alt="decode"><br><img src="Chapter_4/fetch.png" alt="fetch"><br><img src="Chapter_4/control.png" alt="control"></p>
<h2 id="改进的空间"><a href="#改进的空间" class="headerlink" title="改进的空间"></a>改进的空间</h2><ul>
<li>多周期指令<ul>
<li>整数乘法需要3-4个时钟周期完成，而整数除法更是需要64个周期。对于这样的多周期操作，必须调整流水线的设计以适应其运行时间。</li>
</ul>
</li>
<li>与存储系统的接口<ul>
<li>在PIPE设计中，我们假设取指单元和数据内存的读写都可以在一个时钟周期内完成(但这显然是不可能的)。</li>
<li>通过高速缓存和翻译后备缓冲器(将物理地址翻译为虚拟地址)，可以将数据内存读写的速度尽可能降低到一个时钟周期以内。</li>
<li>对于高速缓存不命中和pagefault异常触发等问题，可以使用stall来等待数据就位。</li>
</ul>
</li>
</ul>
<h1 id="Chapter-5-优化程序性能"><a href="#Chapter-5-优化程序性能" class="headerlink" title="Chapter 5 优化程序性能"></a>Chapter 5 优化程序性能</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><ul>
<li>编写高效程序的要素<ul>
<li>合适的算法和数据结构</li>
<li>写出适于编译器优化的代码<ul>
<li>不同的语言优化的难度是不同的，越灵活的语言越是难以优化。</li>
<li>程序员应当在代码性能和代码可读性之间作出权衡。</li>
</ul>
</li>
<li>使用并行计算的策略</li>
</ul>
</li>
</ul>
<h2 id="编译器优化的局限性"><a href="#编译器优化的局限性" class="headerlink" title="编译器优化的局限性"></a>编译器优化的局限性</h2><h3 id="编译器的优化级别"><a href="#编译器的优化级别" class="headerlink" title="编译器的优化级别"></a>编译器的优化级别</h3><p>编译器会对其在编译过程中做的优化工作量做一个分级。以GCC为例，参数-Og表示使用基本的优化，-O1到-O3则代表着越来越大的优化量。</p>
<p>优化量越大，程序的效率一般会越高，但程序和源程序的差距也越大，越难以调试。企业采用的优化标准一般是-O2级，本书采用的级别是-O1.</p>
<h3 id="保证优化的安全性"><a href="#保证优化的安全性" class="headerlink" title="保证优化的安全性"></a>保证优化的安全性</h3><p>为了避免优化前后程序的行为出现差异，编译器被限制为只能做出“安全”的优化。这就意味着编译器能做的改动更小，程序员的优化显得更为重要。</p>
<p>不安全的优化大致有以下几种：</p>
<h4 id="Memory-aliasing"><a href="#Memory-aliasing" class="headerlink" title="Memory aliasing"></a>Memory aliasing</h4><p>在对指针的目标值进行操作的过程中，可能出现两个指针指向同一个内存地址的情况，这种状况称为 <strong>内存别名使用(Memory aliasing)</strong> 。编译器必须假设两个不同的指针可能指向同一位置，这就大大限制了可以作出的优化。</p>
<p>例如，执行下面代码段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*ptr1 = <span class="number">3000</span>;</span><br><span class="line">*ptr2 = <span class="number">1000</span>;</span><br><span class="line">x = *ptr1;</span><br></pre></td></tr></table></figure>
<p>如果两个指针指向不同的位置，那么x无疑等于3000,但如果反之，由于逻辑顺序，x等于1000。考虑到可能出现二义性的后果，编译器不能产生类似这样的代码段(除非源程序有意为之)。</p>
<h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>同一个函数，以同样的参数调用，其返回的值可能不同，这是过程式语言的一大弱点，即所谓的side effect。这就导致了，编译器无法把以几次函数调用的返回值为操作数的多次操作化简为一次操作，比如不能把<code>f()+f()</code>化简为<code>2*f()</code>。</p>
<h2 id="度量程序的性能"><a href="#度量程序的性能" class="headerlink" title="度量程序的性能"></a>度量程序的性能</h2><p>对于线性类复杂度的程序，我们引入 <strong>每元素周期数(CPE)</strong> 作为度量标准。每元素周期数指的是输入每增加一个元素，程序所多消耗的时钟周期数。本质上讲，也就是复杂度公式中n项的参数。</p>
<h2 id="对循环过程进行的优化"><a href="#对循环过程进行的优化" class="headerlink" title="对循环过程进行的优化"></a>对循环过程进行的优化</h2><h3 id="代码移动"><a href="#代码移动" class="headerlink" title="代码移动"></a>代码移动</h3><p>将在循环过程中结果不会改变的操作移到循环外进行，这个过程称为 <strong>代码移动(code motion)</strong> 。编译器在遇到函数调用或内存访问的情况下不敢进行代码移动，因为它们可能产生side effect。这种时候就需要程序员宏观地修改代码进行代码移动。</p>
<p>代码移动是一项简朴易懂但十分有效的优化。虽然看似有经验的程序员都能够自动完成这项工作，但大型项目中也不乏由于没有进行代码移动而导致的效率危机。</p>
<h3 id="减少过程调用"><a href="#减少过程调用" class="headerlink" title="减少过程调用"></a>减少过程调用</h3><p>是应该进行更多的封装，使程序更加模块化和易于复用还是减少过程的调用，直接操作底层数据结构一直是一个保受争议的问题。对于C程序员来说，灵活地操作底层数据结构虽然会增大程序崩溃的几率，但可以大大提高程序的运行效率(因为减少了不必要的条件检查)。</p>
<h3 id="消除不必要的内存引用"><a href="#消除不必要的内存引用" class="headerlink" title="消除不必要的内存引用"></a>消除不必要的内存引用</h3><p>众所周知，内存读写比寄存器的读写要慢的多。因此，在循环过程中用临时变量存储计算中间结果要大大优于每次都进行内存读写。尽量消除不必要的内存读写可以大大提高程序性能，尤其是在循环结构中。</p>
<h2 id="利用硬件特性进行的优化"><a href="#利用硬件特性进行的优化" class="headerlink" title="利用硬件特性进行的优化"></a>利用硬件特性进行的优化</h2><p>现代处理器的微体系结构已经相当发达，这使得汇编语言指定的行为与机器实际的行为大相径庭。由于 <strong>指令级并行</strong> 的存在，现代处理器同时对多条指令进行求值，通过hazard消除技术避免副作用，并通过巧妙的安排让执行结果看上去像是顺序执行的。</p>
<p>在上一章对处理器流水线结构设计的了解中，我们知道要避免Hazard必须满足前后两条指令之间没有依赖关系，否则无论如何后一条指令都必须在前一条指令执行完后才能执行。一系列操作之间的依赖性导致的性能瓶颈称为 <strong>延迟界限(latency bound)</strong>，而处理器本身算力所导致的性能瓶颈称为 <strong>吞吐量界限(throughput bound)</strong> 。</p>
<h3 id="现代微处理器设计"><a href="#现代微处理器设计" class="headerlink" title="现代微处理器设计"></a>现代微处理器设计</h3><p>与之前的流水线顺序处理器不同，现代处理器是乱序处理的，也就是说指令执行顺序甚至不一定与机器语言中规定的相同。为了达成这个目的，处理器分为两部分：<strong>指令控制单元(ICU)</strong> 和 <strong>执行单元(EU)</strong> 。前者负责读出指令序列并生成操作，后者执行这些操作。</p>
<p>ICU会从指令高速缓存中取指令，并利用分支预测技术来决定下一个指令从哪里取出。每取出一个指令，ICU都将其拆分成一个个单元操作，并将单元操作们输送给EU，再由EU中的多个操作单元并行执行各种单元操作。</p>
<h3 id="功能单元的性能"><a href="#功能单元的性能" class="headerlink" title="功能单元的性能"></a>功能单元的性能</h3><p>功能单元的性能从三个方面衡量：<strong>延迟(latency)</strong>，<strong>发射时间(issuetime)</strong>，<strong>容量(capacity)</strong>。</p>
<p>延迟表示运算需要的总时间，而发射时间表示开始执行一次运算后到开始执行下一次运算所需要的时间。在完全顺序执行的情况下两者应该相等，但由于流水线化的设计，一条指令可以在上一条结束前就开始执行，这使得发射时间大大减小了。发射时间为1的操作称为完全流水线化操作，这种操作的两次之间必须是完全无依赖的。</p>
<p>容量则表示了能执行一个操作的功能单元数。一个处理器的 <strong>吞吐量</strong> 由功能单元的发射时间和容量决定，其具体值为 capacity/issuetime。</p>
<h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><p>将操作全部分解为基本操作，理清寄存器的占用与操作之间的依赖关系之后，便可以找出所有依赖链中最长最粗的一条，这条操作链就是关键路径。关键路径的长度和单位长度耗时直接决定着延迟界限，也就是程序性能。</p>
<h2 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h2><p>将原循环过程中的每两次循环合并为一次来书写循环体，这种修改称为 <strong>循环展开</strong> 。</p>
<p>循环展开有如下好处：</p>
<ul>
<li>减少了条件判断和迭代量计算的次数</li>
<li>提供了变化代码，减少关键路径上操作的机会</li>
</ul>
<p>在不改变关键路径操作的情况下，循环展开能将性能改善到逼近延迟界限的程度。</p>
<p>优化等级-O3会使GCC自动使用循环展开优化。</p>
<h2 id="提高并行性"><a href="#提高并行性" class="headerlink" title="提高并行性"></a>提高并行性</h2><p>这一部分，《串并行算法与数据结构》已经讲的足够清楚了。</p>
<h2 id="其他的制约因素"><a href="#其他的制约因素" class="headerlink" title="其他的制约因素"></a>其他的制约因素</h2><h3 id="寄存器溢出"><a href="#寄存器溢出" class="headerlink" title="寄存器溢出"></a>寄存器溢出</h3><p>虽然程序的并行度可以提高，但是处理器的寄存器数量是有限的。如果我们只顾着提高并行度，建立更多的临时循环变量，寄存器就可能发生不够用的情况。这时，处理器会在程序栈甚至内存中存放临时变量，这样甚至会使程序性能变得更低。</p>
<h3 id="预测错误处罚"><a href="#预测错误处罚" class="headerlink" title="预测错误处罚"></a>预测错误处罚</h3><p>分支预测技术的错误处罚代价是很大的，因为要抛弃所有正在运行的指令和结果并跳回到新位置重新开始。很难帮助处理器避免预测错误，因为其预测逻辑不为程序员所见。但是，如果能够尽量用 <strong>条件数据传送</strong> 来取代 <strong>条件控制转移</strong> 命令，就可以大大减少分支预测错误的处罚，因为数据传送一般不涉及控制流跳转问题，发生错误只需要更改结果即可。</p>
<p>对于GCC来说，用条件操作计算值并用值更新程序状态会编译出条件数据传送，而直接用条件操作改变程序状态则会编译出条件控制转移。因此，在一些关键位置改变代码风格可以大大降低错误预测的开销。</p>
<h2 id="程序分析工具gprof"><a href="#程序分析工具gprof" class="headerlink" title="程序分析工具gprof"></a>程序分析工具gprof</h2><p>gprof以二进制可执行文件为参数，它记录输入的程序执行过程中每个函数所花的时间。</p>
<h1 id="Chapter-6-存储器层次结构"><a href="#Chapter-6-存储器层次结构" class="headerlink" title="Chapter 6 存储器层次结构"></a>Chapter 6 存储器层次结构</h1><h2 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h2><h3 id="随机访问存储器-RAM"><a href="#随机访问存储器-RAM" class="headerlink" title="随机访问存储器(RAM)"></a>随机访问存储器(RAM)</h3><p>随机访问存储器分为两类：静态的(SRAM)和动态的(DRAM)。SRAM比DRAM更快(1000倍)，常常用作高速缓存。</p>
<p>SRAM由双稳态存储单元组成。每个单元都是一个六晶体管电路，它只有两种稳态值，只要有电，就算受到扰动也会迅速回归到稳态值上去。</p>
<p>DRAM由C很小的电容组成，用对电容的充电或无电表示1和0。DRAM存储器单元对扰动非常敏感，一旦电压被扰乱便无法恢复。</p>
<h4 id="内存条的存储结构"><a href="#内存条的存储结构" class="headerlink" title="内存条的存储结构"></a>内存条的存储结构</h4><p>每一块DRAM芯片的存储位被组织成同样大小的 <strong>单元</strong> ，每个单元一般含有若干个字节的信息。单元在DRAM芯片中以矩阵形式排列，每个单元都有其唯一的可以被索引的地址。</p>
<p>DRAM芯片通过 <strong>引脚</strong> 和外界沟通，一块芯片有8个data引脚，用以传递一个字节的信息；还有若干个addr引脚，用以索引具体的单元。每个芯片还有一个行缓冲区。</p>
<p>所有的DRAM芯片都连接到一个内存控制器上，内存控制器可以同时向每个DRAM芯片发送一位。在需要读取的时候，控制器首先将需要读取的地址转换成DRAM中的行和列索引，随即向每个DRAM芯片的addr发送一个相同的行索引，让其将对应的行复制到行缓冲区中；然后发送一个列索引，从每个芯片中取到目标单元值，最后内存控制器整合所有的单元值并输出。</p>
<h3 id="非易失性存储器"><a href="#非易失性存储器" class="headerlink" title="非易失性存储器"></a>非易失性存储器</h3><h4 id="只读存储器-ROM"><a href="#只读存储器-ROM" class="headerlink" title="只读存储器(ROM)"></a>只读存储器(ROM)</h4><p>PROM存储器(programmable read-only memory)只能被编程一次，它由能用高电流熔断的熔丝组成。EPROM(erasable PROM)和EEPROM(electrical EPROM)则可以多次编程。</p>
<p>存储在ROM中的程序称为 <strong>固件(firmware)</strong> 。它包括一些基本的输入输出函数和计算机系统启动所必需的程序。</p>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><h1 id="Chapter-7-链接"><a href="#Chapter-7-链接" class="headerlink" title="Chapter 7 链接"></a>Chapter 7 链接</h1><h2 id="Compiler-driver"><a href="#Compiler-driver" class="headerlink" title="Compiler driver"></a>Compiler driver</h2><p>大多数需要编译的语言都会提供一个 <strong>编译器驱动程序(Compiler driver)</strong> ，以C语言为例，这个程序会依次调用预处理器，编译器，汇编器和链接器，将源代码转换为二进制文件。</p>
<p>当我们使用gcc去将多个互相关联的文件编译为一个二进制文件时，这些源文件的预处理、编译和汇编过程都是分别进行的，而在最后的链接过程中被合为一体。</p>
<p>当我们运行可执行文件时，shell调用加载器，将文件内容拷贝到内存中并将控制流转移到二进制文件开头。</p>
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>静态链接器所接受的 <strong>可重定位目标文件</strong> 由各种不同的代码和数据节组成，其中每一节都是一个连续的字节序列。指令、未初始化的全局变量和初始化过的全局变量分居不同的section。</p>
<p>链接器要完成的主要任务是：</p>
<ul>
<li><strong>符号解析</strong>：将目标文件中的每个每个符号引用和其符号定义关联起来。</li>
<li><strong>重定位</strong>：将每个符号引用指向其对应的符号定义的内存位置。</li>
</ul>
<p>注意：链接器进行重定位的依据是汇编器所产生并记录在目标文件中的重定位条目。其自身并不做过多工作。</p>
<h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><p>目标文件有三种：</p>
<ul>
<li>可重定位目标文件：无法直接执行，但包括所有数据和代码的文件</li>
<li>可执行目标文件：经过链接，可以直接复制到内存中执行的文件</li>
<li>共享目标文件：可以动态地加载到内存中进行运行或链接的可重定位目标文件</li>
</ul>
<h3 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h3><p>现代Linux系统下的目标文件格式一般为 <strong>ELF(Executable and Linkable format)</strong> 格式。下表大致地描述了一个ELF可重定位目标文件的组成格式。</p>
<table>
<thead>
<tr>
<th>ELF头</th>
</tr>
</thead>
<tbody>
<tr>
<td>.text</td>
</tr>
<tr>
<td>.rodata</td>
</tr>
<tr>
<td>.data</td>
</tr>
<tr>
<td>.bss</td>
</tr>
<tr>
<td>.symtab</td>
</tr>
<tr>
<td>.rel.text</td>
</tr>
<tr>
<td>.rel.data</td>
</tr>
<tr>
<td>.debug</td>
</tr>
<tr>
<td>.line</td>
</tr>
<tr>
<td>.strtab</td>
</tr>
<tr>
<td>节头部表</td>
</tr>
</tbody>
</table>
<p>灵活地使用linux下的<code>readelf</code>工具可以有很大帮助。</p>
<h4 id="ELF头"><a href="#ELF头" class="headerlink" title="ELF头"></a>ELF头</h4><p>ELF头记录着一个目标文件的基本信息。其内容如下：</p>
<ul>
<li>描述系统 <strong>字长</strong> 和 <strong>字节序</strong> 的一个16字节序列</li>
<li>ELF头的大小</li>
<li>目标文件类型</li>
<li>机器类型</li>
<li>节头部表的位置</li>
<li>节头部表中条目的大小和数量</li>
</ul>
<h4 id="节头部表"><a href="#节头部表" class="headerlink" title="节头部表"></a>节头部表</h4><p>节头部表位于目标文件的末端，它记录了ELF文件中每个节的大小和位置。</p>
<h4 id="节"><a href="#节" class="headerlink" title="节"></a>节</h4><p>在ELF头和节头部表之间的部分都是节。一个典型的ELF文件包括如下节：</p>
<ul>
<li><code>.text</code> 已编译程序的机器代码</li>
<li><code>.rodata</code> 只读数据，包括声明中用到的常量和switch跳转表等</li>
<li><code>.data</code> 已经初始化的全局变量和静态变量(局部变量在程序栈中)</li>
<li><code>.bss</code> 未初始化或初始化为0的全局和静态变量，它们不占据任何实际空间。</li>
<li><code>.symtab</code> 存放着在程序中定义和引用的函数和全局变量信息的符号表<ul>
<li><strong>这个符号表只在链接或调试过程中有用</strong></li>
<li>可以使用<code>strip</code>命令去掉目标文件中的符号表</li>
</ul>
</li>
<li><code>.rel.text</code>和<code>.rel.data</code> 分别是函数和全局变量的重定位表，链接器根据其中储存的信息去制作symtab</li>
<li><code>.debug</code> 一个调试符号表，以-g选项调用编译器才会产生这张表，是调试所需要的</li>
<li><code>.line</code> 同样以-g选项调用才会产生，用于将行数映射到机器指令</li>
<li><code>.strtab</code> 一个字符串表，包括.symtab和.debug节中的符号名和各种节头的名字</li>
</ul>
<p>除了这些节以外，还有没有列入节头部表的几个 <strong>伪节</strong> ：</p>
<ul>
<li><code>ABS</code> 不该被重定位的符号</li>
<li><code>UNDEF</code> 外部符号</li>
<li><code>COMMON</code> 和.bss类似，COMMON包括未初始化的全局变量，其余归.bss。</li>
</ul>
<h4 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h4><p>在链接器的上下文中有三种不同的符号：</p>
<ul>
<li>全局符号：由一个模块定义，被其他模块引用的符号，如非静态函数和全局变量。</li>
<li>外部符号：由其他模块定义，被本模块引用的符号。</li>
<li>局部符号：被一个模块定义且只被其本身引用的符号，包括静态的函数和全局变量。</li>
</ul>
<p><strong>在C中，源文件扮演模块的角色</strong>。用static声明的函数和变量可以视为private的，而不加static的则可以视为pubilc的。</p>
<p><code>.symtab</code>节中的符号表表项是下面的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> name;        <span class="comment">// 指示表项的名称字符串在.strtab中的位置</span></span><br><span class="line">    <span class="keyword">char</span> type:<span class="number">4</span>;     <span class="comment">// 4bits数据，表示该表项是函数还是变量(或者其它类别)</span></span><br><span class="line">    <span class="keyword">char</span> binding:<span class="number">4</span>;  <span class="comment">// 4bits数据，表示该表项是本地还是全局的(或者其它类别)</span></span><br><span class="line">    <span class="keyword">long</span> value;      <span class="comment">// 指示表项的初始化位置距离初始化节起始位置的偏移量</span></span><br><span class="line">    <span class="keyword">long</span> size;       <span class="comment">// 每个表项指向的量所占的字节数</span></span><br><span class="line">    <span class="keyword">short</span> section;   <span class="comment">// 表项所属的节在节头部表中的位置(或伪节的名称)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="可执行目标文件"><a href="#可执行目标文件" class="headerlink" title="可执行目标文件"></a>可执行目标文件</h3><p>可执行目标文件的结构与可重定位目标文件大致相同：</p>
<table>
<thead>
<tr>
<th>ELF头</th>
</tr>
</thead>
<tbody>
<tr>
<td>段头部表</td>
</tr>
<tr>
<td>.init</td>
</tr>
<tr>
<td>.text</td>
</tr>
<tr>
<td>.rodata</td>
</tr>
<tr>
<td>.data</td>
</tr>
<tr>
<td>.bss</td>
</tr>
<tr>
<td>.symtab</td>
</tr>
<tr>
<td>.debug</td>
</tr>
<tr>
<td>.line</td>
</tr>
<tr>
<td>.strtab</td>
</tr>
<tr>
<td>节头部表</td>
</tr>
</tbody>
</table>
<p>ELF头中多出了程序的入口点，即第一条指令地址这一信息。.init节定义了一个初始化函数。由于可执行文件已经完成重定位，它不再需要.rel节。</p>
<p>从.init到.rodata段是只读段，存放代码段；.data和.bss是读写段，存放数据；剩下的位置不加载到内存，多数情况下用于调试。</p>
<p>段头部表指示各个代码/数据段的位置。</p>
<h4 id="可执行目标文件的加载"><a href="#可执行目标文件的加载" class="headerlink" title="可执行目标文件的加载"></a>可执行目标文件的加载</h4><p>加载的过程是由加载器来完成的。加载器首先根据段头部表将各个字节段拷贝到内存的相应位置，然后跳转到程序的入口点，也就是<code>_start</code>函数的地址。这个函数是所有C程序的入口点，<code>_start</code>函数会调用系统启动函数来初始化执行环境并调用main函数。main函数返回后，它接受并处理返回值。</p>
<h2 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h2><h3 id="多重定义的全局符号"><a href="#多重定义的全局符号" class="headerlink" title="多重定义的全局符号"></a>多重定义的全局符号</h3><p>Linux将未初始化的全局变量规定为弱符号，而函数和初始化的全局变量是强符号。</p>
<ul>
<li>当出现同名的强符号时，报错</li>
<li>当出现同名的强符号和弱符号时，选择强符号</li>
<li>当出现同名的弱符号时，随机选择一个</li>
</ul>
<p>后两条规则会导致一些不易察觉的错误。比如，一个文件中定义了一个未初始化的x和一个操作x的函数，而另一个文件中定义了一个初始化过的x，那么函数的执行就可能在另一个文件编写者不知道的情况下改变x的值。</p>
<h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><p>编译系统提供一种机制，将所有相关的目标文件打包成为一个单独的文件，称为静态库。当链接器构造出一个目标文件时，它只会拷贝静态库中被引用的部分。</p>
<p>在编译指令中加上静态库文件的名字可以将这个库作为链接器的输入之一。使用静态库可以减少程序员在源文件中进行include的头文件数。</p>
<p>静态库以一种称为 <strong>存档(archive)</strong> 的特殊文件格式存放在磁盘中。存档文件由后缀<code>.a</code>标识。</p>
<p><code>ar</code>工具可以将几个.o文件打包成为一个静态库。</p>
<p>当将静态库作为gcc的参数时，要注意目标文件和库文件的顺序。一般来说，依赖源放在后面。</p>
<h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>重定位过程合并输入模块，并为每个符号分配运行时地址。</p>
<p>重定位分为两步：</p>
<ul>
<li><strong>重定位节和符号定义</strong>：在这个过程中，链接器将所有相同类型的节进行合并，为它们中的每个条目重新分配运行时内存地址，并更新ELF头和节头部表的信息。完成这一步后，程序中每条 <strong>指令</strong> 和每个 <strong>全局变量</strong> 都具有唯一的运行时内存地址。</li>
<li><strong>重定位符号引用</strong>：修改代码节和数据节中对每个变量或函数的引用，将它们指向正确的运行时地址。完成这一步需要借助可重定位目标文件中的 <strong>重定位条目</strong> 。</li>
</ul>
<h3 id="重定位条目"><a href="#重定位条目" class="headerlink" title="重定位条目"></a>重定位条目</h3><p>汇编器会将每个遇到的引用分别放在等量的重定位条目中，以此告诉链接器如何在目标文件合并时修改这个引用。代码和已初始化数据的重定位条目分别存放在.rel.text和.rel.data中。</p>
<p>重定位条目的格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> offset;    <span class="comment">// 需要被修改的引用在节中的位置</span></span><br><span class="line">    <span class="keyword">long</span> type:<span class="number">32</span>;   <span class="comment">// 重定位类型</span></span><br><span class="line">    <span class="keyword">long</span> symbol:<span class="number">32</span>; <span class="comment">// 被修改的引用应该指向的符号在符号表中的位置,用于标识引用对象</span></span><br><span class="line">    <span class="keyword">long</span> addend;    <span class="comment">// 对最终重定位位置所做的调整</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>重定义类型</strong>有32种，其中最常见的有两种：</p>
<ul>
<li>R_X86_64_PC32 重定义一个使用相对寻址的引用</li>
<li>R_X86_64_32 重定义一个使用绝对寻址的引用</li>
</ul>
<p>对于相对寻址来说，由于在重定位过程中所有模块中的节都已经合并，可以知道引用源和引用对象处于同一个<code>.text</code>节中。这样一来，只需要知道引用对象的地址，就可以通过offset和addend计算出所需要的相对变址，也就是源和对象代码之间的距离。</p>
<p>而绝对寻址更加简单，只需要将引用对象的地址和addend的加值作为绝对地址来重定位即可。</p>
<p>addend项的作用是抵消掉处理器流水线的影响。在相对寻址中，处理器根据当前PC的值和变址来计算应当跳转到的位置。然而当处理器在执行调用指令(比如call)时，此时的PC值其实是下一条指令的地址。因而，此时需要在变址中加入addend值来进行修正，addend值应设置为两条指令之间地址差的相反数。对于绝对寻址，addend一般设置为0.</p>
<h2 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h2><p>动态链接库是一个目标模块，可以加载到任意的内存地址并与内存中的程序链接。这个过程是由 <strong>动态链接器</strong> 来完成的，称为动态链接。动态链接库在LINUX下以<code>.so</code>为后缀，而在windows下则以DLL文件为格式。</p>
<p>对于使用了动态链接库的目标文件，链接器会额外创建一个<code>.interp</code>节来包含动态链接器的路径。在加载器加载和运行可执行目标文件时，它会识别这个节，并加载和运行这个动态链接器。</p>
<p>动态链接器被加载后，将需要的共享库加载到指定内存段，并建立目标程序与共享库之间的链接，最后将控制传递给目标程序。</p>
<p>如果要在编写程序时指定共享库，可以使用<code>&lt;dlfcn.h&gt;</code>。如果要创建共享库，可以使用gcc参数<code>gcc -shared -fpic</code></p>
<p><code>-fpic</code>参数会指定生成 <strong>位置无关代码</strong>(Position-Independent Code) 这种代码可以加载而无需重定位，是为了解决动态链接加载问题而设计的。</p>
<h3 id="位置无关代码-PIC"><a href="#位置无关代码-PIC" class="headerlink" title="位置无关代码(PIC)"></a>位置无关代码(PIC)</h3><p>动态链接的一个问题在于，进程该如何定位加载到内存中的动态链接库代码。如果为每一个动态链接库分配一块指定的内存，既不方便动态链接库的修改与更新，又会使系统的可用资源减少。</p>
<p>PIC利用了加载的一个特性，即加载到内存中的数据段和代码段之间的距离是 <strong>运行时常量</strong> 。它在每个数据段开始的位置创建一个 <strong>全局偏移量表(GOT)</strong> ，这个表的每一项都与数据段中对全局变量或函数的引用关联。在加载时，动态链接器会重定位GOT的每一项，使其指向本模块或其他模块中的引用对象定义/初始化位置。</p>
<p>然而，动态链接库中的函数有可能数量巨大，如果所有函数都交由GOT和动态链接器处理，程序的加载过程将会变得极其耗时。为了解决这个问题，GNU采用一种叫做 <strong>延迟绑定</strong> 的机制，将过程地址的重定位推迟到第一次调用该过程的时间点。</p>
<p>延迟绑定需要GOT和另一种数据结构 —— <strong>过程链接表(PLT)</strong> 的辅助。GOT是数据段的一部分，而PLT是代码段的一部分，它的每个表项都是一个16字节代码段，对应一个函数调用。在初始化GOT的时候，所有对函数引用的GOT都指向其函数对应的PLT的第二个指令。</p>
<p><code>PLT[0]</code>对应动态链接器的入口，用于跳转到动态链接器；<code>PLT[1]</code>对应<code>_start</code>函数，之后的条目则对应用户所声明的函数。而GOT的前两个条目包含动态链接器的参数信息，其后的条目则依次对应PLT中相应函数的入口。由于数据段与代码段之间的距离是运行时不变量，GOT的每个表项<code>GOT[i]</code>与PLT中的<code>PLT[i-2]</code>之间的距离是固定的。</p>
<p>在一个函数第一次被调用时，它的运行时地址被解析：</p>
<ul>
<li>程序进入这个函数对应的PLT条目</li>
<li>PLT条目第一指令是跳转指令，跳转目标是该函数对应GOT所指向的地址</li>
<li>由于GOT的初始值为PLT第二个指令，此时控制来到PLT第二个指令</li>
<li>第二个指令将函数ID压栈，第三个指令跳转到<code>PLT[0]</code></li>
<li><code>PLT[0]</code>通过<code>GOT[1]</code>将动态链接器参数压栈，并通过<code>GOT[2]</code>跳转到动态链接器入口</li>
<li>动态链接器通过两个参数确定函数所在的动态库模块并找到其加载到的内存位置</li>
<li>动态链接器用这个位置重写GOT中该函数表项的值</li>
<li>动态链接器将控制转交给这个函数</li>
</ul>
<p>而之后的调用就会简单很多，因为GOT中关于这个函数的表项已经被重写为正确的地址了，PLT可以直接通过这个地址跳转到函数入口。</p>
<h2 id="库打桩机制"><a href="#库打桩机制" class="headerlink" title="库打桩机制"></a>库打桩机制</h2><p>Linux链接器支持打桩机制，它允许用户截取对系统函数的调用，取而代之地调用一个与这个函数原型完全相同，但内容自由定义的函数。</p>
<h3 id="编译时打桩"><a href="#编译时打桩" class="headerlink" title="编译时打桩"></a>编译时打桩</h3><p>以对malloc.h文件进行打桩为例：</p>
<ul>
<li>首先，在调用了malloc函数的源文件所在文件夹下创建一个malloc.h文件，并在其中将对malloc的调用重新定向：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) fake_malloc(size)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">fake_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>自行编写一个.c文件，将你想要让malloc函数做的事情写进去，并用gcc将其编译为.o文件：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c &lt;xxx&gt;.c</span><br></pre></td></tr></table></figure>
<ul>
<li>用gcc进行编译时打桩</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -I. &lt;源文件&gt;.c &lt;xxx&gt;.o</span><br></pre></td></tr></table></figure>
<p>由于指定了<code>-I.</code>参数，C预处理器会优先在当前文件夹中搜索malloc.h文件，于是打桩成功，计划通！</p>
<h3 id="链接时打桩"><a href="#链接时打桩" class="headerlink" title="链接时打桩"></a>链接时打桩</h3><p>gcc的一组参数可以用于打桩：</p>
<ul>
<li><code>-Wl,&lt;option&gt;</code>参数：将option作为参数传给链接器。option中的空格要替换为逗号来写。</li>
<li><code>--wrap &lt;token&gt;</code>参数：链接器参数，将token解析为<code>__wrap_&lt;token&gt;</code>，并将<code>__real_&lt;token&gt;</code>解析为token。</li>
</ul>
<p>利用这两个参数，可以自定义<code>__wrap_&lt;token&gt;</code>函数，在其中定义自己的函数，再使用<code>__real_&lt;token&gt;</code>来调用原本的token函数。最后，使用<code>gcc -Wl,--wrap,&lt;token&gt;</code>参数来编译。</p>
<h3 id="运行时打桩"><a href="#运行时打桩" class="headerlink" title="运行时打桩"></a>运行时打桩</h3><p>通过设置<code>LD_PRELOAD</code>环境变量的值为一个目录，可以使动态链接器在搜索默认目录的动态库之前先搜索指定目录下的动态库。通过这个特性可以轻松地实现运行时打桩。</p>
<h2 id="工具总结"><a href="#工具总结" class="headerlink" title="工具总结"></a>工具总结</h2><ul>
<li>AR 用于创建和修改静态库 </li>
<li>STRINGS 列出一个 <strong>可执行文件</strong> 中所有可以打印的字符串</li>
<li>STRIP 用于删除符号表</li>
<li>NM 列出一个 <strong>可执行文件</strong> 的符号表信息</li>
<li>SIZE 列出可执行文件中节的信息</li>
<li>READELF</li>
<li>OBJDUMP</li>
<li>LDD 列出一个可执行文件需要的共享库</li>
</ul>
<h1 id="Chapter-8-异常控制流"><a href="#Chapter-8-异常控制流" class="headerlink" title="Chapter 8 异常控制流"></a>Chapter 8 异常控制流</h1><p>控制流会在很多种情况下发生变化：跳转，函数调用，返回都属于正常的控制流变化，在源程序的控制之内；但系统状态的变化也会引起一些控制流突变，我们将这些控制流变化统称为 <strong>异常控制流(Exceptional Control Flow)</strong> 。</p>
<p>在硬件层，硬件可能会因为预料外或不合规定的状态变化而抛出异常；在操作系统层，内核经常将控制权在不同进程之间转移；在应用层，进程之间的信号通信可以让程序回避栈规则进行跳转。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><strong>异常(Exception)</strong> 是异常控制流的一种形式。在任何情况下，如果 <strong>处理器</strong> 检测到有反常事件发生，它就会通过一张叫做 <strong>异常表(exception table)</strong> 的跳转表进行一个间接过程调用(也就是异常)，将控制权转交到这个异常所对应的异常处理程序。</p>
<p>异常处理程序完成处理后，有三种情况:</p>
<ul>
<li>控制权回到异常抛出时正在执行的指令</li>
<li>控制权转交给引发异常的下一条指令</li>
<li>终止被中断的程序</li>
</ul>
<p>系统中可能的每种类型的异常都分配了惟一的一个 <strong>异常号</strong> 。硬件层面的异常号由处理器设计者来规定，软件层面的异常号由操作系统内核设计者来规定。异常号是异常表的索引，在触发一个异常时，处理器取出 <strong>异常表基址寄存器</strong> 的值，与(异常号×异常表表项的大小)做加法，得到异常表对应表项的地址。</p>
<p>异常的函数调用和普通函数调用有一些区别：</p>
<ul>
<li>异常调用的返回地址不一定是正在执行指令的下一条指令</li>
<li>处理器会把一些额外的状态量压入栈中</li>
<li>如果控制从用户转到内核，所有项目被压入内核栈而不是程序栈</li>
<li>异常处理程序运行在系统态</li>
</ul>
<h3 id="异常的类别"><a href="#异常的类别" class="headerlink" title="异常的类别"></a>异常的类别</h3><p>异常可以分为如下四类：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>原因</th>
<th>行为</th>
<th>返回</th>
</tr>
</thead>
<tbody>
<tr>
<td>中断(<strong>Interrupt</strong>)</td>
<td>IO设备的信号</td>
<td>异步</td>
<td>返回到下一条指令</td>
</tr>
<tr>
<td>陷阱(<strong>trap</strong>)</td>
<td>有目的地引发</td>
<td>同步</td>
<td>返回到下一条指令</td>
</tr>
<tr>
<td>故障(<strong>fault</strong>)</td>
<td>潜在的可恢复的错误</td>
<td>同步</td>
<td>返回到下一条或当前指令</td>
</tr>
<tr>
<td>终止(<strong>abort</strong>)</td>
<td>不可恢复的错误</td>
<td>同步</td>
<td>不返回</td>
</tr>
</tbody>
</table>
<h4 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h4><p>IO设备在完成某个读取或写入过程后，就会向处理器的一个引脚发出信号，并将异常号放到系统总线。处理器会在执行完一条指令之后发觉引脚电位的变化，读取异常号并调用对应的异常处理程序来进行下一个IO操作。处理程序返回时，控制权交给下一条指令，使源程序的行为不受影响。</p>
<h4 id="Trap"><a href="#Trap" class="headerlink" title="Trap"></a>Trap</h4><p>陷阱通常用来进行 <strong>系统调用</strong> 。在操作系统学习中已经对系统调用过程有了够多的了解，此处不予详述。</p>
<h4 id="Fault"><a href="#Fault" class="headerlink" title="Fault"></a>Fault</h4><p>当一个故障发生时，异常处理程序会首先试图去修复这个故障。如果修复成功，控制权会回到引起故障的指令并重新执行它；否则，异常处理程序会调用内核中的abort例程并终止引起异常的程序。</p>
<h4 id="Abort"><a href="#Abort" class="headerlink" title="Abort"></a>Abort</h4><p>终止是确定无法恢复的错误，因而会直接终止引发异常的程序。</p>
<h3 id="常见的异常"><a href="#常见的异常" class="headerlink" title="常见的异常"></a>常见的异常</h3><ul>
<li><code>0</code>-除法错误：除法发生的错误属于硬件层面故障，但Linux系统不会试图恢复，而是直接abort。</li>
<li><code>13</code>-<strong>段错误</strong>：对未定义内存区域的引用或对只读文本段的写操作引发的故障，是相当常见的故障。Linux系统同样会直接将段错误进行abort处理，产生大家常常看到的<code>Segmentation fault</code>错误。</li>
<li><code>14</code>-<strong>缺页错误</strong>：指令所引用的虚拟地址所对应的物理页面不在内存中。这种情况是惰性加载的产物，在存储技术中相当常见。异常处理程序会将物理页面加载进内存，并返还控制权。</li>
<li><code>18</code>-机器检查：致命的硬件错误，属于abort类型。</li>
</ul>
<h3 id="Linux的系统调用"><a href="#Linux的系统调用" class="headerlink" title="Linux的系统调用"></a>Linux的系统调用</h3><p>在汇编语言中，<code>%rax</code>寄存器包含系统调用号，<code>%rdi</code>，<code>%rsi</code>，<code>%rdx</code>等寄存器包含最多6个参数的情况下，<code>syscall</code>指令会发起一次系统调用。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程提供给应用程序的关键抽象有二：</p>
<ol>
<li>一个独立的逻辑控制流</li>
<li>一个独立的虚拟地址空间</li>
</ol>
<h3 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h3><p>抢占式的任务调度中，所有的进程会轮流获取CPU的使用权。在这种抽象中，若干个进程可以看做是同时在运行，这种现象称为 <strong>并发</strong> 。而如果两个进程真正在不同的处理器核上运行，那么它们则被称为是 <strong>并行</strong> 的。</p>
<h3 id="私有地址空间"><a href="#私有地址空间" class="headerlink" title="私有地址空间"></a>私有地址空间</h3><p>对于每个进程来说，它的地址空间结构是相同的：</p>
<p><img src="Chapter_8/stack.png" alt="stack"></p>
<h3 id="系统态和用户态"><a href="#系统态和用户态" class="headerlink" title="系统态和用户态"></a>系统态和用户态</h3><p>这一部分详见操作系统课程的相关内容</p>
<h2 id="系统调用的错误处理"><a href="#系统调用的错误处理" class="headerlink" title="系统调用的错误处理"></a>系统调用的错误处理</h2><p>这一部分详见《UNIX系统编程》</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>同样详见《UNIX系统编程》</p>
<h3 id="fork指令"><a href="#fork指令" class="headerlink" title="fork指令"></a>fork指令</h3><p><code>fork()</code>系统调用创建当前程序的一个子进程，宏观上来看在这个调用之后子进程会从下一条指令开始与主进程并发运行相同的代码。区分主进程和子进程的方式是fork的返回值——<strong>在父进程中返回值是子进程的pid，在子进程中返回值为0</strong>。</p>
<p>这个指令的特点有：</p>
<ul>
<li>调用一次，返回两次。为了理清多次fork所创建的进程关系，通常需要画进程图。</li>
<li>父进程与子进程并发执行</li>
<li>子进程的地址空间是父进程的副本，但又与父进程相互独立。</li>
</ul>
<h3 id="子进程的回收"><a href="#子进程的回收" class="headerlink" title="子进程的回收"></a>子进程的回收</h3><p>子进程在返回或终止后并不会马上被内核清除，它会一直保持一个已终止的状态直到被它的父进程回收。这种未被回收但已经中止的进程被称为 <strong>僵尸进程</strong> 。父进程回收子进程后，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程。</p>
<p>如果父进程在它的子进程被回收之前终止,init进程会接管子进程,成为它的养父，并最终回收这些僵尸进程。但是，由于僵尸进程也会占用系统内存等资源，每个进程都应当回收它们的子进程，这就要用到<code>waitpid</code>函数了。它会使进程等待目标子进程终止，并马上回收这个子进程。如果当前没有子进程，这个函数返回-1并设置错误码。</p>
<p><code>pid_t waitpid(pid_t pid, int *statusp, int options)</code></p>
<ul>
<li><code>pid</code>:指定要等待的子进程pid。如果这个值为-1,就等待所有子进程。</li>
<li><code>options</code>: 改变函数默认的执行模式，如果为0则不改变。waitpid默认会挂起进程来等待子进程终止，并返回已终止子进程的pid。<ul>
<li><code>WNOHANG</code>: 立即返回而不等待子进程终止，若没有子进程终止则返回值为0</li>
<li><code>WUNTRACED</code>: 不仅返回已终止子进程的PID，还返回被停止子进程的pid。</li>
<li><code>WCONTINUED</code>: 挂起直到子进程终止或一个被停止的子进程收到信号继续执行</li>
</ul>
</li>
<li><code>statusp</code>: 用于存放返回的子进程的状态信息，<code>wait.h</code>中的宏可以解析这些信息。</li>
</ul>
<p><code>waitpid(-1,NULL,0)</code>会回收所有子进程中最先结束的子进程，然后返回。</p>
<h3 id="加载和运行程序"><a href="#加载和运行程序" class="headerlink" title="加载和运行程序"></a>加载和运行程序</h3><p><code>execve</code>函数可以在当前进程的上下文中加载并运行一个程序。</p>
<p><code>int execve(char* filename, char* argv[], char* envp[])</code></p>
<p>其中filename和argv不必解释，envp指向一个环境变量字符串数组，每个字符串都是<code>“name=value”</code>格式的键值对。</p>
<p><code>getenv</code>函数可以根据环境变量中的<code>name</code>在环境变量数组中搜索并返回对应的<code>value</code>字符串指针。如果找不到则返回NULL。<code>setenv</code>和<code>unsetenv</code>则可以修改环境变量。</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号是一种消息，内核使用信号来通知进程系统中发生的事情。可以执行<code>man 7 signal</code>来查看linux系统支持的信号种类。</p>
<p>传递信号由两个步骤组成：</p>
<ol>
<li>内核通过更新目标进程上下文中的某个状态，向一个进程 <strong>发送信号</strong></li>
<li>目标进程对信号做出的反应被称为 <strong>接受信号</strong></li>
</ol>
<p>一个发出但没有接受的信号被称为 <strong>待处理信号</strong> ，每种类型的信号在 <strong>同一时间只能存在一个待处理信号</strong> ，在这个信号被接受之前的同类型新信号会被丢弃。<strong>每个信号只能被接受一次</strong>。</p>
<h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>每个进程都只属于一个进程组，进程组由一个pgid来标识。用户进程可以通过<code>getpgrp</code>函数获取自己所在的进程组ID，通过<code>setpgid</code>改变自己或者其他进程的进程组。在<code>setpgid(pid,pgid)</code>函数中，如果pid为0则指定自身，如果pgid为0则用pid指定的PID作为进程组ID。</p>
<h3 id="信号的发送"><a href="#信号的发送" class="headerlink" title="信号的发送"></a>信号的发送</h3><p>linux系统下的<code>/bin/kill</code>文件可以向其他的进程发送信号。</p>
<p>使用方式：<code>kill -&lt;sig&gt; &lt;pid&gt;</code></p>
<p>其中<code>sig</code>指定发送的信号种类，而<code>pid</code>指定发送目标。负的pid会将信号发送给进程组中的每个进程。</p>
<p>类似地可以发送信号的函数有<code>signal.h</code>库中的<code>kill</code>函数,它的使用规范与<code>/bin/kill</code>相近；<code>unistd</code>中的<code>alarm</code>函数也可以在sec秒后向调用进程发送一个<code>SIGALRM</code>信号。</p>
<p>键盘输入如<code>ctrl-C</code>也会向当前作业的进程组发送信号。</p>
<h3 id="信号的接受"><a href="#信号的接受" class="headerlink" title="信号的接受"></a>信号的接受</h3><p>当一个进程 <strong>从内核模式切换回用户模式</strong> 时，它会检测进程的待处理信号集合，如果集合为空则将控制流转移给下一条指令，否则 <strong>强制</strong> 这个进程接受这个信号。</p>
<p>进程对于每个信号都有一种默认反应，大多是终止，转储内存，挂起或忽略。我们可以通过使用<code>signal.h</code>中的<code>signal</code>函数来修改默认行为。(<strong>SIGKILL和STGSTOP信号是无法更改的</strong>)</p>
<p><code>sighandler_t signal(int signum, sighandler_t handler)</code></p>
<ul>
<li>返回值：如果失败返回<code>SIG_ERR</code>，可以用于检验是否成功</li>
<li><code>signum</code>：指定要监测并处理的信号</li>
<li><code>handler</code>：指定处理信号的函数<ul>
<li><code>SIG_IGN</code>：忽略这个信号</li>
<li><code>SIG_DEL</code>：取消对信号默认行为的更改</li>
<li>自定义的函数</li>
</ul>
</li>
</ul>
<p>调用这个函数会改变当前进程在其剩余生命周期内对某个信号的行为。</p>
<h3 id="信号的阻塞"><a href="#信号的阻塞" class="headerlink" title="信号的阻塞"></a>信号的阻塞</h3><p><code>sigprocmask</code>函数可以显式地阻塞一些信号。</p>
<p><code>int sigprocmask(int how, sigset_t* set, sigset_t* oldset)</code></p>
<ul>
<li><code>how</code>：指定对两个set的操作<ul>
<li><code>SIG_BLOCK</code>：阻塞所有<code>set</code>中的信号</li>
<li><code>SIG_UNBLOCK</code>：解除对所有<code>set</code>中信号的阻塞</li>
<li><code>SIG_SETMASK</code>：将阻塞集合变成<code>set</code></li>
</ul>
</li>
<li><code>oldset</code>：之前的阻塞信号集合会保存在这里</li>
</ul>
<p>sigset的使用方法是，首先声明一个sigset，再使用辅助函数(<code>sigemptyset</code>,<code>sigaddset</code>,<code>sigdelset</code>)进行构造。</p>
<h3 id="信号处理程序的编写"><a href="#信号处理程序的编写" class="headerlink" title="信号处理程序的编写"></a>信号处理程序的编写</h3><p>信号处理程序与主程序并发运行，因而它很容易引起race condition。因此，我们只能在信号处理函数中使用 <strong>异步安全</strong> 的函数，而printf，scanf，malloc和exit等函数都不在此列，因而输出基本靠<code>write</code>。</p>
<p>还有一种精简信号处理程序的方式是只在程序中改变全局变量的值，然后立即返回，将所有的处理过程留给主程序。</p>
<p>除此之外，任何可能被信号处理程序修改的全局变量都应该使用<code>volatile</code>前缀和<code>sig_atomic_t</code>类型，前者保证这个变量不会被缓存，后者保证对这个变量的所有读写都是原子操作。</p>
<p>最后，处理程序有义务保存调用时errno的值，并在返回时将其重置。</p>
<p>另一个需要注意的问题是，由于未被处理的信号同时每种只能存在一个，当我们发现有一个未被处理的信号时很可能有 <strong>不止一个</strong> 信号已经到达。比如，我们在一个模拟shell行为的程序中监听SIGCHLD信号，每接受到一个SIGCHLD就回收相应的子进程。如果在handler处理第一个SIGCHLD的过程中又有两个新的SIGCHLD到达，那么其中的一个就会被丢弃。</p>
<p>为了解决这个问题，我们需要用一个不断执行<code>waitpid</code>直到返回-1的循环来取代对<code>waitpid</code>操作次数的计数。</p>
<h3 id="信号处理的兼容性"><a href="#信号处理的兼容性" class="headerlink" title="信号处理的兼容性"></a>信号处理的兼容性</h3><p>在不同的Unix系统上，<code>signal</code>函数的行为可能不一致。为此，我们可以显式地调用<code>sigaction</code>函数来设定默认行为。</p>
<h3 id="信号处理的常见问题及解决方案"><a href="#信号处理的常见问题及解决方案" class="headerlink" title="信号处理的常见问题及解决方案"></a>信号处理的常见问题及解决方案</h3><h4 id="任务列表管理中的race-condition问题"><a href="#任务列表管理中的race-condition问题" class="headerlink" title="任务列表管理中的race condition问题"></a>任务列表管理中的race condition问题</h4><p>有一个经典的案例：父进程通过fork创建一个子进程并将其添加到任务列表中，并在接受到SIG_CHLD信号之后将其从任务列表中移除。然而由于某些状况，子进程在被创建之后立即退出。在这个案例中，系统的控制流是这样变化的：</p>
<ul>
<li>父进程发出请求创建子进程，控制流陷入内核</li>
<li>内核创建子进程并移交控制权</li>
<li>子进程退出，控制权回到内核，内核向父进程发送一个SIG_CHLD信号</li>
</ul>
<p>需要注意的是这个时候父进程还并没有拿回控制权，因而它并不知道子进程已经终止。但它在接收到SIG_CHLD信号的时候会马上调用对应的handler去从任务列表中移除子进程，而当时任务列表中甚至还没有这个子进程！</p>
<p>为了解决这个问题，处理程序应当在创建子进程之前阻塞SIG_CHLD信号，并在添加完任务之后再取消这个阻塞。这样就实现了并发进程之间的同步。</p>
<h3 id="显式地等待信号"><a href="#显式地等待信号" class="headerlink" title="显式地等待信号"></a>显式地等待信号</h3><p>另一个例子是，父进程在创建一个子进程之后需要等待其返回再进行下一步操作。判断等待何时结束显然要依靠SIG_CHLD信号的接受和处理，但在等待的过程中应该做什么呢？</p>
<p><code>sigsuspend(const sigset_t *mask)</code>函数可以解决这个问题。它包括了用mask取代原有的阻塞集合、等待某个信号到达和恢复原有的阻塞集合三个操作，但不同于分别进行这三个操作的是，这个函数是 <strong>原子的</strong> 。</p>
<p>常见的处理机制是，父进程阻塞SIG_CHLD信号并创建子进程，然后调用<code>sigsuspend</code>函数来取消阻塞并等待SIG_CHLD信号，在接受信号之后恢复阻塞并继续执行之后的指令。</p>
<h2 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h2><p>有一种方式可以让用户程序摆脱一般函数的调用-返回逻辑，直接将控制流跳转到一个指定位置，并设定当时的 <strong>系统环境</strong> (系统环境是指程序计数器，栈指针，通用寄存器的值等信息)。</p>
<p><code>int setjmp(jmp_buf env)</code>函数可以在当前的位置设定一个跳转坐标，并将当前的系统环境保存在env变量中，之后挂起等待跳转。如果用户程序在其他位置调用了<code>longjmp(jmp_buf env, int retval)</code>函数，控制流就会跳转到setjmp的调用位置，恢复env所保存的环境，然后<code>setjmp</code>函数返回，返回值为retval。</p>
<p>需要注意的是，<code>setjmp</code>函数的返回值不能被用来赋值，只能用于判断。</p>
<h2 id="操作进程的工具"><a href="#操作进程的工具" class="headerlink" title="操作进程的工具"></a>操作进程的工具</h2><ul>
<li><code>strace</code>：打印一个正在运行的程序以及它的子进程所做的系统调用轨迹</li>
<li><code>ps</code>：列出所有进程</li>
<li><code>pmap</code>：显示进程的内存映射</li>
<li><code>top/htop</code>：类似于任务管理器</li>
</ul>
<h1 id="Chapter-9-虚拟内存"><a href="#Chapter-9-虚拟内存" class="headerlink" title="Chapter 9 虚拟内存"></a>Chapter 9 虚拟内存</h1><p>虚拟内存提供了三个重要的能力：</p>
<ul>
<li>在主存中只保留活动区域，高效地利用了主存</li>
<li>它为每个进程分配了一致的地址空间，简化了内存管理</li>
<li>每个进程拥有了自己独特的地址空间，内存空间因而不会受到破坏</li>
</ul>
<h2 id="物理寻址和虚拟寻址"><a href="#物理寻址和虚拟寻址" class="headerlink" title="物理寻址和虚拟寻址"></a>物理寻址和虚拟寻址</h2><p>计算机的主存系统被组织成一个由M个连续字节组成的一个数组。每个字节都有一个唯一的 <strong>物理地址</strong> 。现代操作系统的主存一般使用 <strong>虚拟地址</strong> 来访问，CPU上的内存管理单元(Memory Management Unit, <strong>MMU</strong>)可以将虚拟地址翻译成物理地址。</p>
<p>物理地址的最大值与物理主存有关，其值等于物理主存的容量。虚拟地址的最大值与计算机系统的寻址位数相关，其值等于2的x次幂，其中x是寻址位数(如32和64)。</p>
<h3 id="虚拟内存作为缓存"><a href="#虚拟内存作为缓存" class="headerlink" title="虚拟内存作为缓存"></a>虚拟内存作为缓存</h3><p>主存可以看作是对磁盘上数据的缓存。和存储器层次结构中的其他缓存一样，磁盘中的数据被分割成块，这些块作为主存和磁盘之间的数据传输单元。</p>
<p>虚拟内存系统将虚拟内存划分为大小相同的 <strong>虚拟页</strong>(VP) ，这些虚拟页就是数据传输的单元。所有的虚拟页被内存管理系统分为三个不相交的子集：</p>
<ul>
<li>未分配的：这个VP在虚拟内存系统中还没有写入数据，不占用物理磁盘空间</li>
<li>未缓存的：这个VP已经被写入了一部分数据，但它所对应的物理内存中尚未缓存这些数据</li>
<li>已缓存的：VP和物理内存中都已经存储了数据</li>
</ul>
<h4 id="缓存的组织结构"><a href="#缓存的组织结构" class="headerlink" title="缓存的组织结构"></a>缓存的组织结构</h4><p>我们将主存与CPU之间的三层高速缓存称为 <strong>SRAM缓存</strong> ，将虚拟内存系统对应的缓存(主存)称为 <strong>DRAM缓存</strong> 。一般来说，DRAM比SRAM慢数百倍，而比磁盘快十万倍。这样一来，DRAM缓存不命中的开销就变的非常之大。不仅如此，从磁盘的扇区开始读第一个字节的开销比阅读连续字节大得多。</p>
<p>DRAM的这些特性决定了它的组织结构：</p>
<ul>
<li><strong>虚拟页很大</strong>，通常是4KB-2MB，这样对缓存发起的请求不命中的概率会比较小，缓存也就不需要进程该行回到效率低下的磁盘去寻求对请求的回应。</li>
<li><strong>替换策略更精密</strong>，因为替换错了虚拟页的开销非常大。</li>
<li><strong>使用回写而不是直写</strong>。<ul>
<li>回写：系统先将数据写入缓存，在需要时再写回磁盘</li>
<li>直写：系统将数据同时写入缓存和磁盘</li>
</ul>
</li>
</ul>
<h4 id="分页表"><a href="#分页表" class="headerlink" title="分页表"></a>分页表</h4><p>虚拟内存系统必须能够确认一个VP是否缓存在DRAM中。如果是，还要明确它在真实物理内存中的位置。在缓存不命中时，系统必须判断这个页在磁盘中的位置，然后从物理内存中选择一个牺牲页，并用磁盘中的页取代这个牺牲页。</p>
<p>物理内存中的 <strong>页表</strong>(page table) 负责将虚拟页映射到物理页。页表是一个由 <strong>PTE(page table entry)</strong> 构成的数组，每个PTE都由一个有效位和一个n位地址字段所构成，操作系统用虚拟地址作为索引来找到虚拟页对应的PTE。</p>
<ul>
<li>有效位：表明该虚拟页当前是否已经被缓存<ul>
<li>如果有效位为1,那么地址字段存放这个虚拟页所对应的物理页的物理地址</li>
<li>如果有效位为0<ul>
<li>如果地址是空地址，说明这个页还没有被分配。</li>
<li>如果这个页被分配了但未被缓存，这个地址会存放它在磁盘中的位置。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如果地址翻译硬件发现一个需要访问的VP是未被缓存的,它就会抛出一个 <strong>缺页异常</strong>(page fault) ，从而调用内核中的异常处理程序来选择一个牺牲页，并将磁盘中的页复制到牺牲页的位置。如果牺牲页已经被改动了，异常处理程序会先将其写回磁盘当中(回写式策略的体现)。</p>
<p>缺页异常缓存好需要的VP之后，将控制流交还给导致缺页的指令，使其重新执行一遍。这一次，由于VP已经被缓存，缺页异常就不会发生。</p>
<h4 id="页的生命周期"><a href="#页的生命周期" class="headerlink" title="页的生命周期"></a>页的生命周期</h4><p>在创建新页的时候，操作系统在磁盘上开辟一片区域，并让一个废弃的PTE指向这个区域。程序所有对这一页虚拟内存的操作会首先被缓存到物理内存DRAM上。当这一页成为牺牲页的时候，回写策略会将这一页更新的所有内容写回磁盘中对应的区域。</p>
<h3 id="虚拟内存作为内存管理工具"><a href="#虚拟内存作为内存管理工具" class="headerlink" title="虚拟内存作为内存管理工具"></a>虚拟内存作为内存管理工具</h3><p>操作系统会为每个进程分配一个相同的页表，也就是说每个进程都有一个一致的地址空间。按需的页面调度使这种设计成为可能，这对内存的使用和管理产生了深远的影响。</p>
<ul>
<li><strong>简化链接</strong>：由于所有进程的内存结构都是一样的，链接器可以使用完全相同的工作逻辑去生成可执行文件，而且这些可执行文件是独立于物理地址中数据和代码的位置的。</li>
<li><strong>简化加载</strong>：在向内存中加载可执行文件或者共享库时，调度系统为代码和数据段分配虚拟页，将它们标记为未被缓存的虚拟页，并将PTE指针指向磁盘中的相应位置。这样，代码和数据按需调用，节省了很多加载无用数据的时间和空间。</li>
<li><strong>简化共享</strong>：不同进程的PTE可以指向同一个磁盘区域，这样它们就实现了自然的文件共享。</li>
<li><strong>简化内存分配</strong>：当用户进程申请额外内存时，可以从磁盘中随机映射等量的内存块。</li>
</ul>
<h3 id="虚拟内存作为内存保护工具"><a href="#虚拟内存作为内存保护工具" class="headerlink" title="虚拟内存作为内存保护工具"></a>虚拟内存作为内存保护工具</h3><p>在PTE中增加几个许可位使得内存的权限控制变得异常简单。一般来说，许可位会包括SUP(进程是否必须运行在root下)，READ和WRITE等。</p>
<p>如果一个进程违反了这种条件，CPU就会引发一个异常。这种异常一般会以段错误的形式进行报错。</p>
<p>在编写C语言程序时常常出现的segmentation fault错误就是因为内存访问越界，从而触发了这个异常。</p>
<h2 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>首先列出一些常用的地址翻译符号：</p>
<p><img src="Chapter_9/symbol.png" alt="symbol.png"></p>
<p>形式上来讲，地址翻译是一个N元素的虚拟地址空间和一个M元素的物理地址空间中元素之间的映射。MMU利用页表来实现这种映射。</p>
<p>CPU中的 <strong>页表基址寄存器</strong> 指向当前页表。</p>
<p>n位的虚拟地址分为两个部分：</p>
<table>
<thead>
<tr>
<th>虚拟页号(n-p位)</th>
<th>虚拟页面偏移(p位)</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>而m位的物理地址也分为两个部分：</p>
<p>| 物理页号(m-p位) | 物理页面偏移(p位) |</p>
<p>在进行映射的时候，MMU将虚拟页号作为索引去找到对应的PTE，从而找到对应的物理页号；而由于物理页和虚拟页的大小是相同的，虚拟页面偏移可以直接作为物理页面偏移。这样，我们就得到了一个物理地址。</p>
<h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>Linux可以将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这片内存区域的内容，这种机制称为内存映射。虚拟内存区域可以映射为如下两种类型的对象中的一种：</p>
<ol>
<li>普通文件：一个区域可以映射到一个磁盘中的连续部分，覆盖一个普通Linux文件。文件区被分为页大小的片，每一片都与一个PTE相关联。当缺页中断被触发时，触发中断的那一片文件会被读入内存。</li>
<li>匿名文件：匿名文件是一个抽象的文件，它的内容完全是二进制零。当CPU请求映射到匿名文件的内存区域时，就直接用二进制零覆盖牺牲页面。这种情况下，内存与磁盘之间并没有实质的数据交换。</li>
</ol>
<h3 id="共享对象与私有对象"><a href="#共享对象与私有对象" class="headerlink" title="共享对象与私有对象"></a>共享对象与私有对象</h3><p>对于一个共享对象，它可以同时被多个进程所引用和修改，而且这些修改对所有共享它的进程都是可见的。因此，一个被多进程共享的对象只需要在物理内存中保留自己的一个副本，让各个进程的PTE都指向这个副本即可。</p>
<p>而对于私有对象，操作系统使用了一种 <strong>写时复制(copy-on-write)</strong> 技术，即对于被多个进程分别私有占有的一个对象，一开始只保留它的一个物理内存副本；直到其中的一个进程试图对这个对象进行写操作时，才触发一个异常来复制这个对象并将新副本分配给那个进程。</p>
<p>写时复制机制充分利用了珍贵的内存空间。</p>
<p>有了这种机制，我们就可以理解fork在创建子进程时的行为了。fork创建新的子进程时，它会继承父进程的地址空间，数据结构等信息，而这些信息都可以通过写时复制机制来进行存储，这样创建新的子进程的开销就会变得很小。</p>
<p>而对于二进制可执行文件的加载和运行，就需要分别映射共享内存区域和私有区域，并最后转交控制权。映射完成后的进程内存空间结构如下图：</p>
<p><img src="Chapter_9/structure.png" alt="structure.png"></p>
<h3 id="用户级内存映射"><a href="#用户级内存映射" class="headerlink" title="用户级内存映射"></a>用户级内存映射</h3><p><code>mmap</code>函数可以在虚拟内存中创建一片区域并将一个对象映射过去。<code>munmap</code>可以取消这种映射。</p>
<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p>动态内存分配主要指堆内存。它紧接着未初始化变量区，并向上生长。</p>
<p>堆顶指针称为<code>brk</code>，它决定着堆的大小。分配器将堆看作一些大小不同的块来维护。每个块都是一个内存片，要么是已分配的，要么是空闲的。分配器有两种风格：</p>
<ul>
<li>显式分配：比如C语言的malloc和free，还有C++的new和delete。</li>
<li>隐式分配：典型的有Java，Lisp和ML的垃圾回收。</li>
</ul>
<h3 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h3><p>一个简单的堆块的数据结构格式是这样的：</p>
<ul>
<li>一个头部，包括块大小信息和标识这个块是否被分配的信息</li>
<li>有效载荷(malloc返回的地址是这个区域的开始地址)</li>
<li>填充部分，为了使块大小固定的填充物</li>
</ul>
<p>这样，我们就将堆块组织成为一个序列。它们由头部中的堆块大小信息隐式相连。</p>
<h3 id="放置策略"><a href="#放置策略" class="headerlink" title="放置策略"></a>放置策略</h3><p>当应用请求一个字节块时，分配器搜索空闲链表以找到一个大小足够的块。这个搜索过程有几种策略可以选用：</p>
<ul>
<li>首次适配：每次都从头开始搜索</li>
<li>下一次适配：从上次结束的位置开始</li>
<li>最佳适配：每次都遍历链表，找到最合适的块</li>
</ul>
<p>对于链表式的存储来讲，最佳适配显然有些慢了。但是利用更加精细的数据结构，我们可以做到让最佳适配的时间和空间复杂度都做到很低。</p>
<h3 id="空闲块分割"><a href="#空闲块分割" class="headerlink" title="空闲块分割"></a>空闲块分割</h3><p>如果没有很合适大小的空闲块，系统会将一个大空闲块切开，从而得到一个合适大小的块。</p>
<h3 id="合并空闲块"><a href="#合并空闲块" class="headerlink" title="合并空闲块"></a>合并空闲块</h3><p>对于空闲块分割产生的碎片的合并问题，有立即合并和推迟合并两种策略。我们假设使用立即合并，但其实大部分快速的分配器都会使用推迟合并。</p>
<p>由于隐式链表是单向的，如果要合并一个前面的块就很不方便。knuth提出了一种解决方法，即在每个块的最后增加一个头部的副本，称为脚部。这样，每个块都可以通过访问前面块的脚部来确定前面一个块的大小，从而实现合并。</p>
<p>有一种对脚部空间占用率的优化，它利用了脚部和头部的最后部分是定长标志位的特性。由于已分配的堆块显然不能合并，完全可以将已分配堆块的脚部用于存放数据，只留下最后的标志位。空闲块通过判断标志位判断前面的块是否已分配，从而决定是否可以合并。这样就大大缩减了脚部所占用的空间。</p>
<h3 id="分离的空闲链表"><a href="#分离的空闲链表" class="headerlink" title="分离的空闲链表"></a>分离的空闲链表</h3><p>如果使用最佳适配策略，一个使用单向空闲链表的分配器需要与空闲块数量成线性关系的时间来分配。一个流行的减小分配时间的策略是使用 <strong>分离存储</strong> 的策略，就是维护多个空闲链表，其中每个链表的块大小都在某个小范围内。</p>
<p>分配器维护着一个空闲链表数组，每个大小类都是数组的一个元素，当分配器需要一个大小为n的块时，它就搜索对应的空闲链表，如果搜索不命中则去搜索下一个链表，以此类推。</p>
<p>分离存储策略有几十种不同的实现，这里简单介绍两种。</p>
<h4 id="简单分离存储"><a href="#简单分离存储" class="headerlink" title="简单分离存储"></a>简单分离存储</h4><p>在这种存储策略下，每个空闲链表中的块大小 <strong>完全一致</strong> ，且一般为2的次幂。分配的时候，分配器用常数时间找到大小大于需求且最接近需求的空闲链表，并直接取出第一块，不做分割地分配给请求者。释放的时候，只需要简单地将释放出的内存块挂到相应大小的链表开头即可。如果链表为空，就申请一片大内存，等分为这个链表对应大小的块并做一条新链表。</p>
<p>这种策略的时空复杂度都是最小的。然而，显而易见的会引起严重的碎片化问题。</p>
<h4 id="分离适配"><a href="#分离适配" class="headerlink" title="分离适配"></a>分离适配</h4><p>这种策略下，每个链表的块大小属于一个范围。在分配时，分配器会在相应大小范围的链表内做首次适配，一旦适配完成就取出那个块，分割出与申请大小相等的一部分来授予申请者，剩余的插入与剩余部分大小对应的空闲链表内。这种策略显著提高了空间利用率。</p>
<h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>垃圾收集器使程序员从手动释放内存的枷锁中解放出来。它以某种策略定期识别垃圾内存块，并调用free去自动释放它们。</p>
<p>垃圾收集器将内存视为一个有向图。这个图分为 <strong>堆节点</strong> 和 <strong>根节点</strong> ：堆节点代表着堆内存块，根节点代表着在堆外部的存储，如寄存器和其他内存区域。</p>
<p>任何时候，如果存在着从根节点到一个堆节点的路径，就代表这个堆节点能被访问到，于是它是可用的；但如果一个堆节点无法从根节点抵达，那它显然无法被外部访问，是垃圾内存块。垃圾回收器定期地释放这些不可达节点并返还给空闲链表，来实现垃圾回收。</p>
<p>一种经典的算法称为Mark&amp;Sweep。它首先从所有的根节点出发去进行图遍历，并标记所有能够到达的堆节点；然后遍历所有的堆节点，回收掉那些没有被标记的节点。</p>
<h2 id="C程序中可能引发的与内存相关的错误"><a href="#C程序中可能引发的与内存相关的错误" class="headerlink" title="C程序中可能引发的与内存相关的错误"></a>C程序中可能引发的与内存相关的错误</h2><h3 id="间接引用坏指针"><a href="#间接引用坏指针" class="headerlink" title="间接引用坏指针"></a>间接引用坏指针</h3><p>对于某些接受一个地址并将结果写入该地址的函数，传入的地址参数显然可能非常危险。如果在这里传入了一个保护区域的地址，程序会引发异常并退出；如果正好传入了一个可读写区域的地址，那这个函数就会将输出写到这个区域内。这会覆盖掉这片区域本来的内容。</p>
<h3 id="读未初始化的内存"><a href="#读未初始化的内存" class="headerlink" title="读未初始化的内存"></a>读未初始化的内存</h3><p>堆内存不会被自动初始化为0,因此需要手动设置。</p>
<h3 id="栈缓冲区溢出"><a href="#栈缓冲区溢出" class="headerlink" title="栈缓冲区溢出"></a>栈缓冲区溢出</h3><p>buffer attack的原理，之前在第三章有过描述。</p>
<h3 id="新手常犯的错误"><a href="#新手常犯的错误" class="headerlink" title="新手常犯的错误"></a>新手常犯的错误</h3><ul>
<li>假设变量和指针大小相同</li>
<li>搞错运算符优先级</li>
<li>在函数已经返回后试图用指针引用函数内的局部变量</li>
<li>引用野指针(已经被释放过的指针)</li>
<li>不调用free引起内存泄漏</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/blog/images/lyrica.png" alt="Drac Zhang">
            
              <p class="site-author-name" itemprop="name">Drac Zhang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/blog/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/dracit7" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Drac Zhang</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://Drac_zhang.disqus.com/count.js" async></script>
    

    

  




	





  














  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
