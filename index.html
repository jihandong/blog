<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Gensokyo">
<meta property="og:url" content="https://dracit7.github.io/blog/index.html">
<meta property="og:site_name" content="Gensokyo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Gensokyo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://dracit7.github.io/blog/">





  <title>Gensokyo</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Gensokyo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Youkai's Mountain</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/blog/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2019/06/06/MIT_6.828_code/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/06/06/MIT_6.828_code/" itemprop="url">MIT 6.828 Labs 源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-06T18:59:12+08:00">
                2019-06-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Academic or Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/Operating-System/" itemprop="url" rel="index">
                    <span itemprop="name">Operating System</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2019/06/06/MIT_6.828_code/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/06/06/MIT_6.828_code/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MIT-6-828-Labs-源码分析"><a href="#MIT-6-828-Labs-源码分析" class="headerlink" title="MIT 6.828 Labs 源码分析"></a>MIT 6.828 Labs 源码分析</h1><h2 id="MakeFile-Part"><a href="#MakeFile-Part" class="headerlink" title="MakeFile Part"></a>MakeFile Part</h2><h3 id="GNUmakefile"><a href="#GNUmakefile" class="headerlink" title="/GNUmakefile"></a>/GNUmakefile</h3><p>在6.828的lab根目录下有一个<code>GNUmakefile</code>，这是整个JOS内核的makefile，它会包含各个子目录下的<code>Makefrag</code>文件，负责提供各种编译指令接口。</p>
<h4 id="verbose-commands"><a href="#verbose-commands" class="headerlink" title="verbose commands"></a>verbose commands</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Run 'make V=1' to turn on verbose commands, or 'make V=0' to turn them off.</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(V)</span>,1)</span><br><span class="line"><span class="keyword">override</span> V =</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(V)</span>,0)</span><br><span class="line"><span class="keyword">override</span> V = @</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">-include</span> conf/lab.mk</span><br><span class="line"></span><br><span class="line"><span class="keyword">-include</span> conf/env.mk</span><br><span class="line"></span><br><span class="line">LABSETUP ?= ./</span><br><span class="line"></span><br><span class="line">TOP = .</span><br></pre></td></tr></table></figure>
<p><code>V</code>是<code>conf/env.mk</code>中定义的一个变量，我们可以在这个文件中找到对它的描述：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># '$(V)' controls whether the lab makefiles print verbose commands (the</span></span><br><span class="line"><span class="comment"># actual shell commands run by Make), as well as the "overview" commands</span></span><br><span class="line"><span class="comment"># (such as '+ cc lib/readline.c').</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For overview commands only, the line should read 'V = @'.</span></span><br><span class="line"><span class="comment"># For overview and verbose commands, the line should read 'V ='.</span></span><br><span class="line">V = @</span><br></pre></td></tr></table></figure>
<p>从注释中可以看出，<code>V</code>变量控制了<code>make</code>是否打印出详细的指令(也就是每一条shell指令)。默认情况下，<code>make</code>只会打印出简略的指令信息来告知我们目前在处理哪个指令。</p>
<h4 id="Compiler-Tool-chain-configure"><a href="#Compiler-Tool-chain-configure" class="headerlink" title="Compiler Tool-chain configure"></a>Compiler Tool-chain configure</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cross-compiler jos toolchain</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This Makefile will automatically use the cross-compiler toolchain</span></span><br><span class="line"><span class="comment"># installed as 'i386-jos-elf-*', if one exists.  If the host tools ('gcc',</span></span><br><span class="line"><span class="comment"># 'objdump', and so forth) compile for a 32-bit x86 ELF target, that will</span></span><br><span class="line"><span class="comment"># be detected as well.  If you have the right compiler toolchain installed</span></span><br><span class="line"><span class="comment"># using a different name, set GCCPREFIX explicitly in conf/env.mk</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># try to infer the correct GCCPREFIX</span></span><br><span class="line"><span class="keyword">ifndef</span> GCCPREFIX</span><br><span class="line">GCCPREFIX := <span class="variable">$(<span class="built_in">shell</span> \</span></span><br><span class="line"><span class="variable">	<span class="built_in">if</span> i386-jos-elf-objdump -i 2&gt;&amp;1 | grep '^elf32-i386$$' &gt;/dev/null 2&gt;&amp;1; \</span></span><br><span class="line"><span class="variable">	then echo 'i386-jos-elf-'; \</span></span><br><span class="line"><span class="variable">	elif objdump -i 2&gt;&amp;1 | grep 'elf32-i386' &gt;/dev/null 2&gt;&amp;1; \</span></span><br><span class="line"><span class="variable">	then echo ''; \</span></span><br><span class="line"><span class="variable">	else echo "***" 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">	echo "*** If your i386-*-elf toolchain is installed with a command" 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">	echo "*** prefix other than 'i386-jos-elf-', set your GCCPREFIX" 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">	echo "*** environment variable to that prefix <span class="built_in">and</span> run 'make' again." 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">	echo "*** To turn off this <span class="built_in">error</span>, run 'gmake GCCPREFIX= ...'." 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">	echo "***" 1&gt;&amp;2; exit 1; fi)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># try to infer the correct QEMU</span></span><br><span class="line"><span class="keyword">ifndef</span> QEMU</span><br><span class="line">QEMU := <span class="variable">$(<span class="built_in">shell</span> \</span></span><br><span class="line"><span class="variable">	<span class="built_in">if</span> which qemu &gt;/dev/null 2&gt;&amp;1; \</span></span><br><span class="line"><span class="variable">	then echo qemu; exit; \</span></span><br><span class="line"><span class="variable">        elif which qemu-system-i386 &gt;/dev/null 2&gt;&amp;1; \</span></span><br><span class="line"><span class="variable">        then echo qemu-system-i386; exit; \</span></span><br><span class="line"><span class="variable">	else \</span></span><br><span class="line"><span class="variable">	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \</span></span><br><span class="line"><span class="variable">	<span class="built_in">if</span> test -x $$qemu; then echo $$qemu; exit; fi; fi; \</span></span><br><span class="line"><span class="variable">	echo "***" 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">	echo "*** Error: Couldn't find a working QEMU executable." 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">	echo "*** Is the directory containing the qemu binary in your PATH" 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">	echo "*** <span class="built_in">or</span> have you tried setting the QEMU variable in conf/env.mk?" 1&gt;&amp;2; \</span></span><br><span class="line"><span class="variable">	echo "***" 1&gt;&amp;2; exit 1)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>这一段代码是用来设定编译使用的工具链的。6.828的代码主要会使用两个工具：<code>GCC</code>以及其下属的GNU工具链，以及<code>qemu</code>。6.828官方提供的工具链是以<code>i386-jos-elf</code>之类的前缀打头的，而Linux自带的工具链是没有这些前缀的，makefile接受这两种工具链。</p>
<p>两段Shell语句根据系统中安装的工具链种类分别设定了<code>GCCPREFIX</code>和<code>QEMU</code>两个变量，具体的语句逻辑为：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $(GCCPREFIX)</span></span><br><span class="line"><span class="comment"># objdump -i : List all architectures supported</span></span><br><span class="line">if i386-jos-elf-objdump -i 2&gt;&amp;1 | grep '^elf32-i386$$' &gt;/dev/null 2&gt;&amp;1; then</span><br><span class="line">  <span class="comment"># 1. 这里如果没有安装6.828官方工具链，会报找不到该命令到stderr，这里2&gt;&amp;1将stderr重定向到了stdout</span></span><br><span class="line">  <span class="comment">#    接下来一个管道导向到grep，grep负责看objdump是否支持这种架构，如果不支持，grep进程返回1,</span></span><br><span class="line">  <span class="comment">#    if判断为假控制流转到elif；否则控制流到then，设置$(GCCPREFIX)为i386-jos-elf。</span></span><br><span class="line">  <span class="comment"># 2. 这里由于我们是将shellscript产生的输出设定为$(GCCPREFIX)的值，不希望产生任何额外的输出，</span></span><br><span class="line">  <span class="comment">#    需要将stdout和stderr重定向到/dev/null以丢弃这些输出。</span></span><br><span class="line">	echo 'i386-jos-elf-';</span><br><span class="line">elif objdump -i 2&gt;&amp;1 | grep 'elf32-i386' &gt;/dev/null 2&gt;&amp;1; then</span><br><span class="line">	<span class="comment"># 如果没有安装6.828官方提供的工具链，使用Linux默认的GNU系列工具也是可以的。</span></span><br><span class="line">	echo '';</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">	<span class="comment"># 如果两个工具链都没有/工具链不支持i386-elf架构，报错并退出。</span></span><br><span class="line">	echo <span class="string">"***"</span> 1&gt;&amp;2;</span><br><span class="line">  echo <span class="string">"*** Error: Couldn't find an i386-*-elf version of GCC/binutils."</span> 1&gt;&amp;2;</span><br><span class="line">  echo <span class="string">"*** Is the directory with i386-jos-elf-gcc in your PATH?"</span> 1&gt;&amp;2;</span><br><span class="line">  echo <span class="string">"*** If your i386-*-elf toolchain is installed with a command"</span> 1&gt;&amp;2;</span><br><span class="line">  echo <span class="string">"*** prefix other than 'i386-jos-elf-', set your GCCPREFIX"</span> 1&gt;&amp;2;</span><br><span class="line">  echo <span class="string">"*** environment variable to that prefix and run 'make' again."</span> 1&gt;&amp;2;</span><br><span class="line">  echo <span class="string">"*** To turn off this error, run 'gmake GCCPREFIX= ...'."</span> 1&gt;&amp;2;</span><br><span class="line">  echo <span class="string">"***"</span> 1&gt;&amp;2;</span><br><span class="line">  <span class="comment"># 这里的报错信息是说明如果你安装了自己的工具链，可以通过设置`GCCPREFIX`变量来让make能够找到它们。</span></span><br><span class="line">  exit 1;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="comment"># $(QEMU)是能打开qemu的文件名。</span></span><br><span class="line">if which qemu &gt;/dev/null 2&gt;&amp;1; then</span><br><span class="line">	<span class="comment"># 如果已经安装qemu，which能够找到它，则直接设置</span></span><br><span class="line">	<span class="comment"># 同理，这里我们不要输出</span></span><br><span class="line">	echo qemu;</span><br><span class="line">	exit;</span><br><span class="line">elif which qemu-system-i386 &gt;/dev/null 2&gt;&amp;1; then</span><br><span class="line">  <span class="comment"># qemu可能的另外一种名字</span></span><br><span class="line">	echo qemu-system-i386;</span><br><span class="line">	exit;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="comment"># 高贵的mac用户可能会需要这个情况</span></span><br><span class="line">	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu;</span><br><span class="line">	if test -x $$qemu; then</span><br><span class="line">		echo $$qemu;</span><br><span class="line">		exit;</span><br><span class="line">	fi;</span><br><span class="line">fi;</span><br><span class="line"><span class="comment"># 如果三种情况都不符合，则报错退出</span></span><br><span class="line">echo <span class="string">"***"</span> 1&gt;&amp;2; </span><br><span class="line">echo <span class="string">"*** Error: Couldn't find a working QEMU executable."</span> 1&gt;&amp;2;</span><br><span class="line">echo <span class="string">"*** Is the directory containing the qemu binary in your PATH"</span> 1&gt;&amp;2;</span><br><span class="line">echo <span class="string">"*** or have you tried setting the QEMU variable in conf/env.mk?"</span> 1&gt;&amp;2;</span><br><span class="line">echo <span class="string">"***"</span> 1&gt;&amp;2;</span><br><span class="line">exit 1</span><br></pre></td></tr></table></figure>
<h4 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># try to generate a unique GDB port</span></span><br><span class="line">GDBPORT	:= <span class="variable">$(<span class="built_in">shell</span> expr `id -u` % 5000 + 25000)</span></span><br><span class="line"></span><br><span class="line">CC	:= <span class="variable">$(GCCPREFIX)</span>gcc -pipe</span><br><span class="line">GDB	:= <span class="variable">$(GCCPREFIX)</span>gdb</span><br><span class="line">AS	:= <span class="variable">$(GCCPREFIX)</span>as</span><br><span class="line">AR	:= <span class="variable">$(GCCPREFIX)</span>ar</span><br><span class="line">LD	:= <span class="variable">$(GCCPREFIX)</span>ld</span><br><span class="line">OBJCOPY	:= <span class="variable">$(GCCPREFIX)</span>objcopy</span><br><span class="line">OBJDUMP	:= <span class="variable">$(GCCPREFIX)</span>objdump</span><br><span class="line">NM	:= <span class="variable">$(GCCPREFIX)</span>nm</span><br><span class="line"></span><br><span class="line"><span class="comment"># Native commands</span></span><br><span class="line">NCC	:= gcc <span class="variable">$(CC_VER)</span> -pipe</span><br><span class="line">NATIVE_CFLAGS := <span class="variable">$(CFLAGS)</span> <span class="variable">$(DEFS)</span> <span class="variable">$(LABDEFS)</span> -I<span class="variable">$(TOP)</span> -MD -Wall</span><br><span class="line">TAR	:= gtar</span><br><span class="line">PERL	:= perl</span><br></pre></td></tr></table></figure>
<p>根据之前设定的<code>$(GCCPREFIX)</code>来设置各个工具的名称变量。之后就可以直接使用这些工具。</p>
<h4 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Compiler flags</span></span><br><span class="line"><span class="comment"># -fno-builtin is required to avoid refs to undefined functions in the kernel.</span></span><br><span class="line"><span class="comment"># Only optimize to -O1 to discourage inlining, which complicates backtraces.</span></span><br><span class="line">CFLAGS := <span class="variable">$(CFLAGS)</span> <span class="variable">$(DEFS)</span> <span class="variable">$(LABDEFS)</span> -O1 -fno-builtin -I<span class="variable">$(TOP)</span> -MD</span><br><span class="line">CFLAGS += -fno-omit-frame-pointer</span><br><span class="line">CFLAGS += -std=gnu99</span><br><span class="line">CFLAGS += -static</span><br><span class="line">CFLAGS += -fno-pie</span><br><span class="line">CFLAGS += -Wall -Wno-format -Wno-unused -Werror -gstabs -m32</span><br><span class="line"><span class="comment"># -fno-tree-ch prevented gcc from sometimes reordering read_ebp() before</span></span><br><span class="line"><span class="comment"># mon_backtrace()'s function prologue on gcc version: (Debian 4.7.2-5) 4.7.2</span></span><br><span class="line">CFLAGS += -fno-tree-ch</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add -fno-stack-protector if the option exists.</span></span><br><span class="line">CFLAGS += <span class="variable">$(<span class="built_in">shell</span> <span class="variable">$(CC)</span> -fno-stack-protector -E -x c /dev/null &gt;/dev/null 2&gt;&amp;1 &amp;&amp; echo -fno-stack-protector)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Common linker flags</span></span><br><span class="line">LDFLAGS := -m elf_i386</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linker flags for JOS user programs</span></span><br><span class="line">ULDFLAGS := -T user/user.ld</span><br><span class="line"></span><br><span class="line">GCC_LIB := <span class="variable">$(<span class="built_in">shell</span> <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -print-libgcc-<span class="built_in">file</span>-name)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Lists that the */Makefrag makefile fragments will add to</span></span><br><span class="line">OBJDIRS :=</span><br></pre></td></tr></table></figure>
<p>对编译器和链接器设定的一些参数。</p>
<ul>
<li><code>CFLAGS</code>：gcc使用的各个参数(<strong>重要</strong>)。<ul>
<li><code>-O1</code>：<strong>JOS内核使用<code>O1</code>优化等级编译</strong>，这是为了减少显式的inline声明，让debug变得更简单。</li>
<li><code>-fno-builtin</code>：<strong>不使用任何C语言的内建函数</strong>，防止JOS自己定义和实现的函数与原有的C标准库函数发生命名冲突。这里如果想单独屏蔽几个函数的话也可以<code>-fno-builtin-&lt;functionname&gt;</code>。</li>
<li><code>-I$(TOP)</code>：之前设置了<code>TOP=.</code>所以这个参数其实是<code>-I.</code>。这个参数会让<strong>GCC优先在<code>.</code>目录下查找头文件</strong>，以让JOS在使用<code>&lt;&gt;</code>的情况下也可以优先使用<code>inc</code>目录下的头文件。类似的参数有<code>-L</code>，用来使GCC优先在指定目录下寻找库文件。</li>
<li><code>-MD</code>：将目标文件所需要的全部依赖信息输出到一个<code>.d</code>文件中。这里如果是<code>-M</code>就是输出到<code>stdout</code>，如果是<code>-MM</code>就不输出由头文件包含所引起的依赖。</li>
<li><code>-fno-omit-frame-pointer</code>：<strong>在优化代码时不省略对<code>ebp</code>寄存器的压栈操作</strong>，也就是保持栈帧的完整结构。默认情况下这个选项应该是开启的，这里可能是以防万一。如果这个选项不开启，在函数调用时就不会先压入<code>ebp</code>，从而为<code>backtrace</code>带来困难。</li>
<li><code>-static</code>：优先使用静态库</li>
<li><code>-std=gnu99</code>：使用GNU扩展的<code>C99</code>标准</li>
<li><code>-fno-pie</code>：<strong>不生成位置无关代码</strong>，关系到一些6.828中的思考题</li>
<li><code>-Wall</code>：显示所有警告。这一行主要是关于调试信息生成的。</li>
<li><code>-Werror</code>：<strong>把所有警告当作错误</strong>。<del>与上一行结合起来可以发现设计实验的人是魔鬼(不是)</del></li>
<li><code>-gstabs</code>：生成<code>stab</code>格式的调试信息，在Lab1中设计<code>monitor</code>的时候会用到。</li>
<li><code>-m32</code>：<strong>生成32位汇编代码</strong>。</li>
</ul>
</li>
<li><code>LDFLAGS</code>：链接器使用的参数，这里的<code>-m elf_i386</code>是指定模型。</li>
<li><code>ULDFLAGS = -T user/user.ld</code>：指定链接器使用的用户脚本<ul>
<li><code>info ld</code>可以查看<code>.ld</code>文件的格式介绍</li>
<li>具体的脚本内容在之后研究</li>
</ul>
</li>
<li><code>GCC_LIB</code>：gcc使用的库文件路径</li>
</ul>
<p>Suffixs</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Make sure that 'all' is the first target</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Eliminate default suffix rules</span></span><br><span class="line"><span class="section">.SUFFIXES:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Delete target files if there is an error (or make is interrupted)</span></span><br><span class="line"><span class="section">.DELETE_ON_ERROR:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># make it so that no intermediate .o files are ever deleted</span></span><br><span class="line"><span class="section">.PRECIOUS: %.o <span class="variable">$(OBJDIR)</span>/boot/%.o <span class="variable">$(OBJDIR)</span>/kern/%.o \</span></span><br><span class="line">	   <span class="variable">$(OBJDIR)</span>/lib/%.o <span class="variable">$(OBJDIR)</span>/fs/%.o <span class="variable">$(OBJDIR)</span>/net/%.o \</span><br><span class="line">	   <span class="variable">$(OBJDIR)</span>/user/%.o</span><br><span class="line"></span><br><span class="line">KERN_CFLAGS := <span class="variable">$(CFLAGS)</span> -DJOS_KERNEL -gstabs</span><br><span class="line">USER_CFLAGS := <span class="variable">$(CFLAGS)</span> -DJOS_USER -gstabs</span><br><span class="line"></span><br><span class="line"><span class="comment"># Update .vars.X if variable X has changed since the last make run.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Rules that use variable X should depend on $(OBJDIR)/.vars.X.  If</span></span><br><span class="line"><span class="comment"># the variable's value has changed, this will update the vars file and</span></span><br><span class="line"><span class="comment"># force a rebuild of the rule that depends on it.</span></span><br><span class="line"><span class="variable">$(OBJDIR)</span>/.vars.%: FORCE</span><br><span class="line">	<span class="variable">$(V)</span>echo <span class="string">"$(<span class="variable">$*</span>)"</span> | cmp -s <span class="variable">$@</span> || echo <span class="string">"$(<span class="variable">$*</span>)"</span> &gt; <span class="variable">$@</span></span><br><span class="line"><span class="section">.PRECIOUS: <span class="variable">$(OBJDIR)</span>/.vars.%</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: FORCE</span></span><br></pre></td></tr></table></figure>
<p>这一部分主要是一些内置的makefile目标名，用于进行一些设置。</p>
<ul>
<li><code>all</code>：放在最前面，无条件编译全部代码</li>
<li><code>.SUFFIXS</code>：这个目标后的前置条件是将要用于检查后缀规则的后缀们，在这里是空的代表我们不使用后缀规则。</li>
<li><code>.DELETE_ON_ERROR</code>：如果设置了这个目标，make会<strong>在一个规则的<code>recipe</code>进程返回1时删除掉改变了的目标文件</strong>。</li>
<li><code>.PRECIOUS</code>：<strong>这个目标的所有前置条件不会在相应的<code>recipe</code>进程返回1后被删除</strong>。这个目标与刚才的<code>.DELETE_ON_ERROR</code>相结合，可以<strong>对不想在出错时删除的目标们进行保护</strong>。在这里保护的目标是根目录下和<code>obj</code>目录下的所有<code>.o</code>文件。</li>
<li><code>KERN_CFLAGS</code>/<code>USER_CFLAGS</code>：<strong>在编译时带上不同的宏定义</strong>。gcc的编译选项<code>-D</code>后面可以接一个宏定义的名字，<code>-DJOS_KERNEL</code>表示在编译时带一个宏定义<code>JOS_KERNEL</code>，<code>-DJOS_UER</code>同理。<strong>这两个变量主要用来进行内核/用户的权限管理</strong>。</li>
</ul>
<h4 id="Includes-and-QEMU-configure"><a href="#Includes-and-QEMU-configure" class="headerlink" title="Includes and QEMU configure"></a>Includes and QEMU configure</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Include Makefrags for subdirectories</span></span><br><span class="line"><span class="keyword">include</span> boot/Makefrag</span><br><span class="line"><span class="keyword">include</span> kern/Makefrag</span><br><span class="line"><span class="keyword">include</span> lib/Makefrag</span><br><span class="line"><span class="keyword">include</span> user/Makefrag</span><br><span class="line"><span class="keyword">include</span> fs/Makefrag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CPUS ?= 1</span><br><span class="line"></span><br><span class="line">QEMUOPTS = -drive file=<span class="variable">$(OBJDIR)</span>/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::<span class="variable">$(GDBPORT)</span></span><br><span class="line">QEMUOPTS += <span class="variable">$(<span class="built_in">shell</span> <span class="built_in">if</span> <span class="variable">$(QEMU)</span> -nographic -help | grep -q '^-D '; then echo '-D qemu.log'; fi)</span></span><br><span class="line">IMAGES = <span class="variable">$(OBJDIR)</span>/kern/kernel.img</span><br><span class="line">QEMUOPTS += -smp <span class="variable">$(CPUS)</span></span><br><span class="line">QEMUOPTS += -drive file=<span class="variable">$(OBJDIR)</span>/fs/fs.img,index=1,media=disk,format=raw</span><br><span class="line">IMAGES += <span class="variable">$(OBJDIR)</span>/fs/fs.img</span><br><span class="line">QEMUOPTS += <span class="variable">$(QEMUEXTRA)</span></span><br></pre></td></tr></table></figure>
<p>包含选项包含了各个子目录下的Makefrag。</p>
<p><code>CPUS ?= 1</code>将默认的CPU数目置为1。在做lab的过程中我们经常通过设置<code>CPUS = x</code>来增加核数。</p>
<p>对<code>qemu</code>的参数设置主要是与<code>qemu</code>本身规范有关：</p>
<ul>
<li><code>QEMUOPTS</code>：下面用来运行<code>qemu</code>的各种参数<ul>
<li><code>file</code>：将要运行的镜像</li>
<li><code>index</code>：跟在file后，指定这个镜像的序号</li>
</ul>
</li>
<li><code>IMAGES</code>：使用的镜像列表</li>
</ul>
<h4 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">.gdbinit: .gdbinit.tmpl</span></span><br><span class="line">	sed <span class="string">"s/localhost:1234/localhost:<span class="variable">$(GDBPORT)</span>/"</span> &lt; <span class="variable">$^</span> &gt; <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">gdb:</span></span><br><span class="line">	<span class="variable">$(GDB)</span> -n -x .gdbinit</span><br><span class="line"></span><br><span class="line"><span class="section">pre-qemu: .gdbinit</span></span><br><span class="line"></span><br><span class="line"><span class="section">qemu: <span class="variable">$(IMAGES)</span> pre-qemu</span></span><br><span class="line">	<span class="variable">$(QEMU)</span> <span class="variable">$(QEMUOPTS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">qemu-nox: <span class="variable">$(IMAGES)</span> pre-qemu</span></span><br><span class="line">	@echo <span class="string">"***"</span></span><br><span class="line">	@echo <span class="string">"*** Use Ctrl-a x to exit qemu"</span></span><br><span class="line">	@echo <span class="string">"***"</span></span><br><span class="line">	<span class="variable">$(QEMU)</span> -nographic <span class="variable">$(QEMUOPTS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">qemu-gdb: <span class="variable">$(IMAGES)</span> pre-qemu</span></span><br><span class="line">	@echo <span class="string">"***"</span></span><br><span class="line">	@echo <span class="string">"*** Now run 'make gdb'."</span> 1&gt;&amp;2</span><br><span class="line">	@echo <span class="string">"***"</span></span><br><span class="line">	<span class="variable">$(QEMU)</span> <span class="variable">$(QEMUOPTS)</span> -S</span><br><span class="line"></span><br><span class="line"><span class="section">qemu-nox-gdb: <span class="variable">$(IMAGES)</span> pre-qemu</span></span><br><span class="line">	@echo <span class="string">"***"</span></span><br><span class="line">	@echo <span class="string">"*** Now run 'make gdb'."</span> 1&gt;&amp;2</span><br><span class="line">	@echo <span class="string">"***"</span></span><br><span class="line">	<span class="variable">$(QEMU)</span> -nographic <span class="variable">$(QEMUOPTS)</span> -S</span><br><span class="line"></span><br><span class="line"><span class="section">print-qemu:</span></span><br><span class="line">	@echo <span class="variable">$(QEMU)</span></span><br><span class="line"></span><br><span class="line"><span class="section">print-gdbport:</span></span><br><span class="line">	@echo <span class="variable">$(GDBPORT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For deleting the build</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf <span class="variable">$(OBJDIR)</span> .gdbinit jos.in qemu.log</span><br><span class="line"></span><br><span class="line"><span class="section">realclean: clean</span></span><br><span class="line">	rm -rf lab<span class="variable">$(LAB)</span>.tar.gz \</span><br><span class="line">		jos.out <span class="variable">$(<span class="built_in">wildcard</span> jos.out.*)</span> \</span><br><span class="line">		qemu.pcap <span class="variable">$(<span class="built_in">wildcard</span> qemu.pcap.*)</span> \</span><br><span class="line">		myapi.key</span><br><span class="line"></span><br><span class="line"><span class="section">distclean: realclean</span></span><br><span class="line">	rm -rf conf/gcc.mk</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(V)</span>,@)</span><br><span class="line">GRADEFLAGS += -v</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">grade:</span></span><br><span class="line">	@echo <span class="variable">$(MAKE)</span> clean</span><br><span class="line">	@<span class="variable">$(MAKE)</span> clean || \</span><br><span class="line">	  (echo <span class="string">"'make clean' failed.  HINT: Do you have another running instance of JOS?"</span> &amp;&amp; exit 1)</span><br><span class="line">	./grade-lab<span class="variable">$(LAB)</span> <span class="variable">$(GRADEFLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">git-handin: handin-check</span></span><br><span class="line">	@if test -n <span class="string">"`git config remote.handin.url`"</span>; then \</span><br><span class="line">		echo <span class="string">"Hand in to remote repository using 'git push handin HEAD' ..."</span>; \</span><br><span class="line">		if ! git push -f handin HEAD; then \</span><br><span class="line">            echo ; \</span><br><span class="line">			echo <span class="string">"Hand in failed."</span>; \</span><br><span class="line">			echo <span class="string">"As an alternative, please run 'make tarball'"</span>; \</span><br><span class="line">			echo <span class="string">"and visit http://pdos.csail.mit.edu/6.828/submit/"</span>; \</span><br><span class="line">			echo <span class="string">"to upload lab<span class="variable">$(LAB)</span>-handin.tar.gz.  Thanks!"</span>; \</span><br><span class="line">			false; \</span><br><span class="line">		fi; \</span><br><span class="line">    <span class="keyword">else</span> \</span><br><span class="line">		echo <span class="string">"Hand-in repository is not configured."</span>; \</span><br><span class="line">		echo <span class="string">"Please run 'make handin-prep' first.  Thanks!"</span>; \</span><br><span class="line">		false; \</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">WEBSUB := https://6828.scripts.mit.edu/2018/handin.py</span><br><span class="line"></span><br><span class="line"><span class="section">handin: tarball-pref myapi.key</span></span><br><span class="line">	@SUF=<span class="variable">$(LAB)</span>; \</span><br><span class="line">	test -f .suf &amp;&amp; SUF=`cat .suf`; \</span><br><span class="line">	curl -f -F file=@lab$$SUF-handin.tar.gz -F key=\&lt;myapi.key <span class="variable">$(WEBSUB)</span>/upload \</span><br><span class="line">	    &gt; /dev/null || &#123; \</span><br><span class="line">		echo ; \</span><br><span class="line">		echo Submit seems to have failed.; \</span><br><span class="line">		echo Please go to <span class="variable">$(WEBSUB)</span>/ and upload the tarball manually.; &#125;</span><br><span class="line"></span><br><span class="line"><span class="section">handin-check:</span></span><br><span class="line">	@if ! test -d .git; then \</span><br><span class="line">		echo No .git directory, is this a git repository?; \</span><br><span class="line">		false; \</span><br><span class="line">	fi</span><br><span class="line">	@if test <span class="string">"$$(git symbolic-ref HEAD)"</span> != refs/heads/lab<span class="variable">$(LAB)</span>; then \</span><br><span class="line">		git branch; \</span><br><span class="line">		read -p <span class="string">"You are not on the lab<span class="variable">$(LAB)</span> branch.  Hand-in the current branch? [y/N] "</span> r; \</span><br><span class="line">		test <span class="string">"$$r"</span> = y; \</span><br><span class="line">	fi</span><br><span class="line">	@if ! git diff-files --quiet || ! git diff-index --quiet --cached HEAD; then \</span><br><span class="line">		git status -s; \</span><br><span class="line">		echo; \</span><br><span class="line">		echo <span class="string">"You have uncomitted changes.  Please commit or stash them."</span>; \</span><br><span class="line">		false; \</span><br><span class="line">	fi</span><br><span class="line">	@if test -n <span class="string">"`git status -s`"</span>; then \</span><br><span class="line">		git status -s; \</span><br><span class="line">		read -p <span class="string">"Untracked files will not be handed in.  Continue? [y/N] "</span> r; \</span><br><span class="line">		test <span class="string">"$$r"</span> = y; \</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">UPSTREAM := <span class="variable">$(<span class="built_in">shell</span> git remote -v | grep "pdos.csail.mit.edu/6.828/2018/jos.git (fetch)</span><span class="string">" | awk '&#123;split($$0,a,"</span> <span class="string">"); print a[1]&#125;')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">tarball-pref: handin-check</span></span><br><span class="line"><span class="string">	@SUF=<span class="variable">$(LAB)</span>; \</span></span><br><span class="line"><span class="string">	if test <span class="variable">$(LAB)</span> -eq 3 -o <span class="variable">$(LAB)</span> -eq 4; then \</span></span><br><span class="line"><span class="string">		read -p "</span>Which part would you like to submit? [a, b, c (c for lab 4 only)]<span class="string">" p; \</span></span><br><span class="line"><span class="string">		if test "</span>$$p<span class="string">" != a -a "</span>$$p<span class="string">" != b; then \</span></span><br><span class="line"><span class="string">			if test ! <span class="variable">$(LAB)</span> -eq 4 -o ! "</span>$$p<span class="string">" = c; then \</span></span><br><span class="line"><span class="string">				echo "</span>Bad part \<span class="string">"$$p\""</span>; \</span><br><span class="line">				exit 1; \</span><br><span class="line">			fi; \</span><br><span class="line">		fi; \</span><br><span class="line">		SUF=<span class="string">"<span class="variable">$(LAB)</span>$$p"</span>; \</span><br><span class="line">		echo $$SUF &gt; .suf; \</span><br><span class="line">	<span class="keyword">else</span> \</span><br><span class="line">		rm -f .suf; \</span><br><span class="line">	fi; \</span><br><span class="line">	git archive --format=tar HEAD &gt; lab$$SUF-handin.tar; \</span><br><span class="line">	git diff <span class="variable">$(UPSTREAM)</span>/lab<span class="variable">$(LAB)</span> &gt; /tmp/lab$$SUF-diff.patch; \</span><br><span class="line">	tar -rf lab$$SUF-handin.tar /tmp/lab$$SUF-diff.patch; \</span><br><span class="line">	gzip -c lab$$SUF-handin.tar &gt; lab$$SUF-handin.tar.gz; \</span><br><span class="line">	rm lab$$SUF-handin.tar; \</span><br><span class="line">	rm /tmp/lab$$SUF-diff.patch; \</span><br><span class="line"></span><br><span class="line"><span class="section">myapi.key:</span></span><br><span class="line">	@echo Get an API key for yourself by visiting <span class="variable">$(WEBSUB)</span>/</span><br><span class="line">	@read -p <span class="string">"Please enter your API key: "</span> k; \</span><br><span class="line">	if test `echo <span class="string">"$$k"</span> |tr -d '\n' |wc -c` = 32 ; then \</span><br><span class="line">		TF=`mktemp -t tmp.XXXXXX`; \</span><br><span class="line">		if test <span class="string">"x$$TF"</span> != <span class="string">"x"</span> ; then \</span><br><span class="line">			echo <span class="string">"$$k"</span> |tr -d '\n' &gt; $$TF; \</span><br><span class="line">			mv -f $$TF <span class="variable">$@</span>; \</span><br><span class="line">		<span class="keyword">else</span> \</span><br><span class="line">			echo mktemp failed; \</span><br><span class="line">			false; \</span><br><span class="line">		fi; \</span><br><span class="line">	<span class="keyword">else</span> \</span><br><span class="line">		echo Bad API key: $$k; \</span><br><span class="line">		echo An API key should be 32 characters long.; \</span><br><span class="line">		false; \</span><br><span class="line">	fi;</span><br><span class="line"></span><br><span class="line"><span class="comment">#handin-prep:</span></span><br><span class="line"><span class="comment">#	@./handin-prep</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For test runs</span></span><br><span class="line"></span><br><span class="line"><span class="section">prep-%:</span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(MAKE)</span> <span class="string">"INIT_CFLAGS=$&#123;INIT_CFLAGS&#125; -DTEST=`case <span class="variable">$*</span> in *_*) echo <span class="variable">$*</span>;; *) echo user_<span class="variable">$*</span>;; esac`"</span> <span class="variable">$(IMAGES)</span></span><br><span class="line"></span><br><span class="line"><span class="section">run-%-nox-gdb: prep-% pre-qemu</span></span><br><span class="line">	<span class="variable">$(QEMU)</span> -nographic <span class="variable">$(QEMUOPTS)</span> -S</span><br><span class="line"></span><br><span class="line"><span class="section">run-%-gdb: prep-% pre-qemu</span></span><br><span class="line">	<span class="variable">$(QEMU)</span> <span class="variable">$(QEMUOPTS)</span> -S</span><br><span class="line"></span><br><span class="line"><span class="section">run-%-nox: prep-% pre-qemu</span></span><br><span class="line">	<span class="variable">$(QEMU)</span> -nographic <span class="variable">$(QEMUOPTS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">run-%: prep-% pre-qemu</span></span><br><span class="line">	<span class="variable">$(QEMU)</span> <span class="variable">$(QEMUOPTS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This magic automatically generates makefile dependencies</span></span><br><span class="line"><span class="comment"># for header files included from C source files we compile,</span></span><br><span class="line"><span class="comment"># and keeps those dependencies up-to-date every time we recompile.</span></span><br><span class="line"><span class="comment"># See 'mergedep.pl' for more information.</span></span><br><span class="line"><span class="variable">$(OBJDIR)</span>/.deps: <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>, <span class="variable">$(OBJDIRS)</span>, $(<span class="built_in">wildcard</span> <span class="variable">$(OBJDIR)</span>/<span class="variable">$(dir)</span>/*.d)</span>)</span><br><span class="line">	@mkdir -p $(@D)</span><br><span class="line">	@<span class="variable">$(PERL)</span> mergedep.pl <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(OBJDIR)</span>/.deps</span><br><span class="line"></span><br><span class="line"><span class="section">always:</span></span><br><span class="line">	@:</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: all always \</span></span><br><span class="line">	handin git-handin tarball tarball-pref clean realclean distclean grade handin-prep handin-check</span><br></pre></td></tr></table></figure>
<p>在进行了冗长的配置之后，终于到了规则部分。接下来逐条分析这些规则：</p>
<ul>
<li>比较重要的：<ul>
<li><code>gdb</code>：即我们常用的<code>make gdb</code>，<code>-n</code>指定不以默认的<code>~/.gdbinit</code>文件为初始化文件，<code>-x .gdbinit</code>指定新的初始化文件。初始化文件会将我们的gdb配置为运行在<code>i386</code>架构<code>32</code>位模式下，支持elf文件格式。</li>
<li><code>qemu</code>：使用之前已经初始化好的<code>QEMU</code>和<code>QEMUOPTS</code>运行qemu。</li>
<li><code>qemu-nox</code>：增加一个<code>-no-graphic</code>参数</li>
<li><code>qemu-gdb</code>：增加一个<code>-S</code>参数，让qemu在启动时不马上启动CPU。</li>
<li><code>qemu-nox-gdb</code>：上面两个的叠加。</li>
<li><code>grade</code>：运行目录下当前Lab对应的<code>grading</code>脚本。</li>
<li><code>clean</code>：在切换到之前的lab时，如果不<code>make clean</code>删除掉超前的一些<code>.o</code>文件，编译会因为头文件不足而出错。</li>
</ul>
</li>
<li>不太重要的：<ul>
<li><code>.gdbinit</code>：用<code>sed</code>工具将<code>.gdbinit.tmpl</code>中使用的端口<code>1234</code>替换为之前生成的<code>GDBPORT</code>。<code>&lt; $^</code>是以前置条件，即<code>.gdbinit.tmpl</code>为输入，<code>&gt; $@</code>是以目标，即<code>.gdbinit</code>为输出。</li>
<li><code>print-qemu</code>/<code>print-gdb</code>：打印出我们使用的<code>qemu</code>二进制文件或<code>GDBPORT</code>。</li>
<li><code>realclean</code>/<code>distclean</code>：不大会用到，在<code>make clean</code>的基础上多删除些东西。</li>
<li><code>handin</code>系列：用于提交，我们用不到。</li>
</ul>
</li>
</ul>
<p>比较难以分析的一个规则是<code>prep-%</code>，这个规则是后面的几个<code>run-%</code>规则的基础，后面的几个规则都只是在这个基础上以不同的方式打开qemu。这个规则主要的作用是<strong>以不同的参数重新编译内核</strong>。</p>
<p>首先我们阅读<code>init.c</code>可以发现这样一段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(TEST)</span></span><br><span class="line">	<span class="comment">// Don't touch -- used by grading script!</span></span><br><span class="line">	ENV_CREATE(TEST, ENV_TYPE_USER);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="comment">// Touch all you want.</span></span><br><span class="line">	ENV_CREATE(user_spawnhello, ENV_TYPE_USER);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TEST*</span></span></span><br></pre></td></tr></table></figure>
<p>可以发现，如果我们在编译内核时定义了<code>TEST</code>宏，这里就会为<code>TEST</code>的值对应的用户程序创建新进程，否则会运行内核编写者在<code>init.c</code>中自行定义的用户程序。</p>
<p>将<code>prep-%</code>规则的<code>recipe</code>展开，将所有<code>$*</code>转换为<code>%</code>匹配到的值，得：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">make <span class="string">"</span></span><br><span class="line"><span class="string">	INIT_CFLAGS = $&#123;INIT_CFLAGS&#125; -DTEST=`</span></span><br><span class="line"><span class="string">		case % in</span></span><br><span class="line"><span class="string">*_*) echo %;;</span></span><br><span class="line"><span class="string"> 	*) echo user_%;;</span></span><br><span class="line"><span class="string"> 		esac</span></span><br><span class="line"><span class="string"> 	`</span></span><br><span class="line"><span class="string">"</span> <span class="variable">$(IMAGES)</span></span><br></pre></td></tr></table></figure>
<p>这里的<strong>双引号</strong>是为了防止shell将后面的<code>-DTEST</code>参数识别为<code>make</code>的参数。<code>INIT_CFLAGS</code>参数是<code>kern/Makefrag</code>编译内核时传递给<code>gcc</code>的命令行参数，这里用了一个递归的变量<code>${INIT_CFLAGS}</code>以包含原来的参数，后面增加的参数是<code>-DTEST</code>，这个参数定义了<code>TEST</code>宏并为其赋值，以在<code>init.c</code>中运行特定的测试程序。</p>
<p>赋值的方式是一个shellscript的``表达式，其内容是一个<code>case-in</code>结构。根据shellscipt的语法，<code>case-in</code>结构的含义是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">case [condition] in</span><br><span class="line">&lt;case1&gt;)</span><br><span class="line">	&lt;ins&gt;;;</span><br><span class="line">&lt;case2&gt;)</span><br><span class="line">	&lt;ins&gt;;;</span><br><span class="line">...</span><br><span class="line">*) # default</span><br><span class="line">	&lt;ins&gt;;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<p>照这样看，这个结构检查<code>%</code>匹配到的字符串是否满足<code>*_*</code>结构，也就是是否有下划线，如果有，说明指令是<code>run-user_*</code>，那就可以直接用<code>%</code>去作为<code>TEST</code>宏的值；否则，指令是<code>run-*</code>，那么需要为其加上<code>user_</code>前缀。</p>
<h3 id="kern-Makefrag"><a href="#kern-Makefrag" class="headerlink" title="/kern/Makefrag"></a>/kern/Makefrag</h3><p>内核部分的makefile片段。这边的内容没有根目录下的复杂所以直接分段写出大概的解析。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Makefile fragment for JOS kernel.</span></span><br><span class="line"><span class="comment"># This is NOT a complete makefile;</span></span><br><span class="line"><span class="comment"># you must run GNU make in the top-level directory</span></span><br><span class="line"><span class="comment"># where the GNUmakefile is located.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">OBJDIRS += kern</span><br><span class="line"></span><br><span class="line">KERN_LDFLAGS := <span class="variable">$(LDFLAGS)</span> -T kern/kernel.ld -nostdlib</span><br></pre></td></tr></table></figure>
<p>设置内核的链接选项，<code>-nostdlib</code>指定不使用C标准静态库，<code>-T</code>指定<code>ld script</code>的路径。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># entry.S must be first, so that it's the first code in the text segment!!!</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># We also snatch the use of a couple handy source files</span></span><br><span class="line"><span class="comment"># from the lib directory, to avoid gratuitous code duplication.</span></span><br><span class="line">KERN_SRCFILES :=	kern/entry.S \</span><br><span class="line">			kern/entrypgdir.c \</span><br><span class="line">			kern/init.c \</span><br><span class="line">			kern/console.c \</span><br><span class="line">			kern/monitor.c \</span><br><span class="line">			kern/pmap.c \</span><br><span class="line">			kern/env.c \</span><br><span class="line">			kern/kclock.c \</span><br><span class="line">			kern/picirq.c \</span><br><span class="line">			kern/printf.c \</span><br><span class="line">			kern/trap.c \</span><br><span class="line">			kern/trapentry.S \</span><br><span class="line">			kern/sched.c \</span><br><span class="line">			kern/syscall.c \</span><br><span class="line">			kern/kdebug.c \</span><br><span class="line">			lib/printfmt.c \</span><br><span class="line">			lib/readline.c \</span><br><span class="line">			lib/string.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># Source files for LAB4</span></span><br><span class="line">KERN_SRCFILES +=	kern/mpentry.S \</span><br><span class="line">			kern/mpconfig.c \</span><br><span class="line">			kern/lapic.c \</span><br><span class="line">			kern/spinlock.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># Only build files if they exist.</span></span><br><span class="line">KERN_SRCFILES := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(KERN_SRCFILES)</span>)</span></span><br></pre></td></tr></table></figure>
<p>设定编译内核所需要的源文件列表。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Binary program images to embed within the kernel.</span></span><br><span class="line"><span class="comment"># Binary files for LAB3</span></span><br><span class="line">KERN_BINFILES :=	user/hello \</span><br><span class="line">			user/buggyhello \</span><br><span class="line">			user/buggyhello2 \</span><br><span class="line">			user/evilhello \</span><br><span class="line">			user/testbss \</span><br><span class="line">			user/divzero \</span><br><span class="line">			user/breakpoint \</span><br><span class="line">			user/softint \</span><br><span class="line">			user/badsegment \</span><br><span class="line">			user/faultread \</span><br><span class="line">			user/faultreadkernel \</span><br><span class="line">			user/faultwrite \</span><br><span class="line">			user/faultwritekernel</span><br><span class="line"></span><br><span class="line"><span class="comment"># Binary files for LAB4</span></span><br><span class="line">KERN_BINFILES +=	user/idle \</span><br><span class="line">			user/yield \</span><br><span class="line">			user/dumbfork \</span><br><span class="line">			user/stresssched \</span><br><span class="line">			user/faultdie \</span><br><span class="line">			user/faultregs \</span><br><span class="line">			user/faultalloc \</span><br><span class="line">			user/faultallocbad \</span><br><span class="line">			user/faultnostack \</span><br><span class="line">			user/faultbadhandler \</span><br><span class="line">			user/faultevilhandler \</span><br><span class="line">			user/forktree \</span><br><span class="line">			user/sendpage \</span><br><span class="line">			user/spin \</span><br><span class="line">			user/fairness \</span><br><span class="line">			user/pingpong \</span><br><span class="line">			user/pingpongs \</span><br><span class="line">			user/primes</span><br><span class="line"><span class="comment"># Binary files for LAB5</span></span><br><span class="line">KERN_BINFILES +=	user/faultio\</span><br><span class="line">	      		user/spawnfaultio\</span><br><span class="line">	      		user/testfile \</span><br><span class="line">			user/spawnhello \</span><br><span class="line">			user/icode \</span><br><span class="line">			fs/fs</span><br><span class="line"></span><br><span class="line"><span class="comment"># Binary files for LAB5</span></span><br><span class="line">KERN_BINFILES +=	user/testpteshare \</span><br><span class="line">			user/testfdsharing \</span><br><span class="line">			user/testpipe \</span><br><span class="line">			user/testpiperace \</span><br><span class="line">			user/testpiperace2 \</span><br><span class="line">			user/primespipe \</span><br><span class="line">			user/testkbd \</span><br><span class="line">			user/testshell</span><br><span class="line"></span><br><span class="line">KERN_OBJFILES := <span class="variable">$(<span class="built_in">patsubst</span> %.c, <span class="variable">$(OBJDIR)</span>/%.o, <span class="variable">$(KERN_SRCFILES)</span>)</span></span><br><span class="line">KERN_OBJFILES := <span class="variable">$(<span class="built_in">patsubst</span> %.S, <span class="variable">$(OBJDIR)</span>/%.o, <span class="variable">$(KERN_OBJFILES)</span>)</span></span><br><span class="line">KERN_OBJFILES := <span class="variable">$(<span class="built_in">patsubst</span> <span class="variable">$(OBJDIR)</span>/lib/%, <span class="variable">$(OBJDIR)</span>/kern/%, <span class="variable">$(KERN_OBJFILES)</span>)</span></span><br><span class="line"></span><br><span class="line">KERN_BINFILES := <span class="variable">$(<span class="built_in">patsubst</span> %, <span class="variable">$(OBJDIR)</span>/%, <span class="variable">$(KERN_BINFILES)</span>)</span></span><br></pre></td></tr></table></figure>
<p>设置要嵌入内核的二进制文件列表和内核需要的<code>.o</code>文件列表。<code>patsubst</code>会将通配符展开。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># How to build kernel object files</span></span><br><span class="line"><span class="variable">$(OBJDIR)</span>/kern/%.o: kern/%.c <span class="variable">$(OBJDIR)</span>/.vars.KERN_CFLAGS</span><br><span class="line">	@echo + cc <span class="variable">$&lt;</span></span><br><span class="line">	@mkdir -p $(@D)</span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(CC)</span> -nostdinc <span class="variable">$(KERN_CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(OBJDIR)</span>/kern/%.o: kern/%.S <span class="variable">$(OBJDIR)</span>/.vars.KERN_CFLAGS</span><br><span class="line">	@echo + as <span class="variable">$&lt;</span></span><br><span class="line">	@mkdir -p $(@D)</span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(CC)</span> -nostdinc <span class="variable">$(KERN_CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(OBJDIR)</span>/kern/%.o: lib/%.c <span class="variable">$(OBJDIR)</span>/.vars.KERN_CFLAGS</span><br><span class="line">	@echo + cc <span class="variable">$&lt;</span></span><br><span class="line">	@mkdir -p $(@D)</span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(CC)</span> -nostdinc <span class="variable">$(KERN_CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>目标文件的构造规则，编译或汇编所有的源码文件。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Special flags for kern/init</span></span><br><span class="line"><span class="variable">$(OBJDIR)</span>/kern/init.o: <span class="keyword">override</span> KERN_CFLAGS+=<span class="variable">$(INIT_CFLAGS)</span></span><br><span class="line"><span class="variable">$(OBJDIR)</span>/kern/init.o: <span class="variable">$(OBJDIR)</span>/.vars.INIT_CFLAGS</span><br></pre></td></tr></table></figure>
<p>对于<code>init.o</code>我们需要在编译时添加<code>INIT_CFLAGS</code>，原因见<code>GNUmakefile</code>部分对这个参数的设定。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># How to build the kernel itself</span></span><br><span class="line"><span class="variable">$(OBJDIR)</span>/kern/kernel: <span class="variable">$(KERN_OBJFILES)</span> <span class="variable">$(KERN_BINFILES)</span> kern/kernel.ld \</span><br><span class="line">	  <span class="variable">$(OBJDIR)</span>/.vars.KERN_LDFLAGS</span><br><span class="line">	@echo + ld <span class="variable">$@</span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(LD)</span> -o <span class="variable">$@</span> <span class="variable">$(KERN_LDFLAGS)</span> <span class="variable">$(KERN_OBJFILES)</span> <span class="variable">$(GCC_LIB)</span> -b binary <span class="variable">$(KERN_BINFILES)</span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(OBJDUMP)</span> -S <span class="variable">$@</span> &gt; <span class="variable">$@</span>.asm</span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(NM)</span> -n <span class="variable">$@</span> &gt; <span class="variable">$@</span>.sym</span><br></pre></td></tr></table></figure>
<p>用于编译内核可执行文件的规则。可以看到，内核是由所有用到的<code>.o</code>文件和gcc库文件共同链接得到的。同时，这条规则还会将内核的反汇编代码和符号表信息保存起来。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># How to build the kernel disk image</span></span><br><span class="line"><span class="variable">$(OBJDIR)</span>/kern/kernel.img: <span class="variable">$(OBJDIR)</span>/kern/kernel <span class="variable">$(OBJDIR)</span>/boot/boot</span><br><span class="line">	@echo + mk <span class="variable">$@</span></span><br><span class="line">	<span class="variable">$(V)</span>dd if=/dev/zero of=<span class="variable">$(OBJDIR)</span>/kern/kernel.img~ count=10000 2&gt;/dev/null</span><br><span class="line">	<span class="variable">$(V)</span>dd if=<span class="variable">$(OBJDIR)</span>/boot/boot of=<span class="variable">$(OBJDIR)</span>/kern/kernel.img~ conv=notrunc 2&gt;/dev/null</span><br><span class="line">	<span class="variable">$(V)</span>dd if=<span class="variable">$(OBJDIR)</span>/kern/kernel of=<span class="variable">$(OBJDIR)</span>/kern/kernel.img~ seek=1 conv=notrunc 2&gt;/dev/null</span><br><span class="line">	<span class="variable">$(V)</span>mv <span class="variable">$(OBJDIR)</span>/kern/kernel.img~ <span class="variable">$(OBJDIR)</span>/kern/kernel.img</span><br></pre></td></tr></table></figure>
<p>用于构建内核镜像的规则。</p>
<p><code>dd</code>是用于文件格式转换的工具，在这里被用来将<code>bootloader(/boot/boot)</code>和内核(<code>/kern/kernel</code>)构建为<code>kernel.img</code>。构建过程分为三步：</p>
<ul>
<li>第一步：<code>/dev/zero</code>是一个特殊文件，它能提供无限的<code>0</code>数据流，在这里用于初始化临时文件<code>kernel.img~</code>，初始化大小为<code>10000</code>个块，<code>stderr</code>屏蔽掉。</li>
<li>第二步：将<code>boot</code>文件写入到临时镜像，<code>conv=notrunc</code>指定不要截断原来初始化出的多余部分。</li>
<li>第三步：将<code>kernel</code>文件写入到临时镜像，同样不要截断，<code>seek=1</code>表示跳过第一个块，也就是那个存放了<code>bootloader</code>的块。</li>
</ul>
<p>在这个构建过程中使用临时镜像<code>/kern/kernel.img~</code>而不是直接构建<code>kernel.img</code>的原因是如果make在执行中途发生错误而退出，这种操作不会损坏原有的镜像文件。</p>
<h3 id="lib-Makefrag"><a href="#lib-Makefrag" class="headerlink" title="/lib/Makefrag"></a>/lib/Makefrag</h3><p>函数库的makefile片段。原理和上面的差不多，没什么好说的。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">OBJDIRS += lib</span><br><span class="line"></span><br><span class="line">LIB_SRCFILES :=		lib/console.c \</span><br><span class="line">			lib/libmain.c \</span><br><span class="line">			lib/exit.c \</span><br><span class="line">			lib/panic.c \</span><br><span class="line">			lib/printf.c \</span><br><span class="line">			lib/printfmt.c \</span><br><span class="line">			lib/readline.c \</span><br><span class="line">			lib/string.c \</span><br><span class="line">			lib/syscall.c</span><br><span class="line"></span><br><span class="line">LIB_SRCFILES :=		<span class="variable">$(LIB_SRCFILES)</span> \</span><br><span class="line">			lib/pgfault.c \</span><br><span class="line">			lib/pfentry.S \</span><br><span class="line">			lib/fork.c \</span><br><span class="line">			lib/ipc.c</span><br><span class="line"></span><br><span class="line">LIB_SRCFILES :=		<span class="variable">$(LIB_SRCFILES)</span> \</span><br><span class="line">			lib/args.c \</span><br><span class="line">			lib/fd.c \</span><br><span class="line">			lib/file.c \</span><br><span class="line">			lib/fprintf.c \</span><br><span class="line">			lib/pageref.c \</span><br><span class="line">			lib/spawn.c</span><br><span class="line"></span><br><span class="line">LIB_SRCFILES :=		<span class="variable">$(LIB_SRCFILES)</span> \</span><br><span class="line">			lib/pipe.c \</span><br><span class="line">			lib/wait.c</span><br><span class="line"></span><br><span class="line">LIB_OBJFILES := <span class="variable">$(<span class="built_in">patsubst</span> lib/%.c, <span class="variable">$(OBJDIR)</span>/lib/%.o, <span class="variable">$(LIB_SRCFILES)</span>)</span></span><br><span class="line">LIB_OBJFILES := <span class="variable">$(<span class="built_in">patsubst</span> lib/%.S, <span class="variable">$(OBJDIR)</span>/lib/%.o, <span class="variable">$(LIB_OBJFILES)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(OBJDIR)</span>/lib/%.o: lib/%.c <span class="variable">$(OBJDIR)</span>/.vars.USER_CFLAGS</span><br><span class="line">	@echo + cc[USER] <span class="variable">$&lt;</span></span><br><span class="line">	@mkdir -p $(@D)</span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(CC)</span> -nostdinc <span class="variable">$(USER_CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(OBJDIR)</span>/lib/%.o: lib/%.S <span class="variable">$(OBJDIR)</span>/.vars.USER_CFLAGS</span><br><span class="line">	@echo + as[USER] <span class="variable">$&lt;</span></span><br><span class="line">	@mkdir -p $(@D)</span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(CC)</span> -nostdinc <span class="variable">$(USER_CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(OBJDIR)</span>/lib/libjos.a: <span class="variable">$(LIB_OBJFILES)</span></span><br><span class="line">	@echo + ar <span class="variable">$@</span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(AR)</span> r <span class="variable">$@</span> <span class="variable">$(LIB_OBJFILES)</span></span><br></pre></td></tr></table></figure>
<h3 id="boot-Makefrag"><a href="#boot-Makefrag" class="headerlink" title="/boot/Makefrag"></a>/boot/Makefrag</h3><p>构造<code>bootloader</code>的makefile片段。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Makefile fragment for the JOS kernel.</span></span><br><span class="line"><span class="comment"># This is NOT a complete makefile;</span></span><br><span class="line"><span class="comment"># you must run GNU make in the top-level directory</span></span><br><span class="line"><span class="comment"># where the GNUmakefile is located.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">OBJDIRS += boot</span><br><span class="line"></span><br><span class="line">BOOT_OBJS := <span class="variable">$(OBJDIR)</span>/boot/boot.o <span class="variable">$(OBJDIR)</span>/boot/main.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(OBJDIR)</span>/boot/%.o: boot/%.c</span><br><span class="line">	@echo + cc -Os <span class="variable">$&lt;</span></span><br><span class="line">	@mkdir -p $(@D)</span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(CC)</span> -nostdinc <span class="variable">$(KERN_CFLAGS)</span> -Os -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(OBJDIR)</span>/boot/%.o: boot/%.S</span><br><span class="line">	@echo + as <span class="variable">$&lt;</span></span><br><span class="line">	@mkdir -p $(@D)</span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(CC)</span> -nostdinc <span class="variable">$(KERN_CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(OBJDIR)</span>/boot/main.o: boot/main.c</span><br><span class="line">	@echo + cc -Os <span class="variable">$&lt;</span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(CC)</span> -nostdinc <span class="variable">$(KERN_CFLAGS)</span> -Os -c -o <span class="variable">$(OBJDIR)</span>/boot/main.o boot/main.c</span><br><span class="line"></span><br><span class="line"><span class="variable">$(OBJDIR)</span>/boot/boot: <span class="variable">$(BOOT_OBJS)</span></span><br><span class="line">	@echo + ld boot/boot</span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -N -e start -Ttext 0x7C00 -o <span class="variable">$@</span>.out <span class="variable">$^</span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(OBJDUMP)</span> -S <span class="variable">$@</span>.out &gt;<span class="variable">$@</span>.asm</span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(OBJCOPY)</span> -S -O binary -j .text <span class="variable">$@</span>.out <span class="variable">$@</span></span><br><span class="line">	<span class="variable">$(V)</span>perl boot/sign.pl <span class="variable">$(OBJDIR)</span>/boot/boot</span><br></pre></td></tr></table></figure>
<p>比较重要和复杂的是最后一条规则：</p>
<ul>
<li>第一步：<code>ld</code>链接<ul>
<li><code>-N</code>：将<code>text</code>和<code>data</code>区标记为可读可写的</li>
<li><code>-e start</code>：指定程序开始执行的位置为<code>start</code>标签</li>
<li><code>-Ttext 0x7c00</code>：指定代码区的起始位置为<code>0x7c00</code></li>
</ul>
</li>
<li>第二步：保存<code>bootloader</code>的反汇编代码</li>
<li>第三步：将<code>bootloader</code>的代码段拷贝到<code>boot.out</code><ul>
<li><code>-S</code>：不拷贝符号表和重定位信息</li>
<li><code>-O binary</code>：指定输出格式为二进制</li>
<li><code>-j .text</code>：仅复制代码段</li>
</ul>
</li>
<li>第四步：运行perl脚本</li>
</ul>
<h3 id="user-Makefrag"><a href="#user-Makefrag" class="headerlink" title="/user/Makefrag"></a>/user/Makefrag</h3><p>编译用户程序的makefile片段。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">OBJDIRS += user</span><br><span class="line"></span><br><span class="line">USERLIBS += jos</span><br><span class="line"></span><br><span class="line"><span class="variable">$(OBJDIR)</span>/user/%.o: user/%.c <span class="variable">$(OBJDIR)</span>/.vars.USER_CFLAGS</span><br><span class="line">	@echo + cc[USER] <span class="variable">$&lt;</span></span><br><span class="line">	@mkdir -p $(@D)</span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(CC)</span> -nostdinc <span class="variable">$(USER_CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(OBJDIR)</span>/user/%: <span class="variable">$(OBJDIR)</span>/user/%.o <span class="variable">$(OBJDIR)</span>/lib/entry.o \</span><br><span class="line"><span class="section">$(USERLIBS:%=<span class="variable">$(OBJDIR)</span>/lib/lib%.a) user/user.ld</span></span><br><span class="line">	@echo + ld <span class="variable">$@</span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(LD)</span> -o <span class="variable">$@</span>.debug <span class="variable">$(ULDFLAGS)</span> <span class="variable">$(LDFLAGS)</span> -nostdlib <span class="variable">$(OBJDIR)</span>/lib/entry.o <span class="variable">$@</span>.o -L<span class="variable">$(OBJDIR)</span>/lib $(USERLIBS:%=-l%) <span class="variable">$(GCC_LIB)</span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(OBJDUMP)</span> -S <span class="variable">$@</span>.debug &gt; <span class="variable">$@</span>.asm</span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(NM)</span> -n <span class="variable">$@</span>.debug &gt; <span class="variable">$@</span>.sym</span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(OBJCOPY)</span> -R .stab -R .stabstr --add-gnu-debuglink=<span class="variable">$(<span class="built_in">basename</span> <span class="variable">$@</span>.debug)</span> <span class="variable">$@</span>.debug <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>这里的重点是<code>obj</code>目录下各个用户程序的可执行文件的编译。</p>
<ul>
<li>目标：通过通配符匹配<code>obj/user/</code>目录下的所有无扩展名可执行文件</li>
<li>前置条件：<ul>
<li>该目录下的<code>.o</code>文件</li>
<li><code>obj/lib</code>下的<code>entry.o</code>文件，这个文件是所有用户程序的入口点</li>
<li><code>$(USERLIBS:%=$(OBJDIR)/lib/lib%.a)</code>：这种语法格式是<code>$(&lt;varname&gt;:&lt;pattern1&gt;=&lt;pattern2&gt;)</code>，表示将<code>&lt;varname&gt;</code>变量中所有符合<code>&lt;pattern1&gt;</code>的字符串换为<code>&lt;pattern2&gt;</code>，这里是将<code>USERLIB</code>变量中的所有字符串转换为对应的<code>obj/lib/</code>文件夹下的<code>lib*.a</code>文件。</li>
<li><code>user/user.ld</code>，<code>ld script</code>。</li>
</ul>
</li>
<li><code>recipe</code>：<ul>
<li><code>ld</code>：将<code>entry.o</code>和目标<code>.o</code>文件链接起来成为对应的<code>.debug</code>文件。<ul>
<li><code>ULDFLAGS</code>和<code>LDFLAGS</code>：继承下来的参数</li>
<li><code>-nostdlib</code>：不使用C标准库</li>
<li><code>-L $(OBJDIR)</code>：让ld在JOS的对象库中寻找库文件</li>
<li><code>$(USERLIBS:%=-l%)</code>：在链接时加载JOS的所有用户库</li>
</ul>
</li>
<li>剩下几条与其他<code>Makefrag</code>类似。</li>
</ul>
</li>
</ul>
<h2 id="Tester-Part"><a href="#Tester-Part" class="headerlink" title="Tester Part"></a>Tester Part</h2><h2 id="inc"><a href="#inc" class="headerlink" title="/inc"></a>/inc</h2><p>inc文件夹包含了JOS中的<strong>部分</strong>头文件，这个部分是指那些被不止一个文件所依赖的头文件。如果一个头文件只被一个<code>*.c</code>代码文件所引用，它会被命名为<code>*.h</code>并放置于<code>*.c</code>所在的文件夹下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">inc</span><br><span class="line">├── args.h</span><br><span class="line">├── assert.h</span><br><span class="line">├── COPYRIGHT</span><br><span class="line">├── elf.h</span><br><span class="line">├── env.h</span><br><span class="line">├── error.h</span><br><span class="line">├── fd.h</span><br><span class="line">├── fs.h</span><br><span class="line">├── kbdreg.h</span><br><span class="line">├── lib.h</span><br><span class="line">├── memlayout.h</span><br><span class="line">├── mmu.h</span><br><span class="line">├── partition.h</span><br><span class="line">├── stab.h</span><br><span class="line">├── stdarg.h</span><br><span class="line">├── stdio.h</span><br><span class="line">├── string.h</span><br><span class="line">├── syscall.h</span><br><span class="line">├── trap.h</span><br><span class="line">├── types.h</span><br><span class="line">└── x86.h</span><br></pre></td></tr></table></figure>
<h3 id="inc-mmu-h"><a href="#inc-mmu-h" class="headerlink" title="/inc/mmu.h"></a>/inc/mmu.h</h3><p><code>MMU</code>是x86架构CPU中用于<strong>管理内存</strong>的单元，这个头文件中主要定义了一些用于描述<code>mmu</code>行为的函数、数据结构和宏，包括实现<strong>分页机制</strong>和<strong>段机制</strong>需要的数据结构定义和常量，用来设置<code>cr0</code>，<code>cr4</code>和<code>eflags</code>寄存器标志位的一些<strong>标志常量</strong>，以及用于<strong>异常处理</strong>的数据结构和宏。</p>
<h4 id="Paging-data-structures-and-constants"><a href="#Paging-data-structures-and-constants" class="headerlink" title="Paging data structures and constants"></a>Paging data structures and constants</h4><p>这一部分主要包括用于<strong>分页机制</strong>的一些宏函数。</p>
<h5 id="Analyzing-linear-addresses"><a href="#Analyzing-linear-addresses" class="headerlink" title="Analyzing linear addresses"></a>Analyzing linear addresses</h5><p>有关虚拟地址的结构，在<a href="https://dracit7.github.io/blog/2019/02/24/MIT_6.828/">6.828实验记录</a>的$1.4.1.$<em>Background Knowledge</em>一章已经记录过，并且<code>mmu.h</code>的注释中也有形象详细的描述，这里不再重复。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// page number field of address</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGNUM(la)	(((uintptr_t) (la)) &gt;&gt; PTXSHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// page directory index</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDX(la)		((((uintptr_t) (la)) &gt;&gt; PDXSHIFT) &amp; 0x3FF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// page table index</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTX(la)		((((uintptr_t) (la)) &gt;&gt; PTXSHIFT) &amp; 0x3FF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// offset in page</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGOFF(la)	(((uintptr_t) (la)) &amp; 0xFFF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// construct linear address from indexes and offset</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGADDR(d, t, o)	((void*) ((d) &lt;&lt; PDXSHIFT | (t) &lt;&lt; PTXSHIFT | (o)))</span></span><br></pre></td></tr></table></figure>
<p>这五个都是在内存管理中无比常用的宏，按标准实现起来也很简单，因此不展开说明。</p>
<h5 id="PD-and-PT-constants"><a href="#PD-and-PT-constants" class="headerlink" title="PD and PT constants"></a>PD and PT constants</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NPDENTRIES	1024		<span class="comment">// page directory entries per page directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NPTENTRIES	1024		<span class="comment">// page table entries per page table</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGSIZE		4096		<span class="comment">// bytes mapped by a page</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGSHIFT		12		<span class="comment">// log2(PGSIZE)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTSIZE		(PGSIZE*NPTENTRIES) <span class="comment">// bytes mapped by a page directory entry</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTSHIFT		22		<span class="comment">// log2(PTSIZE)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTXSHIFT	12		<span class="comment">// offset of PTX in a linear address</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDXSHIFT	22		<span class="comment">// offset of PDX in a linear address</span></span></span><br></pre></td></tr></table></figure>
<p>一般来说只要线性地址的结构规定不改变，这些常量的值都不需要修改。不过，为了保持良好的编程习惯，最好还是减少hardcode的次数，改用这些常量来描述。</p>
<h5 id="PTE-flags"><a href="#PTE-flags" class="headerlink" title="PTE flags"></a>PTE flags</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_P		0x001	<span class="comment">// Present</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_W		0x002	<span class="comment">// Writeable</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_U		0x004	<span class="comment">// User</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_PWT		0x008	<span class="comment">// Write-Through</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_PCD		0x010	<span class="comment">// Cache-Disable</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_A		0x020	<span class="comment">// Accessed</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_D		0x040	<span class="comment">// Dirty</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_PS		0x080	<span class="comment">// Page Size</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_G		0x100	<span class="comment">// Global</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The PTE_AVAIL bits aren't used by the kernel or interpreted by the</span></span><br><span class="line"><span class="comment">// hardware, so user processes are allowed to set them arbitrarily.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_AVAIL	0xE00	<span class="comment">// Available for software use</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Flags in PTE_SYSCALL may be used in system calls.  (Others may not.)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_SYSCALL	(PTE_AVAIL | PTE_P | PTE_W | PTE_U)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Address in page table or page directory entry</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_ADDR(pte)	((physaddr_t) (pte) &amp; ~0xFFF)</span></span><br></pre></td></tr></table></figure>
<p>由于每个<code>PTE</code>(页表表项)都其实是一个<strong>物理页面的地址</strong>，而页面的地址是<strong>向PGSIZE对齐的</strong>，每个<code>PTE</code>都会有<strong>空闲的12位</strong>。JOS将这十位作为<code>PTE</code>的标志位，用以标识这一页的具体属性。</p>
<p>根据上面的定义，我们可以大致描绘出这12位的具体用途：</p>
<p><img src="PTE.png" alt="PTE"></p>
<p>在管理页表时，我们最常用到的还是最低三位：</p>
<ul>
<li><code>PTE_P</code>：这个页面已经被分配</li>
<li><code>PTE_W</code>：这个页面具有写权限</li>
<li><code>PTE_U</code>：这个页面可以被用户访问</li>
</ul>
<p><strong>这三位是由操作系统进行设置和管理的</strong>，CPU只负责根据它们来检查访问的合法性。</p>
<p>在管理文件系统的时候也会用到这两位：</p>
<ul>
<li><code>PTE_D</code>：这个页面是否被修改过</li>
<li><code>PTE_A</code>：这个页面是否被访问过</li>
</ul>
<p><strong>这两位是由CPU进行设置的</strong>，操作系统通过读取它们来得知页面的状态，也可以对它们进行修改。</p>
<p>比较特殊的是<strong>最高三位</strong>，它们被标注为<code>PTE_AVAIL</code>，也就是说它们是<strong>保留位</strong>，CPU不会设置或检查它们，这样我们可以用它们来自定义一些页面属性，比如<strong>写时复制</strong>的<code>PTE_COW</code>。</p>
<p>一旦出现了对一个页面的与其权限描述冲突的访问，CPU就会产生一个中断。</p>
<p><code>PTE_SYSCALL</code>不是一个标志位，它代表着<strong>所有能被系统调用访问或修改的标志位的集合</strong>，用于方便我们在实现操作系统的时候限制用户的权限。<code>PTE_ADDR</code>用于<strong>抹除掉一个<code>PTE</code>中的标志位</strong>，好让我们寻找到它指向的页面的起始地址。</p>
<h5 id="Register-flags"><a href="#Register-flags" class="headerlink" title="Register flags"></a>Register flags</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Control Register flags</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR0_PE		0x00000001	<span class="comment">// Protection Enable</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR0_MP		0x00000002	<span class="comment">// Monitor coProcessor</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR0_EM		0x00000004	<span class="comment">// Emulation</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR0_TS		0x00000008	<span class="comment">// Task Switched</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR0_ET		0x00000010	<span class="comment">// Extension Type</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR0_NE		0x00000020	<span class="comment">// Numeric Errror</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR0_WP		0x00010000	<span class="comment">// Write Protect</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR0_AM		0x00040000	<span class="comment">// Alignment Mask</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR0_NW		0x20000000	<span class="comment">// Not Writethrough</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR0_CD		0x40000000	<span class="comment">// Cache Disable</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR0_PG		0x80000000	<span class="comment">// Paging</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR4_PCE		0x00000100	<span class="comment">// Performance counter enable</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR4_MCE		0x00000040	<span class="comment">// Machine Check Enable</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR4_PSE		0x00000010	<span class="comment">// Page Size Extensions</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR4_DE		0x00000008	<span class="comment">// Debugging Extensions</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR4_TSD		0x00000004	<span class="comment">// Time Stamp Disable</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR4_PVI		0x00000002	<span class="comment">// Protected-Mode Virtual Interrupts</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR4_VME		0x00000001	<span class="comment">// V86 Mode Extensions</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Eflags register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FL_CF		0x00000001	<span class="comment">// Carry Flag</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FL_PF		0x00000004	<span class="comment">// Parity Flag</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FL_AF		0x00000010	<span class="comment">// Auxiliary carry Flag</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FL_ZF		0x00000040	<span class="comment">// Zero Flag</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FL_SF		0x00000080	<span class="comment">// Sign Flag</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FL_TF		0x00000100	<span class="comment">// Trap Flag</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FL_IF		0x00000200	<span class="comment">// Interrupt Flag</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FL_DF		0x00000400	<span class="comment">// Direction Flag</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FL_OF		0x00000800	<span class="comment">// Overflow Flag</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FL_IOPL_MASK	0x00003000	<span class="comment">// I/O Privilege Level bitmask</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FL_IOPL_0	0x00000000	<span class="comment">//   IOPL == 0</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FL_IOPL_1	0x00001000	<span class="comment">//   IOPL == 1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FL_IOPL_2	0x00002000	<span class="comment">//   IOPL == 2</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FL_IOPL_3	0x00003000	<span class="comment">//   IOPL == 3</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FL_NT		0x00004000	<span class="comment">// Nested Task</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FL_RF		0x00010000	<span class="comment">// Resume Flag</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FL_VM		0x00020000	<span class="comment">// Virtual 8086 mode</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FL_AC		0x00040000	<span class="comment">// Alignment Check</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FL_VIF		0x00080000	<span class="comment">// Virtual Interrupt Flag</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FL_VIP		0x00100000	<span class="comment">// Virtual Interrupt Pending</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FL_ID		0x00200000	<span class="comment">// ID flag</span></span></span><br></pre></td></tr></table></figure>
<p>这些定义全都用于设置<code>cr0</code>、<code>cr4</code>和<code>eflags</code>三个寄存器的标志位，让我们能更方便地去访问和修改这三个寄存器的值。具体如何使用，参照x86架构对这三个寄存器的定义即可。</p>
<h4 id="Segmentation-data-structures-and-constants"><a href="#Segmentation-data-structures-and-constants" class="headerlink" title="Segmentation data structures and constants"></a>Segmentation data structures and constants</h4><p>这一部分主要包括关于<strong>分段机制</strong>的一些数据结构和常量定义。</p>
<h5 id="setting_gdt">Setting GDT</h5>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __ASSEMBLER__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Macros to build GDT entries in assembly.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG_NULL						\</span></span><br><span class="line">	.word <span class="number">0</span>, <span class="number">0</span>;						\</span><br><span class="line">	.byte <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG(type,base,lim)					\</span></span><br><span class="line">	.word (((lim) &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0xffff</span>), ((base) &amp; <span class="number">0xffff</span>);	\</span><br><span class="line">	.byte (((base) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>), (<span class="number">0x90</span> | (type)),		\</span><br><span class="line">		(<span class="number">0xC0</span> | (((lim) &gt;&gt; <span class="number">28</span>) &amp; <span class="number">0xf</span>)), (((base) &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>	<span class="comment">// not __ASSEMBLER__</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Segment Descriptors</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segdesc</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> sd_lim_15_0 : <span class="number">16</span>;  <span class="comment">// Low bits of segment limit</span></span><br><span class="line">	<span class="keyword">unsigned</span> sd_base_15_0 : <span class="number">16</span>; <span class="comment">// Low bits of segment base address</span></span><br><span class="line">	<span class="keyword">unsigned</span> sd_base_23_16 : <span class="number">8</span>; <span class="comment">// Middle bits of segment base address</span></span><br><span class="line">	<span class="keyword">unsigned</span> sd_type : <span class="number">4</span>;       <span class="comment">// Segment type (see STS_ constants)</span></span><br><span class="line">	<span class="keyword">unsigned</span> sd_s : <span class="number">1</span>;          <span class="comment">// 0 = system, 1 = application</span></span><br><span class="line">	<span class="keyword">unsigned</span> sd_dpl : <span class="number">2</span>;        <span class="comment">// Descriptor Privilege Level</span></span><br><span class="line">	<span class="keyword">unsigned</span> sd_p : <span class="number">1</span>;          <span class="comment">// Present</span></span><br><span class="line">	<span class="keyword">unsigned</span> sd_lim_19_16 : <span class="number">4</span>;  <span class="comment">// High bits of segment limit</span></span><br><span class="line">	<span class="keyword">unsigned</span> sd_avl : <span class="number">1</span>;        <span class="comment">// Unused (available for software use)</span></span><br><span class="line">	<span class="keyword">unsigned</span> sd_rsv1 : <span class="number">1</span>;       <span class="comment">// Reserved</span></span><br><span class="line">	<span class="keyword">unsigned</span> sd_db : <span class="number">1</span>;         <span class="comment">// 0 = 16-bit segment, 1 = 32-bit segment</span></span><br><span class="line">	<span class="keyword">unsigned</span> sd_g : <span class="number">1</span>;          <span class="comment">// Granularity: limit scaled by 4K when set</span></span><br><span class="line">	<span class="keyword">unsigned</span> sd_base_31_24 : <span class="number">8</span>; <span class="comment">// High bits of segment base address</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Null segment</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG_NULL	&#123; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 &#125;</span></span><br><span class="line"><span class="comment">// Segment that is loadable but faults when used</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG_FAULT	&#123; 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0 &#125;</span></span><br><span class="line"><span class="comment">// Normal segment</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG(type, base, lim, dpl) 					\</span></span><br><span class="line">&#123; ((lim) &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0xffff</span>, (base) &amp; <span class="number">0xffff</span>, ((base) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>,	\</span><br><span class="line">    type, <span class="number">1</span>, dpl, <span class="number">1</span>, (<span class="keyword">unsigned</span>) (lim) &gt;&gt; <span class="number">28</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>,		\</span><br><span class="line">    (<span class="keyword">unsigned</span>) (base) &gt;&gt; <span class="number">24</span> &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG16(type, base, lim, dpl) (struct Segdesc)			\</span></span><br><span class="line">&#123; (lim) &amp; <span class="number">0xffff</span>, (base) &amp; <span class="number">0xffff</span>, ((base) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>,		\</span><br><span class="line">    type, <span class="number">1</span>, dpl, <span class="number">1</span>, (<span class="keyword">unsigned</span>) (lim) &gt;&gt; <span class="number">16</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,		\</span><br><span class="line">    (<span class="keyword">unsigned</span>) (base) &gt;&gt; <span class="number">24</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !__ASSEMBLER__ */</span></span></span><br></pre></td></tr></table></figure>
<h2 id="boot"><a href="#boot" class="headerlink" title="/boot"></a>/boot</h2><p>boot文件夹包含了用于构造<code>bootloader</code>所需的源代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boot</span><br><span class="line">├── boot.S：在C语言函数栈建立起来之前做一些基本的准备工作</span><br><span class="line">├── main.c：读取kernel代码到内存并执行它</span><br><span class="line">├── Makefrag：用于构建bootloader二进制程序</span><br><span class="line">└── sign.pl</span><br></pre></td></tr></table></figure>
<h3 id="boot-boot-S"><a href="#boot-boot-S" class="headerlink" title="/boot/boot.S"></a>/boot/boot.S</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;inc/mmu.h&gt;</span><br></pre></td></tr></table></figure>
<p><code>boot.S</code>需要用到<code>mmu.h</code>中一个用于构造<code>GDT</code>表项的<code>SEG</code>宏，因此需要包含这个头文件。</p>
<p>在<code>mmu.h</code>中我们可以看到一段包含在<code>#ifdef __ASSEMBLER__ ... #endif</code>结构中的代码，这段代码就是为了这里而写在那里的，<code>SEG</code>宏的具体细节在<a href="#setting_gdt"><code>mmu.h</code>头文件中分析</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Start the CPU: switch to 32-bit protected mode, jump into C.</span><br><span class="line"># The BIOS loads this code from the first sector of the hard disk into</span><br><span class="line"># memory at physical address 0x7c00 and starts executing in real mode</span><br><span class="line"># with %cs=0 %ip=7c00.</span><br><span class="line"></span><br><span class="line">.set PROT_MODE_CSEG, 0x8         # kernel code segment selector</span><br><span class="line">.set PROT_MODE_DSEG, 0x10        # kernel data segment selector</span><br><span class="line">.set CR0_PE_ON,      0x1         # protected mode enable flag</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">  .code16                     # Assemble for 16-bit mode</span><br><span class="line">  cli                         # Disable interrupts</span><br><span class="line">  cld                         # String operations increment</span><br><span class="line"></span><br><span class="line">  # Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">  xorw    %ax,%ax             # Segment number zero</span><br><span class="line">  movw    %ax,%ds             # -&gt; Data Segment</span><br><span class="line">  movw    %ax,%es             # -&gt; Extra Segment</span><br><span class="line">  movw    %ax,%ss             # -&gt; Stack Segment</span><br><span class="line"></span><br><span class="line">  # Enable A20:</span><br><span class="line">  #   For backwards compatibility with the earliest PCs, physical</span><br><span class="line">  #   address line 20 is tied low, so that addresses higher than</span><br><span class="line">  #   1MB wrap around to zero by default.  This code undoes this.</span><br><span class="line">seta20.1:</span><br><span class="line">  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.1</span><br><span class="line"></span><br><span class="line">  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64</span><br><span class="line">  outb    %al,$0x64</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.2</span><br><span class="line"></span><br><span class="line">  movb    $0xdf,%al               # 0xdf -&gt; port 0x60</span><br><span class="line">  outb    %al,$0x60</span><br><span class="line"></span><br><span class="line">  # Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">  # and segment translation that makes virtual addresses </span><br><span class="line">  # identical to their physical addresses, so that the </span><br><span class="line">  # effective memory map does not change during the switch.</span><br><span class="line">  lgdt    gdtdesc</span><br><span class="line">  movl    %cr0, %eax</span><br><span class="line">  orl     $CR0_PE_ON, %eax</span><br><span class="line">  movl    %eax, %cr0</span><br><span class="line">  </span><br><span class="line">  # Jump to next instruction, but in 32-bit code segment.</span><br><span class="line">  # Switches processor into 32-bit mode.</span><br><span class="line">  ljmp    $PROT_MODE_CSEG, $protcseg</span><br><span class="line"></span><br><span class="line">  .code32                     # Assemble for 32-bit mode</span><br><span class="line">protcseg:</span><br><span class="line">  # Set up the protected-mode data segment registers</span><br><span class="line">  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector</span><br><span class="line">  movw    %ax, %ds                # -&gt; DS: Data Segment</span><br><span class="line">  movw    %ax, %es                # -&gt; ES: Extra Segment</span><br><span class="line">  movw    %ax, %fs                # -&gt; FS</span><br><span class="line">  movw    %ax, %gs                # -&gt; GS</span><br><span class="line">  movw    %ax, %ss                # -&gt; SS: Stack Segment</span><br><span class="line">  </span><br><span class="line">  # Set up the stack pointer and call into C.</span><br><span class="line">  movl    $start, %esp</span><br><span class="line">  call bootmain</span><br><span class="line"></span><br><span class="line">  # If bootmain returns (it shouldn&apos;t), loop.</span><br><span class="line">spin:</span><br><span class="line">  jmp spin</span><br><span class="line"></span><br><span class="line"># Bootstrap GDT</span><br><span class="line">.p2align 2                                # force 4 byte alignment</span><br><span class="line">gdt:</span><br><span class="line">  SEG_NULL				# null seg</span><br><span class="line">  SEG(STA_X|STA_R, 0x0, 0xffffffff)	# code seg</span><br><span class="line">  SEG(STA_W, 0x0, 0xffffffff)	        # data seg</span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">  .word   0x17                            # sizeof(gdt) - 1</span><br><span class="line">  .long   gdt                             # address gdt</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2019/04/11/Verilog/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/04/11/Verilog/" itemprop="url">Verilog语言学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-11T18:51:11+08:00">
                2019-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Academic or Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/Languages/" itemprop="url" rel="index">
                    <span itemprop="name">Languages</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2019/04/11/Verilog/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/04/11/Verilog/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Verilog语言学习笔记"><a href="#Verilog语言学习笔记" class="headerlink" title="Verilog语言学习笔记"></a>Verilog语言学习笔记</h1><h2 id="Verilog的基本特性"><a href="#Verilog的基本特性" class="headerlink" title="Verilog的基本特性"></a>Verilog的基本特性</h2><p>Verilog是一款<strong>大小写敏感</strong>的硬件描述语言。</p>
<h3 id="Verilog程序的组成"><a href="#Verilog程序的组成" class="headerlink" title="Verilog程序的组成"></a>Verilog程序的组成</h3><p>一个Verilog程序由关键字<code>module</code>和<code>endmodule</code>进行定义。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> &lt;name&gt; (&lt;port_list&gt;);</span><br><span class="line">	&lt;port declarations&gt;</span><br><span class="line">	&lt;datatype declarations&gt;</span><br><span class="line">	&lt;functions&gt;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>在Verilog中，一个电路就是一个module。</p>
<h3 id="Verilog的基本元素"><a href="#Verilog的基本元素" class="headerlink" title="Verilog的基本元素"></a>Verilog的基本元素</h3><h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><p>Verilog HDL模型中的所有时延都根据<strong>时间单位</strong>定义。</p>
<p>在<code>assign</code>语句后加<code>#x</code>可以指定这个语句的时延，其中<code>x</code>表示时延的长度。</p>
<p>使用<code></code>timescale`语句可以规定时间单位的长度。</p>
<h4 id="模块的描述方式"><a href="#模块的描述方式" class="headerlink" title="模块的描述方式"></a>模块的描述方式</h4><h5 id="结构描述"><a href="#结构描述" class="headerlink" title="结构描述"></a>结构描述</h5><p>用and，or，not等逻辑函数调用来描述，适用于电路图已知的电路</p>
<h5 id="数据流描述"><a href="#数据流描述" class="headerlink" title="数据流描述"></a>数据流描述</h5><p>利用<code>assign</code>语句后接C风格赋值表达式来进行描述，适用于逻辑表达式已知的电路</p>
<h5 id="行为描述"><a href="#行为描述" class="headerlink" title="行为描述"></a>行为描述</h5><p>用<code>initial</code>或<code>always</code>语句进行描述</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2019/03/21/头条暑期实习面经/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/03/21/头条暑期实习面经/" itemprop="url">字节跳动架构部门暑实面经</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-21T12:10:09+08:00">
                2019-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Experience/" itemprop="url" rel="index">
                    <span itemprop="name">Experience</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2019/03/21/头条暑期实习面经/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/03/21/头条暑期实习面经/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="字节跳动架构部门laaS暑期实习生面经"><a href="#字节跳动架构部门laaS暑期实习生面经" class="headerlink" title="字节跳动架构部门laaS暑期实习生面经"></a>字节跳动架构部门laaS暑期实习生面经</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>面试官很nice，温和好说话，也会给提示。</p>
<h4 id="开始部分"><a href="#开始部分" class="headerlink" title="开始部分"></a>开始部分</h4><p>首先是介绍一些自己做过的项目(自己做的或者跟导师做的)。</p>
<p>我的话就是讲一些简历上写了的项目：</p>
<ul>
<li>视频抓取器Spatium和实现细节</li>
<li>课设C_formatter</li>
<li>跟导师改的一些kubernetes源码</li>
</ul>
<p>说到k8s这部分的时候，面试官很自然地把话题引入计算虚拟化部分。</p>
<h4 id="计算虚拟化部分"><a href="#计算虚拟化部分" class="headerlink" title="计算虚拟化部分"></a>计算虚拟化部分</h4><blockquote>
<p><strong>有关k8s</strong></p>
</blockquote>
<ol>
<li>你知道kubernetes有哪几个主要的模块吗？</li>
</ol>
<p>答：大概有kubelet，kubectl，kubeadm还有coredns等模块。</p>
<ol start="2">
<li>那你知道这些模块里面哪些是功能模块而哪些是工具模块吗？</li>
</ol>
<p>答：主要的功能模块就是kubelet，解释了一下kubelet的各种作用。</p>
<ol start="3">
<li>kubelet在网络中是跟哪个身份的节点相连的？跟哪个进程相连的？</li>
</ol>
<p>答：细节不是很清楚</p>
<blockquote>
<p><strong>对虚拟化的了解</strong></p>
</blockquote>
<ol start="4">
<li>我们岗位就是做虚拟化的，说一下你对虚拟化的认识</li>
</ol>
<p>答：主要答了一些主流虚拟化技术和虚拟机种类，并进行了一些解释</p>
<ul>
<li>三种虚拟化形式：<ul>
<li>虚拟机</li>
<li>容器</li>
<li>库操作系统</li>
</ul>
</li>
<li>三种虚拟机形式：<ul>
<li>运行在裸机上的全虚拟化(最早的虚拟化，讲了原理和劣势)</li>
<li>半虚拟化(修改操作系统内核，讲了原理和劣势，举例Xen)</li>
<li>基于硬件辅助的虚拟化(举了一些例子)</li>
</ul>
</li>
</ul>
<ol start="5">
<li>Intel的处理器有哪些特性支持了第三种虚拟机？</li>
</ol>
<p>答：细节部分没有了解</p>
<ol start="6">
<li>CPU分了哪几个特权级，虚拟机是如何利用它们的？</li>
</ol>
<p>答：一开始口误，把4个特权级说成了0-4，经面试官提醒改为0-3。讲了一下全虚拟化和硬件辅助虚拟化对特权级的利用。</p>
<h4 id="计算机网络部分"><a href="#计算机网络部分" class="headerlink" title="计算机网络部分"></a>计算机网络部分</h4><ol start="7">
<li>假如要写一个基于TCP的Server-Client程序，在S端和C端分别要做哪些工作？从代码的角度讲。</li>
</ol>
<p>答：用python举例，讲了S端的<code>socket</code>，<code>bind</code>，<code>listen</code>，<code>accept</code>的调用时机、参数和一些特性；C端的<code>socket</code>，<code>connect</code>的调用时机、参数；<code>send</code>和<code>recv</code>方法的使用。</p>
<ol start="8">
<li>假设我在<code>bind</code>函数调用时不设定特定IP地址，要用什么端口？</li>
</ol>
<p>答：这个不大清楚</p>
<ol start="9">
<li><code>accept</code>函数返回的<code>fd</code>你是如何处理的？比如是直接处理还是开新线程？</li>
</ol>
<p>答：如果有需求的话一般是给每个accept开一个新线程来处理，以实现高并发性。</p>
<h4 id="算法和编程部分"><a href="#算法和编程部分" class="headerlink" title="算法和编程部分"></a>算法和编程部分</h4><ol start="10">
<li>假设我有一个袋子，里面装着黑白两色的球；每次从袋子里取出两个球并丢掉，如果两个球颜色相同就往袋子里放一个白球，否则放一个黑球，问最终剩下的球和袋子里原本白球和黑球个数的关系。</li>
</ol>
<p>答：智力捉急，一开始没想出来。考官提示跟奇偶有关系，于是试着从简单的状态开始推了一下：</p>
<ul>
<li>初态1：袋子里还剩两白一黑<ul>
<li>这种情况下，穷举法能发现无论怎么取最后都是剩黑球</li>
<li>向这种情况下加入一个白球，发现情况并没有变化</li>
<li>继续加入白球，可以发现规律，似乎白球的初始个数对最后的结果并没有影响</li>
</ul>
</li>
<li>初态2：袋子里还剩两黑一白<ul>
<li>仍然用穷举法，可以发现最后剩下的一定是白球</li>
<li>加入一个黑球，发现剩下的变成了黑球</li>
<li>多举几种情况可以发现，黑球的奇偶决定着最后球的颜色</li>
</ul>
</li>
</ul>
<p>总结规律，就是：白球的数量对结果没有影响，黑球为奇数时剩下的是黑球，否则是白球。</p>
<ol start="11">
<li>给定一个由<code>{}[]()</code>三对括号组成的字符串，写一个函数判断它是否是匹配的。例如，<code>{[()]}</code>是匹配的，<code>{([)]}</code>就是不匹配的。</li>
</ol>
<p>答：算法太菜，想了半天，两种思路都发现有问题。考官看我一直想不出来，提示要用到栈，我才反应过来。大体就是遍历字符串，遇到左括号压栈，遇到右括号就判断是否与栈顶的左括号匹配；如果匹配就将栈顶弹出，不匹配就说明整个字符串不匹配。</p>
<h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>二面的面试官表情相对要严肃一点，不过也非常nice，语气很放松。</p>
<h4 id="开始部分-1"><a href="#开始部分-1" class="headerlink" title="开始部分"></a>开始部分</h4><ol>
<li>先自我介绍一下吧。</li>
</ol>
<p>答：照着简历说……</p>
<ol start="2">
<li>你跟导师都做过什么呀？</li>
</ol>
<p>答：主要是在阅读和修改一些k8s的源码</p>
<h4 id="C语言部分"><a href="#C语言部分" class="headerlink" title="C语言部分"></a>C语言部分</h4><p>面试官似乎对我的C语言水平不很信任，出的题很简单。</p>
<ol start="3">
<li>关于数组指针的考察</li>
</ol>
<p>在开始做之前我问了一下机器是多少位，考官指定了64位。</p>
<p>已知：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p = “abcdefg”;</span><br><span class="line"><span class="keyword">char</span> a[] =“abcdefg”;</span><br></pre></td></tr></table></figure></p>
<p>(1)填空：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sizeof(p) = ____，</span><br><span class="line"><span class="keyword">sizeof</span>(*p) = ____,</span><br><span class="line"><span class="keyword">sizeof</span>(p[<span class="number">0</span>]) = ____,</span><br><span class="line"><span class="keyword">sizeof</span>(a) = ____,</span><br><span class="line"><span class="keyword">sizeof</span>(a[<span class="number">0</span>]) = ____,</span><br><span class="line"><span class="keyword">sizeof</span>(&amp;a[<span class="number">0</span>]) = ____.</span><br></pre></td></tr></table></figure></p>
<p>(2)回答问题</p>
<ul>
<li><p>执行<code>p[0] = ‘h’</code>; 会发生什么，为什么？</p>
<p>  答：这个由于p是一个常量字符串指针，所处的内存区域是有读保护的，因而会引发中断（linux下是段错误）</p>
</li>
<li><p>执行<code>a[0] = ‘h’</code>; 会发生什么，为什么？</p>
<p>  答：会将a数组的第一个元素值变成h</p>
</li>
</ul>
<h4 id="编译器相关知识"><a href="#编译器相关知识" class="headerlink" title="编译器相关知识"></a>编译器相关知识</h4><ol start="4">
<li><code>inline</code>的作用？对<code>inline</code>的处理发生在编译过程中的什么阶段？有什么限制条件吗？</li>
</ol>
<p>答：inline是指内联，带有inline的函数会优先使用寄存器而不是将所有的局部变量存放在程序栈中。由于<code>inline</code>涉及到生成的汇编代码对寄存器的使用和对栈的操作，应该是发生在生成汇编代码的阶段。对于限制条件不是很清楚。</p>
<p>这个题是我理解有问题，考官想听到的回答是，inline和define都用于嵌入代码，只不过inline函数的嵌入发生在编译阶段，而define在预处理阶段。inline的限制条件就比较复杂了……我没有了解所以这一题没答好。</p>
<ol start="5">
<li>描述一下编译的基本过程吧。</li>
</ol>
<p>答：把编译器的那几个模块依次列了上去。</p>
<ol start="6">
<li>如果我要查看<code>gcc</code>预处理生成的代码，要怎么做？</li>
</ol>
<p>答：这个不太清楚。</p>
<h4 id="算法部分"><a href="#算法部分" class="headerlink" title="算法部分"></a>算法部分</h4><p>说是算法……感觉这一部分面试官出的题都是离散数学题……</p>
<ol start="7">
<li>两个城市A和B，A城市有80W人，B城市有20W人。任何两个人之间电话对打的概率相同。1天之内，共产生了1000W个电话。那么跨城市对打的电话有多少个？</li>
</ol>
<p>答：用排列组合来做就是<code>C(1,800000)*C(1,200000)/C(2,1000000)*10000000</code>。</p>
<p>考官说我想复杂了，这样算太麻烦。然后就下一题了。</p>
<ol start="8">
<li>6个人一起跑步，结果有多少种结果？A比B的成绩好，同时B比C的成绩好，有多少种结果？</li>
</ol>
<p>答：</p>
<p>1) 第一问就是全排列，720种。<br>2) 第二问我用分类的方式列了一堆，最后算出来是120种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. DEF都在ABC左边，ABC排列的顺序是一定的，这样有P(3,3) = 6种</span><br><span class="line">2. DEF都在右边，同理有6种</span><br><span class="line">3. DEF在AB之间或在BC之间，有2*6=12种</span><br><span class="line">4. DEF中有两个人挨着，另一个被隔开，有P(4,2)*P(3,2) = 72种</span><br><span class="line">5. DEF三个人都被隔开，有P(4,3) = 24种</span><br><span class="line">综上所述，共有6*4+72+24 = 120种</span><br></pre></td></tr></table></figure>
<p>结果考官表示，有更简单的方法，比如，如果只考虑A比B领先，有多少种？</p>
<p>我才发现是我想复杂了，因为ABC三个人的先后次序一共才6种情况，而题中的情况是一种，所以只需要<code>720/6=120</code>即可。</p>
<ol start="9">
<li>上台阶，每次可以一个，也可以每次两个。那么n个台阶，有多少种可能上去呢？</li>
</ol>
<p>这一题要写代码，不过这个算法很简单。写了个带动规的递归函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> stepnum[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">steps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> steps(n<span class="number">-1</span>) + steps(n<span class="number">-2</span>);</span><br><span class="line">&#125; <span class="comment">// 没有优化过的函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stepsNew</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">    stepnum[n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">    stepnum[n] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> steps1 = stepnum[n<span class="number">-1</span>] ? stepnum[n<span class="number">-1</span>] : steps(n<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">int</span> steps2 = stepnum[n<span class="number">-2</span>] ? stepnum[n<span class="number">-2</span>] : steps(n<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">return</span> steps1 + steps2;</span><br><span class="line">&#125; <span class="comment">// 动态规划的函数</span></span><br></pre></td></tr></table></figure>
<ol start="10">
<li>你还有什么想问我的吗？</li>
</ol>
<p>问了一下这个岗位具体一点的工作内容，以及为了符合工作要求应该学习的方向之类的。</p>
<p>面试官的回答：我是在做linux系统内核和KVM相关的。你按照自己的节奏好好学习就可以啦。答的还不错。</p>
<h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><p>二面之后接着有人打电话来约了三面。奇怪的是面试官并没有问多少技术问题，反而面试搞得像hr面：</p>
<ol>
<li>你们学校对实习的态度如何？允不允许？鼓励你们去报什么样的公司？</li>
<li>你最喜欢计算机的哪个方向呢？</li>
<li>据我所知你们大学大二还没有相关课程，你的这些能力是如何积累的呢？</li>
<li>你平时会用什么样的操作系统呢？</li>
</ol>
<h4 id="有关Linux的知识"><a href="#有关Linux的知识" class="headerlink" title="有关Linux的知识"></a>有关Linux的知识</h4><ol start="5">
<li>在Linux下，你主要是用命令行多一些还是图形界面多一些呢？</li>
</ol>
<p>答：除了浏览网页等必须要图形界面的时候，都是命令行。</p>
<ol start="6">
<li>Linux下查看所有进程可以用什么命令？</li>
</ol>
<p>答：<code>ps</code>或者<code>top</code></p>
<ol start="7">
<li>我怎么才能知道某个进程跑在哪个CPU上呢？</li>
</ol>
<p>答：<code>man ps</code>或者<code>man top</code>来查一下</p>
<h4 id="有关并发编程"><a href="#有关并发编程" class="headerlink" title="有关并发编程"></a>有关并发编程</h4><ol start="8">
<li><code>fork</code>函数的返回值有什么意义呢？</li>
</ol>
<p>答：返回0说明是在子进程，返回正整数则代表在父进程，且这个数是子进程的pid。</p>
<ol start="9">
<li>在Go里面，把一些函数用<code>go</code>命令去跑的话，与直接调用有什么不一样的吗？</li>
</ol>
<p>答：讲了一下goroutine的概念和具体实现方式。</p>
<ol start="10">
<li>讲一下你对并发和并行的理解。</li>
</ol>
<p>答：老生常谈了，这里不再赘述。</p>
<ol start="11">
<li>你现在自己在用虚拟机吗？用过哪些？</li>
</ol>
<p>答：之前大一用过VMWARE，最近用了点qemu。</p>
<h4 id="像是hr该问的一些问题"><a href="#像是hr该问的一些问题" class="headerlink" title="像是hr该问的一些问题"></a>像是hr该问的一些问题</h4><ol start="11">
<li>能实习多久？能大概给个范围吗？</li>
<li>你为什么要来头条实习呢？</li>
<li>在就业方面有什么考虑吗？对公司或者工作地点有什么偏向吗？</li>
<li>你有哪些问题想问我的？</li>
<li>你对参与实习之后要做的工作有什么期待吗？</li>
</ol>
<p>这方面我主要是问了一下为了适应岗位我需要进一步学习的东西，以及说了一下我比较想去做虚拟化和内核向的一些工作。这之间面试官跟我讲了很多东西，大概如下：</p>
<p>感觉你现在已经做的挺好了吧，我觉得没必要再给你做什么加法了，从理论上来讲你尽量去把学校的要求掌握的专业课学好就好了，像是数据结构啊，组成原理啊，高数啊概率啊，编译原理啊。在工程上呢去多做一些实践也是很必要的，比如你去使用ArchLinux这种比较典型的现代Linux系统，还有像编程方面，可以去了解一些与传统C控制逻辑不同的并发和并行，尤其是并行这种的领域，等等。理论联系实践地去做吧，毕竟你现在才大二嘛，对吧，已经很不错了。总之就是把知识学好，并多寻找一些实践的机会就挺不错的。</p>
<p>你工作的话到时候可能是在北京的，你这边应该可以过来是吧。其实我们这边在武汉现在好像也有办公室，不过我不是很清楚哈，这些都是后话。</p>
<p>我想跟你说的是，一般来说系统研究这方面是一个非常漫长的过程哈，基本上就像金庸小说一样，可能是说三年略有小成，几十年之后才可能有些成就，这个东西它还是需要很深的积累的。其实呢你几个月的实习时间，虽然你是希望去做一些内核相关的事情，但是从现实角度来看，你可能在这段时间之内只是能够通过一些实践去理解它基本的概念吧。</p>
<p>比如说你要做虚拟化和内核，肯定是要需要很长的准备时间吧。我们这边就算我招一个有经验的工程师进来，也得要三个月到半年的准备才能开始去做一些简单的内核外围的东西的，深层次的可能半年都不止。所以你最好有个心理准备，做系统这方面可不是像解个算法题或者写个软件一样简单，这个要做大量的环境的准备，然后你才能大概知道具体问题在什么地方，找到之后还得然后进一步去了解每个问题的影响范围，再对每个影响范围去进行处理，这是一个非常非常复杂的过程。我建议你就是不要期待能写多少代码，而是在这个上面开始建立一个基本的概念性的东西。我认为你在两个到四个月之间能有个大概的认识，就是一个很不错的结果了哈。还是要有沉的住气的心态的，你了解我说的意思吧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2019/03/10/在ArchLinux下安装和配置LaTex编译环境/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/03/10/在ArchLinux下安装和配置LaTex编译环境/" itemprop="url">在ArchLinux下安装和配置LaTex编译环境</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-10T22:22:37+08:00">
                2019-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Academic or Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/Tools/" itemprop="url" rel="index">
                    <span itemprop="name">Tools</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2019/03/10/在ArchLinux下安装和配置LaTex编译环境/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/03/10/在ArchLinux下安装和配置LaTex编译环境/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="在ArchLinux下安装和配置LaTex编译环境"><a href="#在ArchLinux下安装和配置LaTex编译环境" class="headerlink" title="在ArchLinux下安装和配置LaTex编译环境"></a>在ArchLinux下安装和配置LaTex编译环境</h2><p>之前写文档的时候一直用的是Markdown内置Latex，但这样不如直接编译<code>.tex</code>文件来的灵活，而在安装texlive的时候又遇到了很多坑，因此在这里总结一下安装与配置过程。</p>
<h3 id="安装xeLatex"><a href="#安装xeLatex" class="headerlink" title="安装xeLatex"></a>安装xeLatex</h3><p>用pacman可以安装texlive的许多组件，它们的统一格式是<code>texlive-</code>后跟一个具体的扩展。要安装基本组件只需要其中的<code>bin</code>，<code>core</code>和<code>lang</code>扩展，有特殊需求可以按照文档去安装其他的扩展。</p>
<p>这里我是如下安装：</p>
<p><code>sudo pacman -S texlive-{core,bin,langchinese,latexextra,fontsextra}</code></p>
<h3 id="扩展包的配置"><a href="#扩展包的配置" class="headerlink" title="扩展包的配置"></a>扩展包的配置</h3><h4 id="配置fontawesome"><a href="#配置fontawesome" class="headerlink" title="配置fontawesome"></a>配置fontawesome</h4><p>Fontawesome组件本身是在fontsextra扩展中的，但是由于扩展名问题无法被正常识别，需要在使用了这个组件的tex文件开头加上一句<code>\defaultfontfeatures{Extension = .otf}</code>。</p>
<h4 id="中文字体的问题"><a href="#中文字体的问题" class="headerlink" title="中文字体的问题"></a>中文字体的问题</h4><p>如果系统中没有安装<code>poppler-data</code>包，编译出的pdf文件将会无法显示中文。这个包可以直接使用<code>pacman</code>来安装。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2019/02/24/MIT_6.828/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2019/02/24/MIT_6.828/" itemprop="url">MIT 6.828 Labs 实验记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-24T20:10:08+08:00">
                2019-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Academic or Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/Operating-System/" itemprop="url" rel="index">
                    <span itemprop="name">Operating System</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2019/02/24/MIT_6.828/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/02/24/MIT_6.828/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="MIT-6-828-Labs-实验记录"><a href="#MIT-6-828-Labs-实验记录" class="headerlink" title="MIT 6.828 Labs 实验记录"></a>MIT 6.828 Labs 实验记录</h2><p>本博客中所有代码所对应的github repo地址：<a href="https://github.com/dracit7/6.828" target="_blank" rel="noopener">6.828</a></p>
<h3 id="Overall"><a href="#Overall" class="headerlink" title="Overall"></a>Overall</h3><p>有一些测试技巧是适用于所有Lab的，放在这里以供参考：</p>
<ul>
<li>6.828自带了一个打分系统，在Lab文件夹下执行<code>make grade</code>即可运行这个系统来检验自己的解答。</li>
<li><code>make grade</code>执行过程中JOS console的输出会保存在当前文件夹下的<code>jos.out.xxx</code>文件中。</li>
<li><code>make run-&lt;prog&gt;</code>可以在JOS上运行一个用户程序，其中<code>&lt;prog&gt;</code>是用户程序的无后缀文件名。</li>
</ul>
<p>有些时候我们会需要自定义一些系统调用或库函数来让用户能够运用一些内核权限进行测试。自定义系统调用需要做以下几步：</p>
<ul>
<li>修改<code>inc\syscall.h</code>，在其中的系统调用号枚举类型中添加新的系统调用号定义</li>
<li>修改<code>kern\syscall.c</code>，添加自己定义的功能性系统调用函数，并在<code>syscall</code>函数中添加对新调用号的判断逻辑</li>
<li>修改<code>lib\syscall.c</code>，添加能被用户调用的系统调用函数，在这些函数中调用<code>syscall</code>函数来陷入内核</li>
<li>修改<code>inc\lib.h</code>，在其中添加新的函数声明，以使新添加的函数能被编译器识别</li>
</ul>
<h3 id="Build-up-the-environment"><a href="#Build-up-the-environment" class="headerlink" title="Build up the environment"></a>Build up the environment</h3><h4 id="Compiler-Toolchain"><a href="#Compiler-Toolchain" class="headerlink" title="Compiler Toolchain"></a>Compiler Toolchain</h4><p>由于Archlinux中的objdump和gcc均满足Lab的要求，不需要手动搭建编译环境。</p>
<h4 id="QEMU-emulator"><a href="#QEMU-emulator" class="headerlink" title="QEMU emulator"></a>QEMU emulator</h4><p>建议follow一下MIT官网上最新版的6.828课程页面。老的课程页面上的链接可能不可用。此处根据<a href="https://pdos.csail.mit.edu/6.828/2018/tools.html" target="_blank" rel="noopener">Fall 2018的课程页面</a>进行配置。</p>
<p>由于QEMU的调试系统不完善，课程组准备了改进过的QEMU，使它可以与系统中的GDB调试器绑定，并使用GDB来调试。执行以下步骤安装打好补丁的QEMU:</p>
<ol>
<li>执行<code>git clone https://github.com/mit-pdos/6.828-qemu.git qemu</code>拉取源代码</li>
<li>安装各种依赖。在Archlinux下的安装方式如下：<ul>
<li>libdtc：<code>yay DTC</code>，任选一项安装。</li>
<li>python：坑爹的是都8102年了这门课还不支持python3.不过Arch一般自带python2,问题不大</li>
</ul>
</li>
<li>进入源代码文件夹，Configure the source code<ul>
<li>执行<code>./configure --disable-kvm --disable-werror --python= &lt;pathToPython2&gt;</code></li>
</ul>
</li>
<li>执行<code>make &amp;&amp; make install</code>进行安装</li>
</ol>
<p>安装到一半，报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">qga/commands-posix.c: 在函数‘dev_major_minor’中:</span><br><span class="line">qga/commands-posix.c:634:21: 警告：implicit declaration of <span class="keyword">function</span> ‘major’; did you mean ‘_m_por’? [-Wimplicit-function-declaration]</span><br><span class="line">         *devmajor = major(st.st_rdev);</span><br><span class="line">                     ^~~~~</span><br><span class="line">                     _m_por</span><br><span class="line">qga/commands-posix.c:634:21: 警告：对‘major’的嵌套的外部声明 [-Wnested-externs]</span><br><span class="line">qga/commands-posix.c:635:21: 警告：implicit declaration of <span class="keyword">function</span> ‘minor’; did you mean ‘mknod’? [-Wimplicit-function-declaration]</span><br><span class="line">         *devminor = minor(st.st_rdev);</span><br><span class="line">                     ^~~~~</span><br><span class="line">                     mknod</span><br><span class="line">qga/commands-posix.c:635:21: 警告：对‘minor’的嵌套的外部声明 [-Wnested-externs]</span><br></pre></td></tr></table></figure>
<p>很显然是有两个函数major和minor在使用之前并未声明。这是两个库函数，在linux下的<code>&lt;sys/sysmacros.h&gt;</code>头文件中有定义，然而MIT给的代码里并没有包含这个头文件。根据报错信息打开<code>qga/commands-posix.c</code>，添加<code>#include &lt;sys/sysmacros.h&gt;</code>，保存。</p>
<p>再次安装，装到一半又报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: ../hw/9pfs/virtio-9p.o: <span class="keyword">in</span> <span class="keyword">function</span> `stat_to_v9stat<span class="string">':</span></span><br><span class="line"><span class="string">/home/drac_zhang/Downloads/qemu/hw/9pfs/virtio-9p.c:796: undefined reference to `minor'</span></span><br><span class="line">/usr/bin/ld: /home/drac_zhang/Downloads/qemu/hw/9pfs/virtio-9p.c:796: undefined reference to `major<span class="string">'</span></span><br><span class="line"><span class="string">/usr/bin/ld: ../hw/9pfs/virtio-9p.o: in function `v9fs_mknod'</span>:</span><br><span class="line">/home/drac_zhang/Downloads/qemu/hw/9pfs/virtio-9p.c:2803: undefined reference to `makedev<span class="string">'</span></span><br><span class="line"><span class="string">/usr/bin/ld: ../hw/9pfs/virtio-9p.o: in function `v9fs_create'</span>:</span><br><span class="line">/home/drac_zhang/Downloads/qemu/hw/9pfs/virtio-9p.c:2124: undefined reference to `makedev<span class="string">'</span></span><br><span class="line"><span class="string">collect2: 错误：ld 返回 1</span></span><br></pre></td></tr></table></figure>
<p>差不多的理由，还是缺少库函数。也不管重复包含dirty不dirty了，向<code>hw/9pfs/virtio-9p.c</code>中添加<code>#include &lt;sys/sysmacros.h&gt;</code>，保存后再次编译。</p>
<p>因为类似的理由，还需要添加这个头文件的源文件有<code>linux-user/strace.c</code>。</p>
<h4 id="Other-problems"><a href="#Other-problems" class="headerlink" title="Other problems"></a>Other problems</h4><p>这里是其他各种各样可能会出现的玄学错误。</p>
<h5 id="Dependencies-upgraded"><a href="#Dependencies-upgraded" class="headerlink" title="Dependencies upgraded"></a>Dependencies upgraded</h5><p>在我完成这个lab的过程中，<code>libnfs</code>库在我滚arch的时候升级了，结果一运行<code>make</code>就会报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error <span class="keyword">while</span> loading shared libraries: libnfs.so.12: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
<p>执行<code>whereis libnfs.so.12</code>，发现系统的库中只有<code>libnfs.so.13</code>，原来是这个库在升级的时候名字变掉了……</p>
<p>没办法，只好用<code>downgrade</code>命令手动降级到<code>4.0.0-2</code>版本，再执行<code>make</code>的时候就没事了。</p>
<h3 id="Lab-1-Booting-a-PC"><a href="#Lab-1-Booting-a-PC" class="headerlink" title="Lab 1 Booting a PC"></a>Lab 1 Booting a PC</h3><p>Lab1的源码可以从<code>https://pdos.csail.mit.edu/6.828/2018/jos.git</code>处clone到。</p>
<h4 id="Part-1-PC-bootstrap"><a href="#Part-1-PC-bootstrap" class="headerlink" title="Part 1 PC bootstrap"></a>Part 1 PC bootstrap</h4><p>这一部分的目的是让我们熟悉x86汇编语言和PC bootstrap过程，并熟悉QEMU和gdb的操作。</p>
<p>首先在lab目录下执行<code>make</code>命令来编译内核和启动器。编译完成的内核与启动器位于<code>obj/kern/kernel.img</code>镜像文件中，这个镜像文件是一个用于模拟真实硬盘的虚拟磁盘。</p>
<p>执行<code>make qemu</code>可以正式在qemu中运行编译好的操作系统，此时命令行终端会创建一个新的窗口，同时在终端中显示与窗口中同样的内容(并接受同样的输入)。方便起见，这里我们用终端进行接下来的操作。</p>
<p>一开始这个shell只有两条简单的指令：<code>help</code>和<code>kerninfo</code>。后者会打印出目前的内核状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Special kernel symbols:</span><br><span class="line">  _start                  0010000c (phys)</span><br><span class="line">  entry  f010000c (virt)  0010000c (phys)</span><br><span class="line">  etext  f01019df (virt)  001019df (phys)</span><br><span class="line">  edata  f0113060 (virt)  00113060 (phys)</span><br><span class="line">  end    f01136a0 (virt)  001136a0 (phys)</span><br><span class="line">Kernel executable memory footprint: 78KB</span><br></pre></td></tr></table></figure>
<p>要退出qemu可以打出<code>Ctrl+a x</code>。</p>
<h5 id="Layout-of-the-physical-address-space"><a href="#Layout-of-the-physical-address-space" class="headerlink" title="Layout of the physical address space"></a>Layout of the physical address space</h5><table>
<thead>
<tr>
<th style="text-align:center">+——————————+</th>
<th>&lt;- 0xFFFFFFFF(4GB)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\</td>
<td>内存映射的虚拟地址  \</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">+——————————+</td>
<td>&lt;- 取决于RAM的数量</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td>扩展内存           \</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">+——————————+</td>
<td>&lt;- 0x00100000 (1MB)</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td>BIOS所在的ROM    \</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">+——————————+</td>
<td>&lt;- 0x000F0000 (960KB)</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td>16位机使用的扩展ROM\</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">+——————————+</td>
<td>&lt;- 0x000C0000 (768KB)</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td>VGA Display        \</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">+——————————+</td>
<td>&lt;- 0x000A0000 (640KB)</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td>Low Memory       \</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">+——————————+</td>
<td>&lt;- 0x00000000</td>
</tr>
</tbody>
</table>
<p>一开始的16位机只能使用最下面那一共<strong>1MB</strong>的物理存储，而可用的内存只有标识为Low Memory的<strong>640KB</strong>。标注有VGA Display的部分是硬件保留区，用于当作VGA显示屏的缓冲区。</p>
<p>就算是在Intel突破了“1MB的瓶颈”之后，PC设计师也仍然对于最低的1MB地址空间使用原始的架构，这是为了软件的向后兼容性。这样就在LowMemory和扩展内存之间留下了一个<strong>空洞</strong>(IO hole)。在操作系统的内存分配中，这个空洞所对应的地址段不应被虚拟地址系统所使用。</p>
<p>在计算机从32位升级为64位时，BIOS在地址空间的最顶段因为类似的理由留下了第二个空洞，不过由于本实验在32位系统下进行，这个空洞不予考虑。</p>
<h5 id="The-ROM-BIOS"><a href="#The-ROM-BIOS" class="headerlink" title="The ROM BIOS"></a>The ROM BIOS</h5><p>为了单步调试计算机的启动过程，我们需要两个终端，一个用<code>make qemu-gdb</code>来启动qemu虚拟机，一个用<code>make gdb</code>来将gdb调试环境连接到虚拟机上。</p>
<p><code>make qemu-gdb</code>会将处理器暂停在即将执行第一条指令之前并等待gdb的连接，这时在另一个终端中使用<code>make gdb</code>就可以通过gdb来调试操作系统内核。</p>
<p>gdb终端会显示一段结尾如下的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The target architecture is assumed to be i8086</span><br><span class="line">[f000:fff0]    0xffff0: ljmp   $0xf000,$0xe05b</span><br><span class="line">0x0000fff0 in ?? ()</span><br><span class="line">+ symbol-file obj/kern/kernel</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>其中的第二行代表着目前将要执行的指令，也就是虚拟机开启过程的第一条指令。</p>
<p>这条指令的含义是：</p>
<ul>
<li><code>0xffff0:</code>：指令位于的虚拟存储系统地址，对应于上面的架构，这个位置是属于BIOS的ROM区域的最上面，也就是BIOS程序的起始位置。</li>
<li><code>[f000:fff0]</code>：指示当前CS和IP寄存器的值。CS寄存器指示代码所在的数据段，IP则是偏移量。</li>
<li><code>ljmp</code>：跳转指令，跳转到CS和IP为<code>[f000:e05b]</code>的位置，转换成存储地址就是<code>0xfe05b</code>。<ul>
<li>CS和IP寄存器与物理地址的转换规则为<code>ADDR = CS&lt;&lt;4 + IP</code>。</li>
</ul>
</li>
</ul>
<p>保证启动时优先执行BIOS代码是很重要的，因为一开始内存中根本不会有其他可以执行的代码。BIOS会初始化所有启动所需要的重要设备，检查内存和磁盘的挂载情况。最后，就像操作系统课程中所学的那样，它找到磁盘上的boot loader并将控制权转移给它。</p>
<ul>
<li>对GDB使用<code>si</code>命令可以继续单步调试之后的汇编代码，观察BIOS所做的工作。</li>
</ul>
<h4 id="Part-2-The-boot-loader"><a href="#Part-2-The-boot-loader" class="headerlink" title="Part 2 The boot loader"></a>Part 2 The boot loader</h4><p>众所周知，软盘和硬盘都被分成大小为<code>512字节</code>的段，而这些段是系统级IO的最小单位。如果一个磁盘是启动盘，那么它的第一个段就被称为 <strong>boot sector</strong> ，并被存放boot loader的代码。当BIOS找到一个boot sector后，它就会将其加载到内存中，并将控制权转交给boot loader代码段。</p>
<p>(对于CD-ROM来说，它的前2M都属于boot sector，因此可以存放更大的启动镜像)</p>
<p>在6.828文件夹中，boot loader的代码存放于<code>boot/boot.S</code>与<code>boot/main.c</code>中。这些代码主要完成两件事：</p>
<ol>
<li>将处理器模式切换到<code>32位保护模式</code>，这样软件才可以访问大于1MB的物理地址空间。这个工作由<code>boot.S</code>完成。除此之外，<code>boot.S</code>还要建立一个程序栈，让C程序得以运行。</li>
<li>将内核代码从硬盘中加载到内存，并将控制转交给内核代码的入口函数。这个工作由<code>main.c</code>完成。</li>
</ol>
<p>阅读<code>main.c</code>的代码可以发现很多 <del>非常dirty的</del> 细节(<del>包括但不限于：使用goto，while(1)代替sleep，写的很乱的函数指针</del>)，如果对于这个过程的细节感兴趣可以直接阅读源码，注释写的很详细明白。</p>
<p>bootloader的代码会被BIOS加载到<code>0x7c00</code>，这是由<code>boot/Makefrag</code>文件所决定的。修改这个文件中<code>-Ttext</code>参数后面的地址可以让BIOS从其他地址来加载，执行<code>make clean &amp;&amp; make</code>重新编译可以查看这样做会引发什么样的系统错误(事实上系统会停机并进入一个无限循环等待用户的操作)；在GDB调试时可以在这个位置设置断点，以精确地进入bootloader代码段。</p>
<p><code>obj/boot/boot.asm</code>和<code>obj/kern/kernel.asm</code>分别包含着bootloader和kernel的反汇编结果以及注释，可以用于调试和分析。下面就来分析一下BootLoader的代码逻辑。</p>
<ul>
<li>BootLoader代码逻辑研究<ul>
<li>第一阶段：<strong>初始化</strong><ul>
<li><strong>宏常量的设定</strong>：<code>.set CR0_PE_ON 0x1</code> 这个常量是控制32位保护模式开关的指标。</li>
<li><strong>全局设置</strong>：<code>cli</code>指令关闭中断处理，<code>cld</code>指令将串操作的内存地址访问模式设为增序<ul>
<li>这两个指令其实是设置了<code>DF</code>和<code>IF</code>两个标志位的值</li>
</ul>
</li>
<li><strong>寄存器初始化</strong>：用xor和mov指令将几个关键寄存器清零<ul>
<li><code>ds</code>：数据段寄存器，存放全局变量区域的头指针</li>
<li><code>ss</code>：栈段寄存器，存放堆栈段的首地址(<code>esp</code>寄存器存储的是偏移量)</li>
<li><code>es</code>：扩展段寄存器</li>
</ul>
</li>
</ul>
</li>
<li>第二阶段：<strong>打开32位保护模式</strong><ul>
<li><strong>开启A20地址线</strong>：在16位模式下，用于寻址的地址总线只有20根，这种情况下大于1MB的地址空间是全部被置为0的。只有开启20～23号四条地址线，才能对1MB以上的地址空间进行寻址，从而进入32位模式。<ul>
<li>通过一个循环来等待A20设备准备完毕：用<code>in</code>指令从<code>0x64</code>端口接受信息，如果不是代表准备完毕的信息则继续循环。</li>
<li>向<code>0x64</code>和<code>0x60</code>端口发送信号，打开A20地址线。</li>
</ul>
</li>
<li><strong>建立32位段虚拟内存与物理存储器的映射关系表</strong>：<code>lgdt gdtdesc</code>指令。</li>
<li><strong>启动32位保护模式</strong>：用<code>CR0_PE_ON</code>与<code>cr0</code>寄存器的值做或运算，打开32位保护模式。<code>cr0</code>到<code>cr3</code>四个寄存器是系统控制寄存器，它们的值直接决定系统的运行状态。<code>cr0</code>控制的是处理器，因此可以通过修改其值来进入其他运行模式。</li>
<li><strong>跳转到32位代码区的下一条指令</strong>。</li>
</ul>
</li>
<li>第三阶段：修改段寄存器的值为32位区地址，初始化<code>esp</code>寄存器的值，建立C程序栈</li>
<li>第四阶段：进入<code>main.c</code>的bootmain函数，开始读取内核代码。</li>
<li>第五阶段：跳转到内核代码区，交还控制权。</li>
</ul>
</li>
</ul>
<blockquote>
<h5 id="习题解答"><a href="#习题解答" class="headerlink" title="习题解答"></a>习题解答</h5><p>Q: 处理器什么时候开始执行32位代码？哪条指令切换了处理器模式？</p>
<p>A：<code>0x7c2a:  mov    %eax,%cr0</code>指令切换了处理器模式，从随后的跳转指令开始，处理器开始执行32位代码。</p>
<p>Q：Bootloader执行的最后一条指令是什么？kernel执行的第一条指令又是什么?</p>
<p>A：Bootloader执行的最后一条指令是向内核代码段跳转的指令<code>0x7d71:      call   *0x10018</code>，kernel执行的第一条指令是<code>0x10000c:    movw   $0x1234,0x472</code>。</p>
<p>Q：Bootloader是如何决定它要读取多少数据的？它从哪里获取的kernel大小信息？</p>
<p>A：Bootloader首先从内核代码区读取了长度固定的ELF头部，再从头部中获取了这个区域是否为ELF文件、数据段数量、每段的长度、起始地址等信息。</p>
</blockquote>
<p>(课程网页在这一部分讲了一大堆ELF头和指针的知识，如果已经学过CSAPP第7章的话完全可以跳过。需要注意的是，6.828所采用的可执行目标文件代码 <strong>并非是位置无关代码</strong> ，因而 <strong>链接器会将程序将加载到的内存位置写在文件中</strong> 。利用这一点，我们可以执行<code>objdump -f &lt;filename&gt;</code>命令，获取程序在内存中的入口位置。)</p>
<h4 id="Part-3-The-kernel"><a href="#Part-3-The-kernel" class="headerlink" title="Part 3 The kernel"></a>Part 3 The kernel</h4><p>在内核被授予控制权后，它要做如下几件事：</p>
<h5 id="Virtual-memory-address-mapping"><a href="#Virtual-memory-address-mapping" class="headerlink" title="Virtual memory address mapping"></a>Virtual memory address mapping</h5><p>当我们观察bootloader程序的时候，我们可以发现它的 <strong>链接地址</strong>(指用<code>objdump -h</code>打印出来的ELF节头部信息中的<code>LMA</code>，linked memory address) 和 <strong>虚拟地址</strong>(指用<code>objdump -h</code>打印出来的ELF节头部信息中的<code>VMA</code>，virtual memory address) 是完全一致的；然而对于kernel，这两个地址却有着不小的差距。</p>
<p>操作系统内核常常会在非常高的虚拟地址空间(例如0xf0100000)运行，这是为了把比较低的虚拟地址空间留给用户进程使用。然而大部分机器没有这么多的内存，于是它们将虚拟地址0xf0100000映射到物理地址0x00100000。这样一来虽然内核所在的加载地址很高，它的实际加载地址却是位于RAM区域的最底端，挨着BIOS所在的ROM地址区域。</p>
<p>虚拟地址映射操作是由专门的硬件来完成的，要打开虚拟地址映射只需要对<code>cr0</code>寄存器设置<code>CR0_PG</code>标志，就像之前打开32位保护模式所做的那样。除此之外，为了能让虚拟地址映射正常工作，我们需要将页表的首地址装入<code>cr3</code>寄存器。</p>
<p>kernel被加载的地址为0x100000,因此它从此处开始运行。它所做的第一项工作就是打开虚拟地址映射，然后跳转到虚拟地址<code>0xf010002f</code>的位置，恰好对应于物理地址中下一条指令所在的位置。这样，内核就自然地实现了从物理地址到虚拟地址的转换。</p>
<h5 id="Formatted-printing-to-the-console"><a href="#Formatted-printing-to-the-console" class="headerlink" title="Formatted printing to the console"></a>Formatted printing to the console</h5><p>在完成虚拟地址映射之后，下一步是对终端进行格式化输入输出以创建交互式操作界面。</p>
<p><code>lib/printfmt.c</code>中提供了输出函数的原型，<code>kern/printf.c</code>和<code>kern/console.c</code>则提供了有关内核输出和交互的函数。</p>
<blockquote>
<p><strong>Answer to Exercise 8</strong></p>
<p>本题要求补全printfmt函数对于<code>%o</code>(8进制输出)的处理机制，只需要仿照下面十六进制的机制即可。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">  num = getuint(&amp;ap, lflag);</span><br><span class="line">  base = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">goto</span> number;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>习题解答</strong></p>
<p>Q：解释printf.c和console.c之间的接口，尤其是console.c中的哪个函数被如何用于printf.c。</p>
<p>A：console.c向printf.c提供了cputchar函数,它希望在调用printf.c中的输出函数时可以利用cputchar函数来输出每一个字符。printf.c遵守这个约定,以包含cputchar的外壳函数调用printfmt.c中的输出函数,保证了所有输出都按照console.c所规定的标准来输出。</p>
<p>Q：解释console.c中的这一段代码:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">  <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">    crt_buf[i] = <span class="number">0x0700</span> | <span class="string">' '</span>;</span><br><span class="line">    crt_pos -= CRT_COLS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>A：</p>
<p>这段代码来自cga_putc函数,这个函数是在CGA显示屏图形卡上打印字符的函数。crt_pos是一个整形全局变量,它的含义是目前光标在屏幕上的位置。阅读<code>console.h</code>的内容可以发现CRT_SIZE被定义为屏幕上能够容纳的字符个数,而CRT_COLS则是屏幕的宽度。</p>
<p>条件判断是为了确认当前光标的位置是否已经超出了屏幕底端。如果超出了，就把屏幕上第二行到最后一行的内容全部上移一行，并将空出来的位置用<code>0x0700 | &#39; &#39;</code>填满。</p>
<p>总而言之，这段代码是为了实现屏幕满了之后向上滚动的功能。</p>
<p>Q：单步调试如下代码：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</span><br><span class="line">cprintf(<span class="string">"x %d, y %x, z %d\n"</span>, x, y, z);</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>在对cprintf的调用中，fmt对应的实参是什么？ap呢？</li>
<li>列出对<code>cons_putc</code>, <code>va_arg</code>和<code>vcprintf</code>的每一次调用，以及<code>cons_putc</code>的参数,<code>va_arg</code>中ap的指向和<code>vcprintf</code>的参数值。</li>
</ol>
<p>A：</p>
<ol>
<li>fmt对应的实参是<code>&quot;x %d, y %x, z %d\n&quot;</code>，ap指向带有x，y和z的参数数组。</li>
<li>甚至不需要单步调试，自己阅读<code>lib/printfmt.c</code>就足够了。</li>
</ol>
<p>Q：运行如下代码：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line">cprintf(<span class="string">"H%x Wo%s"</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释输出结果。如果这段代码运行在大端序机器上而非小端序机器上，你会如何修改它来得到同样的结果？</p>
<p>A：输出结果是<code>He110 World</code>。前面的e110是57616在十六进制下的表示(因为使用了<code>%x</code>)，后面的rld是字符串输出的结果。int占4个字节而每个字符占一个字节，因而i所占的内存空间与一个长度为4的字符数组是相同的。这样一来，如果用i的地址去输出字符串，就会从i的地址开始按字符去读取内存中的数据，直到读到0为止。由于运行在小端序机器，0x72排在最前面一个字节，被解析成ASCII码值为0x72的<code>r</code>；接下来0x6c和0x64分别被解释为<code>l</code>和<code>d</code>。最后一个字节是0x00,正好是字符串终结符。</p>
<p>如果机器是大端序，只需要将i修改为<code>0x726c6400</code>即可，57616不需要改变。</p>
<p>Q：被<code>cprintf(&quot;x=%d y=%d&quot;, 3);</code>打印出的y值会是多少？为什么？</p>
<p>A：会是一个随机的整形数。因为cprintf解析到了两个<code>%d</code>符号，但<code>ap</code>的长度只有1,这导致第二个<code>%d</code>读到了一片未赋值的内存地址，其值自然是随机的。</p>
</blockquote>
<h5 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h5><p>(仔细读过CSAPP第三章的话汇编语言和程序栈这一块应该没问题了，就不说了)</p>
<blockquote>
<p><strong>Answer to Exercise 9</strong></p>
<p>Q：确定内核在什么时候初始化程序栈及程序栈的初始位置。内核是如何为栈保存空间的？</p>
<p>A：<code>f010034: mov $0xf0110000, %esp</code>：这一条指令初始化了栈指针，将程序栈建立于虚拟地址<code>0xf0110000</code>位置。从这个地址开始，程序栈随着程序运行向下增长。</p>
</blockquote>
<p><code>ebp</code>指针被称为“基指针”，它的作用是追踪每个函数的栈帧位置。每个被调用的C函数都要进行如下操作：将ebp寄存器的值压栈、将当前esp指针值拷贝到ebp寄存器。在返回之前，这个函数从栈中取出并恢复ebp寄存器的值。通过这种机制，<strong>任何时候ebp寄存器的值都指向正在执行的函数的栈帧头部，而栈帧头部的前一个数据节的值指向该函数调用者的栈帧头部</strong>，于是可以通过ebp链来还原函数调用链。</p>
<blockquote>
<p><strong>Answer to Exercise 10</strong></p>
<p>这个Exercise的目的是让学生熟悉backtrace的操作和C的程序栈结构。在kernel中有一个自我递归的<code>test_backtrace</code>函数,通过对这个函数打上断点可以使用<code>p $ebp</code>获取每次调用的栈帧起始位置.</p>
<p>第一次调用:栈帧的起始位置为<code>0xf010ffd8</code><br>第二次调用:栈帧的起始位置为<code>0xf010ffb8</code></p>
<p>可以看出这个函数的每个栈帧大小都是<code>0x20</code>,也就是32个字节，对于32位系统来说是八个数据。</p>
<p>使用<code>x/xw</code>命令查看从<code>0xf010ffe0</code>开始整个栈帧的结构。(因为32位系统每个数据是四个字节，所以使用<code>x/xw</code>来查看)</p>
<p><code>x/xw 0xf010ffe0</code>：<code>0x00000005</code> 按照栈帧的结构，这个位置应该是调用者压入栈内的参数。第一次对<code>test_backtrace</code>的调用的确只有一个实参5。</p>
<p><code>x/xw 0xf010ffdc</code>：<code>0xf01000f4</code> 由于栈帧是向下的，这条指令其实查看的是上一个栈帧的最后一部分，也就是函数的返回地址，经验证的确指向调用者的下一条指令。</p>
<p><code>x/xw 0xf010ffd8</code>：<code>0xf010fff8</code> 当前函数栈帧的第一部分，保存着上一个函数的基指针值(<code>%ebp</code>的值)，由于上一个函数已经是整个程序栈底部的函数了，这个地址向上就没有数据了，上个函数的基指针指向的是物理内存区的函数。</p>
<p><code>x/xw 0xf010ffd4</code>：<code>0x000100b4</code> 被调用者保存的<code>%esi</code>寄存器的值 </p>
<p><code>x/xw 0xf010ffd0</code>：<code>0xf011304c</code> 被调用者保存的<code>%ebx</code>寄存器的值</p>
<p><code>x/xw 0xf010ffcc</code>：<code>0xf010004a</code> 是<code>test_backtrace</code>中一行代码的地址</p>
<p><code>x/xw 0xf010ffc8</code>：<code>0x00000000</code> 空的，没有数据</p>
<p><code>x/xw 0xf010ffc4</code>：<code>0x00000005</code> 局部变量5</p>
<p><code>x/xw 0xf010ffc0</code>：<code>0x00000004</code> 即将进行下一次递归调用，这是压入的参数4</p>
<p>再往下就是返回地址，然后就是下一个栈帧。总的来说，<code>test_backtrace</code>函数的栈帧结构就是这样。</p>
</blockquote>
<p>完成了对栈帧结构的观察后，就可以利用观察结果去做一下任务了。Exercise 11要求我们实现一个<code>mon_backtrace</code>函数，它记录并打印出栈帧信息。<code>inc/x86.h</code>中提供了<code>read_ebp()</code>函数可以直接返回ebp寄存器的值。</p>
<p>输出格式规定如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack backtrace:</span><br><span class="line">  ebp f0109e58  eip f0100a62  args 00000001 f0109e80 f0109e98 f0100ed2 00000031</span><br><span class="line">  ebp f0109ed8  eip f01000d6  args 00000000 00000000 f0100058 f0109f28 00000061</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Answer to Exercise 11</strong></p>
<p>本题要求是按上面的要求修改<code>kern/monitor.c</code>中的<code>mon_backtrace</code>函数，并将其添加到指令集中。</p>
<p>对代码的修改如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一处修改</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Command</span> <span class="title">commands</span>[] = &#123;</span></span><br><span class="line">        &#123; <span class="string">"help"</span>, <span class="string">"Display this list of commands"</span>, mon_help &#125;,</span><br><span class="line">        &#123; <span class="string">"kerninfo"</span>, <span class="string">"Display information about the kernel"</span>, mon_kerninfo &#125;,</span><br><span class="line">        &#123; <span class="string">"backtrace"</span>, <span class="string">"Display the structure of the stack"</span>, mon_backtrace &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第二处修改</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Your code here.</span></span><br><span class="line">        cprintf(<span class="string">"Stack backtrace:\n"</span>);</span><br><span class="line">        <span class="keyword">int</span> ebp = read_ebp();</span><br><span class="line">        <span class="keyword">int</span> eip = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">int</span> args[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                args[i] = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>*i + <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,ebp,eip,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],args[<span class="number">3</span>],args[<span class="number">4</span>]);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                ebp = *(<span class="keyword">int</span> *)ebp;</span><br><span class="line">                <span class="keyword">if</span> (!ebp) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> eip = *(<span class="keyword">int</span> *)(ebp+<span class="number">4</span>);</span><br><span class="line">                <span class="keyword">int</span> args[<span class="number">5</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                        args[i] = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>*i + <span class="number">8</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,ebp,eip,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],args[<span class="number">3</span>],args[<span class="number">4</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Exercise 12要求我们升级这个函数，使其支持如下的输出格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stack backtrace:</span><br><span class="line">  ebp f010ff78  eip f01008ae  args 00000001 f010ff8c 00000000 f0110580 00000000</span><br><span class="line">         kern/monitor.c:143: monitor+106</span><br><span class="line">  ebp f010ffd8  eip f0100193  args 00000000 00001aac 00000660 00000000 00000000</span><br><span class="line">         kern/init.c:49: i386_init+59</span><br><span class="line">  ebp f010fff8  eip f010003d  args 00000000 00000000 0000ffff 10cf9a00 0000ffff</span><br><span class="line">         kern/entry.S:70: &lt;unknown&gt;+0</span><br></pre></td></tr></table></figure>
<p>为了根据eip找到函数名，行数和文件名等一系列信息，<code>kern/kdebug.c</code>中提供了<code>debuginfo_eip()</code>函数，我们需要完整地实现<code>debuginfo_eip()</code>函数，并在<code>mon_backtrace</code>中调用这个函数来获得信息。</p>
<blockquote>
<p><strong>Answer to Exercise 12</strong></p>
<p>在<code>debuginfo_eip</code>函数中有一些以<code>__STAB_</code>开头的宏常量,它们所代表的是ELF文件中<code>.stab</code>(在CSAPP中是<code>.symtab</code>)区的开头和结尾位置,以及<code>.stabstr</code>(在CSAPP中是<code>.strtab</code>)区的开头和结尾位置,它们是在链接过程中由<code>kernel.ld</code>定义的。</p>
<p>以下是修改内容：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kern/monitor.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Your code here.</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">        cprintf(<span class="string">"Stack backtrace:\n"</span>);</span><br><span class="line">        <span class="comment">// Parse the structure of the stack</span></span><br><span class="line">        <span class="keyword">int</span> ebp = read_ebp();</span><br><span class="line">        <span class="keyword">int</span> eip = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">int</span> args[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                args[i] = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>*i + <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Print some information in restricted format.</span></span><br><span class="line">        cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,ebp,eip,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],args[<span class="number">3</span>],args[<span class="number">4</span>]);</span><br><span class="line">        <span class="comment">// Exercise 12, get the debuginfo by eip</span></span><br><span class="line">        debuginfo_eip(eip, &amp;info);</span><br><span class="line">        cprintf(<span class="string">"         %s:%d: "</span>,info.eip_file, info.eip_line);</span><br><span class="line">        <span class="comment">// info.eip_fn_name is a non-null-terminated string</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;info.eip_fn_namelen;i++) cprintf(<span class="string">"%c"</span>,*(info.eip_fn_name+i));</span><br><span class="line">        cprintf(<span class="string">"+%d\n"</span>,eip - info.eip_fn_addr);</span><br><span class="line">        <span class="comment">// Backtracing</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                ebp = *(<span class="keyword">int</span> *)ebp;</span><br><span class="line">                <span class="keyword">if</span> (!ebp) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> eip = *(<span class="keyword">int</span> *)(ebp+<span class="number">4</span>);</span><br><span class="line">                <span class="keyword">int</span> args[<span class="number">5</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                        args[i] = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>*i + <span class="number">8</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,ebp,eip,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],args[<span class="number">3</span>],args[<span class="number">4</span>]);</span><br><span class="line">                debuginfo_eip(eip, &amp;info);</span><br><span class="line">                cprintf(<span class="string">"         %s:%d: "</span>,info.eip_file, info.eip_line);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;info.eip_fn_namelen;i++) cprintf(<span class="string">"%c"</span>,*(info.eip_fn_name+i));</span><br><span class="line">                cprintf(<span class="string">"+%d\n"</span>,eip - info.eip_fn_addr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kern/kdebug.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">debuginfo_eip(<span class="keyword">uintptr_t</span> addr, struct Eipdebuginfo *info)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line">    stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</span><br><span class="line">    <span class="keyword">if</span> (lline &lt;= rline) info-&gt;eip_line = stabs[lline].n_desc;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此Lab1结束。运行<code>make grade</code>，<code>50/50</code>大成功。</p>
<h3 id="Lab-2-Memory-Management"><a href="#Lab-2-Memory-Management" class="headerlink" title="Lab 2 Memory Management"></a>Lab 2 Memory Management</h3><p>在这个Lab中，我们需要实现操作系统的内存管理系统。内存管理系统包括两个部分：</p>
<ul>
<li>物理内存调度：我们要实现一个以4096个字节大小的页为单位的内存分配器，它将空闲的内存分配给内核和用户，并释放使用完的内存。</li>
<li>虚拟内存映射</li>
</ul>
<p>执行<code>git checkout -b lab2 origin/lab2</code>命令切换到lab2分支，执行<code>git merge lab1</code>合并在lab1所做的更改。</p>
<p>Lab2增加的文件有：</p>
<ul>
<li><code>inc/memlayout.h</code>：定义描述虚拟内存空间的布局的函数，定义PageInfo结构体</li>
<li><code>kern/pmap.c</code>和<code>kern/pmap.h</code>：实现<code>inc/memlayout.h</code>中定义的函数</li>
<li><code>kern/kclock.c</code>和<code>kern/kclock.h</code>：与CMOS硬件沟通，读取PC的硬件信息</li>
</ul>
<p><code>inc/mmu.h</code>中记录了应当烧录于MMU<br>单元中的逻辑代码，同样可能对这个lab有所帮助。</p>
<h4 id="Background-knowledge"><a href="#Background-knowledge" class="headerlink" title="Background knowledge"></a>Background knowledge</h4><p>由于虚拟内存是将很小的物理内存映射到很大的虚拟内存空间，这个映射关系需要一个输入地址和一个输出地址才能作用。<strong>物理地址</strong>是物理内存中真实的地址，可以直接由硬件寻址得到；<strong>虚拟地址/线性地址</strong>是物理地址通过转换得到的，用于虚拟内存空间索引的地址。</p>
<p><code>mmu.h</code>中详细地介绍了线性地址的结构。大体上讲，线性地址分为三段：</p>
<ul>
<li><code>Page directory index</code>：页目录的序号(10位)</li>
<li><code>Page table index</code>：页表的序号(10位)</li>
<li><code>Page offset</code>：地址在页内的偏移(12位)</li>
</ul>
<p>从线性地址的三段式结构可以看出，每个页表包括<code>1024</code>(2的10次方)个页，每个页目录包括<code>1024</code>个页表，而每一页的大小是<code>4096</code>个字节(也就是<code>4KB</code>)。</p>
<p>3段加起来的总长度是<code>32 bits</code>，也就是<code>4个字节</code>，这代表着线性地址可以用一个<code>int32</code>变量表示。</p>
<p>我们可以使用宏命令来取出线性地址的各个段，或将线性地址映射为物理地址。在本lab中，虚拟地址似乎是特指<code>物理地址+固定偏置值</code>所映射到的地址。</p>
<p>在<code>memlayout.h</code>中可以查看到整个虚拟内存地址空间的分配，在此列出并加以解释：</p>
<p><img src="memlayout.png" alt="memlayout"></p>
<ul>
<li><code>0xf0000000</code>以上：<code>Remapped physical memory</code>，物理内存的原样映射，这一部分为虚拟地址</li>
<li><code>0xefc00000</code>以上：内核栈区域，存放各个CPU的内核栈。<ul>
<li><code>0xef800000</code>：内核内存区和用户内存区的分界线，这以上用户不可读写</li>
</ul>
</li>
<li><code>0xef400000</code>以上：页表区域</li>
<li><code>0xef000000</code>以上：页区域</li>
<li><code>0xeec00000</code>以上：当前进程的环境变量区域<ul>
<li><code>0xeec00000</code>：用户只读区和读写区的分界线，这以上用户只有读权限</li>
</ul>
</li>
<li><code>1 PGSIZE</code>：用户的异常栈</li>
<li><code>1 PGSIZE</code>：用户栈，可以增长</li>
<li><code>一段留空内存</code></li>
<li><code>0x00800000</code>以上：用户的堆区域和程序数据</li>
<li>以下：用户的符号表区域和空内存</li>
</ul>
<h4 id="Definitions-guide"><a href="#Definitions-guide" class="headerlink" title="Definitions guide"></a>Definitions guide</h4><p>6.828的代码充满了缩写这种使人不明所以的命名,且有些地方码风诡异,因而将一些可能用到的概念和缩写列举如下:</p>
<ol>
<li><code>V</code>和<code>P</code>:带V的标识符指<code>virtual</code>,与内核虚拟内存有关；而带P的标识符往往指<code>physical</code>,与物理存储有关。如：<ul>
<li><code>kva</code>:<code>kernel virtual address</code>的简写</li>
<li><code>pa</code>:<code>physical address</code>的简写</li>
<li><code>la</code>:<code>linear address</code>的简写</li>
</ul>
</li>
<li><code>PT</code>和<code>PD</code>：分别指<code>page table</code>和<code>page directory</code>。</li>
<li><code>U</code>和<code>K</code>:带U的标识符指<code>User</code>，而带K的标识符指<code>Kernel</code>。如：<ul>
<li><code>UVPT</code>：<code>User virtual page table</code>的缩写，是用户页表的开始地址。</li>
<li><code>UTOP</code>：用户地址空间的上限</li>
</ul>
</li>
</ol>
<p>为了实现目标功能的代码，我们需要调用许多定义好的函数或者宏，为了方便查看和使用将一些可能需要使用的函数和宏列举如下：</p>
<ul>
<li><code>pmap.h</code>:<ul>
<li><code>PADDR(addr)</code>:将虚拟地址addr转换为物理地址返回</li>
<li><code>KADDR(addr)</code>:将物理地址addr转换为虚拟地址返回</li>
<li><code>PTE_ADDR(addr)</code>:将物理地址addr中的权限位去掉</li>
<li><code>page2pa(PageInfo*)</code>:将PageInfo结构体转换为对应Page的物理地址</li>
<li><code>pa2page(addr)</code>:将物理地址转换为pages数组中的PageInfo</li>
<li><code>page2kva(PageInfo*)</code>:将PageInfo结构体转换为对应Page的虚拟地址</li>
</ul>
</li>
<li><code>mmu.h</code>:<ul>
<li><code>PDX(la)</code>:将线性地址转换为页目录(page directory)的索引</li>
<li><code>PTX(la)</code>:将线性地址转换为页表的索引</li>
</ul>
</li>
</ul>
<h4 id="Part-1-Physical-page-management"><a href="#Part-1-Physical-page-management" class="headerlink" title="Part 1 Physical page management"></a>Part 1 Physical page management</h4><p>在这个部分我们需要实现物理内存管理器。这个函数追踪一个由<code>PageInfo</code>结构体组成的链表(这个链表的节点代表着一页未分配的内存)，并负责物理内存的分配和回收。</p>
<p>要想完成这部分的任务，必须要提前了解虚拟内存系统的概念(可以参考操作系统专业教材或者计算机系统教材)，才能看懂并运用各种神奇的操作。</p>
<blockquote>
<p><strong>boot_alloc</strong></p>
</blockquote>
<p>这个函数是在建立虚拟内存系统过程中用来为数据结构分配内存空间的，在虚拟内存系统建立之后就会废弃。因而，其功能比较简单。</p>
<p>值得注意的是，这个函数首次调用的时候，会从内核区bss段的结束处开始分配内存块，具体的位置是通过<code>extern</code>从链接器那里得知的。首次调用情况下的代码已经被完成了，我们只需要照葫芦画瓢地完成之后调用时的代码即可。</p>
<p>这里所谓“内核区bss段的结束处”是指内核区中没有分配代码段和数据段的第一个位置，它在虚拟地址空间中的位置在<code>0xf0000000</code>以上的部分，也就是物理内存的映射区。从这里开始，我们开始建立用于管理虚拟内存的内核数据结构。</p>
<ul>
<li><em>panic函数可以被当作printf的一个能够引发中断的版本。灵活利用它可以方便地调试系统。</em></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a chunk large enough to hold 'n' bytes, then update</span></span><br><span class="line">	<span class="comment">// nextfree.  Make sure nextfree is kept aligned</span></span><br><span class="line">	<span class="comment">// to a multiple of PGSIZE.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// LAB 2: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!n)	<span class="keyword">return</span> nextfree;</span><br><span class="line">	result = nextfree;</span><br><span class="line">	nextfree = ROUNDUP((<span class="keyword">char</span> *) (nextfree+n), PGSIZE);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>mem_init</strong></p>
</blockquote>
<p>这个函数首先用之前实现好的<code>boot_alloc</code>函数分配了 <strong>一页</strong> 空闲内存，初始化之，并用一个<code>kern_pgdir</code>指针指向了这片内存的起始位置。这一片区域用来存放<code>page directory</code>。</p>
<p>接下来是我们的工作：为一个页数组<code>pages</code>分配内存。</p>
<p><code>pages</code>数组存储了每个分页的信息，其索引和页的物理地址可以用函数相互转换。可以说，<code>pages</code>的每一个元素都唯一对应着一个物理页面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pages = (struct PageInfo *) boot_alloc(<span class="keyword">sizeof</span>(struct PageInfo) * npages);</span><br><span class="line"><span class="built_in">memset</span>(pages, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct PageInfo) * npages);</span><br></pre></td></tr></table></figure>
<p>这样我们就已经为内存分配相关的内核数据结构分配好了空间。接下来，<code>mem_init</code>函数调用<code>page_init</code>函数，去初始化所有物理内存分页。这个步骤结束之后，所有内存相关操作都可以通过<code>page</code>开头的函数来完成。</p>
<blockquote>
<p><strong>page_init</strong></p>
</blockquote>
<p>Lab中已经给出了示例代码，但是这段代码是不严谨的(它将所有物理内存页都标记为是free的)，有几处问题没有考虑到：</p>
<ul>
<li><strong>物理页面0应该标记为used</strong>。这是因为这一部分保存着BIOS数据结构和IDT(中断描述符表)，我们以后可能会用到这些结构。</li>
<li>之前讲到过的由于考虑到向后兼容性而留下的<code>IO hole</code>不应该被分配。</li>
<li>在<code>IO hole</code>之后就是extended memory部分，这一部分中的有些位置存放了内核代码和内核数据结构，因而这些位置不能标记为free。</li>
</ul>
<p>我们的任务是修改代码，使其只将那些该标记为free的放进<code>page_free_list</code>。</p>
<p>考察<code>memlayout.h</code>中的<code>PageInfo</code>结构体，可以发现其属性<code>pp_ref</code>用于指示引用这一页的进程数量,而<code>pp_link</code>指向空闲链表中下一项的地址。对于要放入<code>page_free_list</code>的pages，我们将其<code>pp_ref</code>设定为0，并利用<code>pp_link</code>将其插入空闲链表。</p>
<p><strong>本任务的难点在于如何确定Extended Memory中的哪一部分已经被Kernel所占用</strong>。观察之前的代码可以发现，<code>boot_alloc</code>是从kernel代码和数据段的结束位置开始分配内存的，而kernel代码段的起始位置是<code>IO hole</code>的结束位置(<code>0x100000</code>,参考Lab 1)，这意味着从<code>IO hole</code>到<code>boot_alloc</code>分配的最后一块内存末尾之间的所有内存都是被占用的。</p>
<p>而根据之前的两个函数，<code>boot_alloc</code>分配的最后一块内存应该就是页表的最后一块内存(也就是<code>pages</code>数组的末尾)，因此我们从<code>pages</code>的头地址开始向后应该就可以找到kernel占用内存区的末尾位置。</p>
<p>根据这些信息，可以修改代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">size_t</span> i;</span><br><span class="line">	<span class="comment">// 1) First page, ignore it</span></span><br><span class="line">	<span class="comment">// 2) Base memory</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; npages_basemem; i++) &#123;</span><br><span class="line">		pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">		pages[i].pp_link = page_free_list;</span><br><span class="line">		page_free_list = &amp;pages[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3) IO hole</span></span><br><span class="line">	<span class="comment">// Mention that npages_basemem = IOPHYSMEM / PGSIZE</span></span><br><span class="line">	<span class="comment">// IOPHYSMEM and EXTPHYSMEM is represented by B instead of KB, so div it by PGSIZE.</span></span><br><span class="line">	<span class="comment">// (Here is no operation, because we do not need to deal with occupied pages.)</span></span><br><span class="line">	;</span><br><span class="line">	<span class="comment">// 4) Extended memory</span></span><br><span class="line">	<span class="comment">// The question is where is the end of kernel segment.</span></span><br><span class="line">	<span class="keyword">char</span>* end_addr = (<span class="keyword">char</span> *)envs + <span class="keyword">sizeof</span>(struct Env) * NENV - KERNBASE;</span><br><span class="line">	<span class="keyword">int</span> end_index = (<span class="keyword">int</span>)(ROUNDUP(end_addr, PGSIZE)) / PGSIZE;</span><br><span class="line">	<span class="keyword">for</span> (i = end_index; i &lt; npages; i++) &#123;</span><br><span class="line">		pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">		pages[i].pp_link = page_free_list;</span><br><span class="line">		page_free_list = &amp;pages[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>page_alloc</strong></p>
</blockquote>
<p>这个函数就是很简单的链表操作，仔细阅读注释的内容即可正确实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *</span></span><br><span class="line"><span class="class"><span class="title">page_alloc</span>(<span class="title">int</span> <span class="title">alloc_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Returns NULL if out of free memory</span></span><br><span class="line">	<span class="keyword">if</span> (page_free_list == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// Get a free page from page_free_list</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">free_page</span> = <span class="title">page_free_list</span>;</span></span><br><span class="line">	page_free_list = free_page-&gt;pp_link;</span><br><span class="line">	<span class="comment">// Init the free page</span></span><br><span class="line">	free_page-&gt;pp_link = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (alloc_flags &amp; ALLOC_ZERO)</span><br><span class="line">		<span class="built_in">memset</span>(page2kva(free_page), <span class="number">0</span>, PGSIZE);</span><br><span class="line">	<span class="comment">// Return the free page to caller</span></span><br><span class="line">	<span class="keyword">return</span> free_page;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>page_free</strong></p>
</blockquote>
<p>同样没有什么难度，直接贴出代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_free(struct PageInfo *pp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></span><br><span class="line">	<span class="comment">// pp-&gt;pp_link is not NULL.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pp-&gt;pp_ref) panic(<span class="string">"This page is still occupied by other processes."</span>);</span><br><span class="line">	<span class="keyword">if</span> (pp-&gt;pp_link) panic(<span class="string">"You can't free a freed page."</span>);</span><br><span class="line">	pp-&gt;pp_link = page_free_list;</span><br><span class="line">	page_free_list = pp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Part-2-Virtual-Memory"><a href="#Part-2-Virtual-Memory" class="headerlink" title="Part 2 Virtual Memory"></a>Part 2 Virtual Memory</h4><p>在开始这一部分之前，先要对几个地址之间的转换有一个大概的了解。</p>
<h5 id="Segments"><a href="#Segments" class="headerlink" title="Segments"></a>Segments</h5><p>在保护模式下，有关<span id="segments">段</span>的信息是非常复杂的。对于一个段来说，除了段基地址之外，还有段的大小，特权级，类型，是否被执行过，读写权限等等多种信息要保存。用于描述这些信息的数据项称为 <strong>描述符(Descirptor)</strong> 。</p>
<p>描述符一般用<code>4个字</code>来表述所有信息，具体的描述符结构如下图所示：</p>
<p><img src="descriptor.png" alt="descriptor"></p>
<p>其中各个部分的作用：</p>
<ul>
<li>第一个字：<strong>段的界限</strong>，也就是这个段的长度。需要注意的是一个段的长度是用20位来表示的，因此这个字表示的段界限是不完整的，需要和描述符中另一段数据拼接起来才是完整的段界限。</li>
<li>第二个字：<strong>段的基址</strong>，段在虚拟地址空间内的起始位置。由于虚拟空间地址是32位的，这个字同样无法表示完整的段基址，需要与另外两段数据进行拼接。</li>
<li>第三个字：<ul>
<li>高字节分为如下几个字段：<ul>
<li><code>P</code>：<strong>存在位</strong>，表示该描述符对应的段是否已经读入内存。</li>
<li><code>DPL</code>：长度为两位，表示该段所属的特权级</li>
<li><code>1</code>或<code>0</code>：记录段的类型是存储段还是系统段</li>
<li><code>TYPE</code>：记录段的属性<ul>
<li>如果是存储段，那么是代码段还是数据段</li>
<li>段的读写权限如何</li>
</ul>
</li>
<li><code>A</code>：访问位，记录段是否被访问过</li>
</ul>
</li>
<li>低字节为段基址的16-23位。</li>
</ul>
</li>
<li>第四个字：<ul>
<li>高字节为段基址的24-31位。</li>
<li>低字节分为如下几个字段：<ul>
<li><code>G</code>：<strong>粒度位</strong>，G=0说明段长度的单位是<code>Byte</code>，而G=1说明单位是<code>page</code>。</li>
<li><code>X</code>：用于区分32位和16位访问方式。</li>
<li><code>O</code>和<code>AVL</code>：保留位和系统专用位</li>
<li><code>LIMIT</code>：段界限的16-19位</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>所有的描述符都储存在 <strong>描述符表</strong> 中。描述符表分为以下三类：</p>
<ul>
<li><code>LDT</code>：局部描述符表。每个进程都有它自己的局部描述符表，存放在一个特定的系统段内。LDT中存放着对应进程的代码和数据段位置等信息。</li>
<li><code>GDT</code>：全局描述符表。只有一个，存放着操作系统内核使用的描述符和所有系统段的描述符。通过GDT可以去索引所有的LDT。</li>
<li><code>IDT</code>：中断描述符表。用于定位所有的中断处理程序。</li>
</ul>
<p>用于索引描述符表的字段称为<strong>Selector</strong>，<code>cs</code>等段寄存器所存放的就是Selector。它由三部分组成：</p>
<ul>
<li>最低2位：决定这个段的<strong>特权级</strong></li>
<li>第三位：决定这个段的位置(0代表在<code>GDT</code>，1代表在<code>LDT</code>)</li>
<li>4-16位：这个段在描述符表中的<strong>索引</strong></li>
</ul>
<p>在这个Lab中，我们暂时不涉及内存的分段机制，因而GDT中每个描述符的base为0而limit为0xffffffff。在kernel代码段中我们已经建立了一个简单的页表(能够映射4MB大小的内存),现在我们需要做的是拓展这个页表以映射整个虚拟内存。</p>
<h5 id="Pages"><a href="#Pages" class="headerlink" title="Pages"></a>Pages</h5><p>在Background knowledge里面我们已经讲了线性地址的构成，现在为了能够完成下面的实验，需要进一步了解一些关于页目录和页表的知识。</p>
<p>在MMU取到一个线性地址la时，它会首先取出la中的 <strong>页目录索引部分</strong> ，并用其与<code>cr3</code>中存放的页目录首地址结合去找到la所在的 <strong>页表首地址</strong> 。在此之后，MMU取出la中的 <strong>页表索引部分</strong> ，与之前找到的页表首地址结合来找到la所对应的具体 <strong>页表项</strong> 。</p>
<p>在这个过程中，la所在的页目录表项被称为 <strong>DIR entry</strong> ，而它所在的页表表项被称为 <strong>Page table entry</strong>。Directory entry中存放的物理地址与la的页表索引部分的结合是Page table entry的地址，而page table entry中存放的物理地址与la的偏移部分的结合是la所对应物理页的地址。</p>
<p>每个PDE或者PTE的内容都是<code>phyaddr</code>和 <strong>权限位</strong> 的组合。因为PDE和PTE的内容都指向一个物理页的首地址，它们的最后12位是用不到的。这12位被内存管理系统用作权限位，每一位都代表一个特定的权限，管理系统通过将这些位置0或置1来设定这一页的权限。</p>
<h5 id="Addresses"><a href="#Addresses" class="headerlink" title="Addresses"></a>Addresses</h5><blockquote>
<p><strong>Exercise 3</strong></p>
<p>你可以在<code>qemu-gdb</code>中键入<code>ctrl-a c</code>来进入qemu的monitor。在这里，你可以用<code>xp</code>命令来查询指定物理地址的数据(<code>xp</code>指令的用法与gdb的<code>x</code>指令类似)。与此同时，在<code>gdb</code>中用<code>x</code>指令可以查询指定虚拟地址的数据。将存在映射关系的虚拟地址与物理地址存放的内容作对比，看看是否是一致的。</p>
</blockquote>
<p>JOS的源代码定义了<code>uintptr_t</code>来存放虚拟地址，而<code>physaddr_t</code>用来存放物理地址。</p>
<blockquote>
<p><strong>Question</strong></p>
<p>Q:如果下面的代码是正确的,变量x的类型应当是uintptr_t还是physaddr_t?</p>
<p>A:uintptr_t,因为C中的指针都是指向虚拟地址的.</p>
</blockquote>
<p>JOS内核有时需要读取或修改只知道物理地址的内存。例如，向页表添加映射可能需要分配物理内存来存储页目录，然后初始化该内存。但是，内核不能绕过虚拟地址转换，因此不能直接修改物理地址。这就是为什么我们要把物理内存用一个线性函数映射到虚拟内存中<code>0xf0000000</code>以上的区域:这方便了内核直接操作物理内存。<code>PADDR</code>和<code>KADDR</code>两个宏定义让我们可以很方便地实现物理地址和虚拟地址之间的转换。</p>
<h5 id="page-management"><a href="#page-management" class="headerlink" title="page management"></a>page management</h5><p>我们知道，同一个物理页面可能会被映射到数个不同虚拟空间的数个虚拟页面，我们通过修改<code>PageInfo</code>结构体中的<code>pp_ref</code>属性来反映这一点。每当我们分配一个UTOP以下的页面，我们让该物理页面的<code>pp_ref</code>属性+1。(UTOP以上的页面属于内核，它们永远不应该被free，因而无需更改这个属性)</p>
<p>需要注意的是，我们在实现<code>page_alloc</code>函数时并没有让它去增加<code>pp_ref</code>属性值，因此调用<code>page_alloc</code>的函数需要 <strong>自行增加这个属性的值</strong> 。</p>
<blockquote>
<p><strong>pgdir_walk</strong></p>
</blockquote>
<p>这个函数接受一个线性地址和一个页目录，返回线性地址对应的页面所在页表的物理地址。为了达成这个目的，我们可以通过线性地址中的页目录索引部分去找到页目录中的对应页表地址。如果这个页表还没有被创建，且create参数为真，那就创建一个新的页表并返回它的物理地址。</p>
<p>根据函数前面的注释，<strong>MMU会同时检查页目录表项和页表表项中的权限位</strong>，因而我们对于页目录中新页表物理地址的权限可以把要求放宽松一点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pte_t</span> *</span><br><span class="line">pgdir_walk(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">int</span> create)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find the page table where va locates.</span></span><br><span class="line">	<span class="keyword">physaddr_t</span> pgtab = pgdir[PDX(va)];</span><br><span class="line">	<span class="keyword">if</span> (!pgtab) &#123;</span><br><span class="line">		<span class="keyword">if</span> (create) &#123;</span><br><span class="line">			<span class="comment">// Allocate a new page table.</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">new_pt</span> = <span class="title">page_alloc</span>(<span class="title">ALLOC_ZERO</span>);</span></span><br><span class="line">			<span class="keyword">if</span> (new_pt == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				new_pt-&gt;pp_ref++;</span><br><span class="line">				<span class="comment">// Leave permissions of pt more permissive</span></span><br><span class="line">				<span class="comment">// We allow users to read this page</span></span><br><span class="line">				pgdir[PDX(va)] = page2pa(new_pt) | PTE_P | PTE_U | PTE_W;</span><br><span class="line">				<span class="keyword">return</span> KADDR(PTE_ADDR(pgdir[PDX(va)])+PTX(va)*<span class="keyword">sizeof</span>(<span class="keyword">pte_t</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// We need to return the address of page table **entry**</span></span><br><span class="line">		<span class="comment">// PTE_ADDR: get rid of the permission bits in `pgtab`</span></span><br><span class="line">		<span class="comment">// PTX(va)*sizeof(pte_t): find the 'PTX(va)'th element in a `pte_t` array.</span></span><br><span class="line">		<span class="keyword">return</span> KADDR(PTE_ADDR(pgtab)+PTX(va)*<span class="keyword">sizeof</span>(<span class="keyword">pte_t</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>boot_map_region</strong></p>
</blockquote>
<p>这个函数将一段指定的虚拟地址映射到同样长度的指定的物理地址。因为映射以页为单位，我们可以依次映射这段地址中的每一页：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">boot_map_region(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> va, <span class="keyword">size_t</span> size, <span class="keyword">physaddr_t</span> pa, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> page_num = size / PGSIZE;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; page_num; i++) &#123;</span><br><span class="line">		<span class="keyword">pte_t</span>* pgtab = pgdir_walk(pgdir,(<span class="keyword">void</span>*)(va+i*PGSIZE),<span class="number">1</span>);</span><br><span class="line">		*pgtab = (pa+i*PGSIZE) | perm | PTE_P;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>page_lookup</strong></p>
</blockquote>
<p>这个函数寻找va在pgdir中的页表地址和物理地址。依照注释完成,没有多大难度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *</span></span><br><span class="line"><span class="class"><span class="title">page_lookup</span>(<span class="title">pde_t</span> *<span class="title">pgdir</span>, <span class="title">void</span> *<span class="title">va</span>, <span class="title">pte_t</span> **<span class="title">pte_store</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">pte_t</span>* pgtab = pgdir_walk(pgdir, va, <span class="number">0</span>); <span class="comment">// Page table address</span></span><br><span class="line">	<span class="keyword">if</span> (pgtab == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (pte_store != <span class="literal">NULL</span>)</span><br><span class="line">			*pte_store = pgtab;</span><br><span class="line">		<span class="keyword">return</span> pa2page(PTE_ADDR(*pgtab));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>page_remove</strong></p>
</blockquote>
<p>这个函数移除va指定的页。基本上都是在调用函数，只要认真阅读了注释即很简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_remove(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">pte_t</span> *pg_pte;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pgtab</span> = <span class="title">page_lookup</span>(<span class="title">pgdir</span>, <span class="title">va</span>, &amp;<span class="title">pg_pte</span>);</span></span><br><span class="line">	<span class="keyword">if</span> (!pgtab) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// This function frees the page automatically if refcount reaches 0.</span></span><br><span class="line">	page_decref(pgtab);</span><br><span class="line">	*pg_pte = <span class="number">0</span>;</span><br><span class="line">	tlb_invalidate(pgdir, va);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>page_insert</strong></p>
</blockquote>
<p>这个函数将虚拟地址va所对应的页设定为pp。这个函数的一个很容易出错的边界条件是将一个 <strong>原本空闲的</strong> page <strong>连续插入两次</strong> ，按正常的逻辑第二次插入应该不会有任何影响，但实现不当的话会出现问题。</p>
<p>如果先进行<code>page_remove</code>再增加引用数的话，首先在调用<code>page_remove</code>的时候这个page已经进入了<code>page_free_list</code>，但接下来我们接着又要用到这个page且没有经过<code>page_alloc</code>，这样一来这个page既在空闲链表中引用数又不为0，会成为一个bug。</p>
<p>根据注释的提示，有一种优雅的无需条件判断的方式可以解决这个问题。这种方式就是 <strong>将增加引用数的步骤提前</strong> ，这样这个页面在<code>page_remove</code>之前引用数就是2，就不会在<code>page_remove</code>中被回收到<code>page_free_list</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">page_insert(<span class="keyword">pde_t</span> *pgdir, struct PageInfo *pp, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">pte_t</span>* pgtab = pgdir_walk(pgdir, va, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (pgtab == <span class="literal">NULL</span>) <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	pp-&gt;pp_ref++;</span><br><span class="line">	<span class="keyword">if</span> (*pgtab &amp; PTE_P)</span><br><span class="line">		page_remove(pgdir, va);</span><br><span class="line">	*pgtab = page2pa(pp) | perm | PTE_P;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Part-3-Kernel-address-space"><a href="#Part-3-Kernel-address-space" class="headerlink" title="Part 3 Kernel address space"></a>Part 3 Kernel address space</h4><p>JOS的地址空间被<code>ULIM</code>划分为两个部分：<strong>用户地址空间</strong> 和 <strong>内核地址空间</strong> 。后者大概拥有256MB的剩余空间可以使用。</p>
<p>由于用户区和内核区同在一个地址空间内，我们需要使用页表管理中的 <strong>权限位</strong> 来保证用户只能访问用户区的页。</p>
<ul>
<li>常用的权限位：<ul>
<li><code>PTE_P</code>: 页面存在</li>
<li><code>PTE_W</code>: 该页是可写的</li>
<li><code>PTE_U</code>: 该页可以由用户访问</li>
</ul>
</li>
</ul>
<p>用户不应有访问任何<code>ULIM</code>以上内存的权限,而内核应当能读写这一块区域。在<code>UTOP</code>和<code>ULIM</code>之间的区域是 <strong>只读区</strong>(对用户和内核都是) 。低于<code>UTOP</code>的内存区域权限由用户自行设置。</p>
<h5 id="Initializing-the-Kernel-Address-Space"><a href="#Initializing-the-Kernel-Address-Space" class="headerlink" title="Initializing the Kernel Address Space"></a>Initializing the Kernel Address Space</h5><blockquote>
<p><strong>Exercise 5</strong></p>
</blockquote>
<p>这个任务要求我们补全<code>mem_init</code>函数。</p>
<p>第一段要求我们把整个<code>pages</code>数组映射到<code>UPAGE</code>地址以上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cautious: we map the phyaddr of pages instead of their content</span></span><br><span class="line"><span class="comment">// So we use PADDR here, not page2pa.</span></span><br><span class="line">boot_map_region(kern_pgdir, UPAGES, npages*<span class="keyword">sizeof</span>(struct PageInfo), PADDR(pages), PTE_U);</span><br></pre></td></tr></table></figure>
<p>第二段要求我们把内核栈映射到<code>KSTACKTOP-KSTKSIZE</code>到<code>KSTACKTOP</code>区域。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boot_map_region(kern_pgdir, (KSTACKTOP-KSTKSIZE), KSTKSIZE, PADDR(bootstack), PTE_P | PTE_W);</span><br></pre></td></tr></table></figure>
<p>第三段要求我们映射整个内核区域。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> kern_size = (<span class="keyword">unsigned</span>)~<span class="number">0</span> - KERNBASE;</span><br><span class="line">boot_map_region(kern_pgdir, KERNBASE, kern_size, <span class="number">0</span>, PTE_P | PTE_W);</span><br></pre></td></tr></table></figure>
<p>三段都是看着注释调函数即可，没有很大难度。不得不说6.828的注释仔细研究可以省去很多精力。</p>
<blockquote>
<p><strong>Questions</strong></p>
<p>Q：在这个过程中哪些PDE被填入了信息？它们对应哪些线性地址，又指向哪些物理地址？</p>
<p>A：被填入的PDE索引：</p>
<ul>
<li>956-UPAGES，线性地址0xef000000,指向pages数组在物理内存中的首地址</li>
<li>957-UVPT，线性地址0xef400000,指向kern_pgdir在物理内存中的地址</li>
<li>959-KSTACK，线性地址0xefc00000,指向bootstack数组在物理内存中的首地址</li>
<li>960～1023-内核内存区，线性地址0xf0000000以上，指向物理内存地址0。</li>
</ul>
<p>Q：既然我们把用户和内核的内存区域放在同一个地址空间中，到底是什么机制保护了内核内存不能被用户访问？</p>
<p>A：权限位<code>PTE_U</code>决定了一页能否被用户访问。</p>
<p>Q：这个操作系统能够支持多大的物理内存？为什么？</p>
<p>A：内存空间内能存放pages的空间是一个PTSIZE，也就是最多能够映射PTSIZE/sizeof(struct PageInfo)个页面，每页大小为4KB，因此总共能映射的物理内存大小为2GB。</p>
<p>Q：如果我们拥有能支持的最大的物理内存，管理这些内存需要多少空间开销？如何减少这些开销？</p>
<p>A：管理满载的512K个页面需要512个页表，每个页表占内存空间都是一个PGSIZE，总共就会有4MB左右内存用于页表储存。加上用于存放pages的4MB和页目录的4KB，总共会有8MB左右空间开销。如果把PGSIZE取大一点，这种开销就可以稍微减小。</p>
<p>Q：在我们刚打开分页机制的时候，程序还运行在低地址，控制流在什么时候跳转到KERNBASE以上？为什么在打开分页机制之后我们仍能够运行在一个低地址？</p>
<p>A：在打开分页的下一步，控制流就用jmp指令跳转到了KERNBASE以上的高地址。打开分页机制后仍能在低地址运行的原因是低地址和KERNBASE以上的高地址都被映射到同一片物理内存，这是为了保持兼容性。</p>
</blockquote>
<p>完成上面的所有代码之后，运行<code>make grade</code>，<code>70/70</code>大成功。</p>
<blockquote>
<p><strong>Challenge</strong></p>
</blockquote>
<p>这个挑战的内容主要是为JOS的monitor加入一些实用的指令，以方便之后的调试过程，具体的指令细节可以自己调整和定制。增加指令后，要记得在<code>monitor.h</code>中添加声明。</p>
<p>我主要做了以下几条指令(下面是修改后的Commands数组)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>pageinfo</strong></li>
</ol>
<p>这个指令接受一个命令行参数。</p>
<p><code>pageinfo addr</code>：打印出虚拟地址addr所在的页目录，页表，以及所在的物理页面，物理地址。</p>
<p>如果addr使用十六进制地址，必须在数字前面加上<code>0x</code>。</p>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Must include pmap.h in monitor.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;kern/pmap.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_pageinfo(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cannot declare vars in switch-case statement.</span></span><br><span class="line">    <span class="keyword">physaddr_t</span> addr;</span><br><span class="line">    <span class="keyword">pte_t</span>* pte;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (argc) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            cprintf(<span class="string">"Error: too few arguments.\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            addr = str2int(argv[<span class="number">1</span>]);</span><br><span class="line">            pte = pgdir_walk(kern_pgdir, (<span class="keyword">void</span> *)addr, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!pte) &#123;</span><br><span class="line">                cprintf(<span class="string">"This address has not been mapped yet.\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!(*pte &amp; PTE_P)) &#123;</span><br><span class="line">                cprintf(<span class="string">"Exception: Page does not exist.\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cprintf(<span class="string">"Mapping information of address %x:\n"</span>, addr);</span><br><span class="line">            cprintf(<span class="string">"  Page directory entry: %d\n"</span>, PDX(addr));</span><br><span class="line">            cprintf(<span class="string">"  Page table entry: %d\n"</span>, PTX(addr));</span><br><span class="line">            cprintf(<span class="string">"  Page physical address: %x\n"</span>, PTE_ADDR(*pte));</span><br><span class="line">            cprintf(<span class="string">"  Physical address: %x\n"</span>, PTE_ADDR(*pte) + PGOFF(addr));</span><br><span class="line">            cprintf(<span class="string">"  Page permission:\n"</span>);</span><br><span class="line">            <span class="keyword">if</span> ((*pte &amp; PTE_U) &amp;&amp; (*pte &amp; PTE_W)) &#123;</span><br><span class="line">                cprintf(<span class="string">"    Readable and writeable by user and kernel\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((*pte &amp; PTE_U)) &#123;</span><br><span class="line">                cprintf(<span class="string">"    Readable by user and kernel\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((*pte &amp; PTE_W)) &#123;</span><br><span class="line">                cprintf(<span class="string">"    Readable and writeable by kernel\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cprintf(<span class="string">"    Readable by kernel\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cprintf(<span class="string">"Error: too many arguments.\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">str2int(<span class="keyword">char</span>* str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">'0'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(++str) != <span class="string">'x'</span>)</span><br><span class="line">            base = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            base = <span class="number">16</span>;</span><br><span class="line">            str++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> (base == <span class="number">10</span> || base == <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">while</span> (*str) &#123;</span><br><span class="line">            num = num * base + *str - <span class="string">'0'</span>;</span><br><span class="line">            str++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">while</span> (*str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*str &gt;= <span class="string">'a'</span> &amp;&amp; *str &lt;= <span class="string">'f'</span>)</span><br><span class="line">            num = num * base + *str - <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*str &gt;= <span class="string">'A'</span> &amp;&amp; *str &lt;= <span class="string">'F'</span>)</span><br><span class="line">            num = num * base + *str - <span class="string">'A'</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            num = num * base + *str - <span class="string">'0'</span>;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>chperm</strong></li>
</ol>
<p>这个指令接受三个命令行参数。</p>
<p><code>chperm &lt;PDX&gt; &lt;PTX&gt; &lt;perm&gt;</code>：修改<code>&lt;PDX&gt;</code>和<code>&lt;PTX&gt;</code>对应页面的权限。</p>
<p><code>&lt;perm&gt;</code>的使用方法：</p>
<ul>
<li><code>+</code>：增加一种权限</li>
<li><code>-</code>：消除一种权限</li>
<li><code>w</code>：对应于<code>PTE_W</code></li>
<li><code>u</code>：对应于<code>PTE_U</code></li>
<li><code>p</code>：对应于<code>PTE_P</code></li>
</ul>
<p>使用样例：<code>chperm 960 256 -w</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Change the permittions of a certain page.</span></span><br><span class="line"><span class="comment">// chperm &lt;PDX&gt; &lt;PTX&gt; &lt;perm&gt;</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_chperm(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pdx, ptx, perm = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>* ptr;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">// 0 represents '-', 1 represents '+'</span></span><br><span class="line">    <span class="keyword">pte_t</span>* pgaddr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (argc) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"></span><br><span class="line">            pdx = str2int(argv[<span class="number">1</span>]);</span><br><span class="line">            ptx = str2int(argv[<span class="number">2</span>]);</span><br><span class="line">            ptr = argv[<span class="number">3</span>];</span><br><span class="line">            pgaddr = pgdir_walk(kern_pgdir, (<span class="keyword">void</span> *)(PGADDR(pdx,ptx,<span class="number">0</span>)), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (*ptr) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>: flag = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>: flag = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    cprintf(<span class="string">"Error: Illegal operation \'%c\'.\n"</span>, *ptr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (*(ptr+<span class="number">1</span>))   &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'w'</span>:</span><br><span class="line">                    <span class="keyword">if</span> (flag) *pgaddr = *pgaddr | PTE_W;</span><br><span class="line">                    <span class="keyword">else</span> *pgaddr = *pgaddr &amp; (~PTE_W);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">                    <span class="keyword">if</span> (flag) *pgaddr = *pgaddr | PTE_U;</span><br><span class="line">                    <span class="keyword">else</span> *pgaddr = *pgaddr &amp; (~PTE_U);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'p'</span>:</span><br><span class="line">                    <span class="keyword">if</span> (flag) *pgaddr = *pgaddr | PTE_P;</span><br><span class="line">                    <span class="keyword">else</span> *pgaddr = *pgaddr &amp; (~PTE_P);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    cprintf(<span class="string">"Error: Illegal operation \'%c\'.\n"</span>, *(ptr+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cprintf(<span class="string">"Error: bad usage.\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>man</strong></li>
</ol>
<p>虽然命名为man，但是其实这个命令的行为更像<code>--help</code>。</p>
<p>需要注意的是，每增加一条新的命令就要增加<code>command_usage</code>数组的内容。并且，这个数组中的元素顺序必须与<code>commands</code>数组中的顺序一致。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* command_usage[] = &#123;</span><br><span class="line">    <span class="string">"help\nDisplay the list of commands"</span>,</span><br><span class="line">    <span class="string">"exit\nLeave the monitor and shutdown"</span>,</span><br><span class="line">    <span class="string">"kerninfo\nDisplay information about the kernel"</span>,</span><br><span class="line">    <span class="string">"backtrace\nDisplay the structure of the stack"</span>,</span><br><span class="line">    <span class="string">"pageinfo &lt;addr&gt;\nDisplay the information of the page virtual address &lt;addr&gt; locates"</span>,</span><br><span class="line">    <span class="string">"chperm &lt;PDX&gt; &lt;PTX&gt; &lt;perm&gt;\nChange the permittion of the page with index &lt;PDX&gt; and &lt;PTX&gt;\n  \</span></span><br><span class="line"><span class="string">&lt;perm&gt; is the combination of a symbol('+' or '-') and a permittion code. \</span></span><br><span class="line"><span class="string">In particular, '+' is for permittion addition and '-' is for permittion erasure.\n\</span></span><br><span class="line"><span class="string">Possible permittion codes:\n  u: PTE_U\n  p: PTE_P\n  w: PTE_W\n"</span>,</span><br><span class="line">    <span class="string">"man\nDisplay the usage of a command"</span>,  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Display the usage of a command.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_man(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        cprintf(<span class="string">"Usage: man &lt;command&gt;\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE(commands); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], commands[i].name) == <span class="number">0</span>) &#123;</span><br><span class="line">            cprintf(<span class="string">"Usage: %s\n"</span>, command_usage[i]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">"Error: no such command.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这一章的最后还有几个挑战，一个是实现一种不同的分页机制使用户可以不受限制地使用整个4GB内存空间，由于并没有什么主流操作系统使用这种模式就没写。另一个是实现一个类似于<code>malloc/free</code>堆内存分配的分配机制，过于麻烦，等有空再写这个吧。</p>
<h4 id="Summarize"><a href="#Summarize" class="headerlink" title="Summarize"></a>Summarize</h4><p>总结一下JOS使用的内存管理机制：</p>
<p>目前整个操作系统由一个页目录——<strong>内核页目录</strong>(<code>kern_pgdir</code>)来维持，页目录的大小为一页，包括<em>1024</em>个条目。每个条目都是一个4字节的物理地址，指向对应的页表所在的物理内存地址。每个页表大小也是一页，同样包括<em>1024</em>个条目，每个条目指向对应的页所在的物理内存地址。</p>
<p>每个物理地址与一个线性地址唯一对应。线性地址的前10位和中间10位分别是这个地址所在物理页面的<strong>页目录索引</strong>和<strong>页表索引</strong>，最后12位代表这个地址在物理页面内的<strong>偏移量</strong>。</p>
<p>除此之外，内核还维护着一个<code>pages</code>数组。真正的page每个<strong>4KB</strong>，由整个物理地址空间平分；pages数组中的元素<code>PageInfo</code>大小<strong>8字节</strong>，记录着这个page的引用数和空闲链表中它的下一个元素的地址。<strong>pages数组中元素的索引可以线性地换算出对应page在物理内存中的首地址</strong>。</p>
<p><code>page_free_list</code>指针是空闲链表的头指针。它指向pages数组中第一个空闲的元素。空闲链表中的其他元素可以由<code>PageInfo</code>中的指针来索引。</p>
<p>这个内存管理机制被外界调用的接口函数有：</p>
<ul>
<li><code>page_alloc</code>：分配一块空闲的物理页，并将其对应的<code>PageInfo</code>结构体指针返回。注意调用者需要自行增加<code>pp_ref</code>的值。</li>
<li><code>page_free</code>：释放一块被占用的物理页。</li>
<li><code>page_insert</code>：将一块已分配的物理页与一个虚拟地址建立关系</li>
</ul>
<h3 id="Lab-3-User-Environments"><a href="#Lab-3-User-Environments" class="headerlink" title="Lab 3 User Environments"></a>Lab 3 User Environments</h3><p>在前两个Lab中，我们成功加载并运行了JOS内核，还建立了整个内核虚拟地址空间的内存映射，但这些都只是对内核的操作。在这个Lab里，我们要开始建立一个用户环境。换句话说，我们要建立一个用户进程，并使其受内核的监管。内核应当接受并处理所有用户进程发起的系统调用和引发的异常。</p>
<p>执行<code>git checkout -b lab3 origin/lab3</code>命令切换到lab3分支，执行<code>git merge lab2</code>合并在lab2所做的更改。这一步可能会出现conflict，解决之后重新commit即可。</p>
<p>Lab3增加的文件有：</p>
<table>
<thead>
<tr>
<th></th>
<th>文件名</th>
<th>文件功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>inc/</code></td>
<td><code>env.h</code></td>
<td>有关用户环境的一些声明和定义</td>
</tr>
<tr>
<td></td>
<td><code>trap.h</code></td>
<td>关于trap类异常处理的声明和定义(有关四种异常可以参考CSAPP第八章)</td>
</tr>
<tr>
<td></td>
<td><code>syscall.h</code></td>
<td>关于系统调用处理的声明和定义</td>
</tr>
<tr>
<td></td>
<td><code>lib.h</code></td>
<td>用户使用的系统库</td>
</tr>
<tr>
<td><code>kern/</code></td>
<td><code>env.h</code>/<code>env.c</code></td>
<td>内核维持用户环境所需要的声明和定义</td>
</tr>
<tr>
<td></td>
<td><code>trap.h</code>/<code>trap.c</code></td>
<td>内核对trap类异常的接受和处理</td>
</tr>
<tr>
<td></td>
<td><code>trapentry.S</code></td>
<td>汇编语言编写的trap异常处理程序入口</td>
</tr>
<tr>
<td></td>
<td><code>syscall.h</code>/<code>syscall.c</code></td>
<td>内核对系统调用的接受和处理</td>
</tr>
<tr>
<td><code>lib/</code></td>
<td><code>Makefrag</code></td>
<td>用来构建<code>obj/lib/libjos.a</code>的makefile</td>
</tr>
<tr>
<td></td>
<td><code>entry.S</code></td>
<td>汇编语言编写的用户进程入口</td>
</tr>
<tr>
<td></td>
<td><code>libmain.c</code></td>
<td><code>entry.S</code>调用的用于初始化用户环境的代码</td>
</tr>
<tr>
<td></td>
<td><code>syscall.c</code></td>
<td>用户环境的系统调用函数</td>
</tr>
<tr>
<td></td>
<td><code>console.c</code></td>
<td>用户模式下的 <code>putchar</code> 和 <code>getchar</code>实现, 用于提供console的I/O</td>
</tr>
<tr>
<td></td>
<td><code>exit.c</code></td>
<td>用户模式下的 <code>exit</code></td>
</tr>
<tr>
<td></td>
<td><code>panic.c</code></td>
<td>用户模式下的<code>panic</code></td>
</tr>
<tr>
<td><code>user/</code></td>
<td><code>*</code></td>
<td>测试程序</td>
</tr>
</tbody>
</table>
<p>除此之外，lab3更改了不少lab2中的文件。可以执行<code>git diff lab2</code>来查看具体的改动。</p>
<p>在这个Lab中，GCC提供的<strong>内联汇编</strong>特性非常有帮助。内联汇编的格式可以参考<a href="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html" target="_blank" rel="noopener">6.828提供的教程</a>，也可以参考<a href="https://dracit7.github.io/blog/2018/11/23/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/">中文的博客</a>。</p>
<h4 id="Part-A-User-Environments-and-Exception-Handling"><a href="#Part-A-User-Environments-and-Exception-Handling" class="headerlink" title="Part A User Environments and Exception Handling"></a>Part A User Environments and Exception Handling</h4><p><code>inc/env.h</code>包含着对<code>Env</code>结构的定义。<code>Env</code>结构类似于<code>PageInfo</code>结构，只不过后者储存的是页面的信息而前者储存的是用户环境的信息。内核利用这些结构来管理所有用户环境。在这个Lab中我们只需要实现一个用户环境，但我们也要完成管理多个用户环境的机制，以支持以后的Lab功能。</p>
<p>在<code>kern/inv.c</code>中定义有三个变量:</p>
<ul>
<li><code>struct Env *envs</code>：所有用户环境信息链表头指针</li>
<li><code>struct Env *curenv</code>：当前的用户环境</li>
<li><code>static struct Env *env_free_list</code>：空闲的用户环境链表头指针</li>
</ul>
<p>JOS系统最多能够支持<code>NENV</code>个用户环境，这个常量的定义在<code>inc/kern.h</code>中，默认的值是10。在初始化时，<code>envs</code>数组会被初始化为<code>NENV</code>长度的链表。</p>
<p><strong>注</strong>：在这个Lab中，<strong>用户环境和进程是指的同一个东西</strong>。</p>
<h5 id="Environment-State"><a href="#Environment-State" class="headerlink" title="Environment State"></a>Environment State</h5><p>我们可以分析一下<code>Env</code>结构的内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span>	<span class="comment">// Saved registers</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span>		<span class="comment">// Next free Env</span></span><br><span class="line">	<span class="keyword">envid_t</span> env_id;			<span class="comment">// Unique environment identifier</span></span><br><span class="line">	<span class="keyword">envid_t</span> env_parent_id;		<span class="comment">// env_id of this env's parent</span></span><br><span class="line">	<span class="keyword">enum</span> EnvType env_type;		<span class="comment">// Indicates special system environments</span></span><br><span class="line">	<span class="keyword">unsigned</span> env_status;		<span class="comment">// Status of the environment</span></span><br><span class="line">	<span class="keyword">uint32_t</span> env_runs;		<span class="comment">// Number of times environment has run</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Address space</span></span><br><span class="line">	<span class="keyword">pde_t</span> *env_pgdir;		<span class="comment">// Kernel virtual address of page dir</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>env_tf</code>：这是一个<code>Trapframe</code>结构体，它负责在这个用户环境挂起的时候<strong>保存其所有寄存器值</strong>。可以观察一下<code>Trapframe</code>结构体的<span id="trapframe">定义</span>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">	<span class="keyword">uint16_t</span> tf_es;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_padding1;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_ds;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_padding2;</span><br><span class="line">	<span class="keyword">uint32_t</span> tf_trapno;</span><br><span class="line">	<span class="comment">/* below here defined by x86 hardware */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> tf_err;</span><br><span class="line">	<span class="keyword">uintptr_t</span> tf_eip;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_cs;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_padding3;</span><br><span class="line">	<span class="keyword">uint32_t</span> tf_eflags;</span><br><span class="line">	<span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> tf_esp;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_ss;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_padding4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，所有x86的关键寄存器的值在这里都有保存(通用寄存器的值都保存在<code>PushRegs</code>结构内)。</p>
<ul>
<li><code>env_link</code>：指向空闲用户环境链表中的下一个元素</li>
<li><code>env_id</code>：内核用于<strong>唯一地标识</strong>这个用户环境的描述符，也就是进程的pid。当用户环境被回收时这个id也会被回收，也就是说id和这个<code>Env</code>在链表中的位置是无关的。</li>
<li><code>env_parent_id</code>：这个进程的父进程的id。</li>
<li><code>env_type</code>：用于区分进程的类型(用户进程还是系统服务进程)</li>
<li><p><code>env_status</code>：当前用户环境的状态</p>
<ul>
<li><code>ENV_FREE</code>：位于<code>env_free_list</code>中</li>
<li><code>ENV_RUNNABLE</code>：该进程可以运行，正在等待CPU的调度</li>
<li><code>ENV_RUNNING</code>：该进程正在CPU上运行</li>
<li><code>ENV_NOT_RUNNABLE</code>：该进程是活动的，但由于某些原因无法运行</li>
<li><code>ENV_DYING</code>：该进程目前是僵尸进程</li>
</ul>
</li>
<li><p><code>env_pgdir</code>：当前用户环境使用的页目录地址</p>
</li>
</ul>
<h5 id="Allocating-the-Environments-Array"><a href="#Allocating-the-Environments-Array" class="headerlink" title="Allocating the Environments Array"></a>Allocating the Environments Array</h5><blockquote>
<p><strong>Exercise 1</strong></p>
<p>你需要向<code>mem_init</code>函数中添加初始化<code>envs</code>数组的代码，就像之前初始化<code>pages</code>那样。此外，你还需要将初始化后的<code>envs</code>数组映射到<code>UENVS</code>地址以使用户能够查看它。</p>
</blockquote>
<p>由于有了之前初始化pages的经验，这里使用相同的方法可以轻松完成任务：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">envs = (struct Env *) boot_alloc(<span class="keyword">sizeof</span>(struct Env) * NENV);</span><br><span class="line"><span class="built_in">memset</span>(envs, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct Env) * NENV);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boot_map_region(kern_pgdir, UENVS, NENV*<span class="keyword">sizeof</span>(struct Env), PADDR(envs), PTE_U);</span><br></pre></td></tr></table></figure>
<p>运行后一看，为什么本来过了的<code>check_page_free_list()</code>失败了呢？百思不得其解，逆着逻辑流往前找，最终发现是因为之前在<code>page_init</code>函数中在计算内核空闲地址空间的起始位置时用到了<code>pages</code>，而现在我们在<code>pages</code>数组后面又分配了更多的空间给<code>envs</code>，原本空闲的内存变得不空闲了，但<code>page_init</code>的逻辑没有变，于是本来正确的函数出现了错误。改正方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// char* end_addr = (char *)pages + sizeof(struct PageInfo) * npages - KERNBASE;</span></span><br><span class="line"><span class="keyword">char</span>* end_addr = (<span class="keyword">char</span> *)envs + <span class="keyword">sizeof</span>(struct Env) * NENV - KERNBASE;</span><br></pre></td></tr></table></figure>
<h5 id="Creating-and-Running-Environments"><a href="#Creating-and-Running-Environments" class="headerlink" title="Creating and Running Environments"></a>Creating and Running Environments</h5><p>我们现在需要完善<code>kern/env.c</code>中的代码来运行一个用户环境。由于我们现在还没有构建文件系统，我们会让内核加载一个静态的二进制镜像(这个镜像是以ELF格式嵌在内核中的)。</p>
<p>Lab3的<code>GNUMakefile</code>在<code>obj/user</code>目录中生成了很多二进制镜像。<code>kern</code>目录中的<code>Makefrag</code>文件将它们利用linker的<code>-b</code>参数直接嵌入内核的可执行文件当中(不是以可重定位文件<code>.o</code>的形式，是将整个二进制文件原样嵌入)，内核可以在运行时索引并运行这些镜像。</p>
<blockquote>
<p><strong>Exercise 2</strong></p>
<p>完成下列函数来初始化用户环境：</p>
<ul>
<li><code>env_init()</code>：初始化所有<code>envs</code>数组中的元素并将它们加入<code>env_free_list</code>链表中。这个函数还应该调用<code>env_init_percpu</code>来配置关于分段机制的硬件。</li>
<li><code>env_setup_vm()</code>：为新的用户环境初始化一个<strong>页目录</strong>并初始化这个用户环境的内核部分内存</li>
<li><code>region_alloc()</code>：用于为用户环境分配物理内存</li>
<li><code>load_icode()</code>：解析用户进程要跑的任务文件的ELF头，并将二进制文件加载到虚拟地址空间</li>
<li><code>env_create()</code>：调用上面两个函数来为一个任务建立一个新的用户环境</li>
<li><code>env_run()</code>：运行一个用户环境</li>
</ul>
</blockquote>
<p>这一部分编码涉及到比较多的错误码处理，在这里可以活用<code>cprintf</code>的<code>%e</code>转义字符：它可以打印出一个errorcode对应的错误信息。</p>
<p>首先是<code>env_init</code>函数。只要认真阅读过函数前面的注释，按部就班地来就没有什么难度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Set up envs array</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		envs[i].env_id = <span class="number">0</span>;</span><br><span class="line">		envs[i].env_status = ENV_FREE;</span><br><span class="line">		envs[i].env_link = env_free_list;</span><br><span class="line">		env_free_list = &amp;envs[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">	env_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后是<code>env_setup_vm</code>函数。这个函数的作用是为这个用户环境建立整个虚拟内存系统。看上去很吓人，但注释中提示我们，所有用户环境在UTOP以上的虚拟内存空间都是内核虚拟内存空间中这一部分的副本，而UTOP以下的部分在初始化过程中全都可以置0，因此我们可以直接以<code>kern_pgdir</code>为模板来初始化<code>e-&gt;env_pgdir</code>的表项：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the page directory</span></span><br><span class="line">p-&gt;pp_ref++;</span><br><span class="line">e-&gt;env_pgdir = page2kva(p);</span><br><span class="line"><span class="comment">// Set up the virtual memory space</span></span><br><span class="line"><span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</span><br></pre></td></tr></table></figure>
<p>接下来是<code>region_alloc</code>函数，这个函数其实不写也行，主要是为了简化物理内存的分配过程。在<code>load_icode</code>函数中我们要频繁地为一段虚拟内存分配物理内存，这个函数就是为了简化这一过程而生的。</p>
<p>如果我们对之前Lab2中自己实现过的函数的功能和调用关系很熟悉的话，这个函数的实现会很简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">region_alloc(struct Env *e, <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">uintptr_t</span> start_addr = ROUNDDOWN((<span class="keyword">uintptr_t</span>)va, PGSIZE);</span><br><span class="line">	<span class="keyword">uintptr_t</span> end_addr = ROUNDUP((<span class="keyword">uintptr_t</span>)(va + len), PGSIZE);</span><br><span class="line">	<span class="keyword">for</span> ( ; start_addr &lt; end_addr; start_addr += PGSIZE) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">rawpg</span> = <span class="title">page_alloc</span>(<span class="title">ALLOC_ZERO</span>);</span></span><br><span class="line">		<span class="keyword">if</span> (!rawpg) panic(<span class="string">"region_alloc: %e"</span>,-E_NO_MEM);</span><br><span class="line">		page_insert(e-&gt;env_pgdir, rawpg, (<span class="keyword">void</span> *)start_addr, PTE_U | PTE_W);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一个函数<code>load_icode</code>的实现难度就比较大了，它会<strong>将目标ELF镜像文件加载到内存中</strong>，为此它需要解析ELF头的内容，这一步与bootloader所做的比较相似，可以参考<code>boot/main.c</code>中的实现；它还会为这个已经加载的二进制文件<strong>建立一个程序栈</strong>。</p>
<p>在<code>inc/elf.h</code>中已经定义好了ELF头和段头的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> e_magic;	<span class="comment">// must equal ELF_MAGIC</span></span><br><span class="line">	<span class="keyword">uint8_t</span> e_elf[<span class="number">12</span>];</span><br><span class="line">	<span class="keyword">uint16_t</span> e_type;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_machine;</span><br><span class="line">	<span class="keyword">uint32_t</span> e_version;</span><br><span class="line">	<span class="keyword">uint32_t</span> e_entry;</span><br><span class="line">	<span class="keyword">uint32_t</span> e_phoff;</span><br><span class="line">	<span class="keyword">uint32_t</span> e_shoff;</span><br><span class="line">	<span class="keyword">uint32_t</span> e_flags;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_ehsize;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_phentsize;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_phnum;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_shentsize;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_shnum;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_shstrndx;</span><br><span class="line">&#125;; <span class="comment">// ELF头的结构</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> p_type;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_offset;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_va;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_pa;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_filesz;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_memsz;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_flags;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_align;</span><br><span class="line">&#125;; <span class="comment">// 段头部的结构</span></span><br></pre></td></tr></table></figure>
<p>关于ELF文件结构的详细知识可以参考CSAPP的第7章链接部分知识，我们现在只需要知道，<strong>ELF头</strong>位于一个二进制文件的开头部分，而且通过解析ELF头的信息可以得到<strong>段头部表</strong>的位置和大小。通过解析每个段头部，我们又可以得知所有段的信息，从而将它们有选择性地加载到内存中。</p>
<p>这里可能需要解释一下6.828的诡异命名的含义：<code>ph</code>是指二进制文件中各个段的段头部结构体指针，其类型为<code>struct Proghdr*</code>。只要理解了这一层，按照注释就可以按部就班地完成这个函数了。</p>
<p>比较需要注意的一点是<code>cr3</code>寄存器值的切换。在这个函数执行之前当前运行的环境是kernel，因此<code>cr3</code>的值是<code>kern_pgdir</code>，如果我们直接用<code>memcpy</code>函数去加载binary就会将binary加载到<strong>内核地址空间</strong>而非<strong>用户环境地址空间</strong>。所以我们需要在加载binary之前先用<code>lcr3</code>函数切换<code>cr3</code>寄存器的值，在加载完之后再切换回<code>kern_pgdir</code>。</p>
<p>另一个问题是如何设置加载进内存的二进制程序的<strong>入口点</strong>。根据注释中的提示观察<code>env_pop_tf</code>函数可以发现，这个函数从<code>env_tf</code>结构中恢复了所有上下文寄存器的值，其中就包括<code>tf_eip</code>这个决定着下一条命令位置的寄存器，随后就执行<code>iret</code>汇编指令切换用户环境。这样一来，只要我们将<code>(e-&gt;env_tf).tf_eip</code>的值修改为二进制程序入口点的值，就可以让控制流自然地跳转到那个位置了。</p>
<p>但是二进制程序入口点的值是什么呢？这个值其实存放在ELF头中，就是<code>e_entry</code>这个结构体元素的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">load_icode(struct Env *e, <span class="keyword">uint8_t</span> *binary)</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Elf</span>* <span class="title">elf_ptr</span> = <span class="title">binary</span>;</span> <span class="comment">// The pointer to the binary's elf header</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check the type of the binary</span></span><br><span class="line">	<span class="keyword">if</span> (elf_ptr-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">		panic(<span class="string">"This binary is not a valid ELF file!"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Load each program segment</span></span><br><span class="line">	ph = (struct Proghdr *)(binary + elf_ptr-&gt;e_phoff);</span><br><span class="line">	eph = ph + elf_ptr-&gt;e_phnum;</span><br><span class="line">	<span class="comment">// As we need to load the binary into e's virtual memory,</span></span><br><span class="line">	<span class="comment">// we should change cr3 to e's page directory (or the binary</span></span><br><span class="line">	<span class="comment">// would be loaded to kernel's virtual memory).</span></span><br><span class="line">	lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">	<span class="keyword">for</span> (; ph &lt; eph; ph++) &#123;</span><br><span class="line">		<span class="comment">// Do what the hint told us to</span></span><br><span class="line">		<span class="keyword">if</span> (ph-&gt;p_type == ELF_PROG_LOAD) &#123;</span><br><span class="line">			region_alloc(e, ph-&gt;p_va, ph-&gt;p_memsz);</span><br><span class="line">			<span class="built_in">memcpy</span>(ph-&gt;p_va, binary + ph-&gt;p_offset, ph-&gt;p_filesz);</span><br><span class="line">			<span class="built_in">memset</span>(binary + ph-&gt;p_va + ph-&gt;p_filesz, <span class="number">0</span>, ph-&gt;p_memsz - ph-&gt;p_filesz);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Change cr3 back to kern_pgdir.</span></span><br><span class="line">	lcr3(PADDR(kern_pgdir));</span><br><span class="line">	<span class="comment">// Set the entry point of the binary</span></span><br><span class="line">	(e-&gt;env_tf).tf_eip = elf_ptr-&gt;e_entry;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now map one page for the program's initial stack</span></span><br><span class="line">	<span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	region_alloc(e, USTACKTOP - PGSIZE, PGSIZE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数完成之后，剩下的两个函数就比较简单了。<code>env_create</code>函数直接按照注释中的要求调用函数即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_create(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">new_env</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err = env_alloc(&amp;new_env, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		panic(<span class="string">"env_create: %e"</span>, err);</span><br><span class="line">	load_icode(new_env, binary);</span><br><span class="line">	new_env-&gt;env_type = type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的<code>env_run</code>也按照注释的要求完成即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_run(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1</span></span><br><span class="line">	<span class="keyword">if</span> (curenv != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (curenv-&gt;env_status == ENV_RUNNING)</span><br><span class="line">			curenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">		<span class="keyword">else</span> panic(<span class="string">"env_run: The current process's status is not ENV_RUNNING."</span>);</span><br><span class="line">	&#125;	<span class="comment">// 1.</span></span><br><span class="line">	curenv = e; <span class="comment">// 2.</span></span><br><span class="line">	curenv-&gt;env_status = ENV_RUNNING; <span class="comment">// 3.</span></span><br><span class="line">	curenv-&gt;env_runs++; <span class="comment">// 4.</span></span><br><span class="line">	lcr3(PADDR(e-&gt;env_pgdir)); <span class="comment">// 5.</span></span><br><span class="line">	<span class="comment">// Step 2</span></span><br><span class="line">	env_pop_tf(&amp;curenv-&gt;env_tf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们还没有完成系统调用相关的处理代码，加载完成的binary并无法正常工作。在binary执行到系统调用那一步之后，CPU会发现它还不能处理这个中断，于是抛出一个<strong>一般保护错误</strong>(general protection fault)。然而这个保护错误目前不能被处理，于是CPU再抛出一个<code>double fault</code>异常，并发现这也不能被处理，最终放弃治疗并抛出<code>triple fault</code>异常，也就是我们之前在调试过程中常见的那个<code>triple fault</code>。</p>
<p>一个<code>triple fault</code>异常通常会引起系统重启，但为了方便debug，6.828修改了qemu使得它在<code>triple fault</code>的时候打印出所有寄存器的值和内存状态。</p>
<p>为了检验我们的工作是否正确完成，我们可以用<code>qemu-gdb</code>和<code>gdb</code>来进行调试。首先在<code>env_pop_tf</code>函数处打上断点并<code>c</code>到这个函数，<code>si</code>单步调试直到<code>iret</code>将控制流跳转到用户地址空间，这时可以发现<code>gdb</code>中的地址信息显示从<code>0xf0000000</code>以上变成了<code>0x00800000</code>以上，能进行到这一步说明我们对于用户地址空间创建的实现没有问题。</p>
<p>在<code>0x800101</code>处(系统调用的前一句指令)打一个断点，执行到这一句汇编指令。如果在执行到这里的过程中始终没有触发错误，说明我们Exercise 2的实现是没有问题的。</p>
<h5 id="Handling-Interrupts-and-Exceptions"><a href="#Handling-Interrupts-and-Exceptions" class="headerlink" title="Handling Interrupts and Exceptions"></a>Handling Interrupts and Exceptions</h5><p>现在的情况是，一旦用户环境执行了系统调用，控制流是无法从内核返回给用户环境的。我们现在需要实现的是内核对于<strong>基本的异常和系统调用的处理</strong>，首先我们要熟悉x86的中断和异常机制。</p>
<blockquote>
<p><strong>Exercise 3</strong></p>
<p>阅读<a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/c09.htm" target="_blank" rel="noopener">80386 Programmer’s Manual中有关异常和中断处理的部分</a>。</p>
</blockquote>
<p>(如果已经阅读过CSAPP第八章异常控制流，有关这部分的内容会变得很易于理解。)</p>
<p>中断和异常都是<strong>受保护的控制流转移</strong>，也就是说这两个过程是受内核控制的。内核通过中断或异常来切换到内核态，以使得用户代码没有干预内核运行的机会。</p>
<p>Intel是这样定义<strong>异常</strong>和<strong>中断</strong>的：</p>
<ul>
<li>中断(Interrupt)是<strong>处理器外部</strong>的设备向处理器发出的<strong>异步</strong>(<em>asynchronous</em>)信号引起的(典型的例子是IO)。</li>
<li>异常(Exception)是<strong>处理器本身</strong>执行的代码所触发的<strong>同步</strong>(<em>synchronous</em>)信号引起的，系统调用和错误都算做异常。</li>
</ul>
<p>从这个定义我们可以看出，Intel对中断的定义和CSAPP一致，但异常的定义其实是包括了CSAPP中定义的<strong>陷阱</strong>(trap)，<strong>错误</strong>(fault)和<strong>终止</strong>(abort)。</p>
<p>为了保证这种控制流转移是<strong>受保护的</strong>，intel使用了两种机制：</p>
<ul>
<li><strong>中断描述符表</strong>(IDT)：处理器保证了当异常或中断触发时，控制流的转移位置是由<strong>内核</strong>而非<strong>触发异常的代码</strong>定义的。intel定义了256种异常，每一种异常有一个独一无二的<strong>异常号</strong>(直译是异常向量，但将一个数称为向量感觉会引起误解)，CPU以异常号为索引去中断描述符表中寻找对应的表项，从而进行对特定中断的处理。CPU可以从中断描述符表中获得：<ul>
<li>指向中断处理程序首地址的eip值</li>
<li>用于处理中断的特权级所对应的CS寄存器值(能处理中断的只有0级和1级，在JOS中均为0级)</li>
</ul>
</li>
<li><strong>任务状态段</strong>(TSS)：在跳转到中断处理程序之前，CPU需要保存它的状态以便在处理完之后将控制权交还。但是这个保存状态的位置必须是用户特权级所不能访问的，否则恶意的用户代码就能够去干预内核的行为。为此CPU为异常处理程序建立了一个<strong>独立于用户栈之外的栈</strong>，在这个栈中处理器压入SS，ESP，EFLAGS，CS，IP等关键信息，并重新设置SS和ESP以将这个栈作为新的程序栈。</li>
</ul>
<p>所有异常都使用<strong>0-31之间</strong>的32个异常号，而剩下的异常号通常对应于软件或硬件引发的中断。</p>
<p>现在我们来看一个例子：假设一个用户环境在执行一条代码的时候试图进行除零运算。</p>
<ul>
<li>处理器根据TSS所定义的SS0和ESP0来切换程序栈，在JOS中它们分别对应着<code>GD_KD</code>和<code>KSTACKTOP</code>。</li>
<li>处理器将需要保护的上下文信息压入新的栈(先后是SS，ESP，EFLAGS，CS，EIP，有些时候还会压入errorcode)。</li>
<li>处理器根据除法异常的异常号(0)找到<code>IDT[0]</code>，并根据其内容设定新的CS：EIP</li>
<li>异常处理程序接管控制流并进行异常处理</li>
</ul>
<p>值得注意的是，<strong>只有当从用户态进入内核态时CPU才会进行程序栈切换</strong>，如果在内核态下发生了中断或异常，CPU不会建立一个新栈，而是在已有的内核栈中先后压入<code>EFLAGS</code>，<code>CS</code>和<code>EIP</code>(有时压入errorcode)，然后进行控制流跳转，这为异常的嵌套提供了一种优雅的解决方式。</p>
<h5 id="Setting-Up-the-IDT"><a href="#Setting-Up-the-IDT" class="headerlink" title="Setting Up the IDT"></a>Setting Up the IDT</h5><p>在这个Lab中我们会建立能够处理异常和系统调用的IDT，<code>inc/trap.h</code>和<code>kern/trap.h</code>可以为我们的工作提供很多帮助，其中后者提供的定义只能由内核访问，前者的定义则可以由内核和用户共同访问。</p>
<p><strong>注意：</strong>有些异常是被intel保留的，这意味着你不需要处理它们。</p>
<p>在<code>trapentry.S</code>中定义了每个中断或异常的处理程序，<code>trap_init()</code>函数应当用它们的地址来初始化IDT。每个处理程序都应当在栈上建立一个<code>struct Trapframe</code>，并以这个结构的指针为参数调用<code>trap.c</code>中的<code>trap()</code>函数。</p>
<blockquote>
<p><strong>Exercise 4</strong></p>
<p>修改<code>trapentry.S</code>和<code>trap.c</code>来实现上面描述的功能。可能有帮助的宏定义有：</p>
<ul>
<li><code>trapentry.S</code>中的<code>TRAPHANDLER</code>和<code>TRAPHANDLER_NOEC</code></li>
<li><code>inc/trap.h</code>中的<code>T_*</code>宏定义们</li>
</ul>
<p>你需要用这些宏为<code>inc/trap.h</code>中定义的每一个trap增加一个入口点。由于每个异常处理函数都会<code>jmp</code>到<code>_alltraps</code>，你还需要完成这段代码的实现。你的<code>_alltraps</code>需要完成这些工作：</p>
<ul>
<li>向栈中压入数据，使栈的结构看起来像<code>struct Trapframe</code>(可以使用<code>pushal</code>指令)</li>
<li>将<code>GD_KD</code>加载到<code>%ds</code>和<code>%es</code></li>
<li><code>pushl %esp</code>作为<code>trap</code>函数的参数</li>
<li>调用<code>trap</code>函数</li>
</ul>
<p>你还需要修改<code>trap_init()</code>函数来初始化IDT，让它的每个表项指向<code>trapentry.S</code>中定义的一个入口点，在这个过程中<code>SETGATE</code>函数可能会有用。</p>
</blockquote>
<p>首先观察<code>trapentry.S</code>中对两个宏的定义和注释，理解它们的作用。<code>TRAPHANDLER</code>接受两个参数<code>name</code>和<code>num</code>，定义一个名为<code>name</code>的<strong>全局的</strong>处理<code>num</code>所对应异常的异常处理函数；而<code>TRAPHANDLER_NOEC</code>与其唯一的区别就是后者会在压入<strong>异常号</strong>之前多压入一个32位的<code>0</code>。这个操作的用意是什么呢？</p>
<p><code>_alltraps</code>定义了所有异常处理函数的公共部分，我们可以从要求中得知它的第一步就是要将一个<code>Trapframe</code>结构压入程序栈。这个结构的定义<a href="#trapframe">在之前遇到过</a>，现在我们来仔细研究一下它的结构：</p>
<p><img src="trapframe.png" alt=""></p>
<p>在之前的描述中我们已经知道在异常触发的时候处理器会帮我们切换好程序栈并压入一些必要信息，其中对于<code>errorcode</code>这一项，有些异常会压入，但有些异常不会压入。如果我们对所有异常一概使用<code>TRAPHANDLER</code>宏去处理，没有压入<code>errorcode</code>的异常的<code>Trapframe</code>就会向上“塌陷”，致使从trap number往下的所有数据错位。为了保持结构的完整性，我们需要对已经压入<code>errorcode</code>的异常使用<code>TRAPHANDLER</code>宏，而对没有压入的异常使用<code>TRAPHANDLER_NOEC</code>宏。</p>
<p>哪些异常压入过<code>errorcode</code>呢？通过查阅<a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/s09_10.htm" target="_blank" rel="noopener">80380 Programmer’s Manual</a>，可以发现一个<code>Error-Code Summary</code>，可以根据这个表给出的信息来选择应该用哪个宏。</p>
<p>在我们成功构造好<code>Trapframe</code>之后，下一步是修改<code>ds</code>和<code>es</code>的值，压入<code>esp</code>的值，最后<code>call trap</code>。只要熟悉AT&amp;T标准的语法和规范，这几步应该不算难。</p>
<p><code>trapentry.S</code>的代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Lab 3: Your code here for generating entry points for the different traps.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">TRAPHANDLER_NOEC(_divide, T_DIVIDE)</span><br><span class="line">TRAPHANDLER_NOEC(_debug, T_DEBUG)</span><br><span class="line">TRAPHANDLER_NOEC(_nmi, T_NMI)</span><br><span class="line">TRAPHANDLER_NOEC(_brkpt, T_BRKPT)</span><br><span class="line">TRAPHANDLER_NOEC(_oflow, T_OFLOW)</span><br><span class="line">TRAPHANDLER_NOEC(_bound, T_BOUND)</span><br><span class="line">TRAPHANDLER_NOEC(_illop, T_ILLOP)</span><br><span class="line">TRAPHANDLER_NOEC(_device, T_DEVICE)</span><br><span class="line">TRAPHANDLER_NOEC(_dblflt, T_DBLFLT)</span><br><span class="line">TRAPHANDLER(_tss, T_TSS)</span><br><span class="line">TRAPHANDLER(_segnp, T_SEGNP)</span><br><span class="line">TRAPHANDLER(_stack, T_STACK)</span><br><span class="line">TRAPHANDLER(_gpflt, T_GPFLT)</span><br><span class="line">TRAPHANDLER(_pgflt, T_PGFLT)</span><br><span class="line">TRAPHANDLER_NOEC(_fperr, T_FPERR)</span><br><span class="line">TRAPHANDLER_NOEC(_align, T_ALIGN)</span><br><span class="line">TRAPHANDLER_NOEC(_mchk, T_MCHK)</span><br><span class="line">TRAPHANDLER_NOEC(_simderr, T_SIMDERR)</span><br><span class="line">TRAPHANDLER_NOEC(_syscall, T_SYSCALL)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Lab 3: Your code here for _alltraps</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">_alltraps:</span><br><span class="line"></span><br><span class="line">	pushw $0x0</span><br><span class="line">	pushw %ds</span><br><span class="line">	pushw $0x0</span><br><span class="line">	pushw %es</span><br><span class="line">	pushal</span><br><span class="line">	movw $(GD_KD), %ax ; Note that ds and es can not be assigned straightly by immediates</span><br><span class="line">	movw %ax, %ds</span><br><span class="line">	movw %ax, %es</span><br><span class="line">	pushl %esp</span><br><span class="line">	call trap</span><br></pre></td></tr></table></figure>
<p>在<code>trap.c</code>中的部分就比较简单了，只需要阅读一下<code>SETGATE</code>这个宏的具体定义(位于<code>inc/mmu.h</code>)，明确各个参数的作用就可以做了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETGATE(gate, istrap, sel, off, dpl)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>gate</code>：这个异常在IDT中的异常描述符</li>
<li><code>istrap</code>：如果是异常则为1，中断则为0</li>
<li><code>sel</code>：异常处理函数的数据段，这里显然是内核代码段<code>GD_KT</code>(各个段选择符的定义在<code>inc/memlayout.h</code>中有)</li>
<li><code>off</code>：异常处理函数首地址的偏移，这里可以使用对应的函数指针</li>
<li><code>dpl</code>：这个异常处理函数能被什么<strong>权限级</strong>的进程显式调用(使用<code>int</code>指令)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarations</span></span><br><span class="line"><span class="keyword">void</span> _divide();</span><br><span class="line"><span class="keyword">void</span> _debug();</span><br><span class="line"><span class="keyword">void</span> _nmi();</span><br><span class="line"><span class="keyword">void</span> _brkpt();</span><br><span class="line"><span class="keyword">void</span> _oflow();</span><br><span class="line"><span class="keyword">void</span> _bound();</span><br><span class="line"><span class="keyword">void</span> _illop();</span><br><span class="line"><span class="keyword">void</span> _device();</span><br><span class="line"><span class="keyword">void</span> _dblflt();</span><br><span class="line"><span class="keyword">void</span> _tss();</span><br><span class="line"><span class="keyword">void</span> _segnp(); </span><br><span class="line"><span class="keyword">void</span> _stack(); </span><br><span class="line"><span class="keyword">void</span> _gpflt(); </span><br><span class="line"><span class="keyword">void</span> _pgflt(); </span><br><span class="line"><span class="keyword">void</span> _fperr(); </span><br><span class="line"><span class="keyword">void</span> _align(); </span><br><span class="line"><span class="keyword">void</span> _mchk();</span><br><span class="line"><span class="keyword">void</span> _simderr();</span><br><span class="line"><span class="keyword">void</span> _syscall();</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Segdesc</span> <span class="title">gdt</span>[];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	SETGATE(idt[<span class="number">0</span>], <span class="number">1</span>, GD_KT, _divide, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">1</span>], <span class="number">1</span>, GD_KT, _debug, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">2</span>], <span class="number">1</span>, GD_KT, _nmi, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">3</span>], <span class="number">1</span>, GD_KT, _brkpt, <span class="number">3</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">4</span>], <span class="number">1</span>, GD_KT, _oflow, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">5</span>], <span class="number">1</span>, GD_KT, _bound, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">6</span>], <span class="number">1</span>, GD_KT, _illop, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">7</span>], <span class="number">1</span>, GD_KT, _device, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">8</span>], <span class="number">1</span>, GD_KT, _dblflt, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">10</span>], <span class="number">1</span>, GD_KT, _tss, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">11</span>], <span class="number">1</span>, GD_KT, _segnp, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">12</span>], <span class="number">1</span>, GD_KT, _stack, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">13</span>], <span class="number">1</span>, GD_KT, _gpflt, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">14</span>], <span class="number">1</span>, GD_KT, _pgflt, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">16</span>], <span class="number">1</span>, GD_KT, _fperr, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">17</span>], <span class="number">1</span>, GD_KT, _align, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">18</span>], <span class="number">1</span>, GD_KT, _mchk, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">19</span>], <span class="number">1</span>, GD_KT, _simderr, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">48</span>], <span class="number">1</span>, GD_KT, _syscall, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Per-CPU setup </span></span><br><span class="line">	trap_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Questions</strong></p>
<p>Q：为什么我们要对每一个中断或异常使用一个单独的函数，而不是用一个函数处理所有中断？</p>
<p>A：CPU对于不同异常在错误码是否压入方面的处理是不一样且不可见的。</p>
<p>Q：评测系统希望softint生成一个异常13(一般保护)，但<code>user/softint.c</code>中的代码触发的是异常14(缺页异常)，为什么错误的代码能够得到正确的结果？如果<code>user/softint.c</code>真的触发了缺页异常，又会发生什么？</p>
<p>A：查看<code>softint.c</code>，可以发现它直接用内联汇编执行了<code>int $14</code>，强行触发一个缺页错误。根据缺页中断的定义和处理方式，缺页中断不能由用户进程显式触发(也就是其dpl为0)，因而<code>softint</code>试图触发它的操作非法，使操作系统抛出一般保护异常来处理这个非法行为。</p>
<p>一旦用户能够显式触发缺页错误，操作系统就会去根据触发中断的指令判断它所访问的内存位置，但这个缺页中断并非由访存指令引起，因而操作系统无法处理这个异常，可能会引起系统崩溃。</p>
</blockquote>
<p>现在运行<code>make grade</code>，Part A <code>30/30</code>大成功，这样Part A就结束了，下面进入Part B。</p>
<h4 id="Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls"><a href="#Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls" class="headerlink" title="Part B  Page Faults, Breakpoints Exceptions, and System Calls"></a>Part B  Page Faults, Breakpoints Exceptions, and System Calls</h4><p>现在JOS已经有了基本的异常处理能力，但是我们需要继续完善它以让它支持一些更强大的功能。</p>
<h5 id="Handling-Page-Faults"><a href="#Handling-Page-Faults" class="headerlink" title="Handling Page Faults"></a>Handling Page Faults</h5><p><strong>缺页中断</strong>比大部分中断特殊，在缺页中断触发时，操作系统会将触发中断的指令储存到<code>cr2</code>寄存器中。我们在<code>trap.c</code>中提供了<code>page_fault_handler()</code>函数来处理缺页错误。</p>
<blockquote>
<p><strong>Exercise 5</strong></p>
<p>修改<code>trap_dispatch</code>函数来将缺页异常派发给<code>page_fault_handler()</code>。</p>
</blockquote>
<p>这是送分题啊同学们！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Handle processor exceptions.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tf-&gt;tf_trapno == T_PGFLT) &#123;</span><br><span class="line">		page_fault_handler(tf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">	print_trapframe(tf);</span><br><span class="line">	<span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">		panic(<span class="string">"unhandled trap in kernel"</span>);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		env_destroy(curenv);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数完成之后，执行<code>make grade</code>应该能拿到总分的前50分了。如果这其中有哪个test没有通过，最好先修好再继续做下面的部分。</p>
<h5 id="The-Breakpoint-Exception"><a href="#The-Breakpoint-Exception" class="headerlink" title="The Breakpoint Exception"></a>The Breakpoint Exception</h5><p><strong>断点异常</strong>是专门为<strong>调试器</strong>而准备的异常。调试器在源程序中插入断点时，其实是在断点位置的指令中插入了一句<code>int $3</code>代码(<code>int $3</code>只占1个字节，因此可以替换掉指令的OPCODE)，触发一个断点异常来让程序暂停。</p>
<p>在JOS中这个异常的功能略有不同，它可以唤醒JOS的monitor，并将这个monitor作为一个比较低配的debugger(高配还是低配其实是看之前Lab2中在<code>monitor.c</code>中实现了多少有用的函数)。<code>panic</code>函数就是一个使用了<code>int $3</code>的例子。</p>
<blockquote>
<p><strong>Exercise 6</strong></p>
<p>修改<code>trap_dispatch</code>函数以让其支持断点异常的处理。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Handle processor exceptions.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</span><br><span class="line">		<span class="keyword">case</span> T_PGFLT:</span><br><span class="line">			page_fault_handler(tf);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> T_BRKPT:</span><br><span class="line">			monitor(tf);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">	print_trapframe(tf);</span><br><span class="line">	<span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">		panic(<span class="string">"unhandled trap in kernel"</span>);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		env_destroy(curenv);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Challenge</strong></p>
<p>为<code>monitor.c</code>增加指令使其支持单步调试。</p>
</blockquote>
<p>单步调试的开关是<code>EFLAGS</code>中的<code>TF</code>标志位。除了单步调试功能之外，这里我还写了一个打印寄存器的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Single-step</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_step(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf) &#123;</span><br><span class="line"></span><br><span class="line">	tf-&gt;tf_eflags |= <span class="number">0x100</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dump registers</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_regs(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		cprintf(<span class="string">"Error: incorrect number of arguments.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">"Registers:\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"base"</span>) == <span class="number">0</span>)</span><br><span class="line">		cprintf(</span><br><span class="line">			<span class="string">"eax: %09x  ebx: %09x  ecx: %09x  edx: %09x\n\</span></span><br><span class="line"><span class="string">edi: %09x  esi: %09x  ebp: %09x  esp: %09x\n"</span>,</span><br><span class="line">			tf-&gt;tf_regs.reg_eax,</span><br><span class="line">			tf-&gt;tf_regs.reg_ebx,</span><br><span class="line">			tf-&gt;tf_regs.reg_ecx,</span><br><span class="line">			tf-&gt;tf_regs.reg_edx,</span><br><span class="line">			tf-&gt;tf_regs.reg_edi,</span><br><span class="line">			tf-&gt;tf_regs.reg_esi,</span><br><span class="line">			tf-&gt;tf_regs.reg_ebp,</span><br><span class="line">			tf-&gt;tf_regs.reg_oesp</span><br><span class="line">		);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"seg"</span>) == <span class="number">0</span>)</span><br><span class="line">		cprintf(</span><br><span class="line">			<span class="string">"cs: %x\tds: %x\tss: %x\tes: %x\n"</span>,</span><br><span class="line">			tf-&gt;tf_cs,</span><br><span class="line">			tf-&gt;tf_ds,</span><br><span class="line">			tf-&gt;tf_ss,</span><br><span class="line">			tf-&gt;tf_es</span><br><span class="line">		);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"flags"</span>) == <span class="number">0</span>)</span><br><span class="line">		cprintf(</span><br><span class="line">			<span class="string">"CF=%d  PF=%d  AF=%d  ZF=%d  SF=%d  OF=%d\nTF=%d  DF=%d  IF=%d\n"</span>,</span><br><span class="line">			tf-&gt;tf_eflags &amp; <span class="number">0x1</span>,</span><br><span class="line">			tf-&gt;tf_eflags &amp; <span class="number">0x4</span>,</span><br><span class="line">			tf-&gt;tf_eflags &amp; <span class="number">0x10</span>,</span><br><span class="line">			tf-&gt;tf_eflags &amp; <span class="number">0x40</span>,</span><br><span class="line">			tf-&gt;tf_eflags &amp; <span class="number">0x80</span>,</span><br><span class="line">			tf-&gt;tf_eflags &amp; <span class="number">0x800</span>,</span><br><span class="line">			tf-&gt;tf_eflags &amp; <span class="number">0x100</span>,</span><br><span class="line">			tf-&gt;tf_eflags &amp; <span class="number">0x200</span>,</span><br><span class="line">			tf-&gt;tf_eflags &amp; <span class="number">0x400</span></span><br><span class="line">		);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"ip"</span>) == <span class="number">0</span>)</span><br><span class="line">		cprintf(<span class="string">"eip: %x\n"</span>, tf-&gt;tf_eip);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cprintf(<span class="string">"Error: Invalid argument.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TF置为1时会触发<code>T_DEBUG</code>中断，因此还要修改<code>trap.c</code>使其能够处理这种中断。</p>
<blockquote>
<p><strong>Questions</strong></p>
<p>Q：根据你初始化IDT的方式，测试文件可能会触发一个断点异常<strong>或一般保护异常</strong>，这是为什么？如何设置IDT才能正常地触发断点异常？什么样的错误设置会触发一般保护异常？</p>
<p>A：对<code>dpl</code>项的设置决定了测试文件会触发怎样的异常。测试文件是跑在用户进程下的，如果<code>dpl</code>为0，只有内核才能用<code>int</code>显式触发断点异常，那么测试文件的这个操作显然非法，会触发一般保护异常；只要将<code>dpl</code>设为3(用户权限级)，这个异常就可以被用户显式触发，测试文件就能够正常地行为了。</p>
<p>Q：简要描述一下各个测试程序，尤其是<code>softint</code>做了什么。</p>
<p>A：测试程序使用尽量简练的语句触发异常，但有些是通过错误操作间接触发异常，有些(比如<code>softint</code>)是直接用<code>int</code>指令触发异常。</p>
</blockquote>
<h5 id="System-Calls"><a href="#System-Calls" class="headerlink" title="System Calls"></a>System Calls</h5><p>有关系统调用的概念性知识在计算机系统和操作系统课程中讲的已经足够详细了，此处不再赘述。在JOS中，我们使用<code>int $0x30</code>来进行系统调用。<strong>调用号</strong>会被放在<code>%eax</code>，而<code>%edx</code>,<code>%ecx</code>, <code>%ebx</code>, <code>%edi</code>和<code>%esi</code>分别用来存放五个参数。系统调用的返回值放在<code>%eax</code>。</p>
<p>6.828在<code>lib/syscall.c</code>中提供了一个系统调用函数<code>syscall()</code>，它用内联汇编描述了上述过程。在完成任务的过程中可以参考它的写法。</p>
<blockquote>
<p><strong>Exercise 7</strong></p>
<p>为内核增加系统调用的处理函数。你需要更改<code>kern/trapentry.S</code>和<code>kern/trap.c</code>的<code>trap_init()</code>函数。你还需要在<code>trap_dispatch()</code>中以正确的参数调用<code>syscall()</code>(<strong>注意是<code>kern</code>文件夹的<code>syscall</code>而不是<code>lib</code>中的！</strong>)处理系统调用，并将返回值通过<code>%eax</code>交还给调用者。</p>
<p>最后，你还需要实现<code>kern/syscall.c</code>中的<code>syscall</code>函数。确保当调用号无效的时候函数返回<code>-E_INVAL</code>。你需要通过调用内核函数处理<code>inc/syscall.h</code>中列出的所有系统调用。</p>
</blockquote>
<p>在之前贴出的代码中已经将<code>kern/trapentry.S</code>和<code>kern/trap.c</code>的<code>trap_init()</code>函数修改到符合要求了，这里不重复贴了。修改后的<code>trap_dispatch()</code>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Handle processor exceptions.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int32_t</span> return_val;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</span><br><span class="line">		<span class="keyword">case</span> T_PGFLT:</span><br><span class="line">			page_fault_handler(tf);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">case</span> T_BRKPT:</span><br><span class="line">			monitor(tf);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">case</span> T_SYSCALL:</span><br><span class="line">			return_val = syscall(</span><br><span class="line">				tf-&gt;tf_regs.reg_eax,</span><br><span class="line">				tf-&gt;tf_regs.reg_edx,</span><br><span class="line">				tf-&gt;tf_regs.reg_ecx,</span><br><span class="line">				tf-&gt;tf_regs.reg_ebx,</span><br><span class="line">				tf-&gt;tf_regs.reg_edi,</span><br><span class="line">				tf-&gt;tf_regs.reg_esi</span><br><span class="line">			); <span class="comment">// 系统调用</span></span><br><span class="line">			<span class="keyword">if</span> (return_val &lt; <span class="number">0</span>)</span><br><span class="line">				panic(<span class="string">"trap_dispatch: %e\n"</span>, return_val);</span><br><span class="line">			tf-&gt;tf_regs.reg_eax = return_val; <span class="comment">// 注意这里要放到tf的eax而非当前eax中！</span></span><br><span class="line">			<span class="keyword">return</span>; <span class="comment">// 注意这里要用return而非break，否则当前环境会被后面的代码销毁</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">	print_trapframe(tf);</span><br><span class="line">	<span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">		panic(<span class="string">"unhandled trap in kernel"</span>);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		env_destroy(curenv);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是<code>syscall()</code>函数。如果说<code>lib/syscall.c</code>中的<code>syscall</code>函数是用<code>int</code>来真正进行了系统调用，<code>kern/syscall.c</code>中的这个版本就是假的系统调用——它归根结底调用的其实是系统函数，这些系统函数再通过调用链最终抵达<code>lib/syscall.c</code>，进行真正的系统调用。</p>
<p>既然是假的系统调用，这个任务就不需要汇编，按照要求做就行了，没什么难度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatches to the correct kernel function, passing the arguments.</span></span><br><span class="line"><span class="keyword">int32_t</span></span><br><span class="line">syscall(<span class="keyword">uint32_t</span> syscallno, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2, <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Call the function corresponding to the 'syscallno' parameter.</span></span><br><span class="line">	<span class="comment">// Return any appropriate return value.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// panic("syscall not implemented");</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line">		<span class="keyword">case</span> SYS_cgetc:</span><br><span class="line">			<span class="keyword">return</span> sys_cgetc();</span><br><span class="line">		<span class="keyword">case</span> SYS_cputs:</span><br><span class="line">			sys_cputs((<span class="keyword">const</span> <span class="keyword">char</span> *)a1, a2);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">case</span> SYS_getenvid:</span><br><span class="line">			<span class="keyword">return</span> sys_getenvid();</span><br><span class="line">		<span class="keyword">case</span> SYS_env_destroy:</span><br><span class="line">			<span class="keyword">return</span> sys_env_destroy(a1);</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做完这一步之后，执行<code>make grade</code>进行测试，如果<code>testbss</code>仍然无法通过，说明你的实现存在问题。否则，执行<code>make run-hello</code>测试<code>hello.c</code>，如果其成功打印出<code>hello world</code>并随即触发一个<code>page fault</code>，说明我们的实现没有问题，可以继续。</p>
<h5 id="User-mode-Startup"><a href="#User-mode-Startup" class="headerlink" title="User-mode Startup"></a>User-mode Startup</h5><p>所有的用户程序是从<code>lib/entry.S</code>开始运行的。在进行一些初始化操作后，这些代码会调用<code>lib/libmain.c</code>中的<code>libmain()</code>函数。<code>libmain()</code>函数随机调用<code>umain()</code>，也就是<code>user</code>文件夹中某个测试程序的主函数。可以注意到<code>hello.c</code>中程序试图访问<code>thisenv-&gt;env_id</code>，这就是为什么它触发了<code>page fault</code>。</p>
<blockquote>
<p><strong>Exercise 8</strong></p>
<p>修改<code>libmain()</code>函数以初始化全局指针<code>thisenv</code>，使其指向<code>envs</code>数组中代表当前用户环境的<code>Env</code>结构体(<code>libmain()</code>已经将envs映射到了<code>UENV</code>地址)。</p>
<p>你可以使用<code>inc/env.h</code>中的<code>sys_getenvid</code>调用。</p>
</blockquote>
<p><del>你以为这是一道送分题，其实是我KENG哒！</del></p>
<p>做题之前最好先研究一下<code>env.h</code>中的描述：<code>sys_getenvid()</code>返回的是<code>envid_t</code>数据类型，在<code>env.h</code>的定义中这个四字节数据有三部分：</p>
<ul>
<li>最高位置零</li>
<li>最低10位用于在<code>envs</code>数组中作为索引</li>
<li>中间21位是<code>Uniqueifier</code>，用于记录这个环境当前是第几次运行</li>
</ul>
<p>这样看来，如果直接用<code>sys_getenvid()</code>的返回值去当<code>envs</code>数组的索引，<code>Uniqueifier</code>会使索引值过大引发越界错误，所以应当将返回值用<code>ENVX</code>宏处理过后再用于索引。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thisenv = &amp;envs[ENVX(sys_getenvid())];</span><br></pre></td></tr></table></figure>
<p>通过研究这道题涉及到的几个文件我们可以稍微了解到运行测试文件的机制。</p>
<h5 id="Page-faults-and-memory-protection"><a href="#Page-faults-and-memory-protection" class="headerlink" title="Page faults and memory protection"></a>Page faults and memory protection</h5><p><strong>内存保护</strong>是操作系统的一个重要功能，它保证了一个有问题的程序不会破坏掉内核或其他用户环境的内存空间。操作系统的内存保护实现通常要依赖于硬件，因而它要时刻让硬件能够得知哪块内存有效而哪块无效。当程序进行非法的访问操作时，硬件会阻止这一行为并调用IDT中对应的异常处理程序。</p>
<p>一个例子是程序的<strong>栈扩充机制</strong>。在用户环境创建伊始，我们实现的内核只会为它分配一页大小的栈空间。当用户环境试图将<code>esp</code>减小到超过这一页的下限时，硬件会阻止这一行为并抛出一个异常，操作系统内核处理这个异常，分配一页新的栈空间，并将控制权返还给用户，这样这个操作就变的合法了。通过这种抽象，用户可以认为他有一个无限大小的栈。</p>
<p>在很多系统调用中，用户会向内核传递一个指向一段内存空间的指针，让内核向其中写入数据。这种机制可能会产生两个问题：</p>
<ul>
<li>如果在内核解引用指针的时候触发了一个<code>page fault</code>，它需要一种机制来使它记得<strong>这个错误其实是由用户而非内核引发的</strong>。这很重要，因为内核缺页错误比用户缺页错误要严重的多：用户触发缺页错误只会暂停用户进程直到那一页被加载到内存，而内核触发缺页错误会使整个内核暂时停转。</li>
<li>内核在解引用之前需要明确<strong>用户</strong>对指针指向的区域是否有访问权限。内核本身的权限要大于用户，所以如果不经检查，对某些用户不能访问的区域的访问也不会触发<code>gpflt</code>。这可能被利用于攻击内核或获取信息。</li>
</ul>
<p>如果我们处理好了这两个问题，内核其实不会因为用户指针的解引用发生<code>page fault</code>。如果它发生了，我们应当让内核<code>panic</code>。</p>
<blockquote>
<p><strong>Exercise 9</strong></p>
<ul>
<li><p>修改<code>kern/trap.c</code>，使内核在内核代码触发<code>pgflt</code>的时候<code>panic</code>。</p>
</li>
<li><p>阅读<code>kern/pmap.c</code>中的<code>user_mem_assert</code>函数，并实现<code>user_mem_check</code>函数。</p>
</li>
<li>修改<code>kern/syscall.c</code>来理智地检查系统调用的参数。</li>
</ul>
<p>为了检查触发异常的是用户代码还是内核代码，可以检查<code>Trapframe</code>中的<code>cs</code>寄存器值。</p>
</blockquote>
<p>第一步注意不要改错了地方，注释有提示我们应修改<code>page_fault_handler</code>函数。在之前<a href="#segments">关于段的介绍</a>处已经提到了如何根据<code>cs</code>的值来判断特权级，这边直接贴出代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_fault_handler(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> fault_va;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Read processor's CR2 register to find the faulting address</span></span><br><span class="line">	fault_va = rcr2();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Handle kernel-mode page faults.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Kernel represents privilege level 0</span></span><br><span class="line">	<span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">0x3</span>) == <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"Error: page fault triggered by kernel."</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We've already handled kernel-mode exceptions, so if we get here,</span></span><br><span class="line">	<span class="comment">// the page fault happened in user mode.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">	cprintf(<span class="string">"[%08x] user fault va %08x ip %08x\n"</span>,</span><br><span class="line">		curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">	print_trapframe(tf);</span><br><span class="line">	env_destroy(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步只要对Lab2各个函数的理解足够深就很简单：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">user_mem_check(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">uintptr_t</span> firstpg = ROUNDDOWN((<span class="keyword">uintptr_t</span>)va, PGSIZE);</span><br><span class="line">	<span class="keyword">uintptr_t</span> lastpg = ROUNDUP((<span class="keyword">uintptr_t</span>)va + len, PGSIZE);</span><br><span class="line">	<span class="keyword">for</span> (; firstpg &lt; lastpg; firstpg += PGSIZE) &#123;</span><br><span class="line">		<span class="keyword">pte_t</span>* pg = pgdir_walk(env-&gt;env_pgdir, (<span class="keyword">void</span> *)firstpg, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (!((*pg &amp; (PTE_P | perm)) == (PTE_P | perm)) || firstpg &gt;= ULIM) &#123;</span><br><span class="line">			<span class="keyword">if</span> (firstpg &lt; (<span class="keyword">uintptr_t</span>)va)</span><br><span class="line">				user_mem_check_addr = (<span class="keyword">uintptr_t</span>)va;</span><br><span class="line">			<span class="keyword">else</span> user_mem_check_addr = firstpg;</span><br><span class="line">			<span class="keyword">return</span> -E_FAULT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步只需要调用第二步完成的函数即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">sys_cputs(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Check that the user has permission to read memory [s, s+len).</span></span><br><span class="line">	<span class="comment">// Destroy the environment if not.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	user_mem_assert(curenv, (<span class="keyword">void</span> *)s, len, PTE_U);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Print the string supplied by the user.</span></span><br><span class="line">	cprintf(<span class="string">"%.*s"</span>, len, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成这三步之后，执行<code>make grade</code>进行测试，<code>80/80</code>大成功，Lab 3正式完成。</p>
<h3 id="Lab-4-Preemptive-Multitasking"><a href="#Lab-4-Preemptive-Multitasking" class="headerlink" title="Lab 4 Preemptive Multitasking"></a>Lab 4 Preemptive Multitasking</h3><p>在这个lab中你将要完成一个<strong>抢占式的</strong>(Preemptive)多进程管理系统。在<code>Part A</code>中，你需要实现一个使用<strong>轮询调度算法</strong>(round-robin)的伪多核CPU，并实现基本的进程管理系统调用；在<code>Part B</code>中，你需要实现一个<code>fork()</code>系统调用；最后在<code>Part C</code>中，你需要实现<strong>进程间通信</strong>(IPC, inter-process communicating)机制，以及一些硬件中断。</p>
<p>拉取、切换和合并分支的操作和之前相同，在之后不再重复。</p>
<h4 id="Part-A-Multiprocessor-Support-and-Cooperative-Multitasking"><a href="#Part-A-Multiprocessor-Support-and-Cooperative-Multitasking" class="headerlink" title="Part A Multiprocessor Support and Cooperative Multitasking"></a>Part A Multiprocessor Support and Cooperative Multitasking</h4><p>在这一部分，你需要首先将JOS扩展到支持多核处理，然后实现能够创建新进程的用户系统调用。你还需要实现<strong>轮询调度</strong>，在这种调度方式中下一个用户环境将在当前用户环境自愿让出CPU之后获取CPU控制权。</p>
<h5 id="Multiprocessor-Support"><a href="#Multiprocessor-Support" class="headerlink" title="Multiprocessor Support"></a>Multiprocessor Support</h5><p>我们要在JOS中实现的是<strong>对称多处理器模型</strong>(SMP, symmetric multiprocessing)，这个模型使所有的CPU对内存和IO等资源拥有平等的使用权。在启动阶段这些处理器可以分为两种：<strong>启动处理器</strong>(BSP)负责启动和初始化操作系统，而<strong>应用处理器</strong>(AP)在系统初始化完成后被BSP唤醒运行。</p>
<p>由哪个处理器来担任BSP是由BIOS和bootloader决定的。在我们的JOS中，到现在为止实现的所有代码都是在BSP上运行的。</p>
<p>在使用SMP的系统中，每个CPU都有一个自己的<strong>APIC单元</strong>(advanced programmable interrupt controller)，这个单元被CPU们用于互相传递中断信号，从而实现一定程度上的互相控制。APIC还会为它所在的CPU提供一个独一无二的标识符。本Lab中的APIC单元实现可以在<code>kern/lapic.c</code>中查看，有几个函数可能会用到：</p>
<ul>
<li><code>int cpunum()</code>：返回当前正在运行的CPU的ID</li>
<li><code>lapic_startap()</code>：从BSP发送一个<code>STARTUP</code>信号给某个AP来唤醒它</li>
<li><code>apic_init()</code>：在Part C中我们会编码LAPIC内置的计时器来支持<strong>抢占式调度</strong></li>
</ul>
<p>处理器们访问它们的LAPIC的方式被称为<strong>MMIO</strong>(memory-mapped IO)，在这种机制下<strong>物理内存的一部分</strong>与<strong>某些IO设备的寄存器</strong>是绑定的(硬件层面上)，因而用于访存的指令可以直接用于访问设备寄存器。LAPIC所在的虚拟内存地址位于<strong>第二个IO hole</strong>(0xFE000000以上)，我们无法用普通的内存映射去访问它。JOS在<code>MMIOBASE</code>处留下了<code>4MB</code>内存，这样我们才有机会去访问这些硬件。</p>
<blockquote>
<p><strong>Exercise 1</strong></p>
<p>实现<code>kern/pmap.c</code>中的<code>mmio_map_region</code>函数。它会在<code>kern/lapic.c</code>的<code>lapic_init</code>函数中被调用。为了让对这个函数的测试能够正常运行，你还需要事先完成下一个Exercise。</p>
</blockquote>
<p>这个函数将会从虚拟内存空间的MMIO区中分配一块新的内存，并将其映射到需求的物理地址。函数中定义的<code>base</code>是一个指向MMIO区最低空闲地址的<code>static</code>指针，分配内存要从这里开始，且分配完后要更新之。</p>
<p>由于这一片地址是设备存储器而非物理内存，我们需要告诉CPU缓存这片地址是不安全的，为此我们需要在映射内存时将权限位注明<code>PTE_PCD</code>和<code>PTE_PWT</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">mmio_map_region(<span class="keyword">physaddr_t</span> pa, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">uintptr_t</span> base = MMIOBASE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Your code here:</span></span><br><span class="line"></span><br><span class="line">	size = ROUNDUP(size, PGSIZE);</span><br><span class="line">	<span class="keyword">if</span> (base + size &gt;= MMIOLIM)</span><br><span class="line">		panic(<span class="string">"mmio_map_region: not enough memory"</span>);</span><br><span class="line">  <span class="comment">// 注意这里不要忘记加PTE_W，不然在Exercise 4中会出现内核触发page fault的问题</span></span><br><span class="line">	boot_map_region(kern_pgdir, base, size, pa, PTE_PCD | PTE_PWT | PTE_W);</span><br><span class="line">	base += size;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span> *)(base-size);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Application-Processor-Bootstrap"><a href="#Application-Processor-Bootstrap" class="headerlink" title="Application Processor Bootstrap"></a>Application Processor Bootstrap</h5><p>在启动各个AP之前，BSP应当首先收集各种系统信息(如：CPU的数目，它们的APIC ID，以及它们的LAPIC所在的MMIO地址)。<code>kern/mpconfig.c</code>中的<code>mp_init()</code>函数从<code>BIOS</code>内存区中的MP配置表中获取这些信息。</p>
<p><code>kern/init.c</code>中的<code>boot_aps()</code>函数实现了AP的启动过程。AP们在<strong>实方式</strong>下启动(正如bootloader)那样，因而<code>boot_aps()</code>函数需要将AP的<strong>入口代码</strong>(位于<code>kern/mpentry.S</code>)拷贝到一个<strong>能在实方式下访问的内存地址</strong>。和bootloader不同的是，我们对AP入口代码存放的位置有一定的控制权：在JOS中我们把位置确定为<code>MPENTRY_PADDR</code>，但其实任何<code>640KB</code>下的未使用的页对齐的地址都是可以使用的。</p>
<p>之后，<code>boot_aps()</code>向每个AP的LAPIC发送<code>STARTUP</code>信号来启动它们，同时发送的还有每个AP的入口代码所存放的<code>CS：IP</code>位置。在进行一些简单的初始化之后，它将AP们置于保护模式，随后调用同在<code>kern/init.c</code>下的<code>mp_main()</code>函数。</p>
<p>在唤醒下一个AP之前，<code>boot_aps()</code>应当等待当前的AP将一个<code>CPU_STARTED</code>信号通过<code>struct CpuInfo</code>中的<code>cpu_status</code>域发送给它。</p>
<blockquote>
<p><strong>Exercise 2</strong></p>
<p>阅读上面提到的三个函数，确保你理解了在AP启动过程中的控制流转移逻辑，然后改动<code>kern/pmap.c</code>中的<code>page_init()</code>函数来避免将<code>MPENTRY_PADDR</code>加入<code>page_free_list</code>，以使我们安全地在这里拷贝和运行AP的启动代码。</p>
</blockquote>
<p>在系统的初始化过程中，<code>boot_aps()</code>函数被调用。在<code>mpentry.S</code>中已经使用<code>.public</code>声明了两个标签来定义代码段的开始和结束，<code>boot_aps()</code>利用这两个标签的地址来进行<code>memmove</code>操作，将AP要执行的代码拷贝到内存。接下来，它会设定AP使用的栈地址，并调用<code>lapic_startap()</code>函数来启动AP。最后，它用一个空转的while循环(过于dirty)来等待AP的状态变为<code>CPU_STARTED</code>。</p>
<p>AP启动之后，会开始执行已经加载的<code>mpentry.S</code>中的代码。执行完之后，AP已经从实方式转换为了保护模式，并跳转到了<code>mp_main()</code>函数。在这个函数中AP会切换页目录(切换至<code>kern_pgdir</code>)，初始化LAPIC、用户环境和中断处理，最后设定<code>CpuInfo</code>中的<code>cpu_status</code>字段来告知BPS它已经成功启动。</p>
<p>为了完成这个任务，我们要明确<code>MPENTRY_PADDR</code>的位置是物理内存区，因而修改的部分应当在<code>base mem</code>的初始化部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4:</span></span><br><span class="line">	<span class="comment">// Change your code to mark the physical page at MPENTRY_PADDR</span></span><br><span class="line">	<span class="comment">// as in use</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">size_t</span> i;</span><br><span class="line">	<span class="comment">// 1) First page, ignore it</span></span><br><span class="line">	<span class="comment">// 2) Base memory(需要改动的只有这一部分)</span></span><br><span class="line">	<span class="keyword">int</span> mmio_index = ROUNDUP(MPENTRY_PADDR, PGSIZE) / PGSIZE;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; npages_basemem; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i == mmio_index)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">		pages[i].pp_link = page_free_list;</span><br><span class="line">		page_free_list = &amp;pages[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3) IO hole</span></span><br><span class="line">	<span class="comment">// Mention that npages_basemem = IOPHYSMEM / PGSIZE</span></span><br><span class="line">	<span class="comment">// IOPHYSMEM and EXTPHYSMEM is represented by B instead of KB, so div it by PGSIZE.</span></span><br><span class="line">	<span class="comment">// (Here is no operation, because we do not need to deal with occupied pages.)</span></span><br><span class="line">	;</span><br><span class="line">	<span class="comment">// 4) Extended memory</span></span><br><span class="line">	<span class="comment">// The question is where is the end of kernel segment.</span></span><br><span class="line">	<span class="keyword">char</span>* end_addr = (<span class="keyword">char</span> *)envs + <span class="keyword">sizeof</span>(struct Env) * NENV - KERNBASE;</span><br><span class="line">	<span class="keyword">int</span> end_index = (<span class="keyword">int</span>)(ROUNDUP(end_addr, PGSIZE)) / PGSIZE;</span><br><span class="line">	<span class="keyword">for</span> (i = end_index; i &lt; npages; i++) &#123;</span><br><span class="line">		pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">		pages[i].pp_link = page_free_list;</span><br><span class="line">		page_free_list = &amp;pages[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在完成这个任务之后，你的代码应当能够通过<code>check_page_free_list</code>测试，但会在<code>check_kern_pgdir</code>测试失败。</p>
<blockquote>
<p><strong>Question</strong></p>
<p>比较<code>kern/mpentry.S</code>与<code>boot/boot.S</code>的代码。这两者同样是被加载到<code>KERNBASE</code>之上运行，为什么<code>kern/mpentry.S</code>的代码需要一个多余的宏<code>MPBOOTPHYS</code>来计算它的符号的绝对地址，而不是让链接器去填入这些地址？如果我们不使用这个宏，会发生什么？</p>
</blockquote>
<p>在Lab1对bootloader的研究中，我们可以发现bootloader的<strong>链接地址</strong>和<strong>虚拟地址</strong>是完全一致的。因而，链接器填入的各个符号的地址可以直接作为保护模式下的地址去使用。然而<code>mpentry.S</code>没有这一特性，它的链接地址是物理地址，而虚拟地址在内核区，不加转化的话系统根本无法找到代码的位置。</p>
<h5 id="Per-CPU-State-and-Initialization"><a href="#Per-CPU-State-and-Initialization" class="headerlink" title="Per-CPU State and Initialization"></a>Per-CPU State and Initialization</h5><p>在编写多核操作系统的时候，区分<strong>每个CPU的私有状态</strong>(per-CPU state)和<strong>全局状态</strong>是非常重要的。<code>kern/cpu.h</code>在<code>CpuInfo</code>结构体中定义了大部分私有状态。<code>cpunum()</code>函数通过<code>lapic</code>信息来获取当前CPU在<code>cpus</code>数组中的索引，我们也可以使用<code>thiscpu</code>宏，它在展开之后是当前CPU的<code>CpuInfo</code>结构指针。</p>
<p>你需要注意以下私有状态：</p>
<ul>
<li>每个CPU的<strong>内核栈</strong><ul>
<li>由于多个CPU可能会同时陷入内核，我们需要为每一个CPU设置一个单独的内核栈，以防不同CPU破坏彼此的栈结构。用于存储每个CPU内核栈的数据结构是<code>percpu_stacks[NCPU][KSTKSIZE]</code>数组，我们需要将这个数组中的每一项映射到虚拟内存空间的指定位置。</li>
<li>CPU 0的内核栈从<code>KSTACKTOP</code>开始向下增长，之后第n个CPU的内核栈从<code>KSTACKTOP - n*KSTKGAP</code>开始向下增长。</li>
</ul>
</li>
<li>每个CPU的<strong>TSS和TSS描述符</strong><ul>
<li>每个CPU的<code>TSS</code>被储存在其<code>CpuInfo</code>中的<code>cpu_ts</code>中，而对应的TSS描述符被定义在GDT表项<code>gdt[(GD_TSS0 &gt;&gt; 3)+i]</code>中。定义在<code>kern/trap.c</code>中的全局<code>ts</code>变量不再有作用。</li>
</ul>
</li>
<li>每个CPU的<strong>当前用户环境指针</strong><ul>
<li>每个CPU上正在运行的进程指针位于其<code>CpuInfo</code>中的<code>cpu_env</code>中。</li>
</ul>
</li>
<li>每个CPU的<strong>寄存器值</strong><ul>
<li>所有寄存器(包括系统寄存器)都是CPU所私有的，因而用于初始化这些寄存器的函数(<code>lcr3</code>，<code>lgdt</code>，<code>lidt</code>等)需要对每个CPU执行一遍。<code>env_init_percpu()</code>和<code>trap_init_percpu()</code>的功能就在于此。</li>
</ul>
</li>
</ul>
<p>除此之外，如果在之前的Lab中你有设置其他的CPU私有的初始化函数，也要在这里对每个CPU执行。</p>
<blockquote>
<p><strong>Exercise 3</strong></p>
<p>修改<code>kern/pmap.c</code>中的<code>mem_init_mp</code>函数以将CPU的内核栈映射到虚拟内存。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">mem_init_mp(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// LAB 4: Your code here:</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++) &#123;</span><br><span class="line">		boot_map_region (</span><br><span class="line">			kern_pgdir, </span><br><span class="line">			KSTACKTOP - i * (KSTKGAP + KSTKSIZE) - KSTKSIZE, </span><br><span class="line">			KSTKSIZE, </span><br><span class="line">			PADDR(percpu_kstacks[i]), </span><br><span class="line">			PTE_W</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在完成这个任务之后，我们的代码应当能够通过<code>check_kern_pgdir()</code>测试。</p>
<blockquote>
<p><strong>Exercise 4</strong></p>
<p>在<code>kern/trap.c</code>中的<code>trap_init_percpu()</code>函数为<strong>BSP</strong>初始化了TSS和TSS描述符。它能在Lab3中正常工作，但在其他CPU上运行时会出错。用每个CPU的tss去取代这个函数中的全局变量<code>ts</code>，以使其能够正常工作。</p>
</blockquote>
<p>需要改变的也就只有几个量：首先是ts要换成<code>thiscpu-&gt;cpu_ts</code>，然后就是TSS的selector要加一个<code>cpuId&lt;&lt;3</code>，还有就是CPU的栈地址需要改成新的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init_percpu(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here:</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> cpuId = thiscpu-&gt;cpu_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Taskstate</span>* <span class="title">curts</span> = &amp;<span class="title">thiscpu</span>-&gt;<span class="title">cpu_ts</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Setup a TSS so that we get the right stack</span></span><br><span class="line">	<span class="comment">// when we trap to the kernel.</span></span><br><span class="line">	curts-&gt;ts_esp0 = KSTACKTOP - cpuId * (KSTKSIZE+KSTKGAP);</span><br><span class="line">	curts-&gt;ts_ss0 = GD_KD;</span><br><span class="line">	curts-&gt;ts_iomb = <span class="keyword">sizeof</span>(struct Taskstate);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize the TSS slot of the gdt.</span></span><br><span class="line">	gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + cpuId] = SEG16(STS_T32A, (<span class="keyword">uint32_t</span>) (curts),</span><br><span class="line">		<span class="keyword">sizeof</span>(struct Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + cpuId].sd_s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Load the TSS selector (like other segment selectors, the</span></span><br><span class="line">	<span class="comment">// bottom three bicurts are special; we leave them 0)</span></span><br><span class="line">	ltr(GD_TSS0 + (cpuId &lt;&lt; <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Load the IDT</span></span><br><span class="line">	lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在做这个任务的时候一开始犯了一个很低级的错误：在声明<code>curts</code>的时候，直接将其声明为了一个新的<code>Taskstate</code>结构而非结构指针，这直接导致之后的所有操作都没有真正地改变<code>thiscpu-&gt;cpu_ts</code>的值。更致命的是这个Exercise的检查机制并没有查出这个错误，导致这个错误直到Exercise 6才引发了原因不明的<code>Triple fault</code>，给debug工作带来了极大的困难。</p>
<p><del>这个故事告诉我们，写码需谨慎，三思而后行，不要过了测试就以为没事了</del></p>
<p>在完成这个任务之后，以<code>CPUS=4</code>的命令行参数运行<code>make qemu</code>，可以得到这样的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">check_page_alloc() succeeded!</span><br><span class="line">check_page() succeeded!</span><br><span class="line">check_kern_pgdir() succeeded!</span><br><span class="line">check_page_installed_pgdir() succeeded!</span><br><span class="line">SMP: CPU 0 found 4 CPU(s)</span><br><span class="line">enabled interrupts: 1 2</span><br><span class="line">SMP: CPU 1 starting</span><br><span class="line">SMP: CPU 2 starting</span><br><span class="line">SMP: CPU 3 starting</span><br></pre></td></tr></table></figure>
<h5 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h5><p>在现在的代码中，AP在完成自己的初始化之后会进行一个无限循环(什么也不做)。在让它们进一步做出动作之前，我们需要先解决各个CPU在同时运行内核代码时会出现的<strong>竞争条件</strong>。说到竞争条件，我们首先想到的肯定是加锁——事实上，这里最简单的解决方法就是为内核加一个锁。</p>
<p><strong>大内核锁</strong>是一个全局锁，任一个用户环境在陷入内核的时候都要先获取它，并在退出内核时释放它。在这个模型中，在用户模式中的进程可以在任一数量的CPU上并行运行，但同时只能有一个进程处于内核态。</p>
<p><code>kern/spinlock.h</code>中提供了这个锁的实现<code>kernel_lock</code>和两个函数<code>lock_kernel()</code>与<code>unlock_kernel()</code>，用于方便我们的加锁与开锁操作。我们需要在<strong>四</strong>个地方使用内核锁：</p>
<ul>
<li><code>i386_init()</code>：在BSP唤醒其他CPU之前加锁</li>
<li><code>mp_main()</code>：在初始化AP之后获取锁，然后调用<code>sched_yield()</code>函数来运行用户环境。</li>
<li><code>trap()</code>：在用户环境陷入内核之前获取锁(注意不要在内核触发中断的时候也试图获取锁<del>死锁警告</del>)</li>
<li><code>env_run()</code>：在切换到用户环境之前释放锁。</li>
</ul>
<blockquote>
<p><strong>Exercise 5</strong></p>
<p>按照上面的要求给内核在适当的位置加锁。</p>
</blockquote>
<p>需要加锁的地方有四处：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">i386_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// Lab 4 multitasking initialization functions</span></span><br><span class="line">	pic_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Acquire the big kernel lock before waking up APs</span></span><br><span class="line">	<span class="comment">// Your code here:</span></span><br><span class="line"></span><br><span class="line">	lock_kernel();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Starting non-boot CPUs</span></span><br><span class="line">	boot_aps();</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">mp_main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// Your code here:</span></span><br><span class="line"></span><br><span class="line">	lock_kernel();</span><br><span class="line">	sched_yield();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Remove this after you finish Exercise 6</span></span><br><span class="line">	<span class="comment">// for (;;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">trap(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="comment">// Trapped from user mode.</span></span><br><span class="line">		<span class="comment">// Acquire the big kernel lock before doing any</span></span><br><span class="line">		<span class="comment">// serious kernel work.</span></span><br><span class="line">		<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">		assert(curenv);</span><br><span class="line">    lock_kernel();</span><br><span class="line">  	...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_run(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// Step 2</span></span><br><span class="line">	unlock_kernel();</span><br><span class="line">	env_pop_tf(&amp;e-&gt;env_tf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在完成Exercise 6之前，我们暂时还无法我们的解答是否正确。</p>
<blockquote>
<p><strong>Question</strong></p>
<p>看上去大内核锁保证了同时只能有一个CPU在内核态运行，为什么我们还是需要将不同CPU的内核栈分开？描述一个不分开内核栈所可能导致的错误场景。</p>
</blockquote>
<p>我们研究一下每个CPU开始跑用户环境时的代码：</p>
<p>在<code>mpentry.S</code>中，AP在打开分页机制之后切换了内核栈。如果在这里没有切换到一个独立的内核栈，可以看到接下来就是对<code>mp_main</code>的间接调用(和bootloader中的间接调用原理一致，这里的间接调用是因为刚刚打开分页机制，只有使用绝对地址跳转才能到达<code>0xf0000000</code>以上的高地址，如果直接调用则是相对寻址，仍留在低地址区)，<strong>这个调用会有压栈操作</strong>，且这个压栈操作发生在<code>mp_main()</code>中上内核锁之前。如果多个AP使用同一个内核栈，并行的压栈操作会引起race。</p>
<blockquote>
<p><strong>Challenge</strong></p>
<p>大内核锁虽然方便，但完全限制了内核代码并行的可能性。现代的操作系统更多地使用<strong>细粒度锁</strong>(fine-grained locking)，也就是用不同的锁去保护不同的共享区域。请尝试用细粒度锁取代大内核锁，以实现JOS内核的并行化。</p>
<p>你可以使用自旋锁来保护以下共享区域：</p>
<ul>
<li>页管理器</li>
<li>控制台驱动</li>
<li>调度器</li>
<li>你将在Part C中实现的IPC状态</li>
</ul>
</blockquote>
<p>鉴于现在实现细粒度锁可能会为之后的实验埋下潜在的bug，我决定在完成整个6.828之后再来做这个Challenge。</p>
<h5 id="Round-Robin-Scheduling"><a href="#Round-Robin-Scheduling" class="headerlink" title="Round-Robin Scheduling"></a>Round-Robin Scheduling</h5><p>你的下一个任务是实现对用户环境的轮询调度。</p>
<ul>
<li><code>kern/sched.c</code>中的<code>sched_yield()</code>函数负责从用户环境中选一个运行。它从当前在运行的环境开始在<code>envs</code>数组中循环寻找，找到第一个状态为<code>ENV_RUNNABLE</code>的环境并调用<code>env_run()</code>去运行它。</li>
<li><code>sched_yield()</code>决不能在两个CPU上运行同一个用户环境。它可以通过环境的状态是否为<code>ENV_RUNNING</code>来辨认这个环境是否已经跑在某个CPU上。</li>
<li>用户环境可以使用<code>sys_yield()</code>系统调用来让内核用<code>sched_yield()</code>将另一个进程调度到CPU。</li>
</ul>
<blockquote>
<p><strong>Exercise 6</strong></p>
<p>在<code>sched_yield()</code>中实现上面描述的机制。别忘了修改<code>syscall()</code>函数来处理新的系统调用<code>sys_yield()</code>。</p>
<p>修改<code>kern/init.c</code>来让三个(或以上)的用户环境同时运行<code>user/yield.c</code>，然后分别以不同的CPU数目运行<code>make qemu</code>，观察结果。在所有进程结束退出之后，kernel monitor应当被唤醒。</p>
</blockquote>
<p>由于最开始调用<code>sched_yield</code>的是<code>i386_init()</code>函数，<code>curenv</code>在第一次调用时为0，我们需要额外处理这种情况。其他部分基本照着上面的描述做就没什么问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">sched_yield(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">idle</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">envid_t</span> curid, i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Switch the environment</span></span><br><span class="line">	<span class="keyword">if</span> (curenv) &#123;</span><br><span class="line">		curid = ENVX(curenv-&gt;env_id);</span><br><span class="line">		i = (curid+<span class="number">1</span>) % NENV;</span><br><span class="line">		<span class="keyword">while</span> (i != curid) &#123;</span><br><span class="line">			<span class="keyword">if</span> (envs[i].env_status == ENV_RUNNABLE)</span><br><span class="line">				env_run(&amp;envs[i]);</span><br><span class="line">			i = (i+<span class="number">1</span>) % NENV;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (curenv-&gt;env_status == ENV_RUNNING)</span><br><span class="line">			env_run(&amp;envs[i]);</span><br><span class="line">	<span class="comment">// Find a environment to run</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NENV; i++)</span><br><span class="line">			<span class="keyword">if</span> (envs[i].env_status == ENV_RUNNABLE) &#123;</span><br><span class="line">				env_run(&amp;envs[i]);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sched_halt never returns</span></span><br><span class="line">	sched_halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改<code>syscall()</code>函数的时候最好去看一下新的调用对应的调用号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span></span><br><span class="line">syscall(<span class="keyword">uint32_t</span> syscallno, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2, <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Call the function corresponding to the 'syscallno' parameter.</span></span><br><span class="line">	<span class="comment">// Return any appropriate return value.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// panic("syscall not implemented");</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line">		<span class="keyword">case</span> SYS_cgetc:</span><br><span class="line">			<span class="keyword">return</span> sys_cgetc();</span><br><span class="line">		<span class="keyword">case</span> SYS_cputs:</span><br><span class="line">			sys_cputs((<span class="keyword">const</span> <span class="keyword">char</span> *)a1, a2);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">case</span> SYS_getenvid:</span><br><span class="line">			<span class="keyword">return</span> sys_getenvid();</span><br><span class="line">		<span class="keyword">case</span> SYS_env_destroy:</span><br><span class="line">			<span class="keyword">return</span> sys_env_destroy(a1);</span><br><span class="line">		<span class="keyword">case</span> SYS_yield:</span><br><span class="line">			sys_yield();</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是修改<code>kern/init.c</code>，为了让它运行<code>user/yield.c</code>三次，我们需要连续以<code>user_yield</code>(而非一开始默认的<code>user_primes</code>)调用<code>ENV_CREATE</code>函数三次：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(TEST)</span></span><br><span class="line">	<span class="comment">// Don't touch -- used by grading script!</span></span><br><span class="line">	ENV_CREATE(TEST, ENV_TYPE_USER);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="comment">// Touch all you want.</span></span><br><span class="line">	ENV_CREATE(user_yield, ENV_TYPE_USER);</span><br><span class="line">	ENV_CREATE(user_yield, ENV_TYPE_USER);</span><br><span class="line">	ENV_CREATE(user_yield, ENV_TYPE_USER);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TEST*</span></span></span><br></pre></td></tr></table></figure>
<p>全部完成后，我们以<code>make qemu</code>打开qemu，可以看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Hello, I am environment 00001000.</span><br><span class="line">Hello, I am environment 00001001.</span><br><span class="line">Hello, I am environment 00001002.</span><br><span class="line">Back in environment 00001000, iteration 0.</span><br><span class="line">Back in environment 00001001, iteration 0.</span><br><span class="line">Back in environment 00001002, iteration 0.</span><br><span class="line">Back in environment 00001000, iteration 1.</span><br><span class="line">Back in environment 00001001, iteration 1.</span><br><span class="line">Back in environment 00001002, iteration 1.</span><br><span class="line">Back in environment 00001000, iteration 2.</span><br><span class="line">Back in environment 00001001, iteration 2.</span><br><span class="line">Back in environment 00001002, iteration 2.</span><br><span class="line">Back in environment 00001000, iteration 3.</span><br><span class="line">Back in environment 00001001, iteration 3.</span><br><span class="line">Back in environment 00001002, iteration 3.</span><br><span class="line">Back in environment 00001000, iteration 4.</span><br><span class="line">All done in environment 00001000.</span><br><span class="line">[00001000] exiting gracefully</span><br><span class="line">[00001000] free env 00001000</span><br><span class="line">Back in environment 00001001, iteration 4.</span><br><span class="line">All done in environment 00001001.</span><br><span class="line">[00001001] exiting gracefully</span><br><span class="line">[00001001] free env 00001001</span><br><span class="line">Back in environment 00001002, iteration 4.</span><br><span class="line">All done in environment 00001002.</span><br><span class="line">[00001002] exiting gracefully</span><br><span class="line">[00001002] free env 00001002</span><br></pre></td></tr></table></figure>
<p>可以看到，单核模式下，各个用户环境是以轮询的方式依次被调度的。</p>
<p>以<code>make qemu CPUS=2</code>再次运行<code>qemu</code>，可以发现iteration的顺序被稍微打乱了。继续增加<code>CPUS</code>的个数到3，运行结果显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Hello, I am environment 00001000.</span><br><span class="line">Hello, I am environment 00001001.</span><br><span class="line">Hello, I am environment 00001002.</span><br><span class="line">Back in environment 00001000, iteration 0.</span><br><span class="line">Back in environment 00001001, iteration 0.</span><br><span class="line">Back in environment 00001002, iteration 0.</span><br><span class="line">Back in environment 00001000, iteration 1.</span><br><span class="line">Back in environment 00001001, iteration 1.</span><br><span class="line">Back in environment 00001002, iteration 1.</span><br><span class="line">Back in environment 00001000, iteration 2.</span><br><span class="line">Back in environment 00001001, iteration 2.</span><br><span class="line">Back in environment 00001002, iteration 2.</span><br><span class="line">Back in environment 00001000, iteration 3.</span><br><span class="line">Back in environment 00001001, iteration 3.</span><br><span class="line">Back in environment 00001002, iteration 3.</span><br><span class="line">Back in environment 00001001, iteration 4.</span><br><span class="line">Back in environment 00001002, iteration 4.</span><br><span class="line">Back in environment 00001000, iteration 4.</span><br><span class="line">All done in environment 00001001.</span><br><span class="line">All done in environment 00001002.</span><br><span class="line">All done in environment 00001000.</span><br><span class="line">[00001001] exiting gracefully</span><br><span class="line">[00001001] free env 00001001</span><br><span class="line">[00001002] exiting gracefully</span><br><span class="line">[00001002] free env 00001002</span><br><span class="line">[00001000] exiting gracefully</span><br><span class="line">[00001000] free env 00001000</span><br></pre></td></tr></table></figure>
<p>可以发现，三个用户环境在三个AP上可以完全并行运行。继续增加<code>CPUS</code>也不会改变这个结果。</p>
<blockquote>
<p><strong>Questions</strong></p>
<p>Q：在<code>env_run</code>函数的实现中你应该调用过<code>lcr3()</code>函数。在这个调用的之前和之后，你的代码都对函数的参数<code>e</code>进行了引用。为什么在系统的页目录改变过的情况下，我们仍能安全地对<code>e</code>解引用？</p>
<p>A：<code>e</code>是一个指向<code>Env</code>结构的指针，而所有的<code>Env</code>结构在虚拟内存空间中的映射地址都是<code>UENVS</code>-<code>UPAGES</code>的那片区域，这个区域在所有的用户环境中都是相同的，就算页目录切换了，<code>e</code>也只会指向相同的内容。</p>
<p>Q：在内核进行用户环境切换的时候，它必须保证旧用户环境的寄存器被妥善保存以便之后的恢复。这个过程是什么时候进行的？</p>
<p>A：用户环境申请环境切换是通过系统调用进行的，这就一定会触发中断从而进入<code>trapentry.S</code>中，系统会在那里在栈上构建出一个<code>Trapframe</code>并赋给用户环境的<code>env_tf</code>属性，从而保存用户环境的寄存器。如果是内核自己唤醒一个用户环境，<code>curenv</code>应该是<code>NULL</code>，也就没什么好保存的了。</p>
</blockquote>
<blockquote>
<p><strong>Challenge</strong></p>
<ol>
<li>用一个不那么简单的调度策略取代我们现在使用的轮询调度，比如UNIX风格的<strong>可调整的优先调度</strong>，或者更复杂的<strong>彩票调度</strong>(给每个进程发一定数量的彩票，每次调度都开票并切换到中彩的那个进程)或<strong>步幅调度</strong>。</li>
<li>改进<code>Env</code>结构以使其能够保存处理器的浮点数相关状态，并更改相关代码以使这些状态能够正确地被保存和复原，以使JOS支持浮点操作。<code>FXSAVE</code>和<code>FXRSTOR</code>操作也许会有帮助。</li>
</ol>
</blockquote>
<p>同理，这种改进型的挑战留到整个6.828完成之后再做。</p>
<h5 id="System-Calls-for-Environment-Creation"><a href="#System-Calls-for-Environment-Creation" class="headerlink" title="System Calls for Environment Creation"></a>System Calls for Environment Creation</h5><p>虽然现在你的内核已经可以在不同用户环境之下自由切换，但所有的进程仍然是在<code>i386_init()</code>函数中由内核一次创建的。我们应当实现能让用户环境自行创建新进程的系统调用。</p>
<p>UNIX系统提供了<code>fork()</code>调用作为进程创建工具。它会将父进程的整个地址空间完整地拷贝给子进程，因而创建之初两个进程唯一的区别是<code>pid</code>和<code>ppid</code>。在之后，由于两个进程的地址空间不共享，它们的地址空间会逐渐出现差别。</p>
<p>我们在这里需要实现一个不同的(更加原始的)系统调用集：</p>
<ul>
<li><code>sys_exofork()</code>：这个调用创建一个近乎空白的进程——它的用户部分地址空间是空的，而且它不能运行。两个环境在一开始会享有相同的寄存器状态。在父进程中，这个调用会返回子进程的<code>pid</code>(或一个负数错误码)；在子进程它会返回0。(<del>由于子进程的状态是不可运行，其实这个调用不会在子进程中返回，除非父进程手动改变它的状态</del>)</li>
<li><code>sys_env_set_status()</code>：用于设置一个进程的状态为<code>RUNNABLE</code>或者<code>NOT_RUNNABLE</code>。这个调用用于在子进程的初始化完成之后将其标记为可以运行。</li>
<li><code>sys_page_alloc()</code>：分配一块物理内存并将其映射到指定进程的指定地址。</li>
<li><code>sys_page_map()</code>：将一个进程的一块内存映射拷贝给另一个进程，从而实现两个进程之间的共享内存</li>
<li><code>sys_page_unmap()</code>：取消一个进程中某个地址的内存映射</li>
</ul>
<p>在以上所有函数中，进程号<code>0</code>代表着当前进程。<code>kern/env.c</code>中的<code>envid2env()</code>函数包含了这种转换机制。</p>
<blockquote>
<p><strong>Exercise 7</strong></p>
<p>实现之前描述的五个系统调用，并确保<code>syscall()</code>函数会调用它们。</p>
<p>现在，在你使用<code>envid2env()</code>的时候，可以直接将<code>checkperm</code>参数置为1。如果你发现有的系统调用参数无效，应当返回<code>-E_INVAL</code>。</p>
</blockquote>
<p><code>sys_exofork()</code>的难点应该就在如何让子进程的这个系统调用返回0上。我们在上一个Lab中知道，在父进程发出系统调用请求之后会触发中断，控制流转移到<code>trap.c</code>，并进入<code>trap_dispatch()</code>函数。我们可以发现对系统调用返回值的处理是在这里进行的，方式是设置<code>env_tf</code>中的<code>eax</code>寄存器值。</p>
<p>我们应该注意到，进行系统调用的只有父进程，子进程本身是没有发生中断的，它只会从其地址空间中<code>eip</code>所指定的代码段开始继续运行。因此，整个<code>trap.c</code>或<code>syscall.c</code>的处理是不会影响到子进程的，我们可以直接将子进程<code>tf</code>中的<code>eax</code>设置为0，而在<code>sys_exofork()</code>中返回子进程的<code>pid</code>，把父进程的返回值交给<code>trap_dispatch()</code>来处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">envid_t</span></span><br><span class="line">sys_exofork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">new_env</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	err = env_alloc(&amp;new_env, curenv-&gt;env_id);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	new_env-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">	new_env-&gt;env_tf = curenv-&gt;env_tf; </span><br><span class="line">	<span class="comment">// we don't need to change new_env's ip here</span></span><br><span class="line">	<span class="comment">// since the ip of curenv points to the caller code at 0x8000e0</span></span><br><span class="line">	new_env-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> new_env-&gt;env_id;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sys_env_set_status()</code>不难实现，仔细读一下注释和<code>envid2env</code>函数的定义就可以了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_status(<span class="keyword">envid_t</span> envid, <span class="keyword">int</span> status)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE)</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	err = envid2env(envid, &amp;env, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	env-&gt;env_status = status;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来的三个函数也没什么难点，主要考察对注释中细节的考量和对之前Lab中自己实现的函数的熟悉程度<del>以及英语阅读理解能力</del>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_alloc(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">env</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pg</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Inappropriate va</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)va &gt;= UTOP || (<span class="keyword">uintptr_t</span>)va % PGSIZE)</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	<span class="comment">// Inappropriate perm</span></span><br><span class="line">	<span class="keyword">if</span> (!(perm &amp; (PTE_U | PTE_P)) || perm &amp; ~PTE_SYSCALL)</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	err = envid2env(envid, &amp;env, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// Inappropriate envid</span></span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	pg = page_alloc(ALLOC_ZERO);</span><br><span class="line">	<span class="comment">// Out of memory</span></span><br><span class="line">	<span class="keyword">if</span> (pg == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	err = page_insert(env-&gt;env_pgdir, pg, va, perm);</span><br><span class="line">	<span class="comment">// Failed to insert page</span></span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		page_free(pg);</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_map(<span class="keyword">envid_t</span> srcenvid, <span class="keyword">void</span> *srcva,</span><br><span class="line">	     <span class="keyword">envid_t</span> dstenvid, <span class="keyword">void</span> *dstva, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">srcenv</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">dstenv</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pg</span>;</span></span><br><span class="line">	<span class="keyword">pte_t</span>* pg_ptr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Inappropriate va</span></span><br><span class="line">	<span class="keyword">if</span> (</span><br><span class="line">		(<span class="keyword">uintptr_t</span>)srcva &gt;= UTOP ||</span><br><span class="line">		(<span class="keyword">uintptr_t</span>)srcva % PGSIZE ||</span><br><span class="line">		(<span class="keyword">uintptr_t</span>)dstva &gt;= UTOP ||</span><br><span class="line">		(<span class="keyword">uintptr_t</span>)dstva % PGSIZE</span><br><span class="line">	) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	<span class="comment">// Inappropriate perm</span></span><br><span class="line">	<span class="keyword">if</span> (!(perm &amp; (PTE_U | PTE_P)) || perm &amp; ~PTE_SYSCALL)</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	<span class="comment">// Inappropriate envid</span></span><br><span class="line">	err = envid2env(srcenvid, &amp;srcenv, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	err = envid2env(dstenvid, &amp;dstenv, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	<span class="comment">// Page not exist</span></span><br><span class="line">	pg = page_lookup(srcenv-&gt;env_pgdir, srcva, &amp;pg_ptr);</span><br><span class="line">	<span class="keyword">if</span> (pg == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	<span class="comment">// Page-permission</span></span><br><span class="line">	<span class="keyword">if</span> (!(*pg_ptr &amp; PTE_W) &amp;&amp; (perm &amp; PTE_W))</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	<span class="comment">// Page-insertion</span></span><br><span class="line">	err = page_insert(dstenv-&gt;env_pgdir, pg, dstva, perm);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_unmap(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">env</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Inappropriate environment</span></span><br><span class="line">	err = envid2env(envid, &amp;env, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	<span class="comment">// Inappropriate page</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)va &gt;= UTOP || (<span class="keyword">uintptr_t</span>)va % PGSIZE)</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	page_remove(env-&gt;env_pgdir, va);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成之后，运行<code>make grade</code>应该能看到<code>Part A</code>的<code>dumbfork</code>测试通过。至此Part A结束。</p>
<blockquote>
<p><strong>Challenge</strong></p>
<p>为JOS添加一些系统调用以读取<code>curenv</code>的所有重要状态，或对这些状态进行设置。这种系统调用可以用于实现进程的<code>checkpoint</code>与<code>restore</code>。</p>
<p>在实现这些系统调用之后，编写一个用户程序，它创建一个子进程并运行一段时间，然后获取这个子进程的<code>checkpoint</code>，再在子进程继续运行一段时间之后进行<code>restore</code>。通过这种机制，你可以不断重播一个子进程的某一执行过程。</p>
</blockquote>
<h4 id="Part-B-Copy-on-Write-Fork"><a href="#Part-B-Copy-on-Write-Fork" class="headerlink" title="Part B Copy-on-Write Fork"></a>Part B Copy-on-Write Fork</h4><p>我们现在采取的<code>fork</code>策略是在产生新进程的同时将整个父进程的地址空间中所有页的内容拷贝到子进程中，而这是非常低效的方式。尤其是，子进程一般只会使用父进程地址空间中的一小部分内容。</p>
<p>因而，现代Linux操作系统采取的策略一般是让新创建出的子进程与父进程<strong>共享内存</strong>直到<strong>它们中的一个真正去改变共享的一块内存</strong>。这种广为人知的策略被称为“<strong>写时复制</strong>”。</p>
<p>写时复制的详细机制是，在<code>fork</code>操作执行后只将父进程的页目录拷贝给子进程(而不拷贝页的内容)，同时将所有的已共享的页面标记为<strong>只读的</strong>。这样一来，当两个进程之一试图去访问这块内存时，就会触发一个<code>page fault</code>，内核判断出这个错误是因为写时复制引发的，于是它为那个引发错误的进程分配一块内容相同的可写的新页面并将引发错误的地址重新映射到这个页面上。</p>
<p>接下来你需要以一个<strong>用户库函数</strong>的方式实现上面描述的<code>fork()</code>。不将其作为内核函数的目的是让内核保持简洁，而且用户可以以修改库函数的方式更方便地去定制自己需要的<code>fork()</code>版本。</p>
<h5 id="User-level-page-fault-handling"><a href="#User-level-page-fault-handling" class="headerlink" title="User-level page fault handling"></a>User-level page fault handling</h5><p>为了实现用户级的写时复制，我们首先需要让用户具有获知和处理由写权限问题引发的<code>Page fault</code>的能力。</p>
<p>要赋予用户进程这种权限，我们需要为<code>Env</code>结构增加一个成员——<code>env_pgfault_upcall</code>，它是一个函数指针，指向用户进程提供的一个<code>page fault</code>处理函数。为了让用户能够向内核注册这个处理函数，我们提供了新的系统调用<code>sys_env_set_pgfault_upcall</code>。</p>
<blockquote>
<p><strong>Exercise 8</strong></p>
<p>实现<code>sys_env_set_pgfault_upcall</code>系统调用。这是一个危险的系统调用，因此一定要在查找目标环境的时好好利用权限检查参数。</p>
</blockquote>
<p>实现完系统调用函数之后一定不要忘记把它的入口加到<code>syscall</code>函数里，这点很重要。(<del>我才不会说我直到<code>Exercise 11</code>才发现自己没修改<code>syscall</code>函数</del>)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_pgfault_upcall(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *func)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">env</span>;</span></span><br><span class="line"></span><br><span class="line">	err = envid2env(envid, &amp;env, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	env-&gt;env_pgfault_upcall = func;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Normal-and-Exception-Stacks-in-User-Environments"><a href="#Normal-and-Exception-Stacks-in-User-Environments" class="headerlink" title="Normal and Exception Stacks in User Environments"></a>Normal and Exception Stacks in User Environments</h5><p>在正常情况下，用户环境所使用的程序栈应当是<code>USTACKTOP</code>开始向下增长的用户栈，但如果用户环境需要去处理一个<code>page fault</code>，它就必须切换栈。我们可以让JOS去建立一个新的异常处理栈，并替用户进程将程序栈自动切换到这个异常栈。</p>
<p>JOS早就为这个栈规划好了位置：它从<code>UXSTACKTOP</code>开始向下增长，最大大小为一个<code>PGSIZE</code>。用户的<code>PGFLT</code>处理函数应当用系统调用来调整内存映射关系使其正确，然后通过一小段汇编代码返回到原来的栈。</p>
<p>用户异常栈默认是未分配内存的，因此所有想要使用这个异常栈的进程都需要自己使用<code>sys_page_alloc()</code>系统调用来为这个栈分配内存。</p>
<h5 id="Invoking-the-User-Page-Fault-Handler"><a href="#Invoking-the-User-Page-Fault-Handler" class="headerlink" title="Invoking the User Page Fault Handler"></a>Invoking the User Page Fault Handler</h5><p>你现在需要修改<code>kern/trap.c</code>中的异常处理函数来以用户提供的方法处理缺页异常。我们将<strong>错误发生时用户环境所处的状态</strong>称为<strong>异常时状态</strong>(<strong>trap-time state</strong>)。</p>
<p>如果用户环境没有提供异常处理程序，内核像往常一样直接销毁用户进程；否则，内核在用户异常栈上建立一个<code>UTrapframe</code>，并让用户进程在异常栈上运行处理程序。</p>
<p>如果用户进程在处理缺页错误的期间再次触发了缺页错误，不要重新从<code>UXSTACKTOP</code>开始建立异常栈，而是在当前的异常栈上压入一个<code>32位</code>空数据，然后建立新的<code>UTrapframe</code>。(要检查发生缺页错误时用户进程是否在处理缺页错误，只需检查<code>tf-&gt;tf_esp</code>是否位于<code>UXSTACKTOP-PGSIZE</code>和<code>UXSTACKTOP-1</code>之间，包括边界)。</p>
<blockquote>
<p><strong>Exercise 9</strong></p>
<p>完善<code>page_fault_handler()</code>以实现上面描述的机制，注意做好对异常栈的权限检查。</p>
</blockquote>
<p>这个任务的重点是搞清楚<code>curenv-&gt;env_tf</code>、<code>tf</code>和<code>utf</code>三个<code>Trapframe</code>之间的关系。</p>
<p>回顾之前实现的<code>env_run</code>函数可以发现，<code>curenv-&gt;env_tf</code>是用于在这个进程被调度时恢复其上下文。我们需要在这个系统调用中将控制权转交给用户进程，并让其执行它所注册的异常处理函数，这就需要分别修改<code>curenv-&gt;env_tf</code>中的<code>eip</code>和<code>esp</code>为<strong>异常处理函数的首地址</strong>与<strong>用户异常栈中<code>UTrapframe</code>后的地址</strong>。</p>
<p>从<code>tf</code>到<code>utf</code>其实就是内核的中断处理程序将控制权交给了用户进程，中间并没有发生其他的中断，因而<code>tf</code>和<code>utf</code>的含义作用都差不多相同，完全可以将<code>tf</code>的大部分信息原样拷贝给<code>utf</code>。</p>
<p>回顾<code>trap</code>函数可以发现，<strong><code>tf</code>在此时与<code>curenv-&gt;env_tf</code>指向的是相同的东西，也就是修改两者其实是等效的。</strong>换句话说，<strong>我们必须注意修改<code>curenv-&gt;env_tf</code>和引用<code>tf</code>的值两个操作的先后顺序</strong>，因为在进行前者后<code>tf</code>的值也会改变。</p>
<p>另外，要注意不要每次都用<code>user_mem_assertion</code>去检查整个<code>UXSTACK</code>的权限，而应该每次只检查用户是否有对<code>utf</code>所在的一小片栈内存的写权限。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_fault_handler(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> fault_va;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Read processor's CR2 register to find the faulting address</span></span><br><span class="line">	fault_va = rcr2();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Handle kernel-mode page faults.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Kernel represents privilege level 0</span></span><br><span class="line">	<span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">0x3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		print_trapframe(tf);</span><br><span class="line">		panic(<span class="string">"Error: page fault triggered by kernel."</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span> *<span class="title">utf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> *<span class="title">curtf</span> = &amp;<span class="title">curenv</span>-&gt;<span class="title">env_tf</span>;</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> stack_addr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If no handler provided, skip this and destroy the environment.</span></span><br><span class="line">	<span class="keyword">if</span> (curenv-&gt;env_pgfault_upcall != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (tf-&gt;tf_esp &gt;= UXSTACKTOP - PGSIZE &amp;&amp; tf-&gt;tf_esp &lt;= UXSTACKTOP - <span class="number">1</span>)</span><br><span class="line">			stack_addr = tf-&gt;tf_esp - <span class="number">4</span> - <span class="keyword">sizeof</span>(struct UTrapframe); <span class="comment">// Nested page fault</span></span><br><span class="line">		<span class="keyword">else</span> stack_addr = UXSTACKTOP - <span class="keyword">sizeof</span>(struct UTrapframe); <span class="comment">// Usual page fault</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check user's permittion of the exception stack</span></span><br><span class="line">		user_mem_assert(curenv, (<span class="keyword">void</span> *)stack_addr, <span class="keyword">sizeof</span>(struct UTrapframe), PTE_U | PTE_W);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// push a UTrapframe</span></span><br><span class="line">		utf = (struct UTrapframe *)(stack_addr);</span><br><span class="line">		utf-&gt;utf_eflags = tf-&gt;tf_eflags;</span><br><span class="line">		utf-&gt;utf_eip = tf-&gt;tf_eip;</span><br><span class="line">		utf-&gt;utf_err = tf-&gt;tf_err;</span><br><span class="line">		utf-&gt;utf_esp = tf-&gt;tf_esp;</span><br><span class="line">		utf-&gt;utf_regs = tf-&gt;tf_regs;</span><br><span class="line">		utf-&gt;utf_fault_va = fault_va;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Set entry point</span></span><br><span class="line">		curtf-&gt;tf_eip = (<span class="keyword">uintptr_t</span>)curenv-&gt;env_pgfault_upcall;</span><br><span class="line">		curtf-&gt;tf_esp = stack_addr;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Rerun curenv</span></span><br><span class="line">		env_run(curenv);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">	cprintf(<span class="string">"[%08x] user fault va %08x ip %08x\n"</span>,</span><br><span class="line">		curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">	print_trapframe(tf);</span><br><span class="line">	env_destroy(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="User-mode-Page-Fault-Entrypoint"><a href="#User-mode-Page-Fault-Entrypoint" class="headerlink" title="User-mode Page Fault Entrypoint"></a>User-mode Page Fault Entrypoint</h5><p>接下来我们要完成的是在<code>curenv-&gt;env_pgfault_upcall</code>中注册的异常处理程序。这是一段汇编程序，它负责调用C处理函数来处理异常，并在处理完成之后将控制权<strong>直接返还给触发中断的代码</strong>。</p>
<blockquote>
<p><strong>Exercise 10</strong></p>
<p>实现<code>lib/pfentry.S</code>中的<code>_pgfault_upcall</code>过程。</p>
</blockquote>
<p>关于调用C程序进行中断处理的汇编代码已经被6.828提供了，我们需要考虑的是如何以恰当的状态返回<strong>异常时eip</strong>。我们现在可以调度的资源是一个位于栈上的<code>UTrapframe</code>，以及随着上下文的恢复越来越少的可用寄存器。本任务的主要难点是，如何在不影响通用寄存器状态的情况下同时进行栈的切换和控制流的转移。</p>
<p>在即将跳转回异常时<code>eip</code>的时候，我们已经恢复了所有通用寄存器的值和<code>esp</code>的值，这代表着我们既无法利用<code>jmp</code>进行跳转(这需要一个目标地址，而我们不能用寄存器储存这个地址)，又无法直接用<code>ret</code>返回(会改变<code>esp</code>指针的值)。一个自然的解决方案是，在切换栈之前先将<code>异常时eip</code>装载到<code>异常时栈</code>的顶端，并在切换栈的时候将<code>esp</code>的值减小<code>0x4</code>，最后使用<code>ret</code>返回的时候就会取出<code>异常时eip</code>作为返回地址，并使<code>esp</code>的值增大<code>0x4</code>，这样就正好达到了我们的目的。</p>
<p>对于一般的缺页异常，由于栈顶以上是空的，这样做自然没有风险；对嵌套的缺页异常，由于我们之前在两个<code>UTrapframe</code>之间压入了一个<code>32位</code>的空数据，这个<code>padding</code>正好可以装下这个<code>异常时eip</code>。这就是之前我们要压入这个空数据的原因。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// LAB 4: Your code here.</span><br><span class="line"></span><br><span class="line">movl 0x28(%esp), %eax // trap-time eip</span><br><span class="line">subl $0x4, 0x30(%esp)</span><br><span class="line">movl 0x30(%esp), %ebx // trap-time esp</span><br><span class="line">movl %eax, (%ebx)   // push trap-time %eip onto trap-time stack</span><br><span class="line">addl $0x8, %esp</span><br><span class="line"></span><br><span class="line">// Restore the trap-time registers.  After you do this, you</span><br><span class="line">// can no longer modify any general-purpose registers.</span><br><span class="line">// LAB 4: Your code here.</span><br><span class="line"></span><br><span class="line">popal</span><br><span class="line">addl $0x4, %esp</span><br><span class="line"></span><br><span class="line">// Restore eflags from the stack.  After you do this, you can</span><br><span class="line">// no longer use arithmetic operations or anything else that</span><br><span class="line">// modifies eflags.</span><br><span class="line">// LAB 4: Your code here.</span><br><span class="line"></span><br><span class="line">popfl</span><br><span class="line"></span><br><span class="line">// Switch back to the adjusted trap-time stack.</span><br><span class="line">// LAB 4: Your code here.</span><br><span class="line"></span><br><span class="line">popl %esp</span><br><span class="line"></span><br><span class="line">// Return to re-execute the instruction that faulted.</span><br><span class="line">// LAB 4: Your code here.</span><br><span class="line"></span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Exercise 11</strong></p>
<p>实现<code>lib/pgfault.c</code>中的<code>set_pgfault_handler()</code>函数。</p>
</blockquote>
<p>这个函数无非就是给之前实现的系统调用套了层壳，并且在进行系统调用之前首先为<code>UXSTACK</code>分配内存。没什么好说的，按照注释完成即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">set_pgfault_handler(<span class="keyword">void</span> (*handler)(struct UTrapframe *utf))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (_pgfault_handler == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// First time through!</span></span><br><span class="line">		<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">		<span class="keyword">if</span> ((r = sys_page_alloc(<span class="number">0</span>, (<span class="keyword">void</span> *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">			panic(<span class="string">"set_pgfault_handler: %e"</span>, r);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Save handler pointer for assembly to call.</span></span><br><span class="line">	_pgfault_handler = handler;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = sys_env_set_pgfault_upcall(<span class="number">0</span>, _pgfault_upcall)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"set_pgfault_handler: %e"</span>, r);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此为止，运行<code>make grade</code>应当能够通过<code>faulttree</code>之前的所有测试。如果<code>faultalloc</code>和<code>faultallocbad</code>测试出了问题，很可能是没有理解<code>tf</code>和<code>curenv-&gt;env_tf</code>之间的关系；如果<code>faultnostack</code>及其后面的测试出了问题，很可能是<code>user_mem_assertion</code>的调用参数有问题。</p>
<blockquote>
<p><strong>Challenge</strong></p>
<p>拓展你的内核实现，使得除了pagefault以外的其他中断也能够由用户来自定义处理程序。</p>
</blockquote>
<h5 id="Implementing-Copy-on-Write-Fork"><a href="#Implementing-Copy-on-Write-Fork" class="headerlink" title="Implementing Copy-on-Write Fork"></a>Implementing Copy-on-Write Fork</h5><p>在实现了用户级别的pagefault处理逻辑之后，我们就可以利用这些系统调用来实现一个完整的、写时复制的<code>fork</code>调用了，6.828已经在<code>lib/fork.c</code>中提供了这个函数的框架。</p>
<p>与<code>dumbfork</code>不同的是，<code>fork</code>并不会将页面本身拷贝到新进程，而是拷贝页面的映射关系。<code>fork</code>只有在有进程试图去修改某个页面的时候才会真正地将页面拷贝过来。</p>
<p><code>fork</code>的基本逻辑如下：</p>
<ul>
<li>父进程使用之前实现了的<code>set_pgfault_handler()</code>函数来将<code>pgfault</code>函数安装为缺页中断处理程序。</li>
<li>父进程调用<code>sys_exofork()</code>来创建一个子进程。</li>
<li>父进程对每一个<code>UTOP</code>以下的<strong>可写的或写时复制的</strong>页面调用<code>duppage</code>函数，这个函数会把一个页面以<strong>写时复制权限</strong>(<code>PTE_COW</code>)映射到子进程中，并将其以写时复制权限<strong>重新映射</strong>到父进程。<ul>
<li>这里的先后顺序很重要，因为<strong>xxxxx</strong></li>
<li>以写时复制权限映射是指，取消权限<code>PTE_W</code>以使其不可写，但加上权限<code>PTE_COW</code>以使其区别于普通的只读页。</li>
<li><strong>用户异常栈</strong>不能通过这种方式被映射，你需要为子进程分配一个新的页面作为它的异常栈。</li>
<li><code>fork</code>也需要处理那些不是可写的或写时复制的页面。</li>
</ul>
</li>
<li>父进程为子进程设置相同的pagefault处理程序入口。</li>
<li>父进程将子进程标记为可运行的。</li>
</ul>
<p>每当其中一个进程试图写一个权限为写时复制的页面时，都会触发pagefault。<code>pgfault</code>处理函数的逻辑如下：</p>
<ul>
<li>检查错误号是否为<code>FEC_WR</code>(是否是写操作导致了中断)，并检查引发中断的页面的<code>PTE</code>是否是写时复制的。</li>
<li>如果是，分配一个新页面并将原页面的内容拷贝过去，然后将新页面以可读可写权限映射到合适的位置，取代原来的映射。如果不是，panic。</li>
</ul>
<p>由于<code>fork</code>函数是用户进程执行的函数，它并没有使用<code>pgdir_walk</code>等内核函数的权限和途径。在用户的角度，无论是页目录还是页表都是不可见的。然而，我们又需要对页目录表项的权限位进行判断。JOS采用了一种巧妙的机制来让用户进程们也能访问到pte和pde，那就是<code>UVPT</code>机制。</p>
<p>我们知道，每个4GB虚拟地址空间对应一个页目录，一个页目录包含1024个页表，每个页表有1024页，每页的大小是4KB，最终形成4GB地址空间。在解析一个线性地址时，MMU会跟据其PDX，PTX和OFFSET三个部分依次去在页目录和页表中进行索引。</p>
<p><code>UVPT</code>是页目录中的一个特殊的表项，它指向的是页目录自身。假设<code>UVPT</code>的索引值是<code>V</code>，如果我们用一个PDX和PTX都是V的线性地址去进行解析，就会发现由于在页目录中对第V个表项的索引仍然是页目录本身的地址，这个地址最终解析出的就是页目录的物理地址。同理，如果PDX为V而PTX不为V，则会解析出各个页表的地址。通过这种方式，用户可以在<code>UVPT</code>内存区中访问到页目录和各个页表。</p>
<blockquote>
<p><strong>Exercise 12</strong></p>
<p>按照上面描述的逻辑完成<code>fork()</code>、<code>duppage()</code>和<code>pgfault()</code>三个函数。</p>
</blockquote>
<p><code>memlayout.h</code>中已经根据上面对<code>UVPT</code>机制的定义为我们声明好了<code>uvpd</code>和<code>uvpt</code>两个数组，其中<code>uvpd</code>的内容是所有页表的地址，索引是<code>PDX(addr)</code>；<code>uvpt</code>的内容是页目录中所有的页表表项，所以这里不是用<code>PTX(addr)</code>而是<code>PGNUM(addr)</code>为索引。</p>
<p>对地址的映射分为两步：首先，对于<code>0</code>到<code>USTACKTOP</code>的部分，也就是不包含<code>UXSTACK</code>的整个用户地址空间，我们依次对每一页调用duppage进行映射。注意在映射之前不仅要检查这一页是否有<code>PTE_P | PTE_U</code>，还要检查其所在的页表是否有<code>PTE_P</code>。然后，调用<code>sys_page_alloc</code>系统调用为<code>UXSTACK</code>分配新的内存。</p>
<p>另外需要注意的是，对子进程设置pagefault处理程序是不能用<code>set_pagefault_handler</code>的，而调用<code>sys_env_set_pagefault_handler</code>调用是需要以<code>_pgfault_upcall</code>而不是<code>pgfault</code>为参数的，这个区别很重要。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">envid_t</span></span><br><span class="line">fork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// uvpt and uvpd are defined in memlayout.h:</span></span><br><span class="line">	<span class="comment">// pte_t uvpt[];</span></span><br><span class="line">	<span class="comment">// pde_t uvpd[];</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="keyword">uintptr_t</span> addr;</span><br><span class="line">	<span class="keyword">envid_t</span> envid;</span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">void</span> _pgfault_upcall();</span><br><span class="line"></span><br><span class="line">	set_pgfault_handler(pgfault);</span><br><span class="line">	</span><br><span class="line">	envid = sys_exofork();</span><br><span class="line">	<span class="keyword">if</span> (envid &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> envid;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (envid == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// We are the child.</span></span><br><span class="line">		<span class="comment">// Fix thisenv as we did i dumbfork.c and return 0</span></span><br><span class="line">		thisenv = &amp;envs[ENVX(sys_getenvid())];</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We are the parent.</span></span><br><span class="line">	<span class="keyword">for</span> (addr = <span class="number">0</span>; addr &lt; USTACKTOP; addr += PGSIZE) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_U)) &#123;</span><br><span class="line">			duppage(envid, addr / PGSIZE);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((err = sys_page_alloc(envid, (<span class="keyword">void</span> *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((err = sys_env_set_pgfault_upcall(envid, _pgfault_upcall)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span> ((err = sys_env_set_status(envid, ENV_RUNNABLE)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> envid;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将检查页面权限的步骤放到了<code>duppage</code>函数中，这与要求略有不同但效果是一样的。由于是对同一个页面进行映射，这里需要使用的是<code>sys_page_map</code>调用。这个调用可以用来建立一个物理页面到两个虚拟地址空间的映射，也可以用于一个虚拟空间内某个页面的重新映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">duppage(<span class="keyword">envid_t</span> envid, <span class="keyword">unsigned</span> pn)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">void</span> *pg = (<span class="keyword">void</span> *)(pn * PGSIZE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (uvpt[pn] &amp; PTE_W || uvpt[pn] &amp; PTE_COW) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, pg, envid, pg, PTE_P | PTE_U | PTE_COW)) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, pg, <span class="number">0</span>, pg, PTE_P | PTE_U | PTE_COW)) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, pg, envid, pg, PTE_P | PTE_U)) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释中提示我们<code>pgfault</code>函数只需要三个系统调用，需要仔细考虑我们需要哪三个调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pgfault(struct UTrapframe *utf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> *addr = (<span class="keyword">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line">	<span class="keyword">uint32_t</span> err = utf-&gt;utf_err;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check that the faulting access was (1) a write, and (2) to a</span></span><br><span class="line">	<span class="comment">// copy-on-write page.  If not, panic.</span></span><br><span class="line">	<span class="comment">// Hint:</span></span><br><span class="line">	<span class="comment">//   Use the read-only page table mappings at uvpt</span></span><br><span class="line">	<span class="comment">//   (see &lt;inc/memlayout.h&gt;).</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">uintptr_t</span> fault_page = ROUNDDOWN((<span class="keyword">uintptr_t</span>)addr, PGSIZE);</span><br><span class="line">	<span class="keyword">if</span> (!(</span><br><span class="line">		(err &amp; FEC_WR) &amp;&amp;</span><br><span class="line">		(uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp;</span><br><span class="line">		(uvpt[PGNUM(addr)] &amp; PTE_P) &amp;&amp;</span><br><span class="line">		(uvpt[PGNUM(addr)] &amp; PTE_COW))</span><br><span class="line">	)	panic(<span class="string">"Page fault at a non-copy-on-write page."</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate a new page, map it at a temporary location (PFTEMP),</span></span><br><span class="line">	<span class="comment">// copy the data from the old page to the new page, then move the new</span></span><br><span class="line">	<span class="comment">// page to the old page's address.</span></span><br><span class="line">	<span class="comment">// Hint:</span></span><br><span class="line">	<span class="comment">//   You should make three system calls.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_alloc(<span class="number">0</span>, PFTEMP, PTE_P | PTE_U | PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"pgfault: failed to alloc page PFTEMP."</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(PFTEMP, (<span class="keyword">void</span> *)fault_page, PGSIZE);</span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, PFTEMP, <span class="number">0</span>, (<span class="keyword">void</span> *)fault_page, PTE_P | PTE_U | PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"pgfault: failed to remap the faulted page."</span>);</span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_unmap(<span class="number">0</span>, PFTEMP)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"pgfault: failed to unmap the faulted page."</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现这三个函数后，代码应当能够通过<code>Part B</code>部分的所有测试。至此Part B结束。</p>
<blockquote>
<p><strong>Challenge</strong></p>
<ol>
<li><p>实现一种特殊的<strong>共享内存的</strong>fork：<code>sfork</code>。这种fork会使父子进程共享<strong>除栈以外</strong>的所有内存空间，只对栈区进行写时复制处理。你可以修改<code>forktree</code>和<code>pingpong</code>两个测试来使用<code>sfork</code>取代<code>fork</code>，你可能会发现能提供<code>thisenv</code>功能的一种新方式。</p>
</li>
<li><p>实现对系统调用的<strong>批处理</strong>，以减少连续多次系统调用所带来的陷入和离开内核开支。你需要修改系统调用接口来使其支持这个特性，然后修改<code>fork</code>函数以利用这个特性。</p>
</li>
</ol>
</blockquote>
<h4 id="Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC"><a href="#Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC" class="headerlink" title="Part C: Preemptive Multitasking and Inter-Process communication (IPC)"></a>Part C: Preemptive Multitasking and Inter-Process communication (IPC)</h4><p>在这一部分你需要实现<strong>进程的抢占式非合作调度</strong>和<strong>进程间的显式消息传递</strong>。</p>
<h5 id="Interrupt-discipline"><a href="#Interrupt-discipline" class="headerlink" title="Interrupt discipline"></a>Interrupt discipline</h5><p>试着运行<code>user/spin</code>测试程序，我们可以发现用户进程的一个死循环就可以导致整个系统都无法得到CPU的控制权。由于轮询调度的局限性，如果用户进程不主动给出控制权，其他进程和内核就无法获取CPU，这个情况显然不是理想的。我们需要扩展JOS内核以支持外部的硬件中断，以使内核能够从一个运行中的进程那里夺回控制权。</p>
<p>在Lab3中我们处理了各种处理器异常，也就是<code>trap</code>，而设备引起的<strong>外部中断</strong><code>IRQ</code>还没有被处理。共有16个可能的<code>IRQ</code>，它们以0-15的顺序被分别映射到IDT中的<code>IRQ_OFFSET-IRQ_OFFSET+15</code>区域。<code>IRQ_OFFSET</code>被选定为一个让<code>IRQ</code>和处理器异常不会重叠的值，以避免一个IDT表项要处理两个中断这样的冲突。</p>
<p>控制外部设备中断的是<strong><code>EFLAGS</code>寄存器中的<code>IF</code>标志位</strong>，为了简单起见，我们只在用户模式下允许外部设备中断，而在进入内核的时候关闭外部中断。我们需要保证<code>FL_IF</code>标志在用户环境开始运行时被设置，这样在中断到来时才会经过CPU被我们的处理程序所处理。在此之前，外部中断一直是被屏蔽的。</p>
<blockquote>
<p><strong>Exercise 13</strong></p>
<p>修改<code>kern/trapentry.S</code>和<code>kern/trap.c</code>来恰当地处理IRQ们，然后修改<code>env_alloc</code>函数以保证用户进程在能接受外部终端的状态下运行。需要注意，所有IRQ都不会压入error code。</p>
<p>另外，取消<code>sched_halt()</code>函数中<code>sti</code>的注释，这样空闲的CPU就不会屏蔽中断。</p>
</blockquote>
<p>由于之前已经写过对trap的处理，这里要写的也是异曲同工。代码难度不大又比较分散，这里就不贴了。</p>
<p>在这个Exercise中一个需要注意的点是关于<code>SETGATE</code>的参数。由于我们要在进入内核时将<code>FL_IF</code>标志重置为0以关闭外部中断，<strong>所有能够进入内核的GATE(不管是trap还是interrupt)都要将<code>istrap</code>参数设置为0。</strong>这点与注释中对<code>istrap</code>的阐述有所区别，注释的意思似乎是这个参数用于区分是trap还是interrupt，但由于JOS采用了比较简单的外部中断使用策略，只要进入内核就应该关闭外部中断，而<code>istrap</code>参数的真正作用其实是开启和关闭<code>IF</code>标志位，所以我们应当将所有<code>SETGATE</code>函数的<code>istrap</code>参数设置为0。<strong>如果不这么做的话，代码无法通过<code>trap</code>函数中的<code>assert(!(read_eflags() &amp; FL_IF));</code>断言。</strong></p>
<p>在完成这个Exercise之后，试着去运行一个包含硬件中断的test可以发现内核会打印出设备中断的Trapframe。</p>
<h5 id="Handling-Clock-Interrupts"><a href="#Handling-Clock-Interrupts" class="headerlink" title="Handling Clock Interrupts"></a>Handling Clock Interrupts</h5><p>为了防止某一个用户进程一直霸占着CPU，我们应重新对硬件进行编程以使其周期性地产生<strong>时钟中断</strong>以使控制流回到内核，从而调度给另一个进程。</p>
<p>6.828已经在<code>init.c</code>的<code>i386_init</code>函数中写好了对<code>lapic_init</code>和<code>pic_init</code>的调用，它们会设定好产生中断的时钟。我们只需要完成处理这些中断的代码即可。</p>
<blockquote>
<p><strong>Exercise 14</strong></p>
<p>修改<code>trap_dispatch</code>函数，使其在接收到一个时钟中断时调用<code>sched_yield</code>去运行另一个用户进程。</p>
</blockquote>
<p>加一个case即可(不要漏看了前面的注释，要调用<code>lapic_eoi</code>来通知cpu出现了中断)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IRQ_OFFSET+IRQ_TIMER:</span><br><span class="line">  lapic_eoi();</span><br><span class="line">  sched_yield();</span><br></pre></td></tr></table></figure>
<p>完成这个任务后，运行<code>make grade</code>应该能拿到<code>65/80</code>的成绩。</p>
<h5 id="Inter-Process-communication-IPC"><a href="#Inter-Process-communication-IPC" class="headerlink" title="Inter-Process communication (IPC)"></a>Inter-Process communication (IPC)</h5><p>在之前我们一直将注意力集中在保持一种“每个进程都独占CPU”的抽象上面，但操作系统的另一个重要功能是允许各个进程之间进行通信。IPC是进程间交互的强大支持，UNIX的<strong>管道</strong>机制就是其典型应用。</p>
<p>在JOS中我们不会去涉及一些复杂的进程间通信模型，而是将通信机制简化为两个系统调用：<code>sys_ipc_recv</code>和<code>sys_ipc_try_send</code>。进程用这种机制传递的信息由两部分组成：<strong>一个32位整数</strong>和<strong>一个可选的页面映射</strong>。传递页面映射显然可以传递比一个32位整数更多的信息，而且它提供了一种实现共享内存的方便方式。</p>
<h5 id="Sending-and-Receiving-Messages"><a href="#Sending-and-Receiving-Messages" class="headerlink" title="Sending and Receiving Messages"></a>Sending and Receiving Messages</h5><p>当一个用户进程要接受信息的时候，它会进行<code>sys_ipc_recv</code>系统调用。这个调用会将进程挂起直到<strong>任何一个</strong>其他进程向其发送信息。这里的“任何一个”是指发送该信息的进程不需要和这个用户进程有任何关系。换句话说，之前在Part A中实现的权限检查并没必要应用到这里，因为一个进程并没法通过发送信息让另一个进程运行失常。</p>
<p>要发送一个信息，进程必须以目标进程的<code>envid</code>和要发送的值为参数调用<code>sys_ipc_try_send</code>。如果目标进程在等待接受状态，这个调用会发送这个值并返回0；否则，它会返回<code>-E_IPC_NOT_RECV</code>来说明情况。</p>
<p>如果<code>sys_ipc_recv</code>的参数是一个<code>UTOP</code>下的虚拟地址<code>dstva</code>，说明接收者希望接受一个页面。当收到页面后，这个调用会将收到的页面映射到<code>dstva</code>，并覆盖掉之前的映射。同理，如果<code>sys_ipc_try_send</code>的参数是一<code>srcva</code>，它会将目前映射在<code>srcva</code>的页面发送给目标进程，同时自己保持原有的映射不变。只要两个进程之一没有声明要发送的是页面，就不会有页面被发送。</p>
<p>在IPC完成后，内核会设置接收者的<code>Env</code>结构的<code>env_ipc_perm</code>成员：</p>
<ul>
<li>没有接受页面：<code>0</code></li>
<li>接收到的页面权限为<code>perm</code>：<code>perm</code></li>
</ul>
<blockquote>
<p><strong>Exercise 15</strong></p>
<p>根据上面描述的逻辑实现两个IPC系统调用和包装它们的库函数，并在<code>systemcall</code>函数中添加对这两个调用的处理逻辑。当在这两个调用中使用<code>envid2env</code>函数时，可以将<code>checkperm</code>参数设为0。</p>
</blockquote>
<p>要完成这个任务，注释很重要。只要将6.828提供的注释搞清楚了，大部分难点就都被解决了。</p>
<p>另外需要注意的是，在之前Lab3的实现中我们可能对一些不会出现的情况进行了panic处理(比如，<code>env_run</code>调用时当前进程状态不是<code>ENV_RUNNING</code>；<code>syscall</code>函数返回值不为0等)，在这里这些异常情况可能不再异常，因而我们可能会需要取消一些<code>panic</code>语句。</p>
<p>两个系统调用的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_ipc_try_send(<span class="keyword">envid_t</span> envid, <span class="keyword">uint32_t</span> value, <span class="keyword">void</span> *srcva, <span class="keyword">unsigned</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">target_env</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pgptr</span>;</span></span><br><span class="line">	<span class="keyword">pte_t</span>* page;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Bad environment</span></span><br><span class="line">	<span class="keyword">if</span> (envid2env(envid, &amp;target_env, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Target env is not recving</span></span><br><span class="line">	<span class="keyword">if</span> (target_env-&gt;env_ipc_recving == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We are at least able to send a value</span></span><br><span class="line">	target_env-&gt;env_ipc_recving = <span class="number">0</span>;</span><br><span class="line">	target_env-&gt;env_ipc_value = value;</span><br><span class="line">	target_env-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We need to send a page</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)srcva &lt; UTOP &amp;&amp; target_env-&gt;env_ipc_dstva != (<span class="keyword">void</span> *)~<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)srcva % PGSIZE)</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		<span class="keyword">if</span> (!(perm &amp; (PTE_U | PTE_P)) || perm &amp; ~PTE_SYSCALL)</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		pgptr = page_lookup(curenv-&gt;env_pgdir, srcva, &amp;page);</span><br><span class="line">		<span class="keyword">if</span> (!page)</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		<span class="keyword">if</span> ((perm &amp; PTE_W) &amp;&amp; !(*page &amp; PTE_W))</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		<span class="keyword">if</span> (page_insert(target_env-&gt;env_pgdir, pgptr, target_env-&gt;env_ipc_dstva, perm) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">		target_env-&gt;env_ipc_perm = perm;</span><br><span class="line">	&#125; <span class="keyword">else</span> target_env-&gt;env_ipc_perm = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	target_env-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">	target_env-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_ipc_recv(<span class="keyword">void</span> *dstva)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)dstva &lt; UTOP) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)dstva % PGSIZE != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    curenv-&gt;env_ipc_dstva = dstva;</span><br><span class="line">	&#125; <span class="keyword">else</span> curenv-&gt;env_ipc_dstva = (<span class="keyword">void</span> *)~<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	curenv-&gt;env_ipc_recving = <span class="number">1</span>;</span><br><span class="line">	curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">	sched_yield();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包装两个系统调用的库函数代码如下，注意这里注释提示我们选择一个不为0的特殊<code>va</code>来表明我们不希望传递页面映射，这里其实<code>UTOP</code>以上的<code>va</code>都是符合要求的，简单起见我们使用<code>0xffffffff</code>，也就是<code>~0</code>作为这个地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span></span><br><span class="line">ipc_recv(<span class="keyword">envid_t</span> *from_env_store, <span class="keyword">void</span> *pg, <span class="keyword">int</span> *perm_store)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We use ~0 to indicate that no page should be sent.</span></span><br><span class="line">	<span class="keyword">if</span> (pg == <span class="literal">NULL</span>)</span><br><span class="line">		err = sys_ipc_recv((<span class="keyword">void</span> *)~<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">else</span> err = sys_ipc_recv(pg);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The system call failed</span></span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (from_env_store)</span><br><span class="line">			*from_env_store = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (perm_store)</span><br><span class="line">			*perm_store = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (from_env_store) &#123;</span><br><span class="line">		*from_env_store = thisenv-&gt;env_ipc_from;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (perm_store) &#123;</span><br><span class="line">		*perm_store = thisenv-&gt;env_ipc_perm;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> thisenv-&gt;env_ipc_value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ipc_send(<span class="keyword">envid_t</span> to_env, <span class="keyword">uint32_t</span> val, <span class="keyword">void</span> *pg, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!pg) err = sys_ipc_try_send(to_env, val, (<span class="keyword">void</span> *)~<span class="number">0</span>, perm);</span><br><span class="line">		<span class="keyword">else</span> err = sys_ipc_try_send(to_env, val, pg, perm);</span><br><span class="line">		<span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (err == -E_IPC_NOT_RECV)</span><br><span class="line">			sys_yield();</span><br><span class="line">		<span class="keyword">else</span> panic(<span class="string">"ipc_send: %e"</span>, err);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成之后，别忘了在<code>syscall</code>函数中添加对新的系统调用的判断。</p>
<p>运行<code>make grade</code>，<code>80/80</code>大成功，至此Lab 4结束。</p>
<blockquote>
<p><strong>Challenge</strong></p>
<ol>
<li>修改<code>sys_ipc_try_send()</code>调用的接口，使得<code>ipc_send()</code>函数不使用循环也能实现相同功能。请确保你的实现可以处理多个进程同时试图向一个进程发送消息的情况。</li>
<li>素数筛只是多进程消息传递的妙用之一，请阅读<a href="https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf" target="_blank" rel="noopener">这篇论文</a>的666-667页，然后试着实现矩阵乘法的应用。</li>
<li>Doug McIlroy的幂级数计算器是另一个经典的应用，请阅读<a href="https://swtch.com/~rsc/thread/squint.pdf" target="_blank" rel="noopener">这篇论文</a>的661-683页，实现一个幂级数计算器并计算$sin(x+x^3)$的幂级数。</li>
<li>运用<a href="http://www.scs.stanford.edu/nyu/04fa/sched/readings/l3.pdf" target="_blank" rel="noopener">这篇论文</a>中阐述的一些技术去优化我们的内核设计，使JOS的消息传递机制更加高效。</li>
</ol>
</blockquote>
<h3 id="Lab-5-File-system-Spawn-and-Shell"><a href="#Lab-5-File-system-Spawn-and-Shell" class="headerlink" title="Lab 5: File system, Spawn and Shell"></a>Lab 5: File system, Spawn and Shell</h3><p>在这个lab中，我们需要实现加载和运行磁盘上的可执行文件的系统调用<code>spawn</code>。我们还需要改进我们的内核和库函数，使得我们能在控制台上运行一个shell。为了实现这一点，我们还将实现一个简单的文件系统。</p>
<p>在开始之前，我们需要重新运行Lab4的<code>primes</code>、<code>pingpong</code>和<code>forktree</code>三个测试并确保它们的结果仍然是正确的。由于我们还没实现Lab5的一些函数，我们需要注释掉<code>lib/exit.c</code>中的<code>close_all();</code>和<code>kern/init.c</code>中的<code>ENV_CREATE(fs_fs, ENV_TYPE_FS);</code>(并在测试结果正确之后取消注释)。</p>
<p>如果测试无法通过，执行<code>git diff lab4</code>来查看是什么导致了测试失败。修正这些错误直到测试能够通过，在此之前不要开始做Lab5。</p>
<h4 id="Part-A-File-system-preliminaries"><a href="#Part-A-File-system-preliminaries" class="headerlink" title="Part A File system preliminaries"></a>Part A File system preliminaries</h4><p>我们要实现的这个文件系统远比UNIX使用的文件系统简单，但是它已经足以支持分层目录结构下的<strong>创建、读写、删除</strong>等操作。由于JOS是一个单用户操作系统，这个文件系统并没有实现<strong>用户权限管理</strong>、<strong>符号链接</strong>、<strong>时间戳</strong>与<strong>设备文件</strong>。</p>
<h5 id="On-Disk-File-System-Structure"><a href="#On-Disk-File-System-Structure" class="headerlink" title="On-Disk File System Structure"></a>On-Disk File System Structure</h5><p>大多数UNIX文件系统将可用的磁盘空间分为两部分：<strong><code>inode</code>区</strong>和<strong><code>data</code>区</strong>。UNIX文件系统给每一个文件分配一个<code>inode</code>，其中包含了<strong>这个文件的重要元数据</strong>，如它的<code>stat</code>属性和指向文件内容存放地址的指针。<code>data</code>区则被分割成了更大的(一般是8KB以上)数据块，文件系统会在这些数据块里面存储<strong>文件数据和目录元数据</strong>。每个目录包含着<strong>指向目录中各个文件<code>inode</code>的指针</strong>。如果多个目录都包含有指向一个文件<code>inode</code>的指针，那么这个文件被称为是<strong>硬链接</strong>的。</p>
<p>我们的文件系统使用的是一种简单得多的结构：我们根本不使用<code>inode</code>，而是将所有目录下文件和子目录的元数据直接存储在这个目录的数据区。</p>
<p>无论是文件还是目录，其数据都是分散在磁盘中不相邻的数据块中的，文件系统隐藏了这些细节，只向用户提供读写文件数据的接口。我们的文件系统允许用户<strong>直接读取文件夹元数据</strong>，这就意味着用户可以自行实现目录扫描而不需要借助额外的系统调用。这种设计的缺点在于用户程序的编写方式与文件系统的数据存储格式挂钩，一旦我们修改了文件系统的实现，所有用户程序也必须重写。</p>
<h6 id="Sectors-and-Blocks"><a href="#Sectors-and-Blocks" class="headerlink" title="Sectors and Blocks"></a>Sectors and Blocks</h6><p>事实上大多磁盘<strong>并不能实现字节粒度上的读写</strong>，因而它们使用<code>sector</code>作为其读写单位。在JOS中，每个<code>sector</code>的大小是<strong>512字节</strong>。文件系统则使用<code>block</code>作为其读写单位，每个<code>block</code>必须包含整数个<code>sector</code>。现代的文件系统一般使用比较大的<code>block</code>，因为存储空间越来越大，而以更大的空间粒度又更方便管理。JOS使用的<code>block</code>大小为<strong>4096个字节</strong>，和虚拟内存中的<code>page</code>大小相同。</p>
<h6 id="Superblocks"><a href="#Superblocks" class="headerlink" title="Superblocks"></a>Superblocks</h6><p>文件系统经常会在一些<strong>特定的位置</strong>(比如磁盘的开始或结束处)保留一些数据块来存储描述<strong>文件系统整体属性</strong>的数据，比如<strong>块大小</strong>、<strong>磁盘大小</strong>、<strong>根目录位置</strong>、<strong>上一次挂载时间</strong>等。这些块被称为<code>Superblocks</code>。</p>
<p>我们的文件系统只包含一个<code>superblock</code>，也就是<strong>磁盘上的<code>block 1</code></strong>，其结构由<code>inc/fs.h</code>中的<code>Super</code>结构来描述。(在Lab1中我们已经知道磁盘的第一个<code>block</code>一般用来存放<code>bootloader</code>和分区表，因而<strong>文件系统一般不会去使用<code>block 0</code></strong>)</p>
<p>为了提高文件系统的容灾性，大文件系统一般会使用分布在磁盘各个位置的数个<code>Superblock</code>，这样当某一个<code>Superblock</code>被破坏后，文件系统还能使用其他的来进行恢复。</p>
<h6 id="File-Meta-data"><a href="#File-Meta-data" class="headerlink" title="File Meta-data"></a>File Meta-data</h6><p><code>inc/fs.h</code>中的<code>File</code>结构是描述文件属性的元数据结构，其中包含了文件的名字，属性，大小和组成文件的数据块位置。由于我们并没有使用<code>inode</code>，这些元数据都储存在目录下，在我们访问文件时它们会同时存在于内存和硬盘中。</p>
<p><code>f_direct</code>数组存储着<strong>10个</strong>数据块的序号，如果文件的大小小于<code>40KB</code>，这十个数据块就足以存储这个文件；否则，我们还需要分配一个额外的数据块来专门储存更多的数据块序号。这样的一个数据块可以存储<code>1024</code>个额外的数据块序号，也就是说在这种方式下的文件最大可以为<code>4GB</code>。</p>
<h6 id="Directory-versus-Regular-file"><a href="#Directory-versus-Regular-file" class="headerlink" title="Directory versus Regular file"></a>Directory versus Regular file</h6><p>目录文件和普通文件的区分方式是<code>File</code>结构体中的<code>type</code>属性。文件系统对两者的管理方式是完全相同的，只不过对其中数据结构的解析方式有所区别：目录文件会被解析成为目录下所有文件的<code>File</code>结构数组。文件系统中根目录文件的<code>File</code>结构位于<code>Superblock</code>中。</p>
<h4 id="Part-B-The-File-System"><a href="#Part-B-The-File-System" class="headerlink" title="Part B The File System"></a>Part B The File System</h4><p>这个Lab并不要求我们独自实现整个文件系统，而只需要实现磁盘读写，磁盘数据块的分配，文件偏移的映射和几个系统调用。正因为如此，我们必须熟悉6.828提供的部分代码。</p>
<h5 id="Disk-Access"><a href="#Disk-Access" class="headerlink" title="Disk Access"></a>Disk Access</h5><p>到现在为止，我们的内核还没有实现任何对硬盘的访问机制。传统的操作系统会在内核中包含一个磁盘接口驱动并向用户进程提供系统调用接口来访问它，但我们采用一种更轻量的办法，即将磁盘驱动作为用户级文件系统环境的一部分。也就是说，我们使用一个<strong>特殊的文件系统进程</strong>来进行与磁盘的交互。</p>
<p>我们的实现基于<code>polling</code>和<code>PIO</code>而非磁盘设备中断，因为中断驱动的设备驱动需要我们进行额外的中断处理，并将其分派到正确的进程，这是比较复杂的。</p>
<p><code>EFLGS</code>寄存器中的<code>IOPL</code>标志位是用来控制是否允许保护模式下的代码进行设备IO操作的。通过控制这个标志位，内核可以控制各个用户进程对IO设备的访问权限。在我们的设计中，只有文件系统进程有权访问IO设备。</p>
<blockquote>
<p><strong>Exercise 1</strong></p>
<p><code>i386_init</code>函数通过向<code>env_create</code>函数传递<code>ENV_TYPE_FS</code>参数来创建一个文件系统进程。请修改你的<code>env_create</code>实现使得文件系统进程拥有设备IO权限而其他进程没有。</p>
</blockquote>
<p>需要注意四个常量<code>FL_IOPL_x</code>的含义：<code>x</code>所对应的二进制数就是<code>IOPL</code>位将被赋予的值，因而这里我们应当使用<code>FL_IOPL_3</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_create(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">new_env</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err = env_alloc(&amp;new_env, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		panic(<span class="string">"env_create: %e"</span>, err);</span><br><span class="line">	load_icode(new_env, binary);</span><br><span class="line">	new_env-&gt;env_type = type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.</span></span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (type == ENV_TYPE_FS)</span><br><span class="line">		new_env-&gt;env_tf.tf_eflags |= FL_IOPL_3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过观察<code>GNUMakeFile</code>可以发现，这个lab中以<code>obj/kern/kernel.img</code>作为<code>disk 0</code>而<code>obj/fs/fs.img</code>作为<code>disk 1</code>。在这个实验中我们不能修改<code>disk 0</code>，如果你因为一些原因弄坏了两块磁盘中的一块，可以执行<code>rm obj/kern/kernel.img obj/fs/fs.img</code>和<code>make</code>将两块磁盘重置。</p>
<blockquote>
<p><strong>Question</strong></p>
<p>为了保证用户环境切换的时候IO权限设置能够正常地保存，你还需要做些什么？为什么？</p>
</blockquote>
<p>什么都不用做，因为IO权限是由寄存器决定的，而用户环境切换时原有寄存器的值会保存在旧用户环境的<code>tf</code>中，而加载入新用户环境<code>tf</code>中的值，所以其实IO权限是始终跟着用户环境走的。</p>
<blockquote>
<p><strong>Challenge</strong></p>
<p>实现一个中断驱动的磁盘访问机制，你可以将其放在内核中或文件系统进程，或甚至为其新建一个专门的进程。</p>
</blockquote>
<h5 id="The-Block-Cache"><a href="#The-Block-Cache" class="headerlink" title="The Block Cache"></a>The Block Cache</h5><p>在我们的文件系统中，我们只需要在虚拟内存系统的帮助下实现一个很简单的<strong>块缓存</strong>。实现块缓存的代码位于<code>fs/bc.c</code>。</p>
<p>我们的文件系统被限制为只能处理3GB大小的磁盘。我们在文件系统进程的虚拟内存空间中留出一块3GB的空间(从<code>0x10000000</code>(<code>DISKMAP</code>)到<code>0xD0000000</code>(<code>DISKMAP+DISKMAX</code>))来映射这块磁盘。我们可以使用<code>diskaddr</code>函数来将磁盘块的序号转换为其在文件系统进程中的映射地址。</p>
<p>由于将整个磁盘读入文件系统进程需要相当长的时间，我们需要实现<code>demand paging</code>机制，即我们只有在触发<code>pagefault</code>时才分配对应的页并从磁盘中拷贝相应的数据。</p>
<blockquote>
<p><strong>Exercise 2</strong></p>
<p>实现<code>fs/bc.c</code>中的<code>bc_pgfault</code>和<code>flush_block</code>两个函数。需要注意的细节有：</p>
<ul>
<li><code>bc_pgfault</code>函数是一个pagefault处理程序，我们可以用Lab4中实现的机制安装它。<ul>
<li><strong>注意<code>ide_read</code>的单位是<code>sector</code>而不是<code>block</code>。</strong></li>
</ul>
</li>
<li><code>flush_block</code>会在必要的时候将一个块写入磁盘。这里的必要是指，当且仅当这个块已经被映射而且是“dirty”的时候。<ul>
<li>CPU会在一个页面被修改时将其<code>pte</code>加上一个<code>PTE_D</code>位，表示它是“dirty”的。</li>
<li>在完成操作后，函数应当洗掉页面上的<code>PTE_D</code>标志。</li>
</ul>
</li>
</ul>
</blockquote>
<p>实现<code>bc_pgfault</code>的时候别忘了先在进程里分配好页面，不然<code>user_mem_assert</code>通不过。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">bc_pgfault(struct UTrapframe *utf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> *addr = (<span class="keyword">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line">	<span class="keyword">uint32_t</span> blockno = ((<span class="keyword">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check that the fault was within the block cache region</span></span><br><span class="line">	<span class="keyword">if</span> (addr &lt; (<span class="keyword">void</span>*)DISKMAP || addr &gt;= (<span class="keyword">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">		panic(<span class="string">"page fault in FS: eip %08x, va %08x, err %04x"</span>,</span><br><span class="line">		      utf-&gt;utf_eip, addr, utf-&gt;utf_err);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sanity check the block number.</span></span><br><span class="line">	<span class="keyword">if</span> (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks)</span><br><span class="line">		panic(<span class="string">"reading non-existent block %08x\n"</span>, blockno);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 5: you code here:</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// We have 8 sectors per block</span></span><br><span class="line">	<span class="keyword">if</span> (sys_page_alloc(<span class="number">0</span>, ROUNDDOWN(addr, PGSIZE), PTE_P | PTE_U | PTE_W) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"bc_pgfault: sys_page_alloc failed."</span>);</span><br><span class="line">	<span class="keyword">if</span> (ide_read(<span class="number">8</span>*blockno, ROUNDDOWN(addr, PGSIZE), <span class="number">8</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"bc_pgfault: ide_read failed."</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Clear the dirty bit for the disk block page since we just read the</span></span><br><span class="line">	<span class="comment">// block from disk</span></span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"in bc_pgfault, sys_page_map: %e"</span>, r);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check that the block we read was allocated. (exercise for</span></span><br><span class="line">	<span class="comment">// the reader: why do we do this *after* reading the block</span></span><br><span class="line">	<span class="comment">// in?)</span></span><br><span class="line">	<span class="keyword">if</span> (bitmap &amp;&amp; block_is_free(blockno))</span><br><span class="line">		panic(<span class="string">"reading free block %08x\n"</span>, blockno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">flush_block(<span class="keyword">void</span> *addr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> blockno = ((<span class="keyword">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (addr &lt; (<span class="keyword">void</span>*)DISKMAP || addr &gt;= (<span class="keyword">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">		panic(<span class="string">"flush_block of bad va %08x"</span>, addr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span> (va_is_mapped(addr) &amp;&amp; va_is_dirty(addr)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ide_write(blockno*<span class="number">8</span>, ROUNDDOWN(addr, PGSIZE), <span class="number">8</span>) &lt; <span class="number">0</span>)</span><br><span class="line">			panic(<span class="string">"flush_block: ide_write failed."</span>);</span><br><span class="line">		<span class="keyword">if</span> (sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL) &lt; <span class="number">0</span>)</span><br><span class="line">			panic(<span class="string">"flush_block: sys_page_map failed."</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成这两个函数后，运行<code>make grade</code>应当能通过<code>check_bc</code>，<code>check_super</code>和<code>check_bitmap</code>三个测试。</p>
<blockquote>
<p><strong>Challenge</strong></p>
<p>在我们现在的实现中，当一个块由于pagefauly被读入内存后，它会永远驻留内存。试着实现一个<strong>驱逐机制</strong>(eviction policy)，将那些不常用到的块从内存中清除掉。CPU会通过设置<code>PTE_A</code>来表示一个页面是否被访问过，可以利用这一点。小心那些dirty的块。</p>
</blockquote>
<h5 id="The-Block-Bitmap"><a href="#The-Block-Bitmap" class="headerlink" title="The Block Bitmap"></a>The Block Bitmap</h5><p>在<code>fs_init</code>函数设置好<code>bitmap</code>指针之后，我们就可以将<code>bitmap</code>视为一个块数组，每个元素对应着从<code>diskblock 2</code>开始的一个块。</p>
<blockquote>
<p><strong>Exercise 3</strong></p>
<p>以<code>free_block</code>为模板实现<code>fs.c</code>中的<code>allock_block</code>函数，它会找到bitmap中一个空闲的块，将其标识为<code>used</code>，然后返回块序号。在返回之前我们还需要使用<code>flush_block</code>将更新后的<code>bitmap</code>写入磁盘，以保证文件系统的一致性。</p>
</blockquote>
<p>虽然这个文件系统用来标识一个块是否空闲的方式有些诡异，但是参考<code>free_block</code>函数就可以知道具体的方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">alloc_block(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; super-&gt;s_nblocks; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (block_is_free(i)) &#123;</span><br><span class="line">			bitmap[i / <span class="number">32</span>] &amp;= ~(<span class="number">1</span>&lt;&lt;(i%<span class="number">32</span>));</span><br><span class="line">			flush_block(bitmap);</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成这个任务后，运行<code>make grade</code>应当能通过<code>alloc_block</code>测试。</p>
<h5 id="File-Operations"><a href="#File-Operations" class="headerlink" title="File Operations"></a>File Operations</h5><p>6.828在<code>fs/fs.c</code>中提供了一系列函数，以让我们能够管理<code>File</code>结构，扫描和管理目录，解析绝对路径等。确<strong>保你在进行下面的任务之前仔细阅读过这些代码。</strong></p>
<blockquote>
<p><strong>Exercise 4</strong></p>
<p>实现<code>file_block_walk</code>和<code>file_get_block</code>两个函数。前者会找到文件中第n个块在物理磁盘中的序号，后者则会进一步找到其在文件系统进程中的虚拟地址。</p>
</blockquote>
<p>根据前面我们对文件结构的理解，我们知道需要分别处理n在<code>f_direct</code>数组内和<code>indirect block</code>中两种情况。这个函数的难点主要在新内存块的分配上面，这部分细节特别容易出错。</p>
<p>分配一个新的内存块需要三步：</p>
<ul>
<li>调用<code>alloc_block</code>函数分配一个块，并检查返回值</li>
<li>调用<code>memset</code>函数将块的内容清零</li>
<li>调用<code>flush_block</code>函数将新的块写入磁盘</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">file_block_walk(struct File *f, <span class="keyword">uint32_t</span> filebno, <span class="keyword">uint32_t</span> **ppdiskbno, <span class="keyword">bool</span> alloc)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> blockno;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ppdiskbno)</span><br><span class="line">		panic(<span class="string">"file_block_walk: ppdiskbno equals 0"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (filebno &gt;= NDIRECT + NINDIRECT)</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (filebno &lt; NDIRECT) &#123;</span><br><span class="line">		<span class="comment">// f-&gt;f_direct[]</span></span><br><span class="line">		*ppdiskbno = &amp;f-&gt;f_direct[filebno];</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// f-&gt;f_indirect</span></span><br><span class="line">		<span class="keyword">if</span> (f-&gt;f_indirect == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (alloc) &#123;</span><br><span class="line">				<span class="comment">// Alloc an indirect block for f</span></span><br><span class="line">				<span class="keyword">if</span> ((blockno = alloc_block()) &lt; <span class="number">0</span>)</span><br><span class="line">					<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">				f-&gt;f_indirect = blockno;</span><br><span class="line">				<span class="built_in">memset</span>(diskaddr(blockno), <span class="number">0</span>, BLKSIZE);</span><br><span class="line">				flush_block(diskaddr(blockno));</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">		&#125; <span class="keyword">else</span> blockno = f-&gt;f_indirect;</span><br><span class="line">		*ppdiskbno = diskaddr(blockno) + <span class="number">4</span> * (filebno - NDIRECT);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>file_get_block</code>主要需要注意的问题是如果调用<code>file_block_walk</code>返回了0，我们还需要为这个位置分配一个新的block。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">file_get_block(struct File *f, <span class="keyword">uint32_t</span> filebno, <span class="keyword">char</span> **blk)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint32_t</span> *pdiskbno;</span><br><span class="line">	<span class="keyword">int</span> err = file_block_walk(f, filebno, &amp;pdiskbno, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// If f has not alloced such block, alloc one for it.</span></span><br><span class="line">	<span class="keyword">if</span> (!(*pdiskbno)) &#123;</span><br><span class="line">		*pdiskbno = alloc_block();</span><br><span class="line">		<span class="built_in">memset</span>(diskaddr(*pdiskbno), <span class="number">0</span>, BLKSIZE);</span><br><span class="line">		flush_block(f);</span><br><span class="line">		flush_block(diskaddr(*pdiskbno));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (blk) &#123;</span><br><span class="line">		*blk = (<span class="keyword">char</span> *)diskaddr(*pdiskbno);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在运行<code>make grade</code>的话，你应当能通过<code>testfile</code>之前的所有测试，以及<code>testfile</code>测试本身。</p>
<blockquote>
<p><strong>Challenge</strong></p>
<p>文件系统可能因为我们的一些操作而被损坏，比如重启或系统崩溃。试着实现<code>soft update</code>(软更新)或<code>journalling</code>(系统日志)来让文件系统不会因崩溃而损坏，并描述一些新系统能抵抗的崩溃场景。</p>
</blockquote>
<h5 id="The-file-system-interface"><a href="#The-file-system-interface" class="headerlink" title="The file system interface"></a>The file system interface</h5><p>我们现在已经在文件系统进程内部实现了一些关键的功能，但我们还需要提供一些接口以让<strong>其他进程</strong>也能够使用这些功能。由于其他进程不能直接调用文件系统进程中的函数，我们将会通过建立在<code>IPC</code>机制基础上的<strong>RPC</strong>(remote precedure call)机制来实现这些接口。</p>
<p>下图是一个<code>RPC</code>的过程：</p>
<p><img src="RPC.png" alt="RPC"></p>
<ol>
<li><code>read</code>根据指定的文件描述符将控制流分发给对应的设备读函数，在这里是用来读取磁盘上文件的<code>devfile_read</code>。<ul>
<li><code>devfile_read</code>和其他<code>devfile_</code>函数们共同构成了文件系统接口的<strong>客户端</strong>，它们的工作方式是类似的，即构造一个请求结构体，调用<code>fsipc</code>函数发送IPC请求，并处理得到的回应。</li>
</ul>
</li>
<li>接口的<strong>服务端</strong>主体是<code>serve</code>函数，它用一个无限循环不停地试图通过IPC得到一个请求，一旦得到就把请求分发给对应的处理函数，然后通过IPC将返回值发送回去。</li>
<li>处理函数解包请求，调用<code>file_read</code>函数去进行读操作。</li>
</ol>
<p>还记得我们在Lab4中实现的<code>IPC</code>机制吗？一个<code>IPC</code>操作可以传输一个32位整数和一个页面映射。在这里，我们以<strong>RPC请求的服务种类编号</strong>作为请求类别，并将请求的所有参数储存在一个<code>union</code>中，将<code>union</code>所在的页面通过IPC发送给文件系统进程。在客户端，我们要共享的页面位于<code>fsipcbuf</code>；在服务端，我们将发送过来的页面映射到<code>fsreq</code>。</p>
<p>请求结果的返回也要借助IPC。大多数RPC只需要返回一个<strong>返回码</strong>即可，像<code>FSREQ_READ</code>和<code>FSREQ_STAT</code>这样要返回数据的会将数据写到<strong>客户端发送来的页面上</strong>，由于这个页面是共享的，这就自然地实现了数据传送。<code>FSREQ_OPEN</code>还会额外发送一个<code>Fd page</code>给客户端。</p>
<blockquote>
<p><strong>Exercise 5</strong></p>
<p>实现<code>fs/serv.c</code>中的<code>serve_read</code>函数。就像上面说过的，它只需要解析请求报文，以合适的参数调用<code>file_read</code>函数，并将返回值发送回去即可完成任务。你可以参考<code>serve_set_size</code>函数以了解解析报文的方式。</p>
</blockquote>
<p>阅读一下<code>fs.h</code>中对<code>struct fsipc</code>的定义，基本知道哪个参数该填什么，然后照着<code>serve_set_size</code>依葫芦画瓢就行了。需要注意的是在之前的描述中官方并没有仔细解释<code>OpenFile</code>结构的含义，最好在开始做之前根据注释研究清楚这个结构各个成员的意义。</p>
<p><code>OpenFile</code>结构用来标记一个已经打开的文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> o_fileid;	<span class="comment">// file id</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">o_file</span>;</span>	<span class="comment">// mapped descriptor for open file</span></span><br><span class="line">	<span class="keyword">int</span> o_mode;		<span class="comment">// open mode</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">o_fd</span>;</span>	<span class="comment">// Fd page</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> fd_dev_id;</span><br><span class="line">	<span class="keyword">off_t</span> fd_offset;</span><br><span class="line">	<span class="keyword">int</span> fd_omode;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="comment">// File server files</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">FdFile</span> <span class="title">fd_file</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>o_fileid</code>：文件的<code>id</code></li>
<li><code>o_file</code>：存放文件元数据的<code>File</code>结构指针<ul>
<li>文件名，大小，类型，内容等等</li>
</ul>
</li>
<li><code>o_mode</code>：文件的打开方式</li>
<li><code>o_fd</code>：<strong>文件描述符结构指针</strong><ul>
<li><code>fd_dev_id</code>：标识这个文件的设备类型</li>
<li><code>fd_offset</code>：<strong>文件指针目前所在的偏移位置</strong></li>
<li><code>fd_omode</code></li>
</ul>
</li>
</ul>
<p>在完成下面两个任务的时候，<strong>不要忘了修改文件指针的位置</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">serve_read(<span class="keyword">envid_t</span> envid, <span class="keyword">union</span> Fsipc *ipc)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_read</span> *<span class="title">req</span> = &amp;<span class="title">ipc</span>-&gt;<span class="title">read</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsret_read</span> *<span class="title">ret</span> = &amp;<span class="title">ipc</span>-&gt;<span class="title">readRet</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">file</span>;</span></span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (debug)</span><br><span class="line">		cprintf(<span class="string">"serve_read %08x %08x %08x\n"</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Lab 5: Your code here:</span></span><br><span class="line">	<span class="keyword">if</span> ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;file)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ((r = file_read(file-&gt;o_file, ret-&gt;ret_buf, req-&gt;req_n, file-&gt;o_fd-&gt;fd_offset)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	</span><br><span class="line">	file-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Exercise 6</strong></p>
<p>实现<code>fs/serv.c</code>中的<code>serve_write</code>函数和<code>lib/file.c</code>中的<code>devfile_write</code>函数。</p>
</blockquote>
<p><code>serve_write</code>和<code>serve_read</code>是完全类似的，<code>devfile_write</code>也可以参考其他类似的函数。需要注意的是在抄的时候也要带着理智，要注意函数的真正功能如何。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">serve_write(<span class="keyword">envid_t</span> envid, struct Fsreq_write *req)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (debug)</span><br><span class="line">		cprintf(<span class="string">"serve_write %08x %08x %08x\n"</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">file</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;file)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = file_write(file-&gt;o_file, req-&gt;req_buf, req-&gt;req_n, file-&gt;o_fd-&gt;fd_offset)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">	file-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span><br><span class="line">devfile_write(struct Fd *fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// LAB 5: Your code here</span></span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	fsipcbuf.write.req_fileid = fd-&gt;fd_file.id;</span><br><span class="line">	fsipcbuf.write.req_n = n;</span><br><span class="line">  </span><br><span class="line">	<span class="built_in">memcpy</span>(fsipcbuf.write.req_buf, buf, n);</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">if</span> ((r = fsipc(FSREQ_WRITE, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成这两个任务后，运行<code>make grade</code>应当能拿到150分中的90分。</p>
<h4 id="Part-C-Spawning-Processes"><a href="#Part-C-Spawning-Processes" class="headerlink" title="Part C Spawning Processes"></a>Part C Spawning Processes</h4><p>6.828已经提供了<code>spawn</code>函数的实现(<code>lib/spawn.c</code>)，它会创建一个新的子进程，将一个二进制文件从文件系统加载到进程中，然后让子进程开始运行。<code>spawn</code>相当于一个<code>fork</code>后接一个<code>exec</code>。</p>
<p>我们选择<code>spawn</code>而不是<code>exec</code>来实现，因为它不需要那么多内核的帮助。思考一下如果要实现用户级的<code>exec</code>调用需要做哪些事，为什么它更难。</p>
<blockquote>
<p><strong>Exercise 7</strong></p>
<p><code>spawn</code>函数要依赖于新的系统调用<code>sys_env_set_trapframe</code>来初始化新创建的进程。实现这个系统调用，并在<code>syscall</code>中增加对其的处理。</p>
</blockquote>
<p><code>spawn</code>函数的难点已经全被实现好了，我们要实现的这个调用比较简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_trapframe(<span class="keyword">envid_t</span> envid, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="comment">// Remember to check whether the user has supplied us with a good</span></span><br><span class="line">	<span class="comment">// address!</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	err = envid2env(envid, &amp;env, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!tf)</span><br><span class="line">		panic(<span class="string">"sys_env_set_trapframe: tf is null"</span>);</span><br><span class="line">	</span><br><span class="line">	env-&gt;env_tf = *tf</span><br><span class="line">  env-&gt;env_tf.tf_eflags &amp;= ~FL_IOPL_3;</span><br><span class="line">	env-&gt;env_tf.tf_eflags |= FL_IF;</span><br><span class="line">	env-&gt;env_tf.tf_cs |= <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成这个函数后，运行<code>make grade</code>应当能够通过<code>spawn via spawnhello</code>测试。</p>
<blockquote>
<p><strong>Challenge</strong></p>
<ol>
<li>实现Unix风格的<code>exec</code>函数。</li>
<li>实现mmap风格的内存映射文件，并修改<code>spawn</code>使其能直接从ELF文件映射页面到内存。</li>
</ol>
</blockquote>
<h5 id="Sharing-library-state-across-fork-and-spawn"><a href="#Sharing-library-state-across-fork-and-spawn" class="headerlink" title="Sharing library state across fork and spawn"></a>Sharing library state across fork and spawn</h5><p>我么知道，UNIX系统下“<strong>万物皆文件</strong>”，因而管道、IO设备等也都在文件的范畴内。在JOS中，每一种设备都有属于自己的<code>Dev</code>结构，<code>lib/fd.c</code>在这个基础上实现了类UNIX的通用文件描述符接口。<strong>每个<code>Fd</code>结构都会指出它设备的类型</strong>，大多数函数都只是简单地将操作分发到相应<code>Dev</code>结构中的函数。</p>
<p><code>lib/fd.c</code>还在每个应用进程的虚拟地址空间建立一个<strong>文件描述符表</strong>，其地址从<code>FDTABLE(0xd0000000)</code>开始。这个地址保留了一页来保存32个文件描述符，因而每个应用最多也就只能同时打开32个文件。每个文件描述符也在<code>FILEDATA</code>开始的区域拥有一个自已的“数据页”。</p>
<p>由于文件描述符的状态是保存在用户进程的内存空间中的，在<code>fork</code>函数创建的新进程中这些描述符是写时复制的，所以文件状态是被<strong>复制了</strong>而非<strong>共享了</strong>。这样一来进程无法去访问不是它们自己打开的文件，管道也无法通过<code>fork</code>去工作。另一方面，<code>spawn</code>产生的新进程<strong>在开始运行时是没有打开任何文件的</strong>。</p>
<p>我们应当修改<code>fork</code>函数来将一些内存区域标记为<strong>共享的</strong>。比起强行规定一些区域来作为共享内存，我们可以像<code>PTE_COW</code>一样用页表项中的标志位来决定哪些页是共享的。<code>inc/lib.h</code>中将<code>PTE_SHARE</code>规定为该标志，如果<code>pte</code>有这个标志，它在<code>fork</code>或<code>spawn</code>中应当被直接拷贝到新的内存空间中。</p>
<blockquote>
<p><strong>Exercise 8</strong></p>
<p>修改<code>lib/fork.c</code>中的<code>duppage</code>函数来支持上面描述的机制。如果一个<code>pte</code>有<code>PTE_SHARE</code>标志，就直接将映射关系拷贝过去即可。同样地，实现<code>lib/spawn.c</code>中的<code>copy_shared_pages</code>，它应当遍历当前内存空间中全部的页表项，拷贝所有标有<code>PTE_SHARE</code>的映射关系。</p>
</blockquote>
<p>为了让新的映射关系保持原来映射中的权限，我们需要用<code>PTE_SYSCALL</code>作为逻辑掩码来取到原来的<code>uvpt[pn]</code>中的权限位：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">duppage(<span class="keyword">envid_t</span> envid, <span class="keyword">unsigned</span> pn)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">void</span> *pg = (<span class="keyword">void</span> *)(pn * PGSIZE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (uvpt[pn] &amp; PTE_SHARE) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, pg, envid, pg, uvpt[pn] &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (uvpt[pn] &amp; PTE_W || uvpt[pn] &amp; PTE_COW) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, pg, envid, pg, PTE_P | PTE_U | PTE_COW)) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, pg, <span class="number">0</span>, pg, PTE_P | PTE_U | PTE_COW)) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, pg, envid, pg, PTE_P | PTE_U)) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意<code>uvpt</code>数组的索引应当是<code>PGNUM(addr)</code>而不是<code>PTX(addr)</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">copy_shared_pages(<span class="keyword">envid_t</span> child)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="keyword">uintptr_t</span> addr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (addr = <span class="number">0</span>; addr &lt; USTACKTOP; addr += PGSIZE) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; </span><br><span class="line">				(uvpt[PGNUM(addr)] &amp; PTE_P) &amp;&amp;</span><br><span class="line">				(uvpt[PGNUM(addr)] &amp; PTE_SHARE))</span><br><span class="line">			<span class="keyword">if</span> ((err = sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span> *)addr, child, (<span class="keyword">void</span> *)addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成这一步之后，代码应当能通过<code>testpteshare</code>和<code>testfdsharing</code>两个测试。</p>
<h4 id="Part-D-The-Keyboard-Interface"><a href="#Part-D-The-Keyboard-Interface" class="headerlink" title="Part D The Keyboard Interface"></a>Part D The Keyboard Interface</h4><p>要让一个shell能够工作，我们首先要能向里面打字。到现在为止，我们所进行的输入仅仅是在内核monitor中才能被接受。6.828已经在<code>kern/console.c</code>中实现了键盘和串口的驱动，现在你需要把这些驱动连接到系统的其他部分。</p>
<blockquote>
<p><strong>Exercise 9</strong></p>
<p>在<code>kern/trap.c</code>中调用<code>kbd_intr</code>函数和<code>serial_intr</code>函数来分别处理<code>IRQ_KBD</code>中断和<code>IRQ_SERIAL</code>中断。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IRQ_OFFSET+IRQ_KBD:</span><br><span class="line">  kbd_intr();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> IRQ_OFFSET+IRQ_SERIAL:</span><br><span class="line">  serial_intr();</span><br><span class="line">  <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>运行<code>make run-testkbd</code>测试，试着输入几行字，如果有回显则说明功能正常。</p>
<h4 id="Part-E-The-Shell"><a href="#Part-E-The-Shell" class="headerlink" title="Part E The Shell"></a>Part E The Shell</h4><p>运行<code>make run-icode</code>可以运行6.828提供的shell，我们应当能够在其中运行这些指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello world | cat</span><br><span class="line">cat lorem | cat</span><br><span class="line">cat lorem | num</span><br><span class="line">cat lorem | num | num | num | num | num</span><br><span class="line">lsfd</span><br></pre></td></tr></table></figure>
<p>注意我们现在的shell使用<code>cprintf</code>函数来进行打印，这会将所有信息直接打印到屏幕，也就是说我们无法进行输入输出的<strong>重定向</strong>。我们可以使用<code>fprintf</code>来将信息打印到特定的<code>fd</code>，<code>printf</code>是一个打印到<code>fd 1</code>的快捷操作。</p>
<blockquote>
<p><strong>Exercise 10</strong></p>
<p>修改<code>user/sh.c</code>中的shell实现，使其支持<code>&lt;</code>重定向。</p>
</blockquote>
<p>对照下面的<code>&gt;</code>重定向实现和注释即可完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">			<span class="keyword">if</span> ((fd = open(t, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				cprintf(<span class="string">"open %s for read: %e"</span>, t, fd);</span><br><span class="line">				<span class="built_in">exit</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (fd != <span class="number">0</span>) &#123;</span><br><span class="line">				dup(fd, <span class="number">0</span>);</span><br><span class="line">				close(fd);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>完成以上所有任务后，运行<code>make grade</code>，<code>150/150</code>大成功，至此lab5结束。</p>
<blockquote>
<p><strong>Challenge</strong></p>
<p>完善你的Shell。可以添加的内容包括但不限于：</p>
<ul>
<li>后台进程，如<code>ls &amp;</code></li>
<li>串行指令，如<code>make &amp;&amp; rm -rf ./output/</code></li>
<li>指令历史记录</li>
<li>tab补全</li>
<li>Ctrl-C结束进程</li>
<li><a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab5/" target="_blank" rel="noopener">And more</a></li>
</ul>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2018/11/24/用自己建造的DockerImage创建k8s容器/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/24/用自己建造的DockerImage创建k8s容器/" itemprop="url">用自己建造的DockerImage创建k8s容器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-24T14:40:37+08:00">
                2018-11-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Academic or Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/Computation-Virtualization/" itemprop="url" rel="index">
                    <span itemprop="name">Computation Virtualization</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2018/11/24/用自己建造的DockerImage创建k8s容器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/11/24/用自己建造的DockerImage创建k8s容器/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="用自己建造的DockerImage创建k8s容器"><a href="#用自己建造的DockerImage创建k8s容器" class="headerlink" title="用自己建造的DockerImage创建k8s容器"></a>用自己建造的DockerImage创建k8s容器</h2><p>本篇文章记载了定制k8s容器以满足实验需要的具体方法，以供参考。</p>
<h3 id="构建需要的DockerFile"><a href="#构建需要的DockerFile" class="headerlink" title="构建需要的DockerFile"></a>构建需要的DockerFile</h3><p>kubernetes的Pod是以docker容器为基础的，因此每个pod在创建时都需要提供一个基础的容器镜像。因此，要定制一个符合我们需求的Pod，就需要先定制容器镜像。</p>
<p>Docker提供的定制镜像的方式是 <strong>Dockerfile</strong> 。关于Dockerfile的具体写法参见<a href="https://docs.docker.com/v17.09/engine/reference/builder/" target="_blank" rel="noopener">Reference</a></p>
<p>「示例」这是一个简单的CounterImage的DockerFile：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu                     # 每个DockerFile必须在开头用FROM语句指明其母镜像</span><br><span class="line">COPY counter.sh /etc/           # COPY指令可以将目标文件拷贝到镜像内的目标目录中</span><br><span class="line">RUN chmod +x /etc/counter.sh    # RUN指令让目标镜像执行指定指令</span><br></pre></td></tr></table></figure>
<h3 id="用DockerFile建造DockerImage"><a href="#用DockerFile建造DockerImage" class="headerlink" title="用DockerFile建造DockerImage"></a>用DockerFile建造DockerImage</h3><p>写好DockerFile之后，执行<code>docker build</code>指令来构建镜像。</p>
<ul>
<li>关于<code>docker build</code>的参数问题<ul>
<li><code>-f &lt;filepath&gt;</code> 指定DokcerFile的位置，默认在当前目录下寻找DockerFile</li>
<li><code>-t &lt;tag&gt;</code> 为创建的镜像指定tag，tag格式一般是<code>&lt;repo&gt;/&lt;imagename&gt;:&lt;version&gt;</code></li>
</ul>
</li>
</ul>
<p>执行完毕之后，构建好的DockerImage可以用<code>docker images</code>查看到。</p>
<h3 id="用kubectl创建pod"><a href="#用kubectl创建pod" class="headerlink" title="用kubectl创建pod"></a>用kubectl创建pod</h3><p>用kubectl构建pod需要用yaml或json文件指定pod的属性。</p>
<p>「示例」这是用于运行CounterImage实例的Pod配置文件</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> <span class="comment"># 指定k8s版本，一般是v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>      <span class="comment"># 指定要创建的对象的类型，这里是Pod</span></span><br><span class="line"><span class="attr">metadata:</span>      <span class="comment"># 元数据，指定Pod信息</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">testpod</span>   <span class="comment"># 指定Pod的名称</span></span><br><span class="line"><span class="attr">  annotations:</span>    <span class="comment"># 一些必要的注释，可以用于传递信息</span></span><br><span class="line"><span class="attr">spec:</span>          <span class="comment"># 一些其他信息</span></span><br><span class="line"><span class="attr">  containers:</span>     <span class="comment"># 指定Pod使用的基础镜像</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">testcontainer</span>               <span class="comment"># 指定将要创建的容器名称，这个不重要</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">drac/counter:v1</span>            <span class="comment"># 指定使用的镜像名称，这里使用刚刚创建的镜像名</span></span><br><span class="line"><span class="attr">      imagePullPolicy:</span> <span class="string">"IfNotPresent"</span>   </span><br><span class="line">      <span class="comment"># 由于刚刚的镜像并没有上传到远程仓库中，这里需要指定镜像拉取策略为优先使用本地镜像</span></span><br><span class="line"><span class="attr">      command:</span>                          <span class="comment"># 指定容器要运行的指令</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">"etc/counter.sh"</span></span><br><span class="line"><span class="attr">      ports:</span>                            <span class="comment"># 指定容器对外开放的端口</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">8086</span></span><br><span class="line"><span class="attr">          hostPort:</span> <span class="number">8086</span></span><br><span class="line"><span class="attr">  tolerations:</span>    </span><br><span class="line">  <span class="comment"># 这个属性与node的taints有关，由于master节点默认不能调度pods，这里要设置一些tolerations</span></span><br><span class="line"><span class="attr">    - key:</span> <span class="string">"node.kubernetes.io/not-ready"</span></span><br><span class="line"><span class="attr">      operator:</span> <span class="string">"Exists"</span></span><br><span class="line"><span class="attr">      effect:</span> <span class="string">"NoSchedule"</span></span><br><span class="line"><span class="attr">    - key:</span> <span class="string">"node-role.kubernetes.io/master"</span></span><br><span class="line"><span class="attr">      operator:</span> <span class="string">"Exists"</span></span><br><span class="line"><span class="attr">      effect:</span> <span class="string">"NoSchedule"</span></span><br></pre></td></tr></table></figure>
<p>写好配置文件之后，就可以用<code>kubectl create -f &lt;配置文件名&gt;</code>来创建pod了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2018/11/04/在archlinux上单机搭建kubernetes/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/11/04/在archlinux上单机搭建kubernetes/" itemprop="url">在archlinux上单机搭建kubernetes</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-04T21:38:22+08:00">
                2018-11-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Academic or Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/Computation-Virtualization/" itemprop="url" rel="index">
                    <span itemprop="name">Computation Virtualization</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2018/11/04/在archlinux上单机搭建kubernetes/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/11/04/在archlinux上单机搭建kubernetes/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="kubernetes单机搭建流程"><a href="#kubernetes单机搭建流程" class="headerlink" title="kubernetes单机搭建流程"></a>kubernetes单机搭建流程</h2><p>由于工作需要，今天试着在archlinux主机上搭建了k8s。网上完全没有针对archlinux系统的配置教程，因此踩了很多坑，现将archlinux下的搭建流程记录如下。</p>
<h4 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h4><h5 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h5><ul>
<li><code>docker</code>：k8s中担任container职责的依赖，必须安装</li>
<li><code>sudo swapoff -a</code>：k8s的运行不支持内存交换，所以要关掉swap分区</li>
<li><code>ss</code>和<code>privoxy</code>：提供代理环境(k8s的镜像源多是google，而google相关网站大部分被GFW墙掉了)<ul>
<li><strong>注意：</strong>privoxy的监听端口应配置为8008(kubeadm的默认端口)</li>
</ul>
</li>
</ul>
<h5 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h5><p>手动编译kubernetes对内存要求过高，<del>OOM了3次</del>，只好另寻他途。</p>
<p>幸运的是，<code>kubeadm</code>,<code>kubectl</code>,<code>kubelet</code>,<code>kubernetes-cni</code>四项依赖的bin文件都有AUR包，可以用<code>yaourt</code>或者<code>yay</code>来下载。在下载时注意选择二进制文件(即<code>&lt;name&gt;-bin</code>)并提前打开privoxy代理映射。</p>
<p>(注意：这几个包的镜像源服务器都不支持axel，所以请将yay的下载工具换为wget)</p>
<h5 id="初始化集群"><a href="#初始化集群" class="headerlink" title="初始化集群"></a>初始化集群</h5><p>首先要设置docker的代理(这里的代理端口设置与privoxy的设置保持一致)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建conf文件</span></span><br><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line">sudo vim /etc/systemd/system/docker.service.d/http-proxy.conf</span><br><span class="line"><span class="comment"># 在新建的conf文件中加入如下内容</span></span><br><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">"HTTP_PROXY=http://127.0.0.1:8008/"</span></span><br><span class="line"><span class="comment"># 创建conf文件</span></span><br><span class="line">sudo vim /etc/systemd/system/docker.service.d/https-proxy.conf</span><br><span class="line"><span class="comment"># 在新建的conf文件中加入如下内容</span></span><br><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">"HTTPS_PROXY=http://127.0.0.1:8008/"</span></span><br><span class="line"><span class="comment"># 重启service</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>执行<code>sudo kubeadm init --pod-network-cidr=10.244.0.0/16</code>，根据显示的提示信息补全依赖，启动service后再次执行。</p>
<p>在init成功后根据显示的提示信息创建config文件。</p>
<p>执行<code>kubectl get pods --all-namespaces</code>，如果正常显示pods信息则说明正常。</p>
<p>接下来安装网络模块(这里使用的是<code>flannel</code>，当然其他模块也可以，只是要在init的时候指定相应的<code>pod-network-cidr</code>)，执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/bc79dd1505b0c8681ece4de4c0d86c5cd2643275/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>
<p>安装好flannel模块之后，如果<code>/etc/cni</code>文件夹没有被创建，coredns无法正常创建容器，可以在root身份下执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/cni/net.d/</span><br><span class="line">cat &lt;&lt;EOF&gt; /etc/cni/net.d/10-flannel.conf</span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"cbr0"</span>,<span class="string">"type"</span>:<span class="string">"flannel"</span>,<span class="string">"delegate"</span>: &#123;<span class="string">"isDefaultGateway"</span>: <span class="literal">true</span>&#125;&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>来进行配置。</p>
<p>这里如果出现问题可以参考<a href="https://blog.csdn.net/qq_34857250/article/details/82562514" target="_blank" rel="noopener">这篇博客</a></p>
<p>执行<code>watch kubectl get pods --all-namespaces</code>，等待一到两分钟，所有pods状态都为running则说明安装成功。(期间各种crash都是有可能的，耐心等待它自己重启即可)</p>
<h5 id="部署服务"><a href="#部署服务" class="headerlink" title="部署服务"></a>部署服务</h5><p>搭建大成功，接下来只要部署具体的service就可以了。</p>
<h4 id="常见问题及解决方案"><a href="#常见问题及解决方案" class="headerlink" title="常见问题及解决方案"></a>常见问题及解决方案</h4><ul>
<li><p>非root用户使用kubectl时出现错误</p>
<ul>
<li><p>错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unable to connect to the server: net/http: TLS handshake timeout</span><br></pre></td></tr></table></figure>
</li>
<li><p>状态：暂未解决</p>
</li>
<li>折中方案：将config文件放在root目录的<code>.kube</code>目录下，用sudo运行kubectl</li>
</ul>
</li>
<li><p>flannel网络模块安装之后coredns无法正常创建容器</p>
<ul>
<li><p>错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed create pod sandbox: rpc error: code = Unknown desc = [failed to set up sandbox container &quot;dd087d2655e98a25040f7b041e23dffa59aa52206b921e481ad20781d1de4320&quot; network for pod &quot;coredns-86c58d9df4-gtrt4&quot;: NetworkPlugin cni failed to set up pod &quot;coredns-86c58d9df4-gtrt4_kube-system&quot; network: failed to find plugin &quot;portmap&quot; in path [/opt/cni/bin], failed to clean up sandbox container &quot;dd087d2655e98a25040f7b041e23dffa59aa52206b921e481ad20781d1de4320&quot; network for pod &quot;coredns-86c58d9df4-gtrt4&quot;: NetworkPlugin cni failed to teardown pod &quot;coredns-86c58d9df4-gtrt4_kube-system&quot; network: failed to find plugin &quot;portmap&quot; in path [/opt/cni/bin]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">su</span><br><span class="line">mkdir -p /etc/cni/net.d/</span><br><span class="line">cat &lt;&lt;EOF&gt; /etc/cni/net.d/10-flannel.conf</span><br><span class="line">&#123;&quot;name&quot;:&quot;cbr0&quot;,&quot;type&quot;:&quot;flannel&quot;,&quot;delegate&quot;: &#123;&quot;isDefaultGateway&quot;: true&#125;&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Pod无法正常创建Container，出现netplugin error</p>
<ul>
<li><p>错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed create pod sandbox: rpc error: code = Unknown desc = failed to set up sandbox container &quot;81e89630eeb39a5c7b24e330082af265d3cd4480c83664316df3bd92fcfaaa91&quot; network for pod &quot;testpod&quot;: NetworkPlugin cni failed to set up pod &quot;testpod_default&quot; network: &quot;cni0&quot; already has an IP address different from 10.244.0.1/24</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决方案：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubeadm reset 过程</span></span><br><span class="line">systemctl stop kubelet</span><br><span class="line">systemctl stop docker</span><br><span class="line">rm -rf /var/lib/cni/</span><br><span class="line">rm -rf /var/lib/kubelet/*</span><br><span class="line">rm -rf /etc/cni/</span><br><span class="line">ifconfig cni0 down</span><br><span class="line">ifconfig flannel.1 down</span><br><span class="line">ifconfig docker0 down</span><br><span class="line">ip link delete cni0</span><br><span class="line">ip link delete flannel.1</span><br><span class="line">systemctl start kubelet</span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="comment"># kubeadm init 过程</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2018/10/01/LilyPond/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/10/01/LilyPond/" itemprop="url">LilyPond制谱教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-01T12:53:29+08:00">
                2018-10-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Academic or Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/Tools/" itemprop="url" rel="index">
                    <span itemprop="name">Tools</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2018/10/01/LilyPond/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/10/01/LilyPond/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="代码写谱-LilyPond教程"><a href="#代码写谱-LilyPond教程" class="headerlink" title="代码写谱 - LilyPond教程"></a>代码写谱 - LilyPond教程</h1><p>说到五线谱制作，大多数人最先想到的一定会是界面简洁，功能强大的<strong>Overture</strong>。然而，作为一个使用键盘的工作效率大于鼠标的人，我更希望使用一款以写码的方式制谱的软件，而<strong>lilyPond</strong>完美地满足了我的要求。它的功能之强大比起<strong>Overture</strong>更胜一筹，制谱效率也让人十分满意。</p>
<p>为了方便自己日后查阅并向更多人推广这个工具，特此将我的学习过程整理成教程留存。教程大部分的内容都是来自<a href="http://lilypond.org/doc/v2.18/Documentation/" target="_blank" rel="noopener">lilyPond的官方文档</a>，如果更愿意阅读英文可以直接查阅官方的文档。</p>
<h2 id="环境配置与使用方法"><a href="#环境配置与使用方法" class="headerlink" title="环境配置与使用方法"></a>环境配置与使用方法</h2><h3 id="安装lilyPond编译环境"><a href="#安装lilyPond编译环境" class="headerlink" title="安装lilyPond编译环境"></a>安装lilyPond编译环境</h3><p>lilyPond隶属于<strong>GNU项目</strong>，所以不出意外的话使用所有Linux发行版的官方包管理程序都可以下载到。比如，在Archlinux下，只需要执行<code>pacman -S lilypond</code>。Windows版本则可以到lilyPond的官网下载。</p>
<h3 id="渲染出乐谱"><a href="#渲染出乐谱" class="headerlink" title="渲染出乐谱"></a>渲染出乐谱</h3><p>lilyPond项目中有数个不同功能的二进制文件，其中<code>lilypond</code>专门用来将<code>.ly</code>文件渲染为乐谱文件。在作谱的时候，我们首先按照lilypond的语法来编辑<code>.ly</code>文件，再使用<code>lilypond &lt;file&gt;</code>来渲染乐谱。</p>
<p>lilypond默认渲染出的乐谱文件格式为<code>pdf</code>，可以通过调整参数来自定义输出格式。</p>
<h3 id="配置MIDI播放环境"><a href="#配置MIDI播放环境" class="headerlink" title="配置MIDI播放环境"></a>配置MIDI播放环境</h3><p>Linux下的midi播放器可以使用<code>timidity++</code>(Archlinux的aur仓库中有)，不过由于一般linux系统下不会自带音源，我们需要自己下载并配置midi音源才能播放lilypond输出的midi文件。</p>
<p><em>AUR仓库</em>中有几款不错的音源，比如<code>Freepats</code>或<code>soundfont-fluid</code>，我个人倾向于后者。执行<code>yay soundfont-fluid</code>可以直接将这个音源安装到本机，安装完成之后修改<code>/etc/timidity++/timidity.cfg</code>，取消其中的<code>soundfont</code>一行的注释，将其内容改为<code>soundfont /usr/share/soundfonts/FluidR3_GM.sf2</code>，保存即可完成对音源的配置。</p>
<h2 id="Part-1-基本记号"><a href="#Part-1-基本记号" class="headerlink" title="Part 1 基本记号"></a>Part 1 基本记号</h2><h3 id="乐句"><a href="#乐句" class="headerlink" title="乐句"></a>乐句</h3><p>在lilyPond语法中，每一段乐谱都被称为一个<code>musicexpr</code>，也就是”音乐表达式”。每个<code>musicexpr</code>都是由<strong>一对大括号</strong>括起来的一组音符声明，在大括号前可以增加一些对这个<code>musicexpr</code>的描述。</p>
<p>在之后的部分，为了方便书写，我将<code>musicexpr</code>统一翻译为<strong>乐句</strong>。</p>
<h4 id="乐句的嵌套"><a href="#乐句的嵌套" class="headerlink" title="乐句的嵌套"></a>乐句的嵌套</h4><p>每个乐句都可以对其内容进行一定的设定，如果要将几种设定同时施加到一个乐句上就需要进行乐句的嵌套了。乐句的嵌套本质上可以看成是对数个乐句施加了一层新的属性。</p>
<h4 id="乐句的赋值"><a href="#乐句的赋值" class="headerlink" title="乐句的赋值"></a>乐句的赋值</h4><p>我们可以在lilypond中声明一些变量，并用<code>\变量名</code>的方式去引用它们。变量的声明格式为<code>变量名 = 乐句</code>。在我们引用一个变量时，它所指向的乐句将会在引用位置展开。</p>
<h3 id="音高"><a href="#音高" class="headerlink" title="音高"></a>音高</h3><h4 id="音高声明"><a href="#音高声明" class="headerlink" title="音高声明"></a>音高声明</h4><p>lilypond语法中的音高以<strong>小写英文字母</strong>为基准音高，由后缀来决定音高的调整。常用的后缀有：</p>
<ul>
<li>每多一个<code>,</code>表示在基准音的基础上低一个八度，<code>&#39;</code>则表示高一个八度。</li>
<li><code>is</code>后缀表示<strong>升号</strong>(sharp)，<code>es</code>后缀表示<strong>降号</strong>(flat)。对于<strong>重升</strong>和<strong>重降</strong>，只需要重复这两个后缀即可。</li>
<li>表示节奏的后缀，几分音符就是数字几。</li>
</ul>
<p>例如，<code>cis&#39;&#39;4</code>表示一个四分音符时值的高音C-sharp。</p>
<h4 id="在乐句中使用音高声明"><a href="#在乐句中使用音高声明" class="headerlink" title="在乐句中使用音高声明"></a>在乐句中使用音高声明</h4><p>在乐句中，每一个音高声明都唯一对应着一个音符。每个乐句都是由一连串音高声明和一些描述性声明所组成的，lilypond会自动按照这个乐句的<strong>拍号</strong>(默认为4/4拍)划分小节。我们建议将每一个小节写为乐句中的一行，这样更方便我们日后读谱。</p>
<h4 id="和弦"><a href="#和弦" class="headerlink" title="和弦"></a>和弦</h4><p>如果要声明一个和声或和弦，只需要用<strong>尖括号</strong>括起和弦中的各个音符即可。<code>q</code>声明代表<strong>复制</strong>前一个和弦声明。</p>
<h4 id="绝对音高和相对音高"><a href="#绝对音高和相对音高" class="headerlink" title="绝对音高和相对音高"></a>绝对音高和相对音高</h4><p>控制<strong>绝对音高</strong>和<strong>相对音高</strong>的描述分别是<code>\absolute</code>和<code>\relative</code>。<code>\absolute &lt;musicexpr&gt;</code>所声明的乐段中所有音高标记都以<strong>低音C</strong>为基准音，这也是没有音高声明的乐段所默认采用的校准方式。<code>\relative &lt;basepitch&gt; &lt;musicexpr&gt;</code>所声明的乐段中音高的计算方式则比较复杂：</p>
<ul>
<li>如果一个音符后没有<em>八度改变后缀</em>，它所在的八度会被选为一个能<strong>使它与上一个音符的音程小于五度</strong>的八度。</li>
<li><em>八度改变后缀</em>会将音符的音高在第一条规则计算出的音高基础上提高或降低一个八度。</li>
<li>第一个音符的音高按照第一条规则与<code>&lt;basepitch&gt;</code>音高相关。</li>
<li>涉及到和弦后的计算方式更加复杂，这边不予详述，可以参考<a href="http://lilypond.org/doc/v2.18/Documentation/notation/writing-pitches" target="_blank" rel="noopener">官方文档中的描述</a>。</li>
</ul>
<p>虽然相对音高的计算比较复杂，但如果熟练之后应用相对音高会非常便利。我们在之后</p>
<h4 id="高音和低音谱号"><a href="#高音和低音谱号" class="headerlink" title="高音和低音谱号"></a>高音和低音谱号</h4><p>描述性语句<code>\clef</code>可以用于指定和切换谱号。在一个小节的声明之前插入一句<code>\clef</code>声明可以指定从这个小节开始往后的小节所在的谱号。<code>\clef bass</code>会将谱号设定为低音谱，而<code>\clef treble</code>则会设置为高音谱。没有<code>\clef</code>声明的小节默认采用高音谱号。</p>
<p>另外两种谱号，中音和次中音谱号分别对应于<code>\clef alto</code>和<code>\clef tenor</code>。更多的谱号可以参考官方文档的1.1.3节。</p>
<h4 id="升号与降号"><a href="#升号与降号" class="headerlink" title="升号与降号"></a>升号与降号</h4><p>在之前已经讲过升降号的声明，但没有涉及到还原号，这是因为<strong>还原号是不需要特殊声明的</strong>。在lilypond中，没有进行升降号声明的音符都会被处理为标准音高，也就是说<code>cis c</code>会被渲染为一个升C后接一个还原C，而不是两个升C，这和五线谱中升降号保持的法则是不同的。不过，渲染出的乐谱仍按五线谱标准显示。</p>
<p>如果想要在不需要还原号的位置强行显示还原号，可以在对应的音符后加<code>!</code>符号。如果要为变音记号加上括号，可以在对应的音符后加<code>?</code>符号。</p>
<h4 id="设置调号"><a href="#设置调号" class="headerlink" title="设置调号"></a>设置调号</h4><p>在一个小节前使用<code>\key</code>声明可以决定从这个小节开始往后部分的调号。调号由一个音高声明和一个大小调声明组成。大小调声明可以是<code>\major</code>(大调)或者<code>\minor</code>(小调)。</p>
<p>一个调号声明的例子：<code>\key bes \major</code>声明一个降B大调调号。</p>
<p>需要注意的是调号声明仅会打印出一个调号，并不会有其他的作用。</p>
<h4 id="转调声明"><a href="#转调声明" class="headerlink" title="转调声明"></a>转调声明</h4><p>有些时候我们需要将一段乐谱进行转调，如果一个个音符去修改未免工作量过大。乐句声明<code>\transpose</code>为我们提供了一种便利的转调方式。嵌套在带有<code>\transpose</code>声明的乐句内的所有乐句都会按照这个声明规定的转调方式进行转调。</p>
<p><code>\transpose</code>声明的格式为<code>\transpose &lt;basepitch&gt; &lt;nextpitch&gt;</code>，渲染器会计算<code>&lt;basepitch&gt;</code>和<code>&lt;nextpitch&gt;</code>之间的音程，并将整个乐句中嵌套的所有乐句中的所有音符向上移一个等长的音程，同时改变这些乐句中的调号(如果声明过)。</p>
<h4 id="高八度和低八度记号"><a href="#高八度和低八度记号" class="headerlink" title="高八度和低八度记号"></a>高八度和低八度记号</h4><p><code>\ottava &lt;scale&gt;</code>声明可以用于添加高八度和低八度记号。<code>&lt;scale&gt;</code>的取值为<code>#x</code>，其中<code>x</code>为升高或降低的八度个数。如果x为正整数则表示升高，否则表示降低，为0表示还原到原来的高度。</p>
<p>需要注意的是，<strong>这个记号并不会改变音符的实际音高</strong>，因此如果在应用记号后不手动调整音高，音符就会在谱面上做相应的调整以适应原来的音高。</p>
<p>下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\relative c&apos; &#123;</span><br><span class="line">  \key d \minor</span><br><span class="line">  d4 a&apos; g2</span><br><span class="line">  \ottava #1</span><br><span class="line">  f&apos;4 g a c8 a</span><br><span class="line">  \ottava #0</span><br><span class="line">  g,4 f e2 ~</span><br><span class="line">  e4 f2 ~ f4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>渲染出的谱面是这样的：</p>
<p><img src="ottava.png" alt="谱面"></p>
<h3 id="节奏"><a href="#节奏" class="headerlink" title="节奏"></a>节奏</h3><h4 id="音符时值"><a href="#音符时值" class="headerlink" title="音符时值"></a>音符时值</h4><p>正如之前说过的，在音符声明后加数字可以声明一个对应时值的音符，如<code>b4</code>声明四分音符，<code>g32</code>声明三十二分音符等等。在数字后面加<code>.</code>可以在音符后加<strong>浮点</strong>，其时值增加规则和乐理知识中相同。</p>
<p>如果未加声明，后面的音符会自动继承前面音符的时值。如，<code>c4 d e f</code>会渲染出四个连续的四分音符。</p>
<p><code>\autoBeamOn</code>和<code>\autoBeamOff</code>可以打开或关闭切分音之间的自动连线。自动连线机制默认是打开的。</p>
<h4 id="三连音"><a href="#三连音" class="headerlink" title="三连音"></a>三连音</h4><p>声明三连音或多连音均可以使用<code>\tuplet</code>声明。其格式为<code>\tuplet &lt;fraction&gt; { &lt;notes&gt; }</code>，其中<code>&lt;fraction&gt;</code>是一个分式，分母为整个tuplet的总时值，分子为等分的份数。例如，<code>5/4</code>声明一个平分四分音符的五连音。</p>
<p>需要注意的是，<code>&lt;note&gt;</code>中的音符一定要标定对应的时值。如果要声明一个平分四分音符的三连音，就必须将<code>&lt;note&gt;</code>中的音符声明为8分音符，否则渲染会出现偏差。</p>
<h4 id="拍号的声明"><a href="#拍号的声明" class="headerlink" title="拍号的声明"></a>拍号的声明</h4><p>一个乐句的默认拍号是<code>4/4拍</code>，但我们可以使用<code>\time</code>声明显式地修改拍号。<code>\time N/M</code>可以将乐句的拍号修改为N-M拍(有基本乐理知识的人应该都明白N-M拍是什么意思，这边不予详述)。</p>
<p><code>\defaultTimeSignature</code>和<code>\numericTimeSignature</code>可以用于两种拍号表示方式的切换。</p>
<p>如果我们声明了一个比较奇怪的节奏型(比如《哈德曼的妖怪少女》的<code>7/8</code>拍)，lilypond默认的符尾连接方式会失效，需要我们手动设置，否则所有时值小于等于八分音符的音符符尾全都不会相连，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\relative c&apos; &#123;</span><br><span class="line">  \time 7/8</span><br><span class="line">  a&apos;8 f d \tuplet 3/2 &#123;c&apos;4 bes c&#125;</span><br><span class="line">  a8 f d gis e cis gis&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="time.png" alt="koishi"></p>
<p>手动设置的方式是在<code>\time</code>后面加一个<code>#&#39;(&lt;pattern&gt;)</code>记号。<code>&lt;pattern&gt;</code>是一连串数字，这些数字将每个小节中的音符依次分为大小等于每个数字的组，同组间的音符会有符尾连接，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\relative c&apos; &#123;</span><br><span class="line">  \time #&apos;(3 4) 7/8</span><br><span class="line">  a&apos;8 f d \tuplet 3/2 &#123;c&apos;4 bes c&#125;</span><br><span class="line">  a8 f d gis e cis gis&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="timeplus.png" alt="koishi_plus"></p>
<h4 id="隐式地改变音符的时值"><a href="#隐式地改变音符的时值" class="headerlink" title="隐式地改变音符的时值"></a>隐式地改变音符的时值</h4><p>有些时候我们希望在改变音符时值的同时不影响乐谱的外观，这时我们可以在一个音符声明的后面加一个<code>*x/y</code>后缀，其中<code>x/y</code>是一个分数，代表改变后的时值(<code>/y</code>部分可以缺省)。</p>
<h4 id="连音线"><a href="#连音线" class="headerlink" title="连音线"></a>连音线</h4><p><strong>连音线只能连接两个相同音高的音符</strong>。在两个这样的音符之间加一个<code>~</code>即可为它们加上连音线。</p>
<p>如果需要给被小节线分隔的两个音打上连音线，我们可以利用lilypond的<strong>自动切割功能</strong>，即在第一个音符处声明一个时值等于两个音符时值之和的音符，lilypond会自动将其切割为两个被连音线连接的跨小节音符。</p>
<p>当两个<strong>和弦声明</strong>被连音线连接时，和弦中所有等音高的音符会被连音线连接，而不同音高的不会。</p>
<p>更多关于连音线的线条形式或曲线属性的设置可以参考<a href="http://lilypond.org/doc/v2.18/Documentation/notation/writing-rhythms#ties" target="_blank" rel="noopener">官方文档中的说明</a>。</p>
<h4 id="休止符"><a href="#休止符" class="headerlink" title="休止符"></a>休止符</h4><p>一般的休止符由字母<code>r</code>和表示时值的后缀组成。如果用<code>s</code>取代<code>r</code>，则可以声明一个<strong>不可见的</strong>休止符。</p>
<h4 id="速度标志"><a href="#速度标志" class="headerlink" title="速度标志"></a>速度标志</h4><p>一般的乐谱开始位置都会有一个标志来表示乐谱的演奏速度，这种标志可以用于设定节拍器，因而称为<code>Metronome mark</code>。<code>\tempo</code>声明可以用于声明这种标志。</p>
<p><code>\tempo</code>最常见的用法是后跟<code>&lt;duration&gt; = &lt;speed&gt;</code>，其中<code>&lt;duration&gt;</code>是一个表示速度标记中左边那个音符时值的数字，<code>&lt;speed&gt;</code>是速度标记中右边那个数字。另一种没有那么精确的用法是<code>\tempo &quot;&lt;text&gt;&quot;</code>，其中<code>&lt;text&gt;</code>可以是各种用于描述速度的标记，如<code>Allegreto</code>(快板)。<strong>这两种用法可以混用</strong>，混用时速度标记会被小括号括起来。</p>
<h4 id="弱起小节"><a href="#弱起小节" class="headerlink" title="弱起小节"></a>弱起小节</h4><p>在一些乐曲中第一个小节是不完整的：我们使用弱拍作为乐曲的开始而非惯用的强拍。在这种情况下，需要使用<code>\partial &lt;duration&gt;</code>来声明这个不完整的小节，其中<code>&lt;duration&gt;</code>是小节更改后的长度。</p>
<h4 id="特殊的小节线"><a href="#特殊的小节线" class="headerlink" title="特殊的小节线"></a>特殊的小节线</h4><p>我们可以通过<code>\bar &quot;&lt;symbols&gt;&quot;</code>声明来<strong>显式地</strong>声明一个小节线。这个小节线不受自动小节划分的限制，可以安放在任何位置。我们可以通过<code>&lt;symbols&gt;</code>来显式定义小节线的样式，<code>&lt;symbol&gt;</code>由几种字符组成：</p>
<ul>
<li><code>:</code> 代表小节线中的冒号，一般与重复小节线有关</li>
<li><code>.</code> 代表粗小节线，与重复小节线和终止线有关</li>
<li><code>|</code> 代表普通小节线</li>
</ul>
<p>大部分小节线都可以用这三种符号的排列来表示。</p>
<h4 id="装饰音"><a href="#装饰音" class="headerlink" title="装饰音"></a>装饰音</h4><p>在一个音符声明前加上<code>\grace</code>标记可以让这个音符成为装饰音。如果要声明多个连续的装饰音，可以用<strong>大括号</strong>将这些音符括起，在大括号前加<code>\grace</code>。</p>
<h3 id="增强表现力的符号"><a href="#增强表现力的符号" class="headerlink" title="增强表现力的符号"></a>增强表现力的符号</h3><p>增强表现力的符号一般绑定在某个音符上，其声明形式为<code>&lt;note&gt;\&lt;symbol&gt;</code>，其中<code>&lt;note&gt;</code>是一个音符声明，<code>&lt;symbol&gt;</code>是特定的标号。</p>
<h4 id="表示处理方式"><a href="#表示处理方式" class="headerlink" title="表示处理方式"></a>表示处理方式</h4><p>常用的加在单个音符上的标号有<code>\staccato</code>(跳音符)，<code>\fermata</code>(延音符)，<code>\accent</code>(重音符)，<code>\trill</code>(颤音符)等。完整的符号表可以参照<a href="http://lilypond.org/doc/v2.18/Documentation/notation/list-of-articulations" target="_blank" rel="noopener">官方文档</a>。</p>
<p>除了标准声明形式之外，还有一些常用的简写来减轻我们的工作量，比如<code>-&gt;</code>与<code>\accent</code>等效，<code>-.</code>与<code>\staccato</code>等效。</p>
<h4 id="表示音符强弱"><a href="#表示音符强弱" class="headerlink" title="表示音符强弱"></a>表示音符强弱</h4><p>与音符绑定的强弱符也可以用这个形式来声明，其对应的symbol与强弱符在谱面上的标号一致，如<code>\pp</code>或<code>\sf</code>。渐强渐弱符需要一个起点音符和一个终点音符：起点音符与<code>\&gt;</code>或<code>\&lt;</code>绑定，终点音符与<code>\!</code>绑定。另一种形式的渐强渐弱符只需要在起点绑定一个<code>\cresc</code>或<code>\dim</code>标号即可。</p>
<h4 id="连唱线"><a href="#连唱线" class="headerlink" title="连唱线"></a>连唱线</h4><p>连唱线开始位置的音符需要加一个<code>(</code>后缀，而结束位置的音符需要加一个<code>)</code>后缀。连唱线可以嵌套。</p>
<h4 id="琶音"><a href="#琶音" class="headerlink" title="琶音"></a>琶音</h4><p>琶音的声明用于和弦。在一个和弦后绑定<code>\arpeggio</code>记号可以在这个和弦上加琶音线。</p>
<h4 id="颤音"><a href="#颤音" class="headerlink" title="颤音"></a>颤音</h4><p>之前提到过的<code>\trill</code>记号用于声明在单个音符上方的颤音符<code>tr</code>，另一种有起止位置的颤音符可以以开始音符绑定<code>\startTrillSpan</code>，结束音符绑定<code>stopTrillSpan</code>的方式声明。</p>
<h3 id="复调"><a href="#复调" class="headerlink" title="复调"></a>复调</h3><p>用<code>&lt;&lt; &gt;&gt;</code>括起来的两个或以上的乐句可以并行演奏，这种记谱方式称为<code>polyphony</code>(复调)。</p>
<p>如果不加显式的标记，这些乐句会被<strong>默认地放入同一个声部中</strong>，这通常会导致音符在乐谱中的碰撞，从而使某些音符渲染失败或不正常渲染。通常在进行复调作谱时，会用这几种方式将几个乐句安排到不同的声部中：</p>
<ul>
<li>在每个乐句的内部开始位置加一个<code>\voiceOne</code>～<code>\voiceFour</code>的声明以指明这个乐句属于哪个声部，同时在每个乐句的前面增加<code>\new Voice</code>声明，为它们分别创造新的声部。</li>
<li>在乐句之间加入<code>\\</code>记号，这样lilypond会自动为这些乐句分配不同的声部。</li>
</ul>
<h3 id="乐器记号"><a href="#乐器记号" class="headerlink" title="乐器记号"></a>乐器记号</h3><p><code>\new</code>或<code>\context</code>声明被用于声明一组乐谱。</p>
<p>最基本的乐器是<code>Staff</code>，<code>\new Staff</code>可以声明一组最简单的钢琴五线谱。除了普通的<code>Staff</code>之外，还有<code>DrumStaff</code>，<code>RhythmicStaff</code>等乐谱格式可以使用。</p>
<h4 id="乐谱组"><a href="#乐谱组" class="headerlink" title="乐谱组"></a>乐谱组</h4><p>绝大部分器乐乐谱都需要乐谱的分组，比如钢琴谱的左右手，交响乐谱的各种乐器。用之前提到过的复调记号就可以实现乐谱的分组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;</span><br><span class="line">\new Staff &#123;...&#125;</span><br><span class="line">\new Staff &#123;...&#125;</span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>效果如图：</p>
<p><img src="Staff.png" alt=""></p>
<p>可以在复调记号之前使用乐谱组声明来改变乐谱的外观：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\new StaffGroup &lt;&lt;</span><br><span class="line">  \new Staff &#123;...&#125;</span><br><span class="line">  \new Staff &#123;...&#125;</span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>效果如图：</p>
<p><img src="StaffGroup.png" alt=""></p>
<p>也可以使用钢琴谱声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\new GrandStaff &lt;&lt;</span><br><span class="line">  \new Staff &#123;...&#125;</span><br><span class="line">  \new Staff &#123;...&#125;</span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>效果如图：</p>
<p><img src="GrandStaff.png" alt=""></p>
<h4 id="乐器属性"><a href="#乐器属性" class="headerlink" title="乐器属性"></a>乐器属性</h4><p>可以在<code>\new Staff</code>声明之后紧跟一个<code>\with {}</code>声明块来描述这个乐器的属性。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\new Staff\with &#123;</span><br><span class="line">  instrumentName = #&quot;Piano &quot;</span><br><span class="line">&#125; &#123; c d e f &#125;</span><br></pre></td></tr></table></figure>
<p>可以在乐谱前显示Piano字样。</p>
<h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><h4 id="在音符上下方添加文本"><a href="#在音符上下方添加文本" class="headerlink" title="在音符上下方添加文本"></a>在音符上下方添加文本</h4><p>在一个音符声明上方添加文本可以使用<code>^&lt;text&gt;</code>，如果是下方则为<code>_&lt;text&gt;</code>，这和LateX的语法是相同的。<code>&lt;text&gt;</code>可以是简单的文本常量<code>&quot;aslkdj&quot;</code>，也可以是一些复杂的表达式，比如<code>\markup</code>语句块。</p>
<p>也可以用<code>\mark &lt;text&gt;</code>声明在音符之间的位置上方添加文本。</p>
<h4 id="Markup语句块"><a href="#Markup语句块" class="headerlink" title="Markup语句块"></a>Markup语句块</h4><p><code>\markup {...}</code> 可以声明一个Markup语句块。你可以在Markup语句块中用各种LaTeX语法来格式化文本。常用的标记大致有：</p>
<ul>
<li>改变字体格式<ul>
<li><code>\bold</code></li>
<li><code>\italic</code></li>
<li><code>\underline</code></li>
<li><code>\super</code> (上标)</li>
<li><code>\sub</code>  (下标)</li>
<li><code>\smallCaps</code></li>
</ul>
</li>
<li>改变字号<ul>
<li><code>\huge</code></li>
<li><code>\teeny</code></li>
<li><code>\normalsize</code></li>
<li><code>\fontsize #&lt;num&gt;</code></li>
</ul>
</li>
<li>排版<ul>
<li><code>\column {}</code>：其中的元素只能是<code>\line {}</code><ul>
<li><code>\center-column</code></li>
</ul>
</li>
<li><code>\line {}</code>：其中放置一行文本</li>
</ul>
</li>
<li>字体<ul>
<li><code>\sans</code></li>
<li><code>\typewriter</code></li>
<li><code>\roman</code></li>
</ul>
</li>
</ul>
<p>更多标记可以参考<a href="http://lilypond.org/doc/v2.18/Documentation/notation/formatting-text" target="_blank" rel="noopener">官方文档</a>。</p>
<h2 id="Part-2-特殊记号"><a href="#Part-2-特殊记号" class="headerlink" title="Part 2 特殊记号"></a>Part 2 特殊记号</h2><h3 id="踏板"><a href="#踏板" class="headerlink" title="踏板"></a>踏板</h3><p><code>\sustainOn</code>和<code>\sustainOff</code>声明可以用来控制钢琴的踏板。</p>
<h2 id="Part-3-IO"><a href="#Part-3-IO" class="headerlink" title="Part 3 IO"></a>Part 3 IO</h2><h3 id="乐谱的输出"><a href="#乐谱的输出" class="headerlink" title="乐谱的输出"></a>乐谱的输出</h3><p>每段乐谱在输出时必须被包装在一个<code>\score {}</code>块中。除了乐谱部分，我们还可能需要一个<code>\header {}</code>块，在这个块中我们可以指定<code>title = &quot;...&quot;</code>，<code>composer = &quot;...&quot;</code>以及<code>subtitle = &quot;...&quot;</code>等。</p>
<p>一个<code>\bookpart {}</code>块代表乐谱本中的一部分，每个这种块中必须包含一个<code>\header</code>和一个<code>\score</code>块。</p>
<h2 id="Appendix-乐理名词翻译"><a href="#Appendix-乐理名词翻译" class="headerlink" title="Appendix 乐理名词翻译"></a>Appendix 乐理名词翻译</h2><h3 id="Pitch-音高"><a href="#Pitch-音高" class="headerlink" title="Pitch 音高"></a>Pitch 音高</h3><ul>
<li>octave 八度</li>
<li>bass 低音</li>
<li>treble 高音</li>
<li>chord 和弦</li>
<li>accidental 变音记号<ul>
<li>sharp 升</li>
<li>flat 降</li>
<li>natural 还原</li>
</ul>
</li>
<li>interval 音程<ul>
<li>major 大音程</li>
<li>minor 小音程</li>
<li>augmented 增音程</li>
<li>diminished 减音程</li>
</ul>
</li>
</ul>
<h3 id="Rhythm-节奏"><a href="#Rhythm-节奏" class="headerlink" title="Rhythm 节奏"></a>Rhythm 节奏</h3><ul>
<li>duration 时值</li>
<li>tuplet <code>x</code>连音</li>
<li>tie 连音线</li>
<li>measure 小节</li>
<li>bar 小节线</li>
<li>metronome 节拍器</li>
<li>rest 休止符</li>
<li>grace 装饰音</li>
</ul>
<h3 id="Expression-表现"><a href="#Expression-表现" class="headerlink" title="Expression 表现"></a>Expression 表现</h3><ul>
<li>dynamic 强弱符</li>
<li>slur 连唱线</li>
<li>Arpeggio 琶音</li>
<li>trill 颤音</li>
<li>polyphony 复调</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2018/07/11/ArchLinux下的软件安装/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/07/11/ArchLinux下的软件安装/" itemprop="url">ArchLinux下的软件安装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-11T09:39:48+08:00">
                2018-07-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Academic or Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/ArchLinux-and-Shell/" itemprop="url" rel="index">
                    <span itemprop="name">ArchLinux and Shell</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2018/07/11/ArchLinux下的软件安装/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/07/11/ArchLinux下的软件安装/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Archlinux下的软件安装方式总结"><a href="#Archlinux下的软件安装方式总结" class="headerlink" title="Archlinux下的软件安装方式总结"></a>Archlinux下的软件安装方式总结</h2><p>虽然Archlinux既有稳定的官方镜像源又有完善的aur社区，仍然有一些软件是我们通过这两种方式无法安装的。今天就来总结一下Archlinux下所有的安装方式，让我们能方便舒适地使用所有软件。</p>
<h3 id="pacman"><a href="#pacman" class="headerlink" title="pacman"></a>pacman</h3><p><code>pacman</code>是Arch官方的包管理工具。这里能下载到的都是Arch官方支持的软件，因此很多软件是无法从这种途径获取的。</p>
<h4 id="找到需要的软件包"><a href="#找到需要的软件包" class="headerlink" title="找到需要的软件包"></a>找到需要的软件包</h4><p>有些时候我们会发现有的软件依赖的二进制文件并没有被安装，导致软件无法运行。想要查找一个二进制文件所在的pacman软件包，可以使用<code>pkgfile</code>工具。使用方法是<code>pkgfile &lt;文件名&gt;</code>。它会输出这个文件所在的软件包名。</p>
<h4 id="pacman的使用方式"><a href="#pacman的使用方式" class="headerlink" title="pacman的使用方式"></a>pacman的使用方式</h4><ul>
<li>常用参数<ul>
<li><code>-S</code> 后面跟软件包名，与镜像源同步，一般使用这个参数安装新的软件包或升级旧的软件包。</li>
<li><code>-U</code> 后面跟一个文件名，通过下载到本地的安装包安装软件</li>
<li><code>-R</code> 后面跟软件包名，卸载这个软件并删除软件包</li>
<li><code>-Syu</code> 俗称 <em>滚Arch</em> ，进行全面的系统更新</li>
</ul>
</li>
</ul>
<h4 id="定制pacman下载工具"><a href="#定制pacman下载工具" class="headerlink" title="定制pacman下载工具"></a>定制pacman下载工具</h4><p><code>pacman</code>的配置文件是<code>/etc/pacman.conf</code>。在这个文件中我们可以对<code>pacman</code>的行为进行自定义。</p>
<ul>
<li>常用的自定义项<ul>
<li>改变<code>pacman</code>的镜像源：修改<code>/etc/pacman.d/mirrorlist</code>文件内容</li>
<li>改变<code>pacman</code>使用的下载工具：修改<code>XferCommand</code>变量的值<ul>
<li><code>/usr/bin/curl -C - -f %u &gt; %o</code> pacman默认使用<code>curl</code>作为下载工具</li>
<li><code>/usr/bin/wget --passive-ftp -c -O %o %u</code> <code>wget</code>是一款非常优秀的单线程下载工具，功能比<code>curl</code>更为强大</li>
<li><code>/usr/bin/axel -o %o %u</code> <code>axel</code>是一款多线程下载工具，速度比前两者要快，推荐设置它为<code>pacman</code>的默认工具。</li>
<li><strong>注意</strong>：<code>wget</code>和<code>axel</code>需要提前用pacman安装。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="yaourt-yay"><a href="#yaourt-yay" class="headerlink" title="yaourt/yay"></a>yaourt/yay</h3><p>官方支持的软件毕竟是有限的，很多我们需要的第三方软件并没有官方提供的支持。在这种时候，Archlinux丰富而强大的aur社区就体现出其威力了——我们可以很方便地从aur社区下载别人制作好的应用软件包或二进制文件，还可以将自己制作的软件包发布在这个社区上(关于发布方式的细节不在这里讨论)。</p>
<p>从aur社区下载软件包所需要的工具是<code>yaourt</code>(现在yaourt已经停止更新了，取而代之的是<code>yay</code>)。使用<code>pacman</code>可以安装<code>yaourt</code>，使用<code>yaourt</code>可以安装<code>yay</code>。</p>
<h4 id="yaourt-yay的使用方式"><a href="#yaourt-yay的使用方式" class="headerlink" title="yaourt/yay的使用方式"></a>yaourt/yay的使用方式</h4><p>与<code>pacman</code>类似，yaourt可以用<code>-S</code>参数来下载并安装软件包。如果不加参数，yaourt会在aur库中搜索所有名字与给出的名字相近的软件包或二进制文件，并以表的形式列出，供用户选择。下载到的二进制文件会默认保存在当前目录中。</p>
<h4 id="定制yaourt-yay下载工具"><a href="#定制yaourt-yay下载工具" class="headerlink" title="定制yaourt/yay下载工具"></a>定制yaourt/yay下载工具</h4><p><code>yaourt</code>和<code>yay</code>的配置文件都是<code>/etc/makepkg.conf</code>。</p>
<p>修改下载工具的方式与pacman类似，只不过修改的是DLAGENTS变量。修改时可以直接删除这个变量原来的所有值，改为<code>DLAGENTS = (&#39;http::/usr/bin/wget --passive-ftp -c -O %o %u&#39;,&#39;https::/usr/bin/wget --passive-ftp -c -O %o %u&#39;)</code></p>
<h4 id="AUR的其他使用方式"><a href="#AUR的其他使用方式" class="headerlink" title="AUR的其他使用方式"></a>AUR的其他使用方式</h4><p>有些时候yay会出现玄学问题，即明明远端的aur包是存在的，在试图拉取的时候却报404。这种时候，我们可以在<a href="https://aur.archlinux.org/packages/" target="_blank" rel="noopener">AUR仓库</a>中搜索这个包的名字，找到其git地址，并使用<code>git clone</code>直接将其拉取到本地。</p>
<p>拉取完成之后，可以在PKGBUILD文件所在的位置执行<code>makepkg</code>命令来安装这个包。如果仍然出现下载错误，就复制PKGBUILD中source变量指明的下载地址并用wget去手动下载，并在下载完成之后修改source变量的值为这个包在本地的路径，再次执行<code>makepkg</code>就可以了。</p>
<h3 id="通过下载好的软件包安装"><a href="#通过下载好的软件包安装" class="headerlink" title="通过下载好的软件包安装"></a>通过下载好的软件包安装</h3><p>如果一个软件既无法通过<code>pacman</code>下载又无法通过aur库得到，那就只能手动安装了。首先我们要通过各种渠道获取软件的安装包(<code>GitHub</code>/<code>wget</code>/软件官网/其他)，随后的操作要视软件包而定。</p>
<h4 id="软件是单文件-二进制文件"><a href="#软件是单文件-二进制文件" class="headerlink" title="软件是单文件(二进制文件)"></a>软件是单文件(二进制文件)</h4><p>这种情况最简单，没有软件包，直接把二进制文件移动到<code>/usr/bin</code>文件夹下即可(注意要加<code>sudo</code>)。</p>
<h4 id="软件包中有安装脚本"><a href="#软件包中有安装脚本" class="headerlink" title="软件包中有安装脚本"></a>软件包中有安装脚本</h4><p>大多软件会在软件包中放一个命名为<code>install.sh</code>(或其他名字)的安装脚本。在这种情况下，可以直接执行<code>sh install.sh</code>或<code>./install.sh</code>来安装软件。(最好结合软件的READ.ME或官方说明安装)</p>
<h4 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h4><p>如果安装脚本不能在Arch下正常运行，那就只好手动拆包安装了。这种时候可以搜索一下各种后缀的软件包的格式，然后手动将二进制文件，lib文件和其他配置文件cp到需要的位置完成安装。</p>
<h3 id="downgrade"><a href="#downgrade" class="headerlink" title="downgrade"></a>downgrade</h3><p>和前面几种方式不同，downgrade是一种给软件包<strong>降级</strong>的方式。使用这个工具可以很方便地回滚软件包等级，从而解决一些可能存在的依赖问题。</p>
<p>执行<code>yay downgrade</code>命令可以直接从aur仓库安装downgrade工具。</p>
<p>使用downgrade工具需要root权限。使用方式：<code>sudo downgrade &lt;软件包&gt;</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2018/05/02/MakeFile/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/05/02/MakeFile/" itemprop="url">MakeFile学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-02T12:00:34+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Academic or Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/Tools/" itemprop="url" rel="index">
                    <span itemprop="name">Tools</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2018/05/02/MakeFile/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/05/02/MakeFile/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="MakeFile学习笔记"><a href="#MakeFile学习笔记" class="headerlink" title="MakeFile学习笔记"></a>MakeFile学习笔记</h2><p>学习资料：<a href="https://www.gnu.org/software/make/manual/make.html" target="_blank" rel="noopener">GNU make官方文档</a></p>
<h3 id="Basis"><a href="#Basis" class="headerlink" title="Basis"></a>Basis</h3><h4 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h4><p>MakeFile最重要的元素是<code>rule</code>，也就是<strong>构造规则</strong>。一条规则有这样的形式：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;target&gt;:&lt;prerequisites&gt;</span></span><br><span class="line">	&lt;recipe&gt;</span><br><span class="line">	&lt;recipe&gt;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<h5 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h5><p>一个<strong>目标</strong>可以是：</p>
<ul>
<li>一个文件的名字</li>
<li>一个标识符，且标识符的名字不应与MakeFile所在文件夹下的文件名重合</li>
</ul>
<p>不加标注的话，MakeFile<strong>会优先将目标识别为文件名</strong>。如果要显式地将目标指定为标识符，需要在这一条规则前面加一条<code>.PHONY: &lt;ident&gt;</code>指令，其中<code>&lt;ident&gt;</code>是要指定的标识符。</p>
<h5 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h5><p><strong>前置条件</strong>是创建目标所需要的文件列表。这个列表中的文件之间用<strong>空格</strong>隔开。</p>
<p>只有在前置条件中的<strong>某一个(或多个)文件发生过改变</strong>后，这条规则才会执行<code>&lt;recipe&gt;</code>们，否则无事发生。</p>
<p>当然，在<code>&lt;recipe&gt;</code>存在的情况下，前置条件是可以缺省的，这样只要执行这条规则就会执行<code>&lt;recipe&gt;</code>。</p>
<h5 id="Recipes"><a href="#Recipes" class="headerlink" title="Recipes"></a>Recipes</h5><p>每一条<code>recipe</code>都是一条shell指令。这条规则在自身被执行的时候依次执行它们。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>Make用以区分多条<code>recipe</code>的是<strong><code>tab</code>符</strong>。也就是说，只要在每条<code>recipe</code>前面加一个<code>tab</code>符就可以了。如果想改用其他符号来标志，也可以设置<code>.RECIPEPREFIX</code>变量。</li>
<li>不同的<code>recipe</code>在不同的shell中执行，因此很多环境变量可能会不共享。</li>
</ul>
<p><code>recipe</code>是可以缺省的。<strong>当我们的<code>object</code>是<code>*.o</code>文件时，make会默认以<code>cc -c *.c</code>作为这条规则的<code>recipe</code>。</strong>与此同时，这个<code>*.c</code>文件还会自动被加入<strong>前置条件</strong>。</p>
<p>另外，当我们需要将一个长行分割为几行的时候，可以用<code>\</code>去连接它们。</p>
<h4 id="Processing-Rules"><a href="#Processing-Rules" class="headerlink" title="Processing Rules"></a>Processing Rules</h4><p>一个MakeFile中优先被执行的规则是<strong>第一条不以<code>.</code>开头的规则</strong>。</p>
<p>当make执行一条规则的时候，如果它的<strong>前置条件有着属于自己的规则</strong>，那么它会先去执行这个前置条件所依赖的规则。如果一条非默认规则不被任何规则所依赖，它就无法被单纯的<code>make</code>指令执行。</p>
<p>一种巧妙的用法，如果前置条件是一个非文件<code>target</code>，那么执行这条规则时就会顺带无条件执行这个前置条件对应的规则。</p>
<h4 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h4><p>我们可以使用<code>&lt;ident&gt; = &lt;content&gt;</code>来声明一个变量。不过说是变量其实这更像一个宏。</p>
<p>要引用一个变量，我们需要使用这样的格式：<code>$(&lt;ident&gt;)</code></p>
<p>我们可以在执行<code>make</code>的时候以<code>&lt;ident&gt;=&lt;value&gt;</code>(注意中间不能带空格)的形式预先声明变量的值，以这种方式声明的参数值会覆盖在makefile中的变量赋值。</p>
<p>如果使用了一个既没有在makefile中初始化又没有在命令行中赋值的变量，那么这个变量就会被忽略。</p>
<h4 id="Including"><a href="#Including" class="headerlink" title="Including"></a>Including</h4><p>我们可以使用<code>include &lt;filenames&gt;</code>来将其他文件(通常是子文件夹下的makefile)包含进来。</p>
<p>使用<code>include</code>时，如果make无法找到指定的文件或文件夹，就会报错并退出。<code>-include</code>命令可以让make直接忽略找不到的文件，不进行报错和退出。</p>
<h3 id="Advanced"><a href="#Advanced" class="headerlink" title="Advanced"></a>Advanced</h3><h4 id="Echoing"><a href="#Echoing" class="headerlink" title="Echoing"></a>Echoing</h4><p>make默认会<strong>打印出</strong>每一条执行的<code>recipe</code>，这种行为称为回声。</p>
<p>如果要让make只执行不打印，就需要在这条<code>recipe</code>前面加上<strong><code>@</code>符号</strong>。</p>
<p>一般来说，我们只会在注释和<code>echo</code>指令前面加<code>@</code>。</p>
<h4 id="Wildcard"><a href="#Wildcard" class="headerlink" title="Wildcard"></a>Wildcard</h4><p>make使用bash风格的通配符。如，<code>*.&lt;suffix&gt;</code>指代所有的<code>.&lt;suffix&gt;</code>文件。</p>
<p>也可以用<code>%</code>来进行模式匹配，一条带有<code>%</code>的匹配表达式会被替换为所有符合这条表达式的规则。</p>
<h4 id="Valuing"><a href="#Valuing" class="headerlink" title="Valuing"></a>Valuing</h4><p>为了避免引起歧义，变量的赋值有四种方式：</p>
<ul>
<li><code>=</code>：惰性赋值，用到被赋值的变量时再根据赋值者的当前值进行赋值，可以递归</li>
<li><code>:=</code>：在运行前直接根据最近一次赋值进行展开，运行后不再改变</li>
<li><code>?=</code>：只有被赋值者当前没有值时才会赋值</li>
<li><code>+=</code>：相当于<code>append</code></li>
</ul>
<h4 id="Automatic-Variables"><a href="#Automatic-Variables" class="headerlink" title="Automatic Variables"></a>Automatic Variables</h4><ul>
<li><code>$@</code>：指代当前构建的目标</li>
<li><code>$&lt;</code>：指代第一个前置条件</li>
<li><code>$?</code>：指代<strong>比目标更新的</strong>所有前置条件</li>
<li><code>$^</code>：指代所有前置条件</li>
<li><code>$*</code>：指代<code>%</code>匹配到的部分</li>
<li><code>@D</code>：目标的目录部分</li>
</ul>
<h4 id="Control-Flow"><a href="#Control-Flow" class="headerlink" title="Control Flow"></a>Control Flow</h4><p>make使用与bash相似的语法完成条件判断和循环。</p>
<p>比较常用的条件判断语句有：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Type 1</span></span><br><span class="line"><span class="keyword">ifeq</span> (&lt;var/imm&gt;, &lt;var/imm&gt;)</span><br><span class="line">	&lt;command&gt;</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment"># Type 2</span></span><br><span class="line"><span class="keyword">ifndef</span> &lt;var&gt;</span><br><span class="line">	&lt;command&gt;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/blog/images/lyrica.png" alt="Drac Zhang">
            
              <p class="site-author-name" itemprop="name">Drac Zhang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/blog/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/dracit7" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Drac Zhang</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://Drac_zhang.disqus.com/count.js" async></script>
    

    

  




	





  














  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/blog/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
