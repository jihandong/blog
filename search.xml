<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MIT 6.824 Labs 实验记录]]></title>
    <url>%2Fblog%2F2019%2F06%2F17%2FMIT_6.824%2F</url>
    <content type="text"><![CDATA[MIT 6.824 Labs 实验记录本博客中所有代码所对应的github repo地址：6.824 Lab 1 MapReduceIntroduction在这个Lab中我们要实现一个MapReduce的库，以搭建一个容错的分布式系统。在第一部分，我们只需要写一个简单的Mapreduce程序，在第二部分则需要实现一个分发任务给workers和处理错误的master节点。我们使用的接口与容错算法和原始版本的Mapreduce论文中描述的基本一致。 执行git clone git://g.csail.mit.edu/6.824-golabs-2018 6.824可以将2018春季版的6.824仓库拉取到本地。 6.824提供的MapReduce实现有两种操作模式：串行的和分布式的。 串行模式下，程序先依次执行Map任务再依次执行Reduce任务，这种策略比较慢但是容易debug。 分布式模式下，程序将各个Map任务用多线程并行处理，之后再并行处理多个Reduce任务。这种策略很快但是不容易debug。 在mapreduce目录下有一个简单的MapReduce库，用户程序可以调用master.go中的Distributed()函数或Sequential()函数来分别运行一个分布式或串行任务。 任务执行的流程如下： 用户程序提供一系列输入文件，一个map函数和一个reduce函数，以及reduce任务的数量nReduce。 处理函数创建一个master节点，这个节点会： 启动一个RPC服务器(代码见master_rpc.go) 服务器等待worker们用Register函数(定义于master.go中)来注册 schedule函数在任务准备好后决定如何分配任务以及如何处理错误 master将每个输入文件视为一个map任务，并为每个任务调用至少一次doMap函数。它可以自己来完成这个任务，也可以用DoTask函数(定义于worker.go)来将任务分配给worker。 每次对doMap的调用会读取对应的文件，对其内容调用map函数，并将返回的键值对写入nReduce个中间文件中。 doMap会对每个key调用哈希函数来确定对应的中间文件，这样reduce任务就能提取出中间文件对应的key。 在所有map工作完成后，会产生nMap×nReduce个中间文件，每个文件的名字包含一个前缀，map任务序号和reduce任务序号。 每个worker都必须能够访问其他workers创建的文件和输入文件。真正的分布式多节点系统使用GFS这样的分布式存储系统来实现这一点，而我们的所有worker都跑在同一台机器，所以直接使用本地文件系统即可。 master为每个reduce任务调用至少一次doReduce函数。它可以自己来完成这个任务，也可以用DoTask函数(定义于worker.go)来将任务分配给worker。 为reduce任务r进行的doReduce函数的调用会收集起每个map任务产生的第r个中间文件，并为它们中出现的每个key调用reduce函数。 这个过程会产生nReduce个结果文件。 master调用mr.merge()函数(定义于master_splitmerge.go)来将nReduce个结果文件合并为一个输出文件。 master向每个worker发送shutdown信号，然后关掉它自己的RPC服务器。 在接下来的任务中，你需要且只能修改： doMap函数(定义于common_map.go) doReduce函数(定义于common_reduce.go) schedule函数(定义于schedule.go) main/wc.go中的map和reduce函数 Part I Map/Reduce input and output TASK 按照上面的功能描述和文件中的注释实现doMap和doReduce两个函数。 6.824提供了完整的测试来让我们检验答案的正确性。所有的测试程序都在test_test.go中。要检查这一部分的结果是否正确，运行： 1234cd 6.824export "GOPATH=$PWD" # go needs $GOPATH to be set to the project's working directorycd "$GOPATH/src/mapreduce"go test -run Sequential 如果测试没有输出OK的结果，可以修改common.go中的debugEnable变量为true，并在上面的测试指令中添加-v参数。这样测试程序会给出更加详细的输出，让我们可以更方便地debug。]]></content>
      <categories>
        <category>Academic or Technical</category>
        <category>Distributed System</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MIT 6.828 Labs 源码分析]]></title>
    <url>%2Fblog%2F2019%2F06%2F06%2FMIT_6.828_code%2F</url>
    <content type="text"><![CDATA[MIT 6.828 Labs 源码分析MakeFile Part/GNUmakefile在6.828的lab根目录下有一个GNUmakefile，这是整个JOS内核的makefile，它会包含各个子目录下的Makefrag文件，负责提供各种编译指令接口。 verbose commands123456789101112131415# Run 'make V=1' to turn on verbose commands, or 'make V=0' to turn them off.ifeq ($(V),1)override V =endififeq ($(V),0)override V = @endif-include conf/lab.mk-include conf/env.mkLABSETUP ?= ./TOP = . V是conf/env.mk中定义的一个变量，我们可以在这个文件中找到对它的描述： 1234567# '$(V)' controls whether the lab makefiles print verbose commands (the# actual shell commands run by Make), as well as the "overview" commands# (such as '+ cc lib/readline.c').## For overview commands only, the line should read 'V = @'.# For overview and verbose commands, the line should read 'V ='.V = @ 从注释中可以看出，V变量控制了make是否打印出详细的指令(也就是每一条shell指令)。默认情况下，make只会打印出简略的指令信息来告知我们目前在处理哪个指令。 Compiler Tool-chain configure1234567891011121314151617181920212223242526272829303132333435363738394041# Cross-compiler jos toolchain## This Makefile will automatically use the cross-compiler toolchain# installed as 'i386-jos-elf-*', if one exists. If the host tools ('gcc',# 'objdump', and so forth) compile for a 32-bit x86 ELF target, that will# be detected as well. If you have the right compiler toolchain installed# using a different name, set GCCPREFIX explicitly in conf/env.mk# try to infer the correct GCCPREFIXifndef GCCPREFIXGCCPREFIX := $(shell \ if i386-jos-elf-objdump -i 2&gt;&amp;1 | grep '^elf32-i386$$' &gt;/dev/null 2&gt;&amp;1; \ then echo 'i386-jos-elf-'; \ elif objdump -i 2&gt;&amp;1 | grep 'elf32-i386' &gt;/dev/null 2&gt;&amp;1; \ then echo ''; \ else echo "***" 1&gt;&amp;2; \ echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1&gt;&amp;2; \ echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1&gt;&amp;2; \ echo "*** If your i386-*-elf toolchain is installed with a command" 1&gt;&amp;2; \ echo "*** prefix other than 'i386-jos-elf-', set your GCCPREFIX" 1&gt;&amp;2; \ echo "*** environment variable to that prefix and run 'make' again." 1&gt;&amp;2; \ echo "*** To turn off this error, run 'gmake GCCPREFIX= ...'." 1&gt;&amp;2; \ echo "***" 1&gt;&amp;2; exit 1; fi)endif# try to infer the correct QEMUifndef QEMUQEMU := $(shell \ if which qemu &gt;/dev/null 2&gt;&amp;1; \ then echo qemu; exit; \ elif which qemu-system-i386 &gt;/dev/null 2&gt;&amp;1; \ then echo qemu-system-i386; exit; \ else \ qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \ if test -x $$qemu; then echo $$qemu; exit; fi; fi; \ echo "***" 1&gt;&amp;2; \ echo "*** Error: Couldn't find a working QEMU executable." 1&gt;&amp;2; \ echo "*** Is the directory containing the qemu binary in your PATH" 1&gt;&amp;2; \ echo "*** or have you tried setting the QEMU variable in conf/env.mk?" 1&gt;&amp;2; \ echo "***" 1&gt;&amp;2; exit 1)endif 这一段代码是用来设定编译使用的工具链的。6.828的代码主要会使用两个工具：GCC以及其下属的GNU工具链，以及qemu。6.828官方提供的工具链是以i386-jos-elf之类的前缀打头的，而Linux自带的工具链是没有这些前缀的，makefile接受这两种工具链。 两段Shell语句根据系统中安装的工具链种类分别设定了GCCPREFIX和QEMU两个变量，具体的语句逻辑为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# $(GCCPREFIX)# objdump -i : List all architectures supportedif i386-jos-elf-objdump -i 2&gt;&amp;1 | grep '^elf32-i386$$' &gt;/dev/null 2&gt;&amp;1; then # 1. 这里如果没有安装6.828官方工具链，会报找不到该命令到stderr，这里2&gt;&amp;1将stderr重定向到了stdout # 接下来一个管道导向到grep，grep负责看objdump是否支持这种架构，如果不支持，grep进程返回1, # if判断为假控制流转到elif；否则控制流到then，设置$(GCCPREFIX)为i386-jos-elf。 # 2. 这里由于我们是将shellscript产生的输出设定为$(GCCPREFIX)的值，不希望产生任何额外的输出， # 需要将stdout和stderr重定向到/dev/null以丢弃这些输出。 echo 'i386-jos-elf-';elif objdump -i 2&gt;&amp;1 | grep 'elf32-i386' &gt;/dev/null 2&gt;&amp;1; then # 如果没有安装6.828官方提供的工具链，使用Linux默认的GNU系列工具也是可以的。 echo '';else # 如果两个工具链都没有/工具链不支持i386-elf架构，报错并退出。 echo "***" 1&gt;&amp;2; echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1&gt;&amp;2; echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1&gt;&amp;2; echo "*** If your i386-*-elf toolchain is installed with a command" 1&gt;&amp;2; echo "*** prefix other than 'i386-jos-elf-', set your GCCPREFIX" 1&gt;&amp;2; echo "*** environment variable to that prefix and run 'make' again." 1&gt;&amp;2; echo "*** To turn off this error, run 'gmake GCCPREFIX= ...'." 1&gt;&amp;2; echo "***" 1&gt;&amp;2; # 这里的报错信息是说明如果你安装了自己的工具链，可以通过设置`GCCPREFIX`变量来让make能够找到它们。 exit 1;fi# $(QEMU)是能打开qemu的文件名。if which qemu &gt;/dev/null 2&gt;&amp;1; then # 如果已经安装qemu，which能够找到它，则直接设置 # 同理，这里我们不要输出 echo qemu; exit;elif which qemu-system-i386 &gt;/dev/null 2&gt;&amp;1; then # qemu可能的另外一种名字 echo qemu-system-i386; exit;else # 高贵的mac用户可能会需要这个情况 qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; if test -x $$qemu; then echo $$qemu; exit; fi;fi;# 如果三种情况都不符合，则报错退出echo "***" 1&gt;&amp;2; echo "*** Error: Couldn't find a working QEMU executable." 1&gt;&amp;2;echo "*** Is the directory containing the qemu binary in your PATH" 1&gt;&amp;2;echo "*** or have you tried setting the QEMU variable in conf/env.mk?" 1&gt;&amp;2;echo "***" 1&gt;&amp;2;exit 1 Tools1234567891011121314151617# try to generate a unique GDB portGDBPORT := $(shell expr `id -u` % 5000 + 25000)CC := $(GCCPREFIX)gcc -pipeGDB := $(GCCPREFIX)gdbAS := $(GCCPREFIX)asAR := $(GCCPREFIX)arLD := $(GCCPREFIX)ldOBJCOPY := $(GCCPREFIX)objcopyOBJDUMP := $(GCCPREFIX)objdumpNM := $(GCCPREFIX)nm# Native commandsNCC := gcc $(CC_VER) -pipeNATIVE_CFLAGS := $(CFLAGS) $(DEFS) $(LABDEFS) -I$(TOP) -MD -WallTAR := gtarPERL := perl 根据之前设定的$(GCCPREFIX)来设置各个工具的名称变量。之后就可以直接使用这些工具。 Flags1234567891011121314151617181920212223242526# Compiler flags# -fno-builtin is required to avoid refs to undefined functions in the kernel.# Only optimize to -O1 to discourage inlining, which complicates backtraces.CFLAGS := $(CFLAGS) $(DEFS) $(LABDEFS) -O1 -fno-builtin -I$(TOP) -MDCFLAGS += -fno-omit-frame-pointerCFLAGS += -std=gnu99CFLAGS += -staticCFLAGS += -fno-pieCFLAGS += -Wall -Wno-format -Wno-unused -Werror -gstabs -m32# -fno-tree-ch prevented gcc from sometimes reordering read_ebp() before# mon_backtrace()'s function prologue on gcc version: (Debian 4.7.2-5) 4.7.2CFLAGS += -fno-tree-ch# Add -fno-stack-protector if the option exists.CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null &gt;/dev/null 2&gt;&amp;1 &amp;&amp; echo -fno-stack-protector)# Common linker flagsLDFLAGS := -m elf_i386# Linker flags for JOS user programsULDFLAGS := -T user/user.ldGCC_LIB := $(shell $(CC) $(CFLAGS) -print-libgcc-file-name)# Lists that the */Makefrag makefile fragments will add toOBJDIRS := 对编译器和链接器设定的一些参数。 CFLAGS：gcc使用的各个参数(重要)。 -O1：JOS内核使用O1优化等级编译，这是为了减少显式的inline声明，让debug变得更简单。 -fno-builtin：不使用任何C语言的内建函数，防止JOS自己定义和实现的函数与原有的C标准库函数发生命名冲突。这里如果想单独屏蔽几个函数的话也可以-fno-builtin-&lt;functionname&gt;。 -I$(TOP)：之前设置了TOP=.所以这个参数其实是-I.。这个参数会让GCC优先在.目录下查找头文件，以让JOS在使用&lt;&gt;的情况下也可以优先使用inc目录下的头文件。类似的参数有-L，用来使GCC优先在指定目录下寻找库文件。 -MD：将目标文件所需要的全部依赖信息输出到一个.d文件中。这里如果是-M就是输出到stdout，如果是-MM就不输出由头文件包含所引起的依赖。 -fno-omit-frame-pointer：在优化代码时不省略对ebp寄存器的压栈操作，也就是保持栈帧的完整结构。默认情况下这个选项应该是开启的，这里可能是以防万一。如果这个选项不开启，在函数调用时就不会先压入ebp，从而为backtrace带来困难。 -static：优先使用静态库 -std=gnu99：使用GNU扩展的C99标准 -fno-pie：不生成位置无关代码，关系到一些6.828中的思考题 -Wall：显示所有警告。这一行主要是关于调试信息生成的。 -Werror：把所有警告当作错误。与上一行结合起来可以发现设计实验的人是魔鬼(不是) -gstabs：生成stab格式的调试信息，在Lab1中设计monitor的时候会用到。 -m32：生成32位汇编代码。 LDFLAGS：链接器使用的参数，这里的-m elf_i386是指定模型。 ULDFLAGS = -T user/user.ld：指定链接器使用的用户脚本 info ld可以查看.ld文件的格式介绍 具体的脚本内容在之后研究 GCC_LIB：gcc使用的库文件路径 Suffixs 1234567891011121314151617181920212223242526# Make sure that 'all' is the first targetall:# Eliminate default suffix rules.SUFFIXES:# Delete target files if there is an error (or make is interrupted).DELETE_ON_ERROR:# make it so that no intermediate .o files are ever deleted.PRECIOUS: %.o $(OBJDIR)/boot/%.o $(OBJDIR)/kern/%.o \ $(OBJDIR)/lib/%.o $(OBJDIR)/fs/%.o $(OBJDIR)/net/%.o \ $(OBJDIR)/user/%.oKERN_CFLAGS := $(CFLAGS) -DJOS_KERNEL -gstabsUSER_CFLAGS := $(CFLAGS) -DJOS_USER -gstabs# Update .vars.X if variable X has changed since the last make run.## Rules that use variable X should depend on $(OBJDIR)/.vars.X. If# the variable's value has changed, this will update the vars file and# force a rebuild of the rule that depends on it.$(OBJDIR)/.vars.%: FORCE $(V)echo "$($*)" | cmp -s $@ || echo "$($*)" &gt; $@.PRECIOUS: $(OBJDIR)/.vars.%.PHONY: FORCE 这一部分主要是一些内置的makefile目标名，用于进行一些设置。 all：放在最前面，无条件编译全部代码 .SUFFIXS：这个目标后的前置条件是将要用于检查后缀规则的后缀们，在这里是空的代表我们不使用后缀规则。 .DELETE_ON_ERROR：如果设置了这个目标，make会在一个规则的recipe进程返回1时删除掉改变了的目标文件。 .PRECIOUS：这个目标的所有前置条件不会在相应的recipe进程返回1后被删除。这个目标与刚才的.DELETE_ON_ERROR相结合，可以对不想在出错时删除的目标们进行保护。在这里保护的目标是根目录下和obj目录下的所有.o文件。 KERN_CFLAGS/USER_CFLAGS：在编译时带上不同的宏定义。gcc的编译选项-D后面可以接一个宏定义的名字，-DJOS_KERNEL表示在编译时带一个宏定义JOS_KERNEL，-DJOS_UER同理。这两个变量主要用来进行内核/用户的权限管理。 Includes and QEMU configure1234567891011121314151617# Include Makefrags for subdirectoriesinclude boot/Makefraginclude kern/Makefraginclude lib/Makefraginclude user/Makefraginclude fs/MakefragCPUS ?= 1QEMUOPTS = -drive file=$(OBJDIR)/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::$(GDBPORT)QEMUOPTS += $(shell if $(QEMU) -nographic -help | grep -q '^-D '; then echo '-D qemu.log'; fi)IMAGES = $(OBJDIR)/kern/kernel.imgQEMUOPTS += -smp $(CPUS)QEMUOPTS += -drive file=$(OBJDIR)/fs/fs.img,index=1,media=disk,format=rawIMAGES += $(OBJDIR)/fs/fs.imgQEMUOPTS += $(QEMUEXTRA) 包含选项包含了各个子目录下的Makefrag。 CPUS ?= 1将默认的CPU数目置为1。在做lab的过程中我们经常通过设置CPUS = x来增加核数。 对qemu的参数设置主要是与qemu本身规范有关： QEMUOPTS：下面用来运行qemu的各种参数 file：将要运行的镜像 index：跟在file后，指定这个镜像的序号 IMAGES：使用的镜像列表 Rules123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185.gdbinit: .gdbinit.tmpl sed "s/localhost:1234/localhost:$(GDBPORT)/" &lt; $^ &gt; $@gdb: $(GDB) -n -x .gdbinitpre-qemu: .gdbinitqemu: $(IMAGES) pre-qemu $(QEMU) $(QEMUOPTS)qemu-nox: $(IMAGES) pre-qemu @echo "***" @echo "*** Use Ctrl-a x to exit qemu" @echo "***" $(QEMU) -nographic $(QEMUOPTS)qemu-gdb: $(IMAGES) pre-qemu @echo "***" @echo "*** Now run 'make gdb'." 1&gt;&amp;2 @echo "***" $(QEMU) $(QEMUOPTS) -Sqemu-nox-gdb: $(IMAGES) pre-qemu @echo "***" @echo "*** Now run 'make gdb'." 1&gt;&amp;2 @echo "***" $(QEMU) -nographic $(QEMUOPTS) -Sprint-qemu: @echo $(QEMU)print-gdbport: @echo $(GDBPORT)# For deleting the buildclean: rm -rf $(OBJDIR) .gdbinit jos.in qemu.logrealclean: clean rm -rf lab$(LAB).tar.gz \ jos.out $(wildcard jos.out.*) \ qemu.pcap $(wildcard qemu.pcap.*) \ myapi.keydistclean: realclean rm -rf conf/gcc.mkifneq ($(V),@)GRADEFLAGS += -vendifgrade: @echo $(MAKE) clean @$(MAKE) clean || \ (echo "'make clean' failed. HINT: Do you have another running instance of JOS?" &amp;&amp; exit 1) ./grade-lab$(LAB) $(GRADEFLAGS)git-handin: handin-check @if test -n "`git config remote.handin.url`"; then \ echo "Hand in to remote repository using 'git push handin HEAD' ..."; \ if ! git push -f handin HEAD; then \ echo ; \ echo "Hand in failed."; \ echo "As an alternative, please run 'make tarball'"; \ echo "and visit http://pdos.csail.mit.edu/6.828/submit/"; \ echo "to upload lab$(LAB)-handin.tar.gz. Thanks!"; \ false; \ fi; \ else \ echo "Hand-in repository is not configured."; \ echo "Please run 'make handin-prep' first. Thanks!"; \ false; \ fiWEBSUB := https://6828.scripts.mit.edu/2018/handin.pyhandin: tarball-pref myapi.key @SUF=$(LAB); \ test -f .suf &amp;&amp; SUF=`cat .suf`; \ curl -f -F file=@lab$$SUF-handin.tar.gz -F key=\&lt;myapi.key $(WEBSUB)/upload \ &gt; /dev/null || &#123; \ echo ; \ echo Submit seems to have failed.; \ echo Please go to $(WEBSUB)/ and upload the tarball manually.; &#125;handin-check: @if ! test -d .git; then \ echo No .git directory, is this a git repository?; \ false; \ fi @if test "$$(git symbolic-ref HEAD)" != refs/heads/lab$(LAB); then \ git branch; \ read -p "You are not on the lab$(LAB) branch. Hand-in the current branch? [y/N] " r; \ test "$$r" = y; \ fi @if ! git diff-files --quiet || ! git diff-index --quiet --cached HEAD; then \ git status -s; \ echo; \ echo "You have uncomitted changes. Please commit or stash them."; \ false; \ fi @if test -n "`git status -s`"; then \ git status -s; \ read -p "Untracked files will not be handed in. Continue? [y/N] " r; \ test "$$r" = y; \ fiUPSTREAM := $(shell git remote -v | grep "pdos.csail.mit.edu/6.828/2018/jos.git (fetch)" | awk '&#123;split($$0,a," "); print a[1]&#125;')tarball-pref: handin-check @SUF=$(LAB); \ if test $(LAB) -eq 3 -o $(LAB) -eq 4; then \ read -p "Which part would you like to submit? [a, b, c (c for lab 4 only)]" p; \ if test "$$p" != a -a "$$p" != b; then \ if test ! $(LAB) -eq 4 -o ! "$$p" = c; then \ echo "Bad part \"$$p\""; \ exit 1; \ fi; \ fi; \ SUF="$(LAB)$$p"; \ echo $$SUF &gt; .suf; \ else \ rm -f .suf; \ fi; \ git archive --format=tar HEAD &gt; lab$$SUF-handin.tar; \ git diff $(UPSTREAM)/lab$(LAB) &gt; /tmp/lab$$SUF-diff.patch; \ tar -rf lab$$SUF-handin.tar /tmp/lab$$SUF-diff.patch; \ gzip -c lab$$SUF-handin.tar &gt; lab$$SUF-handin.tar.gz; \ rm lab$$SUF-handin.tar; \ rm /tmp/lab$$SUF-diff.patch; \myapi.key: @echo Get an API key for yourself by visiting $(WEBSUB)/ @read -p "Please enter your API key: " k; \ if test `echo "$$k" |tr -d '\n' |wc -c` = 32 ; then \ TF=`mktemp -t tmp.XXXXXX`; \ if test "x$$TF" != "x" ; then \ echo "$$k" |tr -d '\n' &gt; $$TF; \ mv -f $$TF $@; \ else \ echo mktemp failed; \ false; \ fi; \ else \ echo Bad API key: $$k; \ echo An API key should be 32 characters long.; \ false; \ fi;#handin-prep:# @./handin-prep# For test runsprep-%: $(V)$(MAKE) "INIT_CFLAGS=$&#123;INIT_CFLAGS&#125; -DTEST=`case $* in *_*) echo $*;; *) echo user_$*;; esac`" $(IMAGES)run-%-nox-gdb: prep-% pre-qemu $(QEMU) -nographic $(QEMUOPTS) -Srun-%-gdb: prep-% pre-qemu $(QEMU) $(QEMUOPTS) -Srun-%-nox: prep-% pre-qemu $(QEMU) -nographic $(QEMUOPTS)run-%: prep-% pre-qemu $(QEMU) $(QEMUOPTS)# This magic automatically generates makefile dependencies# for header files included from C source files we compile,# and keeps those dependencies up-to-date every time we recompile.# See 'mergedep.pl' for more information.$(OBJDIR)/.deps: $(foreach dir, $(OBJDIRS), $(wildcard $(OBJDIR)/$(dir)/*.d)) @mkdir -p $(@D) @$(PERL) mergedep.pl $@ $^-include $(OBJDIR)/.depsalways: @:.PHONY: all always \ handin git-handin tarball tarball-pref clean realclean distclean grade handin-prep handin-check 在进行了冗长的配置之后，终于到了规则部分。接下来逐条分析这些规则： 比较重要的： gdb：即我们常用的make gdb，-n指定不以默认的~/.gdbinit文件为初始化文件，-x .gdbinit指定新的初始化文件。初始化文件会将我们的gdb配置为运行在i386架构32位模式下，支持elf文件格式。 qemu：使用之前已经初始化好的QEMU和QEMUOPTS运行qemu。 qemu-nox：增加一个-no-graphic参数 qemu-gdb：增加一个-S参数，让qemu在启动时不马上启动CPU。 qemu-nox-gdb：上面两个的叠加。 grade：运行目录下当前Lab对应的grading脚本。 clean：在切换到之前的lab时，如果不make clean删除掉超前的一些.o文件，编译会因为头文件不足而出错。 不太重要的： .gdbinit：用sed工具将.gdbinit.tmpl中使用的端口1234替换为之前生成的GDBPORT。&lt; $^是以前置条件，即.gdbinit.tmpl为输入，&gt; $@是以目标，即.gdbinit为输出。 print-qemu/print-gdb：打印出我们使用的qemu二进制文件或GDBPORT。 realclean/distclean：不大会用到，在make clean的基础上多删除些东西。 handin系列：用于提交，我们用不到。 比较难以分析的一个规则是prep-%，这个规则是后面的几个run-%规则的基础，后面的几个规则都只是在这个基础上以不同的方式打开qemu。这个规则主要的作用是以不同的参数重新编译内核。 首先我们阅读init.c可以发现这样一段代码： 1234567#if defined(TEST) // Don't touch -- used by grading script! ENV_CREATE(TEST, ENV_TYPE_USER);#else // Touch all you want. ENV_CREATE(user_spawnhello, ENV_TYPE_USER);#endif // TEST* 可以发现，如果我们在编译内核时定义了TEST宏，这里就会为TEST的值对应的用户程序创建新进程，否则会运行内核编写者在init.c中自行定义的用户程序。 将prep-%规则的recipe展开，将所有$*转换为%匹配到的值，得： 12345678make " INIT_CFLAGS = $&#123;INIT_CFLAGS&#125; -DTEST=` case % in*_*) echo %;; *) echo user_%;; esac `" $(IMAGES) 这里的双引号是为了防止shell将后面的-DTEST参数识别为make的参数。INIT_CFLAGS参数是kern/Makefrag编译内核时传递给gcc的命令行参数，这里用了一个递归的变量${INIT_CFLAGS}以包含原来的参数，后面增加的参数是-DTEST，这个参数定义了TEST宏并为其赋值，以在init.c中运行特定的测试程序。 赋值的方式是一个shellscript的``表达式，其内容是一个case-in结构。根据shellscipt的语法，case-in结构的含义是这样的： 123456789case [condition] in&lt;case1&gt;) &lt;ins&gt;;;&lt;case2&gt;) &lt;ins&gt;;;...*) # default &lt;ins&gt;;;esac 照这样看，这个结构检查%匹配到的字符串是否满足*_*结构，也就是是否有下划线，如果有，说明指令是run-user_*，那就可以直接用%去作为TEST宏的值；否则，指令是run-*，那么需要为其加上user_前缀。 /kern/Makefrag内核部分的makefile片段。这边的内容没有根目录下的复杂所以直接分段写出大概的解析。 123456789# Makefile fragment for JOS kernel.# This is NOT a complete makefile;# you must run GNU make in the top-level directory# where the GNUmakefile is located.#OBJDIRS += kernKERN_LDFLAGS := $(LDFLAGS) -T kern/kernel.ld -nostdlib 设置内核的链接选项，-nostdlib指定不使用C标准静态库，-T指定ld script的路径。 12345678910111213141516171819202122232425262728293031# entry.S must be first, so that it's the first code in the text segment!!!## We also snatch the use of a couple handy source files# from the lib directory, to avoid gratuitous code duplication.KERN_SRCFILES := kern/entry.S \ kern/entrypgdir.c \ kern/init.c \ kern/console.c \ kern/monitor.c \ kern/pmap.c \ kern/env.c \ kern/kclock.c \ kern/picirq.c \ kern/printf.c \ kern/trap.c \ kern/trapentry.S \ kern/sched.c \ kern/syscall.c \ kern/kdebug.c \ lib/printfmt.c \ lib/readline.c \ lib/string.c# Source files for LAB4KERN_SRCFILES += kern/mpentry.S \ kern/mpconfig.c \ kern/lapic.c \ kern/spinlock.c# Only build files if they exist.KERN_SRCFILES := $(wildcard $(KERN_SRCFILES)) 设定编译内核所需要的源文件列表。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# Binary program images to embed within the kernel.# Binary files for LAB3KERN_BINFILES := user/hello \ user/buggyhello \ user/buggyhello2 \ user/evilhello \ user/testbss \ user/divzero \ user/breakpoint \ user/softint \ user/badsegment \ user/faultread \ user/faultreadkernel \ user/faultwrite \ user/faultwritekernel# Binary files for LAB4KERN_BINFILES += user/idle \ user/yield \ user/dumbfork \ user/stresssched \ user/faultdie \ user/faultregs \ user/faultalloc \ user/faultallocbad \ user/faultnostack \ user/faultbadhandler \ user/faultevilhandler \ user/forktree \ user/sendpage \ user/spin \ user/fairness \ user/pingpong \ user/pingpongs \ user/primes# Binary files for LAB5KERN_BINFILES += user/faultio\ user/spawnfaultio\ user/testfile \ user/spawnhello \ user/icode \ fs/fs# Binary files for LAB5KERN_BINFILES += user/testpteshare \ user/testfdsharing \ user/testpipe \ user/testpiperace \ user/testpiperace2 \ user/primespipe \ user/testkbd \ user/testshellKERN_OBJFILES := $(patsubst %.c, $(OBJDIR)/%.o, $(KERN_SRCFILES))KERN_OBJFILES := $(patsubst %.S, $(OBJDIR)/%.o, $(KERN_OBJFILES))KERN_OBJFILES := $(patsubst $(OBJDIR)/lib/%, $(OBJDIR)/kern/%, $(KERN_OBJFILES))KERN_BINFILES := $(patsubst %, $(OBJDIR)/%, $(KERN_BINFILES)) 设置要嵌入内核的二进制文件列表和内核需要的.o文件列表。patsubst会将通配符展开。 123456789101112131415# How to build kernel object files$(OBJDIR)/kern/%.o: kern/%.c $(OBJDIR)/.vars.KERN_CFLAGS @echo + cc $&lt; @mkdir -p $(@D) $(V)$(CC) -nostdinc $(KERN_CFLAGS) -c -o $@ $&lt;$(OBJDIR)/kern/%.o: kern/%.S $(OBJDIR)/.vars.KERN_CFLAGS @echo + as $&lt; @mkdir -p $(@D) $(V)$(CC) -nostdinc $(KERN_CFLAGS) -c -o $@ $&lt;$(OBJDIR)/kern/%.o: lib/%.c $(OBJDIR)/.vars.KERN_CFLAGS @echo + cc $&lt; @mkdir -p $(@D) $(V)$(CC) -nostdinc $(KERN_CFLAGS) -c -o $@ $&lt; 目标文件的构造规则，编译或汇编所有的源码文件。 123# Special flags for kern/init$(OBJDIR)/kern/init.o: override KERN_CFLAGS+=$(INIT_CFLAGS)$(OBJDIR)/kern/init.o: $(OBJDIR)/.vars.INIT_CFLAGS 对于init.o我们需要在编译时添加INIT_CFLAGS，原因见GNUmakefile部分对这个参数的设定。 1234567# How to build the kernel itself$(OBJDIR)/kern/kernel: $(KERN_OBJFILES) $(KERN_BINFILES) kern/kernel.ld \ $(OBJDIR)/.vars.KERN_LDFLAGS @echo + ld $@ $(V)$(LD) -o $@ $(KERN_LDFLAGS) $(KERN_OBJFILES) $(GCC_LIB) -b binary $(KERN_BINFILES) $(V)$(OBJDUMP) -S $@ &gt; $@.asm $(V)$(NM) -n $@ &gt; $@.sym 用于编译内核可执行文件的规则。可以看到，内核是由所有用到的.o文件和gcc库文件共同链接得到的。同时，这条规则还会将内核的反汇编代码和符号表信息保存起来。 1234567# How to build the kernel disk image$(OBJDIR)/kern/kernel.img: $(OBJDIR)/kern/kernel $(OBJDIR)/boot/boot @echo + mk $@ $(V)dd if=/dev/zero of=$(OBJDIR)/kern/kernel.img~ count=10000 2&gt;/dev/null $(V)dd if=$(OBJDIR)/boot/boot of=$(OBJDIR)/kern/kernel.img~ conv=notrunc 2&gt;/dev/null $(V)dd if=$(OBJDIR)/kern/kernel of=$(OBJDIR)/kern/kernel.img~ seek=1 conv=notrunc 2&gt;/dev/null $(V)mv $(OBJDIR)/kern/kernel.img~ $(OBJDIR)/kern/kernel.img 用于构建内核镜像的规则。 dd是用于文件格式转换的工具，在这里被用来将bootloader(/boot/boot)和内核(/kern/kernel)构建为kernel.img。构建过程分为三步： 第一步：/dev/zero是一个特殊文件，它能提供无限的0数据流，在这里用于初始化临时文件kernel.img~，初始化大小为10000个块，stderr屏蔽掉。 第二步：将boot文件写入到临时镜像，conv=notrunc指定不要截断原来初始化出的多余部分。 第三步：将kernel文件写入到临时镜像，同样不要截断，seek=1表示跳过第一个块，也就是那个存放了bootloader的块。 在这个构建过程中使用临时镜像/kern/kernel.img~而不是直接构建kernel.img的原因是如果make在执行中途发生错误而退出，这种操作不会损坏原有的镜像文件。 /lib/Makefrag函数库的makefile片段。原理和上面的差不多，没什么好说的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546OBJDIRS += libLIB_SRCFILES := lib/console.c \ lib/libmain.c \ lib/exit.c \ lib/panic.c \ lib/printf.c \ lib/printfmt.c \ lib/readline.c \ lib/string.c \ lib/syscall.cLIB_SRCFILES := $(LIB_SRCFILES) \ lib/pgfault.c \ lib/pfentry.S \ lib/fork.c \ lib/ipc.cLIB_SRCFILES := $(LIB_SRCFILES) \ lib/args.c \ lib/fd.c \ lib/file.c \ lib/fprintf.c \ lib/pageref.c \ lib/spawn.cLIB_SRCFILES := $(LIB_SRCFILES) \ lib/pipe.c \ lib/wait.cLIB_OBJFILES := $(patsubst lib/%.c, $(OBJDIR)/lib/%.o, $(LIB_SRCFILES))LIB_OBJFILES := $(patsubst lib/%.S, $(OBJDIR)/lib/%.o, $(LIB_OBJFILES))$(OBJDIR)/lib/%.o: lib/%.c $(OBJDIR)/.vars.USER_CFLAGS @echo + cc[USER] $&lt; @mkdir -p $(@D) $(V)$(CC) -nostdinc $(USER_CFLAGS) -c -o $@ $&lt;$(OBJDIR)/lib/%.o: lib/%.S $(OBJDIR)/.vars.USER_CFLAGS @echo + as[USER] $&lt; @mkdir -p $(@D) $(V)$(CC) -nostdinc $(USER_CFLAGS) -c -o $@ $&lt;$(OBJDIR)/lib/libjos.a: $(LIB_OBJFILES) @echo + ar $@ $(V)$(AR) r $@ $(LIB_OBJFILES) /boot/Makefrag构造bootloader的makefile片段。 12345678910111213141516171819202122232425262728293031## Makefile fragment for the JOS kernel.# This is NOT a complete makefile;# you must run GNU make in the top-level directory# where the GNUmakefile is located.#OBJDIRS += bootBOOT_OBJS := $(OBJDIR)/boot/boot.o $(OBJDIR)/boot/main.o$(OBJDIR)/boot/%.o: boot/%.c @echo + cc -Os $&lt; @mkdir -p $(@D) $(V)$(CC) -nostdinc $(KERN_CFLAGS) -Os -c -o $@ $&lt;$(OBJDIR)/boot/%.o: boot/%.S @echo + as $&lt; @mkdir -p $(@D) $(V)$(CC) -nostdinc $(KERN_CFLAGS) -c -o $@ $&lt;$(OBJDIR)/boot/main.o: boot/main.c @echo + cc -Os $&lt; $(V)$(CC) -nostdinc $(KERN_CFLAGS) -Os -c -o $(OBJDIR)/boot/main.o boot/main.c$(OBJDIR)/boot/boot: $(BOOT_OBJS) @echo + ld boot/boot $(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o $@.out $^ $(V)$(OBJDUMP) -S $@.out &gt;$@.asm $(V)$(OBJCOPY) -S -O binary -j .text $@.out $@ $(V)perl boot/sign.pl $(OBJDIR)/boot/boot 比较重要和复杂的是最后一条规则： 第一步：ld链接 -N：将text和data区标记为可读可写的 -e start：指定程序开始执行的位置为start标签 -Ttext 0x7c00：指定代码区的起始位置为0x7c00 第二步：保存bootloader的反汇编代码 第三步：将bootloader的代码段拷贝到boot.out -S：不拷贝符号表和重定位信息 -O binary：指定输出格式为二进制 -j .text：仅复制代码段 第四步：运行perl脚本 /user/Makefrag编译用户程序的makefile片段。 12345678910111213141516OBJDIRS += userUSERLIBS += jos$(OBJDIR)/user/%.o: user/%.c $(OBJDIR)/.vars.USER_CFLAGS @echo + cc[USER] $&lt; @mkdir -p $(@D) $(V)$(CC) -nostdinc $(USER_CFLAGS) -c -o $@ $&lt;$(OBJDIR)/user/%: $(OBJDIR)/user/%.o $(OBJDIR)/lib/entry.o \$(USERLIBS:%=$(OBJDIR)/lib/lib%.a) user/user.ld @echo + ld $@ $(V)$(LD) -o $@.debug $(ULDFLAGS) $(LDFLAGS) -nostdlib $(OBJDIR)/lib/entry.o $@.o -L$(OBJDIR)/lib $(USERLIBS:%=-l%) $(GCC_LIB) $(V)$(OBJDUMP) -S $@.debug &gt; $@.asm $(V)$(NM) -n $@.debug &gt; $@.sym $(V)$(OBJCOPY) -R .stab -R .stabstr --add-gnu-debuglink=$(basename $@.debug) $@.debug $@ 这里的重点是obj目录下各个用户程序的可执行文件的编译。 目标：通过通配符匹配obj/user/目录下的所有无扩展名可执行文件 前置条件： 该目录下的.o文件 obj/lib下的entry.o文件，这个文件是所有用户程序的入口点 $(USERLIBS:%=$(OBJDIR)/lib/lib%.a)：这种语法格式是$(&lt;varname&gt;:&lt;pattern1&gt;=&lt;pattern2&gt;)，表示将&lt;varname&gt;变量中所有符合&lt;pattern1&gt;的字符串换为&lt;pattern2&gt;，这里是将USERLIB变量中的所有字符串转换为对应的obj/lib/文件夹下的lib*.a文件。 user/user.ld，ld script。 recipe： ld：将entry.o和目标.o文件链接起来成为对应的.debug文件。 ULDFLAGS和LDFLAGS：继承下来的参数 -nostdlib：不使用C标准库 -L $(OBJDIR)：让ld在JOS的对象库中寻找库文件 $(USERLIBS:%=-l%)：在链接时加载JOS的所有用户库 剩下几条与其他Makefrag类似。 Tester Part/incinc文件夹包含了JOS中的部分头文件，这个部分是指那些被不止一个文件所依赖的头文件。如果一个头文件只被一个*.c代码文件所引用，它会被命名为*.h并放置于*.c所在的文件夹下。 12345678910111213141516171819202122inc├── args.h├── assert.h├── COPYRIGHT├── elf.h├── env.h├── error.h├── fd.h├── fs.h├── kbdreg.h├── lib.h├── memlayout.h├── mmu.h├── partition.h├── stab.h├── stdarg.h├── stdio.h├── string.h├── syscall.h├── trap.h├── types.h└── x86.h /inc/mmu.hMMU是x86架构CPU中用于管理内存的单元，这个头文件中主要定义了一些用于描述mmu行为的函数、数据结构和宏，包括实现分页机制和段机制需要的数据结构定义和常量，用来设置cr0，cr4和eflags寄存器标志位的一些标志常量，以及用于异常处理的数据结构和宏。 Paging data structures and constants这一部分主要包括用于分页机制的一些宏函数。 Analyzing linear addresses有关虚拟地址的结构，在6.828实验记录的1.4.1.Background Knowledge一章已经记录过，并且mmu.h的注释中也有形象详细的描述，这里不再重复。 1234567891011121314// page number field of address#define PGNUM(la) (((uintptr_t) (la)) &gt;&gt; PTXSHIFT)// page directory index#define PDX(la) ((((uintptr_t) (la)) &gt;&gt; PDXSHIFT) &amp; 0x3FF)// page table index#define PTX(la) ((((uintptr_t) (la)) &gt;&gt; PTXSHIFT) &amp; 0x3FF)// offset in page#define PGOFF(la) (((uintptr_t) (la)) &amp; 0xFFF)// construct linear address from indexes and offset#define PGADDR(d, t, o) ((void*) ((d) &lt;&lt; PDXSHIFT | (t) &lt;&lt; PTXSHIFT | (o))) 这五个都是在内存管理中无比常用的宏，按标准实现起来也很简单，因此不展开说明。 PD and PT constants1234567891011#define NPDENTRIES 1024 // page directory entries per page directory#define NPTENTRIES 1024 // page table entries per page table#define PGSIZE 4096 // bytes mapped by a page#define PGSHIFT 12 // log2(PGSIZE)#define PTSIZE (PGSIZE*NPTENTRIES) // bytes mapped by a page directory entry#define PTSHIFT 22 // log2(PTSIZE)#define PTXSHIFT 12 // offset of PTX in a linear address#define PDXSHIFT 22 // offset of PDX in a linear address 一般来说只要线性地址的结构规定不改变，这些常量的值都不需要修改。不过，为了保持良好的编程习惯，最好还是减少hardcode的次数，改用这些常量来描述。 PTE flags12345678910111213141516171819#define PTE_P 0x001 // Present#define PTE_W 0x002 // Writeable#define PTE_U 0x004 // User#define PTE_PWT 0x008 // Write-Through#define PTE_PCD 0x010 // Cache-Disable#define PTE_A 0x020 // Accessed#define PTE_D 0x040 // Dirty#define PTE_PS 0x080 // Page Size#define PTE_G 0x100 // Global// The PTE_AVAIL bits aren't used by the kernel or interpreted by the// hardware, so user processes are allowed to set them arbitrarily.#define PTE_AVAIL 0xE00 // Available for software use// Flags in PTE_SYSCALL may be used in system calls. (Others may not.)#define PTE_SYSCALL (PTE_AVAIL | PTE_P | PTE_W | PTE_U)// Address in page table or page directory entry#define PTE_ADDR(pte) ((physaddr_t) (pte) &amp; ~0xFFF) 由于每个PTE(页表表项)都其实是一个物理页面的地址，而页面的地址是向PGSIZE对齐的，每个PTE都会有空闲的12位。JOS将这十位作为PTE的标志位，用以标识这一页的具体属性。 根据上面的定义，我们可以大致描绘出这12位的具体用途： 在管理页表时，我们最常用到的还是最低三位： PTE_P：这个页面已经被分配 PTE_W：这个页面具有写权限 PTE_U：这个页面可以被用户访问 这三位是由操作系统进行设置和管理的，CPU只负责根据它们来检查访问的合法性。 在管理文件系统的时候也会用到这两位： PTE_D：这个页面是否被修改过 PTE_A：这个页面是否被访问过 这两位是由CPU进行设置的，操作系统通过读取它们来得知页面的状态，也可以对它们进行修改。 比较特殊的是最高三位，它们被标注为PTE_AVAIL，也就是说它们是保留位，CPU不会设置或检查它们，这样我们可以用它们来自定义一些页面属性，比如写时复制的PTE_COW。 一旦出现了对一个页面的与其权限描述冲突的访问，CPU就会产生一个中断。 PTE_SYSCALL不是一个标志位，它代表着所有能被系统调用访问或修改的标志位的集合，用于方便我们在实现操作系统的时候限制用户的权限。PTE_ADDR用于抹除掉一个PTE中的标志位，好让我们寻找到它指向的页面的起始地址。 Register flags12345678910111213141516171819202122232425262728293031323334353637383940414243// Control Register flags#define CR0_PE 0x00000001 // Protection Enable#define CR0_MP 0x00000002 // Monitor coProcessor#define CR0_EM 0x00000004 // Emulation#define CR0_TS 0x00000008 // Task Switched#define CR0_ET 0x00000010 // Extension Type#define CR0_NE 0x00000020 // Numeric Errror#define CR0_WP 0x00010000 // Write Protect#define CR0_AM 0x00040000 // Alignment Mask#define CR0_NW 0x20000000 // Not Writethrough#define CR0_CD 0x40000000 // Cache Disable#define CR0_PG 0x80000000 // Paging#define CR4_PCE 0x00000100 // Performance counter enable#define CR4_MCE 0x00000040 // Machine Check Enable#define CR4_PSE 0x00000010 // Page Size Extensions#define CR4_DE 0x00000008 // Debugging Extensions#define CR4_TSD 0x00000004 // Time Stamp Disable#define CR4_PVI 0x00000002 // Protected-Mode Virtual Interrupts#define CR4_VME 0x00000001 // V86 Mode Extensions// Eflags register#define FL_CF 0x00000001 // Carry Flag#define FL_PF 0x00000004 // Parity Flag#define FL_AF 0x00000010 // Auxiliary carry Flag#define FL_ZF 0x00000040 // Zero Flag#define FL_SF 0x00000080 // Sign Flag#define FL_TF 0x00000100 // Trap Flag#define FL_IF 0x00000200 // Interrupt Flag#define FL_DF 0x00000400 // Direction Flag#define FL_OF 0x00000800 // Overflow Flag#define FL_IOPL_MASK 0x00003000 // I/O Privilege Level bitmask#define FL_IOPL_0 0x00000000 // IOPL == 0#define FL_IOPL_1 0x00001000 // IOPL == 1#define FL_IOPL_2 0x00002000 // IOPL == 2#define FL_IOPL_3 0x00003000 // IOPL == 3#define FL_NT 0x00004000 // Nested Task#define FL_RF 0x00010000 // Resume Flag#define FL_VM 0x00020000 // Virtual 8086 mode#define FL_AC 0x00040000 // Alignment Check#define FL_VIF 0x00080000 // Virtual Interrupt Flag#define FL_VIP 0x00100000 // Virtual Interrupt Pending#define FL_ID 0x00200000 // ID flag 这些定义全都用于设置cr0、cr4和eflags三个寄存器的标志位，让我们能更方便地去访问和修改这三个寄存器的值。具体如何使用，参照x86架构对这三个寄存器的定义即可。 Segmentation data structures and constants这一部分主要包括关于分段机制的一些数据结构和常量定义。 Setting GDT 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#ifdef __ASSEMBLER__/* * Macros to build GDT entries in assembly. */#define SEG_NULL \ .word 0, 0; \ .byte 0, 0, 0, 0#define SEG(type,base,lim) \ .word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff); \ .byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)), \ (0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff)#else // not __ASSEMBLER__#include &lt;inc/types.h&gt;// Segment Descriptorsstruct Segdesc &#123; unsigned sd_lim_15_0 : 16; // Low bits of segment limit unsigned sd_base_15_0 : 16; // Low bits of segment base address unsigned sd_base_23_16 : 8; // Middle bits of segment base address unsigned sd_type : 4; // Segment type (see STS_ constants) unsigned sd_s : 1; // 0 = system, 1 = application unsigned sd_dpl : 2; // Descriptor Privilege Level unsigned sd_p : 1; // Present unsigned sd_lim_19_16 : 4; // High bits of segment limit unsigned sd_avl : 1; // Unused (available for software use) unsigned sd_rsv1 : 1; // Reserved unsigned sd_db : 1; // 0 = 16-bit segment, 1 = 32-bit segment unsigned sd_g : 1; // Granularity: limit scaled by 4K when set unsigned sd_base_31_24 : 8; // High bits of segment base address&#125;;// Null segment#define SEG_NULL &#123; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 &#125;// Segment that is loadable but faults when used#define SEG_FAULT &#123; 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0 &#125;// Normal segment#define SEG(type, base, lim, dpl) \&#123; ((lim) &gt;&gt; 12) &amp; 0xffff, (base) &amp; 0xffff, ((base) &gt;&gt; 16) &amp; 0xff, \ type, 1, dpl, 1, (unsigned) (lim) &gt;&gt; 28, 0, 0, 1, 1, \ (unsigned) (base) &gt;&gt; 24 &#125;#define SEG16(type, base, lim, dpl) (struct Segdesc) \&#123; (lim) &amp; 0xffff, (base) &amp; 0xffff, ((base) &gt;&gt; 16) &amp; 0xff, \ type, 1, dpl, 1, (unsigned) (lim) &gt;&gt; 16, 0, 0, 1, 0, \ (unsigned) (base) &gt;&gt; 24 &#125;#endif /* !__ASSEMBLER__ */ 这个条件判断以汇编语言和C语言分别描述了SEG宏，这个宏函数用于构造一个描述符，在JOS中以结构体Segdesc来描述。 在32位保护模式下，段寄存器中存放的是段选择符，CPU取出选择符中用于索引的几位去GDT中索引到段描述符。选择符和描述符的结构见6.828实验记录1.4.4.1。 __ASSEMBLER__是一个特殊的内建宏，如果包含这个头文件的文件是汇编文件则会#deifne这个宏，否则无这个定义。通过一个#ifdef-#else-#endif结构，我们就能在同一个头文件中分别写出能用于汇编代码和C语言代码的宏。在这里，由于汇编和C对结构的描述不一样，所以要采用这种结构来进行定义。这种手段在系统编程中是比较常见的。 汇编的定义方法就是按照描述符结构中各个字或字节的顺序去按照参数依次设置各个位，而C则是采用了结构体初始化的形式去初始化一个定义好的字段结构。具体的初始化形式，完全符合描述符本身的格式。 Descripter flags123456789101112131415161718192021// Application segment type bits#define STA_X 0x8 // Executable segment#define STA_E 0x4 // Expand down (non-executable segments)#define STA_C 0x4 // Conforming code segment (executable only)#define STA_W 0x2 // Writeable (non-executable segments)#define STA_R 0x2 // Readable (executable segments)#define STA_A 0x1 // Accessed// System segment type bits#define STS_T16A 0x1 // Available 16-bit TSS#define STS_LDT 0x2 // Local Descriptor Table#define STS_T16B 0x3 // Busy 16-bit TSS#define STS_CG16 0x4 // 16-bit Call Gate#define STS_TG 0x5 // Task Gate / Coum Transmitions#define STS_IG16 0x6 // 16-bit Interrupt Gate#define STS_TG16 0x7 // 16-bit Trap Gate#define STS_T32A 0x9 // Available 32-bit TSS#define STS_T32B 0xB // Busy 32-bit TSS#define STS_CG32 0xC // 32-bit Call Gate#define STS_IG32 0xE // 32-bit Interrupt Gate#define STS_TG32 0xF // 32-bit Trap Gate 这一部分定义的这些标志位都是段描述符中TYPE字段可能的取值。从段描述符的结构我们可以看出，系统段描述符的TYPE字段有4位，这四位的每一种取值都有独特的含义；而用户段描述符只有三位TYPE字段加上低位的一位表示Access的字段，且TYPE字段的低2位取值的含义要取决于最高位的取值。 Traps这一部分主要是关于TSS和IDT两个中断处理机制的数据结构和宏函数。 TSS 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#ifndef __ASSEMBLER__// Task state segment format (as described by the Pentium architecture book)struct Taskstate &#123; uint32_t ts_link; // Old ts selector uintptr_t ts_esp0; // Stack pointers and segment selectors uint16_t ts_ss0; // after an increase in privilege level uint16_t ts_padding1; uintptr_t ts_esp1; uint16_t ts_ss1; uint16_t ts_padding2; uintptr_t ts_esp2; uint16_t ts_ss2; uint16_t ts_padding3; physaddr_t ts_cr3; // Page directory base uintptr_t ts_eip; // Saved state from last task switch uint32_t ts_eflags; uint32_t ts_eax; // More saved state (registers) uint32_t ts_ecx; uint32_t ts_edx; uint32_t ts_ebx; uintptr_t ts_esp; uintptr_t ts_ebp; uint32_t ts_esi; uint32_t ts_edi; uint16_t ts_es; // Even more saved state (segment selectors) uint16_t ts_padding4; uint16_t ts_cs; uint16_t ts_padding5; uint16_t ts_ss; uint16_t ts_padding6; uint16_t ts_ds; uint16_t ts_padding7; uint16_t ts_fs; uint16_t ts_padding8; uint16_t ts_gs; uint16_t ts_padding9; uint16_t ts_ldt; uint16_t ts_padding10; uint16_t ts_t; // Trap on task switch uint16_t ts_iomb; // I/O map base address&#125;;// Gate descriptors for interrupts and trapsstruct Gatedesc &#123; unsigned gd_off_15_0 : 16; // low 16 bits of offset in segment unsigned gd_sel : 16; // segment selector unsigned gd_args : 5; // # args, 0 for interrupt/trap gates unsigned gd_rsv1 : 3; // reserved(should be zero I guess) unsigned gd_type : 4; // type(STS_&#123;TG,IG32,TG32&#125;) unsigned gd_s : 1; // must be 0 (system) unsigned gd_dpl : 2; // descriptor(meaning new) privilege level unsigned gd_p : 1; // Present unsigned gd_off_31_16 : 16; // high bits of offset in segment&#125;; Taskstate结构是与CPU绑定的，它用于储存这个CPU的各种TSS信息，比较关键的属性有ts_esp0(设置异常栈的位置)，ts_ss0(设置异常栈所在的段选择符)，以及ts_eip等各种原有寄存器信息的保存。Gatedesc结构描述了IDT中中断描述符的结构。 SETGATE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Set up a normal interrupt/trap gate descriptor.// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate. // see section 9.6.1.3 of the i386 reference: "The difference between // an interrupt gate and a trap gate is in the effect on IF (the // interrupt-enable flag). An interrupt that vectors through an // interrupt gate resets IF, thereby preventing other interrupts from // interfering with the current interrupt handler. A subsequent IRET // instruction restores IF to the value in the EFLAGS image on the // stack. An interrupt through a trap gate does not change IF."// - sel: Code segment selector for interrupt/trap handler// - off: Offset in code segment for interrupt/trap handler// - dpl: Descriptor Privilege Level -// the privilege level required for software to invoke// this interrupt/trap gate explicitly using an int instruction.#define SETGATE(gate, istrap, sel, off, dpl) \&#123; \ (gate).gd_off_15_0 = (uint32_t) (off) &amp; 0xffff; \ (gate).gd_sel = (sel); \ (gate).gd_args = 0; \ (gate).gd_rsv1 = 0; \ (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32; \ (gate).gd_s = 0; \ (gate).gd_dpl = (dpl); \ (gate).gd_p = 1; \ (gate).gd_off_31_16 = (uint32_t) (off) &gt;&gt; 16; \&#125;// Set up a call gate descriptor.#define SETCALLGATE(gate, sel, off, dpl) \&#123; \ (gate).gd_off_15_0 = (uint32_t) (off) &amp; 0xffff; \ (gate).gd_sel = (sel); \ (gate).gd_args = 0; \ (gate).gd_rsv1 = 0; \ (gate).gd_type = STS_CG32; \ (gate).gd_s = 0; \ (gate).gd_dpl = (dpl); \ (gate).gd_p = 1; \ (gate).gd_off_31_16 = (uint32_t) (off) &gt;&gt; 16; \&#125;// Pseudo-descriptors used for LGDT, LLDT and LIDT instructions.struct Pseudodesc &#123; uint16_t pd_lim; // Limit uint32_t pd_base; // Base address&#125; __attribute__ ((packed));#endif /* !__ASSEMBLER__ */ SETGATE函数是我们在Lab3和Lab4中起重大作用的宏，它可以为我们方便地组装起一个中断描述符。它的五个参数含义分别为： gate：这个中断描述符在IDT中的位置 istrap：如果为0则在引发这个中断时重置IF标志位为0，否则不改变IF标志位。由于JOS的特殊要求，我们不能简单地按照注释以描述符是interrupt还是trap来决定这个参数的值，具体原因可以参照6.828实验记录中的描述。 sel：中断处理程序所在的代码段的段选择符，即中断处理程序首地址的cs off：中断处理程序在代码段中的偏移量，即中断处理程序首地址的ip dpl：中断的优先级，对应于CPU的权限等级，指定什么权限级的程序可以显式引发这个中断。 /inc/types.h这个头文件基本是由typedef组成的，它给出了我们所使用的各种特殊数据类型的原型，并提供了大小比较，倍数取整等实用的算术宏函数。 Types123#ifndef NULL#define NULL ((void*) 0)#endif NULL被定义为泛型指针类型的0。 123// Represents true-or-false valuestypedef _Bool bool;enum &#123; false, true &#125;; 为C语言提供了C++风格的bool类型支持，这一点超级好评，对码风有很大的帮助。 123456789// Explicitly-sized versions of integer typestypedef __signed char int8_t;typedef unsigned char uint8_t;typedef short int16_t;typedef unsigned short uint16_t;typedef int int32_t;typedef unsigned int uint32_t;typedef long long int64_t;typedef unsigned long long uint64_t; JOS的int_t族类型定义在32位和64位系统下都是正确的。它谨慎地使用了long long而不是long来定义int64_t，因为long型数据在32位下是4字节，而long long型无论在32位还是64位都是8字节。 1234567// Pointers and addresses are 32 bits long.// We use pointer types to represent virtual addresses,// uintptr_t to represent the numerical values of virtual addresses,// and physaddr_t to represent physical addresses.typedef int32_t intptr_t;typedef uint32_t uintptr_t;typedef uint32_t physaddr_t; 关于指针的定义。系统编程中我们时常要做指针和整型数之间的转换，所以JOS干脆拿int32来做一种指针类型的原型。uintptr_t和physaddr_t本质上是一样的，只不过区分它们能让码风更好看，更易于理解。 由于JOS是32位操作系统所以所有指针都是32位的。如果要改成64位系统就要用uint64_t来表示指针。 123456789// Page numbers are 32 bits long.typedef uint32_t ppn_t;// ssize_t is a signed version of ssize_t, used in case there might be an// error return.typedef int32_t ssize_t;// off_t is used for file offsets and lengths.typedef int32_t off_t; 我觉着这几个应该没人用(不是，没有) Operations1234567891011121314151617181920212223242526272829303132// Efficient min and max operations#define MIN(_a, _b) \(&#123; \ typeof(_a) __a = (_a); \ typeof(_b) __b = (_b); \ __a &lt;= __b ? __a : __b; \&#125;)#define MAX(_a, _b) \(&#123; \ typeof(_a) __a = (_a); \ typeof(_b) __b = (_b); \ __a &gt;= __b ? __a : __b; \&#125;)// Rounding operations (efficient when n is a power of 2)// Round down to the nearest multiple of n#define ROUNDDOWN(a, n) \(&#123; \ uint32_t __a = (uint32_t) (a); \ (typeof(a)) (__a - __a % (n)); \&#125;)// Round up to the nearest multiple of n#define ROUNDUP(a, n) \(&#123; \ uint32_t __n = (uint32_t) (n); \ (typeof(a)) (ROUNDDOWN((uint32_t) (a) + __n - 1, __n)); \&#125;)#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))// Return the offset of 'member' relative to the beginning of a struct type#define offsetof(type, member) ((size_t) (&amp;((type*)0)-&gt;member)) 可以发现这些宏函数大量使用了typeof算符来得到参数的类型，这个算符是GNU为C语言做的扩展gnu99中的，原生C99并不支持这种操作。尽管如此，这个算符由于其方便性仍被大量使用到Linux和其他类UNIX系统的内核编写中。 C语言有一个不常被用到的特性，即语句块的值等于其中最后一条语句的值。宏函数利用这种特性可以以一个语句块作为其展开对象，这样就可以在语句块中包含多条语句，只需要将最后一条语句写成想要返回的值即可。 /inc/memlayout.h这个头文件描述了虚拟内存的结构，并给出了在我们管理虚拟内存时非常实用的一些宏常量和函数。 Including1234#ifndef __ASSEMBLER__#include &lt;inc/types.h&gt;#include &lt;inc/mmu.h&gt;#endif /* not __ASSEMBLER__ */ 这个头文件对mmu.h和types.h两个头文件有依赖。基本上只要有数据类型声明就可能会对types.h有依赖，这一点不需要重复说明。 Structure of GDT 123456// Global descriptor numbers#define GD_KT 0x08 // kernel text#define GD_KD 0x10 // kernel data#define GD_UT 0x18 // user text#define GD_UD 0x20 // user data#define GD_TSS0 0x28 // Task segment selector for CPU 0 从这一串定义可以大致描绘出GDT的结构： GDT[0]：空描述符 GDT[1]：内核代码段 GDT[2]：内核数据段(注意0x10不是10，展开是0b10000，去掉右边三位就是2) GDT[3]：用户代码段 GDT[4]：用户数据段 GDT[5]及之后：依次为各个CPU的TSS段 Memory Layout123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// All physical memory mapped at this address#define KERNBASE 0xF0000000// At IOPHYSMEM (640K) there is a 384K hole for I/O. From the kernel,// IOPHYSMEM can be addressed at KERNBASE + IOPHYSMEM. The hole ends// at physical address EXTPHYSMEM.#define IOPHYSMEM 0x0A0000#define EXTPHYSMEM 0x100000// Kernel stack.#define KSTACKTOP KERNBASE#define KSTKSIZE (8*PGSIZE) // size of a kernel stack#define KSTKGAP (8*PGSIZE) // size of a kernel stack guard// Memory-mapped IO.#define MMIOLIM (KSTACKTOP - PTSIZE)#define MMIOBASE (MMIOLIM - PTSIZE)#define ULIM (MMIOBASE)/* * User read-only mappings! Anything below here til UTOP are readonly to user. * They are global pages mapped in at env allocation time. */// User read-only virtual page table (see 'uvpt' below)#define UVPT (ULIM - PTSIZE)// Read-only copies of the Page structures#define UPAGES (UVPT - PTSIZE)// Read-only copies of the global env structures#define UENVS (UPAGES - PTSIZE)/* * Top of user VM. User can manipulate VA from UTOP-1 and down! */// Top of user-accessible VM#define UTOP UENVS// Top of one-page user exception stack#define UXSTACKTOP UTOP// Next page left invalid to guard against exception stack overflow; then:// Top of normal user stack#define USTACKTOP (UTOP - 2*PGSIZE)// Where user programs generally begin#define UTEXT (2*PTSIZE)// Used for temporary page mappings. Typed 'void*' for convenience#define UTEMP ((void*) PTSIZE)// Used for temporary page mappings for the user page-fault handler// (should not conflict with other temporary page mappings)#define PFTEMP (UTEMP + PTSIZE - PGSIZE)// The location of the user-level STABS data structure#define USTABDATA (PTSIZE / 2)// Physical address of startup code for non-boot CPUs (APs)#define MPENTRY_PADDR 0x7000 这一部分定义的主要是虚拟内存空间内各个特殊地址的别称。整个虚拟内存空间的结构可以参考6.828实验记录中的贴图。我做了一张更加详细的内核区贴图(但不保证正确性)，贴在这里： Pages12345678910111213141516171819#ifndef __ASSEMBLER__typedef uint32_t pte_t;typedef uint32_t pde_t;#if JOS_USERextern volatile pte_t uvpt[]; // VA of "virtual page table"extern volatile pde_t uvpd[]; // VA of current page directory#endifstruct PageInfo &#123; // Next page on the free list. struct PageInfo *pp_link; uint16_t pp_ref;&#125;;#endif /* !__ASSEMBLER__ */ uvpd和uvpt两个数据结构是用于让用户进程也能够访问页目录和页表内容的，因此它们被#ifdef-#endif结构定义为只有在用户环境下才能访问。uvpt机制的具体原理可以参考6.828实验记录中的详细描述。(在这里这两个数组是extern过来的，它们的原型定义位于lib/entry.c) PageInfo结构体是用于唯一表示一个物理页面的结构，也就是每个PageInfo结构体可以唯一地换算到它代表的页面的物理地址。在Lab2中我们一直在跟这个结构打交道。 /inc/x86.hx86.h提供了大量x86汇编指令的加壳封装，对于不熟悉gcc内联汇编的同学可能会很有帮助，但是我在需要的时候倾向于直接使用内联汇编所以没怎么用这个头文件里定义的函数。 12345static inline voidbreakpoint(void)&#123; asm volatile("int3");&#125; 断点操作，用于触发断点中断。在Lab3实现中断处理之前会引发Triple fault。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495static inline uint8_tinb(int port)&#123; uint8_t data; asm volatile("inb %w1,%0" : "=a" (data) : "d" (port)); return data;&#125;static inline voidinsb(int port, void *addr, int cnt)&#123; asm volatile("cld\n\trepne\n\tinsb" : "=D" (addr), "=c" (cnt) : "d" (port), "0" (addr), "1" (cnt) : "memory", "cc");&#125;static inline uint16_tinw(int port)&#123; uint16_t data; asm volatile("inw %w1,%0" : "=a" (data) : "d" (port)); return data;&#125;static inline voidinsw(int port, void *addr, int cnt)&#123; asm volatile("cld\n\trepne\n\tinsw" : "=D" (addr), "=c" (cnt) : "d" (port), "0" (addr), "1" (cnt) : "memory", "cc");&#125;static inline uint32_tinl(int port)&#123; uint32_t data; asm volatile("inl %w1,%0" : "=a" (data) : "d" (port)); return data;&#125;static inline voidinsl(int port, void *addr, int cnt)&#123; asm volatile("cld\n\trepne\n\tinsl" : "=D" (addr), "=c" (cnt) : "d" (port), "0" (addr), "1" (cnt) : "memory", "cc");&#125;static inline voidoutb(int port, uint8_t data)&#123; asm volatile("outb %0,%w1" : : "a" (data), "d" (port));&#125;static inline voidoutsb(int port, const void *addr, int cnt)&#123; asm volatile("cld\n\trepne\n\toutsb" : "=S" (addr), "=c" (cnt) : "d" (port), "0" (addr), "1" (cnt) : "cc");&#125;static inline voidoutw(int port, uint16_t data)&#123; asm volatile("outw %0,%w1" : : "a" (data), "d" (port));&#125;static inline voidoutsw(int port, const void *addr, int cnt)&#123; asm volatile("cld\n\trepne\n\toutsw" : "=S" (addr), "=c" (cnt) : "d" (port), "0" (addr), "1" (cnt) : "cc");&#125;static inline voidoutsl(int port, const void *addr, int cnt)&#123; asm volatile("cld\n\trepne\n\toutsl" : "=S" (addr), "=c" (cnt) : "d" (port), "0" (addr), "1" (cnt) : "cc");&#125;static inline voidoutl(int port, uint32_t data)&#123; asm volatile("outl %0,%w1" : : "a" (data), "d" (port));&#125; 对in和out两种与硬件设备交换信息的指令的封装。 1234567891011121314151617static inline voidlidt(void *p)&#123; asm volatile("lidt (%0)" : : "r" (p));&#125;static inline voidlgdt(void *p)&#123; asm volatile("lgdt (%0)" : : "r" (p));&#125;static inline voidlldt(uint16_t sel)&#123; asm volatile("lldt %0" : : "r" (sel));&#125; 描述符表装载指令，指定描述符表的起始地址。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static inline voidltr(uint16_t sel)&#123; asm volatile("ltr %0" : : "r" (sel));&#125;static inline voidlcr0(uint32_t val)&#123; asm volatile("movl %0,%%cr0" : : "r" (val));&#125;static inline uint32_trcr0(void)&#123; uint32_t val; asm volatile("movl %%cr0,%0" : "=r" (val)); return val;&#125;static inline uint32_trcr2(void)&#123; uint32_t val; asm volatile("movl %%cr2,%0" : "=r" (val)); return val;&#125;static inline voidlcr3(uint32_t val)&#123; asm volatile("movl %0,%%cr3" : : "r" (val));&#125;static inline uint32_trcr3(void)&#123; uint32_t val; asm volatile("movl %%cr3,%0" : "=r" (val)); return val;&#125;static inline voidlcr4(uint32_t val)&#123; asm volatile("movl %0,%%cr4" : : "r" (val));&#125;static inline uint32_trcr4(void)&#123; uint32_t cr4; asm volatile("movl %%cr4,%0" : "=r" (cr4)); return cr4;&#125; 对控制寄存器的装载和读取指令。 tr：装载着当前CPU正在运行的进程的TSS段选择符。 cr0：CPU控制寄存器，控制CPU的运行模式 cr1：保留寄存器，未定义它的行为 cr2：页故障寄存器，装载有上一次触发page fault的线性地址，用于中断恢复。 cr3：页目录寄存器，装载有当前进程使用的页目录物理地址。 cr4：与CPU的V8086模式有关，本Lab中不会用到。 1234567static inline voidtlbflush(void)&#123; uint32_t cr3; asm volatile("movl %%cr3,%0" : "=r" (cr3)); asm volatile("movl %0,%%cr3" : : "r" (cr3));&#125; TLB(页表缓存)，又称为快表，其中存储着一些页表页面的内容。由于一次完整的线性地址解析要先通过页目录索引找到页表页，再通过读出的页表页找到对应的物理页面，这中间要进行两次访存，无疑是非常低效的。快表可以减少第一次访存的发生次数，从而提高系统的性能。 tlbflush通过将cr3寄存器的值刷新来刷新整个页表缓存。 1234567891011121314151617181920212223242526272829static inline uint32_tread_eflags(void)&#123; uint32_t eflags; asm volatile("pushfl; popl %0" : "=r" (eflags)); return eflags;&#125;static inline voidwrite_eflags(uint32_t eflags)&#123; asm volatile("pushl %0; popfl" : : "r" (eflags));&#125;static inline uint32_tread_ebp(void)&#123; uint32_t ebp; asm volatile("movl %%ebp,%0" : "=r" (ebp)); return ebp;&#125;static inline uint32_tread_esp(void)&#123; uint32_t esp; asm volatile("movl %%esp,%0" : "=r" (esp)); return esp;&#125; 对几个关键寄存器的读写封装，注意这里对eflags寄存器的访问是先将eflags用pushfl压栈再出栈到一个通用寄存器，这种访问方式是很巧妙的。 12345678910111213141516static inline voidcpuid(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp)&#123; uint32_t eax, ebx, ecx, edx; asm volatile("cpuid" : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx) : "a" (info)); if (eaxp) *eaxp = eax; if (ebxp) *ebxp = ebx; if (ecxp) *ecxp = ecx; if (edxp) *edxp = edx;&#125; 对cpuid指令的封装。cpuid是Intel处理器的一个很强大的指令，它通过读取ax寄存器中的参数将对应的CPU信息放到ax-dx四个寄存器中。这个封装可以很方便地查询CPU信息。 1234567static inline uint64_tread_tsc(void)&#123; uint64_t tsc; asm volatile("rdtsc" : "=A" (tsc)); return tsc;&#125; 用于读取自开机到现在CPU运行的周期数。 123456789101112static inline uint32_txchg(volatile uint32_t *addr, uint32_t newval)&#123; uint32_t result; // The + in "+m" denotes a read-modify-write operand. asm volatile("lock; xchgl %0, %1" : "+m" (*addr), "=a" (result) : "1" (newval) : "cc"); return result;&#125; 封装了一个特定参数的xchg指令，用于更新一个地址处的值并同时返回原来的值。 注意这里在xchgl指令之前使用了lock来进行加锁，这是为了防止多个进程同时访问同一个地址时引起的竞争。 /inc/elf.h这个头文件根据elf文件的结构标准定义了一些用于解析elf文件的结构和常量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758struct Elf &#123; uint32_t e_magic; // must equal ELF_MAGIC uint8_t e_elf[12]; uint16_t e_type; uint16_t e_machine; uint32_t e_version; uint32_t e_entry; uint32_t e_phoff; uint32_t e_shoff; uint32_t e_flags; uint16_t e_ehsize; uint16_t e_phentsize; uint16_t e_phnum; uint16_t e_shentsize; uint16_t e_shnum; uint16_t e_shstrndx;&#125;;struct Proghdr &#123; uint32_t p_type; uint32_t p_offset; uint32_t p_va; uint32_t p_pa; uint32_t p_filesz; uint32_t p_memsz; uint32_t p_flags; uint32_t p_align;&#125;;struct Secthdr &#123; uint32_t sh_name; uint32_t sh_type; uint32_t sh_flags; uint32_t sh_addr; uint32_t sh_offset; uint32_t sh_size; uint32_t sh_link; uint32_t sh_info; uint32_t sh_addralign; uint32_t sh_entsize;&#125;;// Values for Proghdr::p_type#define ELF_PROG_LOAD 1// Flag bits for Proghdr::p_flags#define ELF_PROG_FLAG_EXEC 1#define ELF_PROG_FLAG_WRITE 2#define ELF_PROG_FLAG_READ 4// Values for Secthdr::sh_type#define ELF_SHT_NULL 0#define ELF_SHT_PROGBITS 1#define ELF_SHT_SYMTAB 2#define ELF_SHT_STRTAB 3// Values for Secthdr::sh_name#define ELF_SHN_UNDEF 0 /inc/assert.h这个头文件包含了对panic和warn两个常用调试函数的封装，以及对C语言特有的assert断言的实现。这些可以说是比较底层的东西，运用了很多GNU C提供的扩展语法。 12345678910111213#include &lt;inc/stdio.h&gt;void _warn(const char*, int, const char*, ...);void _panic(const char*, int, const char*, ...) __attribute__((noreturn));#define warn(...) _warn(__FILE__, __LINE__, __VA_ARGS__)#define panic(...) _panic(__FILE__, __LINE__, __VA_ARGS__)#define assert(x) \ do &#123; if (!(x)) panic("assertion failed: %s", #x); &#125; while (0)// static_assert(x) will generate a compile-time error if 'x' is false.#define static_assert(x) switch (x) case 0: case (x): 可以看到，这里的warn和panic被封装成了变参宏，而且这个变参宏的参数形式也和一般的变参宏有所不同——它的参数是...，在C语言中意味着变长参数。在宏函数中使用...，也就是这个宏可以接受任意个参数并将其封装为一个valist。 我们可以看到这两个宏的内容是直接调用了我们在/kern/init.c中实现的_panic和_warn函数，而我们知道这两个函数需要输入当前文件的名称和当前行号作为参数。JOS使用了GNU C的扩展来完成这项工作——__FILE__会被解析为当前文件的名称，__LINE__则被解析为行号，最后__VA_ARGS__则是宏传进来的参数列表。 再往下看，我们可以看到assert断言其实是用panic实现的一个用户级宏。这里的实现使用到了宏编程中经典的do-while(0)结构，这种结构往往用于声明一个功能性的宏函数(即不取其返回值)，而之前介绍过的({...})结构则用于声明求值性的宏函数。这样定义的目的是避免{}与调用式末的分号接触可能带来的语法错误。 除了标准的运行时assert的实现，jos还巧妙地实现了一个编译时assert。其作用的原理是switch-case结构中case后表达式的值不能重复，在这里如果x等于0的话就会引发一个编译错误duplicate case error。不过，这个断言只能用在x的值是常量的情况下。 /bootboot文件夹包含了用于构造bootloader所需的源代码。 12345boot├── boot.S：在C语言函数栈建立起来之前做一些基本的准备工作├── main.c：读取kernel代码到内存并执行它├── Makefrag：用于构建bootloader二进制程序└── sign.pl /boot/boot.S1#include &lt;inc/mmu.h&gt; boot.S需要用到mmu.h中一个用于构造GDT表项的SEG宏，因此需要包含这个头文件。 在mmu.h中我们可以看到一段包含在#ifdef __ASSEMBLER__ ... #endif结构中的代码，这段代码就是为了这里而写在那里的，SEG宏的具体细节在mmu.h头文件中分析。 12345678# Start the CPU: switch to 32-bit protected mode, jump into C.# The BIOS loads this code from the first sector of the hard disk into# memory at physical address 0x7c00 and starts executing in real mode# with %cs=0 %ip=7c00..set PROT_MODE_CSEG, 0x8 # kernel code segment selector.set PROT_MODE_DSEG, 0x10 # kernel data segment selector.set CR0_PE_ON, 0x1 # protected mode enable flag 根据GDT的结构和段选择符的结构，这里定义了内核数据段和内核代码段的段选择符，以及CR0中控制保护模式的标志位，方便之后使用。 1234567891011.globl startstart: .code16 # Assemble for 16-bit mode cli # Disable interrupts cld # String operations increment # Set up the important data segment registers (DS, ES, SS). xorw %ax,%ax # Segment number zero movw %ax,%ds # -&gt; Data Segment movw %ax,%es # -&gt; Extra Segment movw %ax,%ss # -&gt; Stack Segment .code16指定将汇编代码翻译为16位机器码，因为打开保护模式之前系统运行在实方式，无法运行32位机器码；接下来是关闭中断和设置字符串操作顺序，以及将各个16位下的段寄存器值设为零。 .globl start与Makefrag中的-e start呼应，揭示了链接器是如何设置bootloader的入口的。由于我们在链接时设置了-e start和-Ttext 0x7c00两个标签，start标签所对应的地址应该是0x7c00。 12345678910111213141516171819202122232425262728 # Enable A20: # For backwards compatibility with the earliest PCs, physical # address line 20 is tied low, so that addresses higher than # 1MB wrap around to zero by default. This code undoes this.seta20.1: inb $0x64,%al # Wait for not busy testb $0x2,%al jnz seta20.1 movb $0xd1,%al # 0xd1 -&gt; port 0x64 outb %al,$0x64seta20.2: inb $0x64,%al # Wait for not busy testb $0x2,%al jnz seta20.2 movb $0xdf,%al # 0xdf -&gt; port 0x60 outb %al,$0x60 # Switch from real to protected mode, using a bootstrap GDT # and segment translation that makes virtual addresses # identical to their physical addresses, so that the # effective memory map does not change during the switch. lgdt gdtdesc movl %cr0, %eax orl $CR0_PE_ON, %eax movl %eax, %cr0 打开A20地址线，加载GDT并打开保护模式。具体细节描述在6.828实验记录中有过描述。 123456789101112131415161718192021 # Jump to next instruction, but in 32-bit code segment. # Switches processor into 32-bit mode. ljmp $PROT_MODE_CSEG, $protcseg .code32 # Assemble for 32-bit modeprotcseg: # Set up the protected-mode data segment registers movw $PROT_MODE_DSEG, %ax # Our data segment selector movw %ax, %ds # -&gt; DS: Data Segment movw %ax, %es # -&gt; ES: Extra Segment movw %ax, %fs # -&gt; FS movw %ax, %gs # -&gt; GS movw %ax, %ss # -&gt; SS: Stack Segment # Set up the stack pointer and call into C. movl $start, %esp call bootmain # If bootmain returns (it shouldn&apos;t), loop.spin: jmp spin ljmp以cs:ip双操作数进行寻址，前者是定义好的32位内核代码段，后者是接下来的标签。在跳转语句和protcseg标签之间用.code32标识出接下来的汇编代码要翻译成32位机器码。这个跳转是为了从实模式代码段跳转到保护模式代码段继续运行。 跳转结束之后，将ds和ss等段寄存器的值全部设为内核数据段选择符，这里将esp的值设为start，也就是代码段的开始处，说明堆栈从代码段的开始向下增长，堆栈区域和代码区相邻。这里没有将esp设置为KSTACKTOP是因为此时还没有建立起虚拟内存，即使打开了分页机制我们可用的也只有0xf0000000-0xf0100000这一块虚拟地址，因为它们是直接映射到1MB物理内存的。(当然，虚拟地址0x0-0x100000仍然保持与物理内存的映射关系所以也可以用) 所有设置结束之后，控制流跳转到C代码区，而且不需要返回。 12345678910# Bootstrap GDT.p2align 2 # force 4 byte alignmentgdt: SEG_NULL # null seg SEG(STA_X|STA_R, 0x0, 0xffffffff) # code seg SEG(STA_W, 0x0, 0xffffffff) # data seggdtdesc: .word 0x17 # sizeof(gdt) - 1 .long gdt # address gdt 最后一段代码建立起了一个很简陋的GDT，它只包括GDT[0-2]三个段，并且代码段和数据段的范围都是0-0xffffffff。在建立好GDT之后，它紧接着声明了一个包含GDT大小信息和起始地址的gdtdesc结构，我们之前看到的装载GDT的指令lgdt gdtdesc就是根据这个结构中的信息找到并装载GDT的。 /boot/main.c12#include &lt;inc/x86.h&gt;#include &lt;inc/elf.h&gt; x86.h帮助我们操作寄存器，elf.h帮助我们解析elf文件。 12345#define SECTSIZE 512#define ELFHDR ((struct Elf *) 0x10000) // scratch spacevoid readsect(void*, uint32_t);void readseg(uint32_t, uint32_t, uint32_t); SECTSIZE：硬盘上一个section的大小 ELFHDR：磁盘上约定的内核镜像elf头的位置(即第二个sector) 由于readsect和readseg两个函数充满了意义不明的汇编指令，又缺乏对参数的解释，对这部分源码采用自顶向下的研究方式可能会更易于理解。因此我们先来看bootmain函数。 1234567891011121314151617181920212223242526272829303132333435voidbootmain(void)&#123; struct Proghdr *ph, *eph; int i; // read 1st page off disk readseg((uint32_t) ELFHDR, SECTSIZE*8, 0); // is this a valid ELF? if (ELFHDR-&gt;e_magic != ELF_MAGIC) goto bad; // load each program segment (ignores ph flags) ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff); eph = ph + ELFHDR-&gt;e_phnum; for (; ph &lt; eph; ph++) &#123; // p_pa is the load address of this segment (as well // as the physical address) readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset); for (i = 0; i &lt; ph-&gt;p_memsz - ph-&gt;p_filesz; i++) &#123; *((char *) ph-&gt;p_pa + ph-&gt;p_filesz + i) = 0; &#125; &#125; // call the entry point from the ELF header // note: does not return! ((void (*)(void)) (ELFHDR-&gt;e_entry))();bad: outw(0x8A00, 0x8A00); outw(0x8A00, 0x8E00); while (1) /* do nothing */;&#125; 通过bootmain函数中的注释我们可以看出readseg的三个参数的含义： 参数1：读入的segment存放在内存中的地址，即loadaddress。 参数2：读入的长度，以字节为单位 参数3：要读入的segment的起始位置在kernel中的偏移 结合elf.h中的各个结构体定义，可以描述出bootmain函数的逻辑： 将内核镜像的ELF头读到内存中的指定位置(ELFHDR) 判断读入的ELF头是否有效，即内核镜像是否有效 从ELF头中定位到节头部表，并解析出节头的数量 跟据节头部表中的每个节头去将对应的节读入内存中节的加载地址 跳转到ELF头中定义的内核入口 总结起来就是：将内核镜像加载到内存，并运行之。 12345678910111213141516171819202122232425262728// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.// Might copy more than askedvoidreadseg(uint32_t pa, uint32_t count, uint32_t offset)&#123; uint32_t end_pa; end_pa = pa + count; // round down to sector boundary pa &amp;= ~(SECTSIZE - 1); // translate from bytes to sectors, and kernel starts at sector 1 offset = (offset / SECTSIZE) + 1; // If this is too slow, we could read lots of sectors at a time. // We'd write more to memory than asked, but it doesn't matter -- // we load in increasing order. while (pa &lt; end_pa) &#123; // Since we haven't enabled paging yet and we're using // an identity segment mapping (see boot.S), we can // use physical addresses directly. This won't be the // case once JOS enables the MMU. readsect((uint8_t*) pa, offset); pa += SECTSIZE; offset++; &#125;&#125; 我们知道，系统级IO的最小单位就是sector(在JOS中等于512字节)，因此当申请的读取大小并不是sector的整数倍的时候，readseg函数会将count以sector为单位向上取整。 123456789101112131415161718192021222324252627voidwaitdisk(void)&#123; // wait for disk reaady while ((inb(0x1F7) &amp; 0xC0) != 0x40) /* do nothing */;&#125;voidreadsect(void *dst, uint32_t offset)&#123; // wait for disk to be ready waitdisk(); outb(0x1F2, 1); // count = 1 outb(0x1F3, offset); outb(0x1F4, offset &gt;&gt; 8); outb(0x1F5, offset &gt;&gt; 16); outb(0x1F6, (offset &gt;&gt; 24) | 0xE0); outb(0x1F7, 0x20); // cmd 0x20 - read sectors // wait for disk to be ready waitdisk(); // read a sector insl(0x1F0, dst, SECTSIZE/4);&#125; 这个函数将一系列硬件级的汇编指令操作封装成了一个用于读取磁盘上一个sector的函数。我们没必要了解这些跟硬件接口有关的细节，因此只需要了解其原理即可。 dst：读取出的sector的存放位置 offset：要读取的sector的序号 /kernkern文件夹内定义的是用于构建内核的各种内核数据结构和内核态下执行的函数。 1234567891011121314151617181920212223242526272829303132333435kern├── console.c // 管理控制台IO的模块，如键盘输入，VGA输出├── console.h├── COPYRIGHT├── cpu.h // 定义了一些与控制cpu行为有关的函数和数据结构├── entrypgdir.c // 定义了启动阶段要用到的临时页目录├── entry.S // BSP的内核入口代码├── env.c // 进程管理模块├── env.h├── init.c // 初始化内核的代码├── kclock.c // 时间模块├── kclock.h├── kdebug.c // 用于获取和解析调试信息的模块├── kdebug.h├── kernel.ld├── lapic.c // 控制lapic的代码├── Makefrag├── monitor.c // 内核monitor模块，实现了一个内核终端├── monitor.h├── mpconfig.c // 涉及多处理器控制的代码├── mpentry.S // AP们的内核入口代码├── picirq.c├── picirq.h├── pmap.c // 虚拟内存空间模块├── pmap.h├── printf.c // 标准输出函数的实现代码├── sched.c // 多进程调度模块├── sched.h├── spinlock.c // 自旋锁模块├── spinlock.h├── syscall.c // 系统调用模块├── syscall.h├── trap.c // 中断处理模块├── trapentry.S└── trap.h 可以看到，相当一部分内核模块都是由一个.h和一个同名的.c所组成的。在研究的时候，应当将它们放在一起研究。 /kern/entry.Sentry.S是操作系统启动时内核的入口代码。bootloader在将内核加载到内存后，会跳转到这里开始执行。 123#include &lt;inc/mmu.h&gt;#include &lt;inc/memlayout.h&gt;#include &lt;inc/trap.h&gt; entry.S需要用到mmu.h中定义的一些处理器标志，以控制cr0的状态；还要用到memlayout.h中对一些内存特定位置的定义。 1234567891011121314151617# Shift Right Logical #define SRL(val, shamt) (((val) &gt;&gt; (shamt)) &amp; ~(-1 &lt;&lt; (32 - (shamt))))#################################################################### The kernel (this code) is linked at address ~(KERNBASE + 1 Meg), # but the bootloader loads it at address ~1 Meg.# # RELOC(x) maps a symbol x from its link address to its actual# location in physical memory (its load address). ####################################################################define RELOC(x) ((x) - KERNBASE)#define MULTIBOOT_HEADER_MAGIC (0x1BADB002)#define MULTIBOOT_HEADER_FLAGS (0)#define CHECKSUM (-(MULTIBOOT_HEADER_MAGIC + MULTIBOOT_HEADER_FLAGS)) 这一部分主要定义了一些宏，方便接下来使用。SRL就是普通的逻辑右移，做过CSAPP的datalab应该知道这个不难实现。RELOC用于将0xf0000000以上的虚拟地址转换到物理地址。剩下几个关于MULTIBOOT_HEADER的宏是用于构造Multiboot头的，不需要了解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#################################################################### entry point###################################################################.text# The Multiboot header.align 4.long MULTIBOOT_HEADER_MAGIC.long MULTIBOOT_HEADER_FLAGS.long CHECKSUM# '_start' specifies the ELF entry point. Since we haven't set up# virtual memory when the bootloader enters this code, we need the# bootloader to jump to the *physical* address of the entry point..globl _start_start = RELOC(entry).globl entryentry: movw $0x1234,0x472 # warm boot # We haven't set up virtual memory yet, so we're running from # the physical address the boot loader loaded the kernel at: 1MB # (plus a few bytes). However, the C code is linked to run at # KERNBASE+1MB. Hence, we set up a trivial page directory that # translates virtual addresses [KERNBASE, KERNBASE+4MB) to # physical addresses [0, 4MB). This 4MB region will be # sufficient until we set up our real page table in mem_init # in lab 2. # Load the physical address of entry_pgdir into cr3. entry_pgdir # is defined in entrypgdir.c. movl $(RELOC(entry_pgdir)), %eax movl %eax, %cr3 # Turn on paging. movl %cr0, %eax orl $(CR0_PE|CR0_PG|CR0_WP), %eax movl %eax, %cr0 # Now paging is enabled, but we're still running at a low EIP # (why is this okay?). Jump up above KERNBASE before entering # C code. mov $relocated, %eax jmp *%eaxrelocated: # Clear the frame pointer register (EBP) # so that once we get into debugging C code, # stack backtraces will be terminated properly. movl $0x0,%ebp # nuke frame pointer # Set the stack pointer movl $(bootstacktop),%esp # now to C code call i386_init # Should never get here, but in case we do, just spin.spin: jmp spin 接下来是代码段。在汇编级，C程序的入口都是_start函数，因而bootloader从ELF头中取到并跳转到的函数应当就是_start函数。由于内核镜像是被32位链接器所构造出来的，.text段在内核镜像中标记的地址应当是0xf0000000以上的虚拟地址。而在加载时bootloader却会将整个内核镜像加载到物理内存中，鉴于目前还没有打开分页机制，我们就需要用RELOC宏来将entry标签所对应的物理地址作为_start提供给bootloader。 在跳转到entry标签之后，内核是不能直接去开分页机制的，因为此时cr3寄存器中还没有载入一个可用的页目录，如果直接打开分页会由于整个虚拟地址空间都没有PTE_P权限而引发triple fault。在这里，jos已经在entrypgdir.c文件中创建了一个简单的临时页目录，因而首先要做的就是将这个目录装载到cr3寄存器。 装载页目录之后，我们就可以放心地开分页，开分段，开写保护(通过设置三个flags来进行)。都设置好之后，通过一个标签跳转来跳转到高地址。这个跳转方式原理是这样的：entry.S在被汇编链接时，其中所有的符号(比如比如relocated)都会被分配一个高地址。在前面引用符号的时候，我们都使用了RELOC宏来手动将其转换为低地址，但在这里如果我们不使用这个宏直接跳转就可以自然地进入到高地址区。 进入高地址区后，我们还需要建立一个合适的C函数栈。首先清空ebp寄存器，这个操作其实不必要，它是为了让之后进行backtrace的时候能够停在一个合适的位置。然后将esp的值设置为我们构造好的栈顶(构造栈的代码在之后给出)，即可调用init.c中的C函数i386_init进入操作系统初始化阶段了。 12345678910.data#################################################################### boot stack################################################################### .p2align PGSHIFT # force page alignment .globl bootstackbootstack: .space KSTKSIZE .globl bootstacktop bootstacktop: 这个程序栈只是在虚拟内存系统还没建立起来之时权宜之用的临时函数栈，可以看到它只是从数据段的开头部分开始分配了一个KSTKSIZE大小的栈空间，并向外给出一个bootstacktop来标记栈顶位置。 /kern/entrypgdir.c这个文件为entry.S提供了一个构建好的简单的页目录，让内核能在真正的页目录建立起来之前在分页机制下正常运行。 12#include &lt;inc/mmu.h&gt;#include &lt;inc/memlayout.h&gt; 页目录和页表表项的权限位管理需要mmu.h，而它们对虚拟地址空间的操作需要memlayout.h。 1pte_t entry_pgtable[NPTENTRIES]; 由于只是一个简单的页目录，我们只需要一个页表就可以了。为了能在接下来的页目录声明中引用这个页表的地址，需要提前声明好这个页表。这里pte_t是页表项类型，其本质是uint32_t，含义是这个页表项所指向的物理内存的物理地址；NPTENTRIES是一个页表中表项的个数1024。 1234567891011121314151617181920212223// The entry.S page directory maps the first 4MB of physical memory// starting at virtual address KERNBASE (that is, it maps virtual// addresses [KERNBASE, KERNBASE+4MB) to physical addresses [0, 4MB)).// We choose 4MB because that's how much we can map with one page// table and it's enough to get us through early boot. We also map// virtual addresses [0, 4MB) to physical addresses [0, 4MB); this// region is critical for a few instructions in entry.S and then we// never use it again.//// Page directories (and page tables), must start on a page boundary,// hence the "__aligned__" attribute. Also, because of restrictions// related to linking and static initializers, we use "x + PTE_P"// here, rather than the more standard "x | PTE_P". Everywhere else// you should use "|" to combine flags.__attribute__((__aligned__(PGSIZE)))pde_t entry_pgdir[NPDENTRIES] = &#123; // Map VA's [0, 4MB) to PA's [0, 4MB) [0] = ((uintptr_t)entry_pgtable - KERNBASE) + PTE_P, // Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB) [KERNBASE&gt;&gt;PDXSHIFT] = ((uintptr_t)entry_pgtable - KERNBASE) + PTE_P + PTE_W&#125;; __attribute__是GNU C扩展中的内容，它可以用来设置函数或变量的属性。在这里，JOS就是用__attribute__()将页目录设置为与PGSIZE对齐，即其首地址必须是PGSIZE的整数倍。 观察页目录的初始化情况，可以发现它进行了两个映射： 将虚拟地址0x0 - 0x00400000映射到物理地址0x0 - 0x00400000，权限为只读 将虚拟地址0xf0000000 - 0xf0400000映射到物理地址0x0 - 0x00400000，权限为读写 后一个映射是为了让内核代码能够跑在虚拟地址空间中，而前一个映射是为了让CPU在刚打开分页机制，控制流还在低地址区时不至于触发保护错误，而是能够正常运行直到跳转到高地址区。 12345678910111213141516171819202122// Entry 0 of the page table maps to physical page 0, entry 1 to// physical page 1, etc.__attribute__((__aligned__(PGSIZE)))pte_t entry_pgtable[NPTENTRIES] = &#123; 0x000000 | PTE_P | PTE_W, 0x001000 | PTE_P | PTE_W, 0x002000 | PTE_P | PTE_W, 0x003000 | PTE_P | PTE_W, 0x004000 | PTE_P | PTE_W, 0x005000 | PTE_P | PTE_W, 0x006000 | PTE_P | PTE_W, 0x007000 | PTE_P | PTE_W, ... 0x3f8000 | PTE_P | PTE_W, 0x3f9000 | PTE_P | PTE_W, 0x3fa000 | PTE_P | PTE_W, 0x3fb000 | PTE_P | PTE_W, 0x3fc000 | PTE_P | PTE_W, 0x3fd000 | PTE_P | PTE_W, 0x3fe000 | PTE_P | PTE_W, 0x3ff000 | PTE_P | PTE_W,&#125;; 页表的初始化非常长，但全都是重复的，只是简单地将表项和虚拟地址按正比方式去映射起来。 /kern/init.cinit.c包含了内核的初始化代码，它会依次对各个模块进行初始化。将它放在这个位置是因为按照调用逻辑这个时候控制流的确来到了这个文件，但这个文件中调用的函数要涉及到各个模块，因此会将这些函数放在定义之的模块中详细描述。 1234567891011121314#include &lt;inc/stdio.h&gt;#include &lt;inc/string.h&gt;#include &lt;inc/assert.h&gt;#include &lt;kern/monitor.h&gt;#include &lt;kern/console.h&gt;#include &lt;kern/pmap.h&gt;#include &lt;kern/kclock.h&gt;#include &lt;kern/env.h&gt;#include &lt;kern/trap.h&gt;#include &lt;kern/sched.h&gt;#include &lt;kern/picirq.h&gt;#include &lt;kern/cpu.h&gt;#include &lt;kern/spinlock.h&gt; init.c基本包含了内核中各个模块的头文件，因为它要完成各个模块的初始化工作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748voidi386_init(void)&#123; // Initialize the console. // Can't call cprintf until after we do this! cons_init(); cprintf("6828 decimal is %o octal!\n", 6828); // Lab 2 memory management initialization functions mem_init(); // Lab 3 user environment initialization functions env_init(); trap_init(); // Lab 4 multiprocessor initialization functions mp_init(); lapic_init(); // Lab 4 multitasking initialization functions pic_init(); // Acquire the big kernel lock before waking up APs // Your code here: lock_kernel(); // Starting non-boot CPUs boot_aps(); // Start fs. ENV_CREATE(fs_fs, ENV_TYPE_FS);#if defined(TEST) // Don't touch -- used by grading script! ENV_CREATE(TEST, ENV_TYPE_USER);#else // Touch all you want. ENV_CREATE(user_spawnhello, ENV_TYPE_USER);#endif // TEST* // Should not be necessary - drains keyboard because interrupt has given up. kbd_intr(); // Schedule and run the first user environment! sched_yield();&#125; cons_init：初始化VGA，键盘和串口设备，以让操作系统能够接受外部设备的输入输出。 mem_init：初始化虚拟内存，建立起虚拟地址空间。 env_init：初始化用户环境，为用户进程的运行创造条件。 trap_init：初始化中断处理，使操作系统能够处理软中断(异常，包括系统调用)。 mp_init：初始化多处理器(mp)，使BSP以外的其他cpu能够运行 lapic_init：初始化每个处理器的APIC单元，使得CPU间的相互控制成为可能 pic_init：初始化中断控制器，使操作系统能接受和处理硬中断。 在以上这些初始化进行完之后，CPU就可以着手去唤醒其他CPU，开始运行第一个用户进程了。 lock_kernel：在唤醒其他CPU之前需要给内核上锁 boot_aps：启动其他的CPU ENV_CREATE(fs_fs, ENV_TYPE_FS)：创建文件系统进程，打开文件系统 再之后，启动用户进程，具体机制在makefile部分有所描述； 最后，调用sched_yield()将控制权交给下一个准备好的进程。 12345678910111213141516171819202122232425262728293031// While boot_aps is booting a given CPU, it communicates the per-core// stack pointer that should be loaded by mpentry.S to that CPU in// this variable.void *mpentry_kstack;// Start the non-boot (AP) processors.static voidboot_aps(void)&#123; extern unsigned char mpentry_start[], mpentry_end[]; void *code; struct CpuInfo *c; // Write entry code to unused memory at MPENTRY_PADDR code = KADDR(MPENTRY_PADDR); memmove(code, mpentry_start, mpentry_end - mpentry_start); // Boot each AP one at a time for (c = cpus; c &lt; cpus + ncpu; c++) &#123; if (c == cpus + cpunum()) // We've started already. continue; // Tell mpentry.S what stack to use mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE; // Start the CPU at mpentry_start lapic_startap(c-&gt;cpu_id, PADDR(code)); // Wait for the CPU to finish some basic setup in mp_main() while(c-&gt;cpu_status != CPU_STARTED) ; &#125;&#125; mpentry_kstack是提供给mpentry使用的内核栈，mpentry.S通过这个全局变量的值来设定每个CPU的内核栈位置。boot_aps函数是刚刚init.c调用的用以启动各个AP的函数，其具体作用要结合mpentry.S来看。 TODO12345678910111213141516171819202122232425// Setup code for APsvoidmp_main(void)&#123; // We are in high EIP now, safe to switch to kern_pgdir lcr3(PADDR(kern_pgdir)); cprintf("SMP: CPU %d starting\n", cpunum()); lapic_init(); env_init_percpu(); trap_init_percpu(); xchg(&amp;thiscpu-&gt;cpu_status, CPU_STARTED); // tell boot_aps() we're up // Now that we have finished some basic setup, call sched_yield() // to start running processes on this CPU. But make sure that // only one CPU can enter the scheduler at a time! // // Your code here: lock_kernel(); sched_yield(); // Remove this after you finish Exercise 6 // for (;;);&#125; TODO12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* * Variable panicstr contains argument to first call to panic; used as flag * to indicate that the kernel has already called panic. */const char *panicstr;/* * Panic is called on unresolvable fatal errors. * It prints "panic: mesg", and then enters the kernel monitor. */void_panic(const char *file, int line, const char *fmt,...)&#123; va_list ap; if (panicstr) goto dead; panicstr = fmt; // Be extra sure that the machine is in as reasonable state asm volatile("cli; cld"); va_start(ap, fmt); cprintf("kernel panic on CPU %d at %s:%d: ", cpunum(), file, line); vcprintf(fmt, ap); cprintf("\n"); va_end(ap);dead: /* break into the kernel monitor */ while (1) monitor(NULL);&#125;/* like panic, but don't */void_warn(const char *file, int line, const char *fmt,...)&#123; va_list ap; va_start(ap, fmt); cprintf("kernel warning at %s:%d: ", file, line); vcprintf(fmt, ap); cprintf("\n"); va_end(ap);&#125; _panic和_warn两个函数提供了panic和warn两个常用调试函数的原型。panic会打印出引发错误的cpuid和错误位置以及参数中的错误信息，然后直接进入内核monitor并无法退出。而warning只会打印出需要警示的位置和警示信息，不做其他的事。 这里的_panic和_warn由于需要传入文件名和行号作为参数，并不方便我们使用，所以jos提供给我们的是加了一层壳的panic和warn。这两个其实是变参宏，具体的定义在&lt;assert.h&gt;中有所体现。 /kern/console(.c .h)这一部分的代码主要是与硬件(键盘，串口，并口，VGA显示屏)进行交流，关于协议的内容较多而关于算法的内容很少，因而不详细进行解析，只研究这个模块向外提供的接口部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/***** General device-independent console code *****/// Here we manage the console input buffer,// where we stash characters received from the keyboard or serial port// whenever the corresponding interrupt occurs.#define CONSBUFSIZE 512static struct &#123; uint8_t buf[CONSBUFSIZE]; uint32_t rpos; uint32_t wpos;&#125; cons;// called by device interrupt routines to feed input characters// into the circular console input buffer.static voidcons_intr(int (*proc)(void))&#123; int c; while ((c = (*proc)()) != -1) &#123; if (c == 0) continue; cons.buf[cons.wpos++] = c; if (cons.wpos == CONSBUFSIZE) cons.wpos = 0; &#125;&#125;// return the next input character from the console, or 0 if none waitingintcons_getc(void)&#123; int c; // poll for any pending input characters, // so that this function works even when interrupts are disabled // (e.g., when called from the kernel monitor). serial_intr(); kbd_intr(); // grab the next character from the input buffer. if (cons.rpos != cons.wpos) &#123; c = cons.buf[cons.rpos++]; if (cons.rpos == CONSBUFSIZE) cons.rpos = 0; return c; &#125; return 0;&#125;// output a character to the consolestatic voidcons_putc(int c)&#123; serial_putc(c); lpt_putc(c); cga_putc(c);&#125;// initialize the console devicesvoidcons_init(void)&#123; cga_init(); kbd_init(); serial_init(); if (!serial_exists) cprintf("Serial port does not exist!\n");&#125;// `High'-level console I/O. Used by readline and cprintf.voidcputchar(int c)&#123; cons_putc(c);&#125;intgetchar(void)&#123; int c; while ((c = cons_getc()) == 0) /* do nothing */; return c;&#125; cons结构：由一个缓冲区buf，读指针rpos和写指针wpos构成。 buf用于存放近期读入的一段数据 rpos指定内核对缓冲区的读取操作目前进行到的位置 wpos指定输入设备对缓冲区的写入操作目前进行到的位置 cons结构是一个console模块私有的全局结构，它控制着一个输入缓冲区。值得注意的是，这个缓冲区是一个循环缓冲区，也就是读或写指针在到达缓冲区尽头时会返回其开头位置。 cons_intr：由各种输入设备的中断处理程序调用，其参数传入的函数应当返回一个输入设备读入的字符(或-1,代表输入设备读入的字符已经全部被返回)，cons_intr会连续调用这个函数，将返回的字符写到cons结构的buf中，并移动wpos指针。这个函数的作用是从输入设备读一串输入到缓冲区。 cons_getc：提供给内核的标准输入接口 首先，它通过serial_intr()和kdb_intr()间接调用cons_intr来将当前设备读入的数据写到输入缓冲区； 此时，如果有新的输入或缓冲区中的输入并没有全部被读取，由于写的过程中wpos向前移动了，rpos和wpos间的部分就是读入缓冲区的数据。于是，将当前rpos指向的字符返回，rpos增加1 而如果rpos == wpos，说明当前缓冲区没有数据，此时返回0 cons_putc：提供给内核的标准输出接口 比起输入，输出不需要缓冲区，因此直接依次调用对应设备的输出函数即可。 cons_init：初始化函数，主要是初始化各种输入设备 这四个函数是最底层的io相关函数，内核是不会直接去调用它们的，而是采用加壳的方式： cputchar：内核使用的标准输出函数，它直接调用cons_putc来输出一个字符。 getchar：内核使用的标准输入函数，它使用一个空while循环来进行阻塞，直到cons_getc函数返回一个有效的字符才返回。 /kern/pmap(.c .h)pmap模块是整个jos内存管理的核心，是其他各个功能模块的基础。对它的研究就不能像console.c一样简略了，必须详细地研究每个部分。 首先是pmap.h： 123456789101112131415161718/* See COPYRIGHT for copyright information. */#ifndef JOS_KERN_PMAP_H#define JOS_KERN_PMAP_H#ifndef JOS_KERNEL# error "This is a JOS kernel header; user programs should not #include it"#endif#include &lt;inc/memlayout.h&gt;#include &lt;inc/assert.h&gt;struct Env;extern char bootstacktop[], bootstack[];extern struct PageInfo *pages;extern size_t npages;extern pde_t *kern_pgdir; 这个区域使用了一些extern变量，其中，pages、npages和kern_pgdir变量是从pmap.c中extern出来的，为的是向其他引用这个头文件的内核代码提供访问物理页信息和页目录信息的接口。而bootstacktop和bootstack则来自之前研究过的kern/entry.S，它们为我们提供了一个在我们还尚未建立虚拟地址空间时可以使用的临时栈。 1234567891011121314151617181920212223242526/* This macro takes a kernel virtual address -- an address that points above * KERNBASE, where the machine's maximum 256MB of physical memory is mapped -- * and returns the corresponding physical address. It panics if you pass it a * non-kernel virtual address. */#define PADDR(kva) _paddr(__FILE__, __LINE__, kva)static inline physaddr_t_paddr(const char *file, int line, void *kva)&#123; if ((uint32_t)kva &lt; KERNBASE) _panic(file, line, "PADDR called with invalid kva %08lx", kva); return (physaddr_t)kva - KERNBASE;&#125;/* This macro takes a physical address and returns the corresponding kernel * virtual address. It panics if you pass an invalid physical address. */#define KADDR(pa) _kaddr(__FILE__, __LINE__, pa)static inline void*_kaddr(const char *file, int line, physaddr_t pa)&#123; if (PGNUM(pa) &gt;= npages) _panic(file, line, "KADDR called with invalid pa %08lx", pa); return (void *)(pa + KERNBASE);&#125; PADDR和KADDR这两个宏可以说是非常关键，它们为我们提供了一个方便地转换物理地址和虚拟地址的封装。原理上讲，这个转换不过是一个加减法，但这两个宏包括了边界条件的判断和不合法情况下的精确报错，还是非常方便的。 可以注意到两个宏都使用了类似于panic和实现方式，这种机制的具体原理可以参照assert.h部分的讲解。 另一个点是函数名前面的static inline前缀。关于这个前缀的意义，我在另一篇博客中有写到。 123456789101112131415161718192021enum &#123; // For page_alloc, zero the returned physical page. ALLOC_ZERO = 1&lt;&lt;0,&#125;;void mem_init(void);void page_init(void);struct PageInfo *page_alloc(int alloc_flags);void page_free(struct PageInfo *pp);int page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm);void page_remove(pde_t *pgdir, void *va);struct PageInfo *page_lookup(pde_t *pgdir, void *va, pte_t **pte_store);void page_decref(struct PageInfo *pp);void tlb_invalidate(pde_t *pgdir, void *va);void * mmio_map_region(physaddr_t pa, size_t size);int user_mem_check(struct Env *env, const void *va, size_t len, int perm);void user_mem_assert(struct Env *env, const void *va, size_t len, int perm); 这一部分所声明的函数就是pmap模块对外开放的所有接口。查看它们可以帮助我们理解pmap.c中实现的哪些函数是给内核其他模块来用的，哪些是自己用的。 1234567891011121314151617181920212223static inline physaddr_tpage2pa(struct PageInfo *pp)&#123; return (pp - pages) &lt;&lt; PGSHIFT;&#125;static inline struct PageInfo*pa2page(physaddr_t pa)&#123; if (PGNUM(pa) &gt;= npages) panic("pa2page called with invalid pa"); return &amp;pages[PGNUM(pa)];&#125;static inline void*page2kva(struct PageInfo *pp)&#123; return KADDR(page2pa(pp));&#125;pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create);#endif /* !JOS_KERN_PMAP_H */ 最后定义]]></content>
      <categories>
        <category>Academic or Technical</category>
        <category>Operating System</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[字节跳动架构部门暑实面经]]></title>
    <url>%2Fblog%2F2019%2F03%2F21%2F%E5%A4%B4%E6%9D%A1%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F%2F</url>
    <content type="text"><![CDATA[字节跳动架构部门laaS暑期实习生面经一面面试官很nice，温和好说话，也会给提示。 开始部分首先是介绍一些自己做过的项目(自己做的或者跟导师做的)。 我的话就是讲一些简历上写了的项目： 视频抓取器Spatium和实现细节 课设C_formatter 跟导师改的一些kubernetes源码 说到k8s这部分的时候，面试官很自然地把话题引入计算虚拟化部分。 计算虚拟化部分 有关k8s 你知道kubernetes有哪几个主要的模块吗？ 答：大概有kubelet，kubectl，kubeadm还有coredns等模块。 那你知道这些模块里面哪些是功能模块而哪些是工具模块吗？ 答：主要的功能模块就是kubelet，解释了一下kubelet的各种作用。 kubelet在网络中是跟哪个身份的节点相连的？跟哪个进程相连的？ 答：细节不是很清楚 对虚拟化的了解 我们岗位就是做虚拟化的，说一下你对虚拟化的认识 答：主要答了一些主流虚拟化技术和虚拟机种类，并进行了一些解释 三种虚拟化形式： 虚拟机 容器 库操作系统 三种虚拟机形式： 运行在裸机上的全虚拟化(最早的虚拟化，讲了原理和劣势) 半虚拟化(修改操作系统内核，讲了原理和劣势，举例Xen) 基于硬件辅助的虚拟化(举了一些例子) Intel的处理器有哪些特性支持了第三种虚拟机？ 答：细节部分没有了解 CPU分了哪几个特权级，虚拟机是如何利用它们的？ 答：一开始口误，把4个特权级说成了0-4，经面试官提醒改为0-3。讲了一下全虚拟化和硬件辅助虚拟化对特权级的利用。 计算机网络部分 假如要写一个基于TCP的Server-Client程序，在S端和C端分别要做哪些工作？从代码的角度讲。 答：用python举例，讲了S端的socket，bind，listen，accept的调用时机、参数和一些特性；C端的socket，connect的调用时机、参数；send和recv方法的使用。 假设我在bind函数调用时不设定特定IP地址，要用什么端口？ 答：这个不大清楚 accept函数返回的fd你是如何处理的？比如是直接处理还是开新线程？ 答：如果有需求的话一般是给每个accept开一个新线程来处理，以实现高并发性。 算法和编程部分 假设我有一个袋子，里面装着黑白两色的球；每次从袋子里取出两个球并丢掉，如果两个球颜色相同就往袋子里放一个白球，否则放一个黑球，问最终剩下的球和袋子里原本白球和黑球个数的关系。 答：智力捉急，一开始没想出来。考官提示跟奇偶有关系，于是试着从简单的状态开始推了一下： 初态1：袋子里还剩两白一黑 这种情况下，穷举法能发现无论怎么取最后都是剩黑球 向这种情况下加入一个白球，发现情况并没有变化 继续加入白球，可以发现规律，似乎白球的初始个数对最后的结果并没有影响 初态2：袋子里还剩两黑一白 仍然用穷举法，可以发现最后剩下的一定是白球 加入一个黑球，发现剩下的变成了黑球 多举几种情况可以发现，黑球的奇偶决定着最后球的颜色 总结规律，就是：白球的数量对结果没有影响，黑球为奇数时剩下的是黑球，否则是白球。 给定一个由{}[]()三对括号组成的字符串，写一个函数判断它是否是匹配的。例如，{[()]}是匹配的，{([)]}就是不匹配的。 答：算法太菜，想了半天，两种思路都发现有问题。考官看我一直想不出来，提示要用到栈，我才反应过来。大体就是遍历字符串，遇到左括号压栈，遇到右括号就判断是否与栈顶的左括号匹配；如果匹配就将栈顶弹出，不匹配就说明整个字符串不匹配。 二面二面的面试官表情相对要严肃一点，不过也非常nice，语气很放松。 开始部分 先自我介绍一下吧。 答：照着简历说…… 你跟导师都做过什么呀？ 答：主要是在阅读和修改一些k8s的源码 C语言部分面试官似乎对我的C语言水平不很信任，出的题很简单。 关于数组指针的考察 在开始做之前我问了一下机器是多少位，考官指定了64位。 已知：12char *p = “abcdefg”;char a[] =“abcdefg”; (1)填空：123456Sizeof(p) = ____，sizeof(*p) = ____,sizeof(p[0]) = ____,sizeof(a) = ____,sizeof(a[0]) = ____,sizeof(&amp;a[0]) = ____. (2)回答问题 执行p[0] = ‘h’; 会发生什么，为什么？ 答：这个由于p是一个常量字符串指针，所处的内存区域是有读保护的，因而会引发中断（linux下是段错误） 执行a[0] = ‘h’; 会发生什么，为什么？ 答：会将a数组的第一个元素值变成h 编译器相关知识 inline的作用？对inline的处理发生在编译过程中的什么阶段？有什么限制条件吗？ 答：inline是指内联，带有inline的函数会优先使用寄存器而不是将所有的局部变量存放在程序栈中。由于inline涉及到生成的汇编代码对寄存器的使用和对栈的操作，应该是发生在生成汇编代码的阶段。对于限制条件不是很清楚。 这个题是我理解有问题，考官想听到的回答是，inline和define都用于嵌入代码，只不过inline函数的嵌入发生在编译阶段，而define在预处理阶段。inline的限制条件就比较复杂了……我没有了解所以这一题没答好。 描述一下编译的基本过程吧。 答：把编译器的那几个模块依次列了上去。 如果我要查看gcc预处理生成的代码，要怎么做？ 答：这个不太清楚。 算法部分说是算法……感觉这一部分面试官出的题都是离散数学题…… 两个城市A和B，A城市有80W人，B城市有20W人。任何两个人之间电话对打的概率相同。1天之内，共产生了1000W个电话。那么跨城市对打的电话有多少个？ 答：用排列组合来做就是C(1,800000)*C(1,200000)/C(2,1000000)*10000000。 考官说我想复杂了，这样算太麻烦。然后就下一题了。 6个人一起跑步，结果有多少种结果？A比B的成绩好，同时B比C的成绩好，有多少种结果？ 答： 1) 第一问就是全排列，720种。2) 第二问我用分类的方式列了一堆，最后算出来是120种： 1234561. DEF都在ABC左边，ABC排列的顺序是一定的，这样有P(3,3) = 6种2. DEF都在右边，同理有6种3. DEF在AB之间或在BC之间，有2*6=12种4. DEF中有两个人挨着，另一个被隔开，有P(4,2)*P(3,2) = 72种5. DEF三个人都被隔开，有P(4,3) = 24种综上所述，共有6*4+72+24 = 120种 结果考官表示，有更简单的方法，比如，如果只考虑A比B领先，有多少种？ 我才发现是我想复杂了，因为ABC三个人的先后次序一共才6种情况，而题中的情况是一种，所以只需要720/6=120即可。 上台阶，每次可以一个，也可以每次两个。那么n个台阶，有多少种可能上去呢？ 这一题要写代码，不过这个算法很简单。写了个带动规的递归函数： 123456789101112131415161718192021int stepnum[1024];int steps(int n) &#123; if (n == 1) return 1; if (n == 2) return 2; return steps(n-1) + steps(n-2);&#125; // 没有优化过的函数int stepsNew(int n) &#123; if (n == 1) &#123; stepnum[n] = 1; return 1; &#125; if (n == 2) &#123; stepnum[n] = 2; return 2; &#125; int steps1 = stepnum[n-1] ? stepnum[n-1] : steps(n-1); int steps2 = stepnum[n-2] ? stepnum[n-2] : steps(n-2); return steps1 + steps2;&#125; // 动态规划的函数 你还有什么想问我的吗？ 问了一下这个岗位具体一点的工作内容，以及为了符合工作要求应该学习的方向之类的。 面试官的回答：我是在做linux系统内核和KVM相关的。你按照自己的节奏好好学习就可以啦。答的还不错。 三面二面之后接着有人打电话来约了三面。奇怪的是面试官并没有问多少技术问题，反而面试搞得像hr面： 你们学校对实习的态度如何？允不允许？鼓励你们去报什么样的公司？ 你最喜欢计算机的哪个方向呢？ 据我所知你们大学大二还没有相关课程，你的这些能力是如何积累的呢？ 你平时会用什么样的操作系统呢？ 有关Linux的知识 在Linux下，你主要是用命令行多一些还是图形界面多一些呢？ 答：除了浏览网页等必须要图形界面的时候，都是命令行。 Linux下查看所有进程可以用什么命令？ 答：ps或者top 我怎么才能知道某个进程跑在哪个CPU上呢？ 答：man ps或者man top来查一下 有关并发编程 fork函数的返回值有什么意义呢？ 答：返回0说明是在子进程，返回正整数则代表在父进程，且这个数是子进程的pid。 在Go里面，把一些函数用go命令去跑的话，与直接调用有什么不一样的吗？ 答：讲了一下goroutine的概念和具体实现方式。 讲一下你对并发和并行的理解。 答：老生常谈了，这里不再赘述。 你现在自己在用虚拟机吗？用过哪些？ 答：之前大一用过VMWARE，最近用了点qemu。 像是hr该问的一些问题 能实习多久？能大概给个范围吗？ 你为什么要来头条实习呢？ 在就业方面有什么考虑吗？对公司或者工作地点有什么偏向吗？ 你有哪些问题想问我的？ 你对参与实习之后要做的工作有什么期待吗？ 这方面我主要是问了一下为了适应岗位我需要进一步学习的东西，以及说了一下我比较想去做虚拟化和内核向的一些工作。这之间面试官跟我讲了很多东西，大概如下： 感觉你现在已经做的挺好了吧，我觉得没必要再给你做什么加法了，从理论上来讲你尽量去把学校的要求掌握的专业课学好就好了，像是数据结构啊，组成原理啊，高数啊概率啊，编译原理啊。在工程上呢去多做一些实践也是很必要的，比如你去使用ArchLinux这种比较典型的现代Linux系统，还有像编程方面，可以去了解一些与传统C控制逻辑不同的并发和并行，尤其是并行这种的领域，等等。理论联系实践地去做吧，毕竟你现在才大二嘛，对吧，已经很不错了。总之就是把知识学好，并多寻找一些实践的机会就挺不错的。 你工作的话到时候可能是在北京的，你这边应该可以过来是吧。其实我们这边在武汉现在好像也有办公室，不过我不是很清楚哈，这些都是后话。 我想跟你说的是，一般来说系统研究这方面是一个非常漫长的过程哈，基本上就像金庸小说一样，可能是说三年略有小成，几十年之后才可能有些成就，这个东西它还是需要很深的积累的。其实呢你几个月的实习时间，虽然你是希望去做一些内核相关的事情，但是从现实角度来看，你可能在这段时间之内只是能够通过一些实践去理解它基本的概念吧。 比如说你要做虚拟化和内核，肯定是要需要很长的准备时间吧。我们这边就算我招一个有经验的工程师进来，也得要三个月到半年的准备才能开始去做一些简单的内核外围的东西的，深层次的可能半年都不止。所以你最好有个心理准备，做系统这方面可不是像解个算法题或者写个软件一样简单，这个要做大量的环境的准备，然后你才能大概知道具体问题在什么地方，找到之后还得然后进一步去了解每个问题的影响范围，再对每个影响范围去进行处理，这是一个非常非常复杂的过程。我建议你就是不要期待能写多少代码，而是在这个上面开始建立一个基本的概念性的东西。我认为你在两个到四个月之间能有个大概的认识，就是一个很不错的结果了哈。还是要有沉的住气的心态的，你了解我说的意思吧。]]></content>
      <categories>
        <category>Experience</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在ArchLinux下安装和配置LaTex编译环境]]></title>
    <url>%2Fblog%2F2019%2F03%2F10%2F%E5%9C%A8ArchLinux%E4%B8%8B%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AELaTex%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[在ArchLinux下安装和配置LaTex编译环境之前写文档的时候一直用的是Markdown内置Latex，但这样不如直接编译.tex文件来的灵活，而在安装texlive的时候又遇到了很多坑，因此在这里总结一下安装与配置过程。 安装xeLatex用pacman可以安装texlive的许多组件，它们的统一格式是texlive-后跟一个具体的扩展。要安装基本组件只需要其中的bin，core和lang扩展，有特殊需求可以按照文档去安装其他的扩展。 这里我是如下安装： sudo pacman -S texlive-{core,bin,langchinese,latexextra,fontsextra} 扩展包的配置配置fontawesomeFontawesome组件本身是在fontsextra扩展中的，但是由于扩展名问题无法被正常识别，需要在使用了这个组件的tex文件开头加上一句\defaultfontfeatures{Extension = .otf}。 中文字体的问题如果系统中没有安装poppler-data包，编译出的pdf文件将会无法显示中文。这个包可以直接使用pacman来安装。]]></content>
      <categories>
        <category>Academic or Technical</category>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MIT 6.828 Labs 实验记录]]></title>
    <url>%2Fblog%2F2019%2F02%2F24%2FMIT_6.828%2F</url>
    <content type="text"><![CDATA[MIT 6.828 Labs 实验记录本博客中所有代码所对应的github repo地址：6.828 Overall有一些测试技巧是适用于所有Lab的，放在这里以供参考： 6.828自带了一个打分系统，在Lab文件夹下执行make grade即可运行这个系统来检验自己的解答。 make grade执行过程中JOS console的输出会保存在当前文件夹下的jos.out.xxx文件中。 make run-&lt;prog&gt;可以在JOS上运行一个用户程序，其中&lt;prog&gt;是用户程序的无后缀文件名。 有些时候我们会需要自定义一些系统调用或库函数来让用户能够运用一些内核权限进行测试。自定义系统调用需要做以下几步： 修改inc\syscall.h，在其中的系统调用号枚举类型中添加新的系统调用号定义 修改kern\syscall.c，添加自己定义的功能性系统调用函数，并在syscall函数中添加对新调用号的判断逻辑 修改lib\syscall.c，添加能被用户调用的系统调用函数，在这些函数中调用syscall函数来陷入内核 修改inc\lib.h，在其中添加新的函数声明，以使新添加的函数能被编译器识别 Build up the environmentCompiler Toolchain由于Archlinux中的objdump和gcc均满足Lab的要求，不需要手动搭建编译环境。 QEMU emulator建议follow一下MIT官网上最新版的6.828课程页面。老的课程页面上的链接可能不可用。此处根据Fall 2018的课程页面进行配置。 由于QEMU的调试系统不完善，课程组准备了改进过的QEMU，使它可以与系统中的GDB调试器绑定，并使用GDB来调试。执行以下步骤安装打好补丁的QEMU: 执行git clone https://github.com/mit-pdos/6.828-qemu.git qemu拉取源代码 安装各种依赖。在Archlinux下的安装方式如下： libdtc：yay DTC，任选一项安装。 python：坑爹的是都8102年了这门课还不支持python3.不过Arch一般自带python2,问题不大 进入源代码文件夹，Configure the source code 执行./configure --disable-kvm --disable-werror --python= &lt;pathToPython2&gt; 执行make &amp;&amp; make install进行安装 安装到一半，报错： 1234567891011qga/commands-posix.c: 在函数‘dev_major_minor’中:qga/commands-posix.c:634:21: 警告：implicit declaration of function ‘major’; did you mean ‘_m_por’? [-Wimplicit-function-declaration] *devmajor = major(st.st_rdev); ^~~~~ _m_porqga/commands-posix.c:634:21: 警告：对‘major’的嵌套的外部声明 [-Wnested-externs]qga/commands-posix.c:635:21: 警告：implicit declaration of function ‘minor’; did you mean ‘mknod’? [-Wimplicit-function-declaration] *devminor = minor(st.st_rdev); ^~~~~ mknodqga/commands-posix.c:635:21: 警告：对‘minor’的嵌套的外部声明 [-Wnested-externs] 很显然是有两个函数major和minor在使用之前并未声明。这是两个库函数，在linux下的&lt;sys/sysmacros.h&gt;头文件中有定义，然而MIT给的代码里并没有包含这个头文件。根据报错信息打开qga/commands-posix.c，添加#include &lt;sys/sysmacros.h&gt;，保存。 再次安装，装到一半又报错： 12345678/usr/bin/ld: ../hw/9pfs/virtio-9p.o: in function `stat_to_v9stat':/home/drac_zhang/Downloads/qemu/hw/9pfs/virtio-9p.c:796: undefined reference to `minor'/usr/bin/ld: /home/drac_zhang/Downloads/qemu/hw/9pfs/virtio-9p.c:796: undefined reference to `major'/usr/bin/ld: ../hw/9pfs/virtio-9p.o: in function `v9fs_mknod':/home/drac_zhang/Downloads/qemu/hw/9pfs/virtio-9p.c:2803: undefined reference to `makedev'/usr/bin/ld: ../hw/9pfs/virtio-9p.o: in function `v9fs_create':/home/drac_zhang/Downloads/qemu/hw/9pfs/virtio-9p.c:2124: undefined reference to `makedev'collect2: 错误：ld 返回 1 差不多的理由，还是缺少库函数。也不管重复包含dirty不dirty了，向hw/9pfs/virtio-9p.c中添加#include &lt;sys/sysmacros.h&gt;，保存后再次编译。 因为类似的理由，还需要添加这个头文件的源文件有linux-user/strace.c。 Other problems这里是其他各种各样可能会出现的玄学错误。 Dependencies upgraded在我完成这个lab的过程中，libnfs库在我滚arch的时候升级了，结果一运行make就会报错： 1error while loading shared libraries: libnfs.so.12: cannot open shared object file: No such file or directory 执行whereis libnfs.so.12，发现系统的库中只有libnfs.so.13，原来是这个库在升级的时候名字变掉了…… 没办法，只好用downgrade命令手动降级到4.0.0-2版本，再执行make的时候就没事了。 Lab 1 Booting a PCLab1的源码可以从https://pdos.csail.mit.edu/6.828/2018/jos.git处clone到。 Part 1 PC bootstrap这一部分的目的是让我们熟悉x86汇编语言和PC bootstrap过程，并熟悉QEMU和gdb的操作。 首先在lab目录下执行make命令来编译内核和启动器。编译完成的内核与启动器位于obj/kern/kernel.img镜像文件中，这个镜像文件是一个用于模拟真实硬盘的虚拟磁盘。 执行make qemu可以正式在qemu中运行编译好的操作系统，此时命令行终端会创建一个新的窗口，同时在终端中显示与窗口中同样的内容(并接受同样的输入)。方便起见，这里我们用终端进行接下来的操作。 一开始这个shell只有两条简单的指令：help和kerninfo。后者会打印出目前的内核状态： 1234567Special kernel symbols: _start 0010000c (phys) entry f010000c (virt) 0010000c (phys) etext f01019df (virt) 001019df (phys) edata f0113060 (virt) 00113060 (phys) end f01136a0 (virt) 001136a0 (phys)Kernel executable memory footprint: 78KB 要退出qemu可以打出Ctrl+a x。 Layout of the physical address space +——————————+ &lt;- 0xFFFFFFFF(4GB) \ 内存映射的虚拟地址 \ +——————————+ &lt;- 取决于RAM的数量 \ 扩展内存 \ +——————————+ &lt;- 0x00100000 (1MB) \ BIOS所在的ROM \ +——————————+ &lt;- 0x000F0000 (960KB) \ 16位机使用的扩展ROM\ +——————————+ &lt;- 0x000C0000 (768KB) \ VGA Display \ +——————————+ &lt;- 0x000A0000 (640KB) \ Low Memory \ +——————————+ &lt;- 0x00000000 一开始的16位机只能使用最下面那一共1MB的物理存储，而可用的内存只有标识为Low Memory的640KB。标注有VGA Display的部分是硬件保留区，用于当作VGA显示屏的缓冲区。 就算是在Intel突破了“1MB的瓶颈”之后，PC设计师也仍然对于最低的1MB地址空间使用原始的架构，这是为了软件的向后兼容性。这样就在LowMemory和扩展内存之间留下了一个空洞(IO hole)。在操作系统的内存分配中，这个空洞所对应的地址段不应被虚拟地址系统所使用。 在计算机从32位升级为64位时，BIOS在地址空间的最顶段因为类似的理由留下了第二个空洞，不过由于本实验在32位系统下进行，这个空洞不予考虑。 The ROM BIOS为了单步调试计算机的启动过程，我们需要两个终端，一个用make qemu-gdb来启动qemu虚拟机，一个用make gdb来将gdb调试环境连接到虚拟机上。 make qemu-gdb会将处理器暂停在即将执行第一条指令之前并等待gdb的连接，这时在另一个终端中使用make gdb就可以通过gdb来调试操作系统内核。 gdb终端会显示一段结尾如下的信息： 12345The target architecture is assumed to be i8086[f000:fff0] 0xffff0: ljmp $0xf000,$0xe05b0x0000fff0 in ?? ()+ symbol-file obj/kern/kernel(gdb) 其中的第二行代表着目前将要执行的指令，也就是虚拟机开启过程的第一条指令。 这条指令的含义是： 0xffff0:：指令位于的虚拟存储系统地址，对应于上面的架构，这个位置是属于BIOS的ROM区域的最上面，也就是BIOS程序的起始位置。 [f000:fff0]：指示当前CS和IP寄存器的值。CS寄存器指示代码所在的数据段，IP则是偏移量。 ljmp：跳转指令，跳转到CS和IP为[f000:e05b]的位置，转换成存储地址就是0xfe05b。 CS和IP寄存器与物理地址的转换规则为ADDR = CS&lt;&lt;4 + IP。 保证启动时优先执行BIOS代码是很重要的，因为一开始内存中根本不会有其他可以执行的代码。BIOS会初始化所有启动所需要的重要设备，检查内存和磁盘的挂载情况。最后，就像操作系统课程中所学的那样，它找到磁盘上的boot loader并将控制权转移给它。 对GDB使用si命令可以继续单步调试之后的汇编代码，观察BIOS所做的工作。 Part 2 The boot loader众所周知，软盘和硬盘都被分成大小为512字节的段，而这些段是系统级IO的最小单位。如果一个磁盘是启动盘，那么它的第一个段就被称为 boot sector ，并被存放boot loader的代码。当BIOS找到一个boot sector后，它就会将其加载到内存中，并将控制权转交给boot loader代码段。 (对于CD-ROM来说，它的前2M都属于boot sector，因此可以存放更大的启动镜像) 在6.828文件夹中，boot loader的代码存放于boot/boot.S与boot/main.c中。这些代码主要完成两件事： 将处理器模式切换到32位保护模式，这样软件才可以访问大于1MB的物理地址空间。这个工作由boot.S完成。除此之外，boot.S还要建立一个程序栈，让C程序得以运行。 将内核代码从硬盘中加载到内存，并将控制转交给内核代码的入口函数。这个工作由main.c完成。 阅读main.c的代码可以发现很多 非常dirty的 细节(包括但不限于：使用goto，while(1)代替sleep，写的很乱的函数指针)，如果对于这个过程的细节感兴趣可以直接阅读源码，注释写的很详细明白。 bootloader的代码会被BIOS加载到0x7c00，这是由boot/Makefrag文件所决定的。修改这个文件中-Ttext参数后面的地址可以让BIOS从其他地址来加载，执行make clean &amp;&amp; make重新编译可以查看这样做会引发什么样的系统错误(事实上系统会停机并进入一个无限循环等待用户的操作)；在GDB调试时可以在这个位置设置断点，以精确地进入bootloader代码段。 obj/boot/boot.asm和obj/kern/kernel.asm分别包含着bootloader和kernel的反汇编结果以及注释，可以用于调试和分析。下面就来分析一下BootLoader的代码逻辑。 BootLoader代码逻辑研究 第一阶段：初始化 宏常量的设定：.set CR0_PE_ON 0x1 这个常量是控制32位保护模式开关的指标。 全局设置：cli指令关闭中断处理，cld指令将串操作的内存地址访问模式设为增序 这两个指令其实是设置了DF和IF两个标志位的值 寄存器初始化：用xor和mov指令将几个关键寄存器清零 ds：数据段寄存器，存放全局变量区域的头指针 ss：栈段寄存器，存放堆栈段的首地址(esp寄存器存储的是偏移量) es：扩展段寄存器 第二阶段：打开32位保护模式 开启A20地址线：在16位模式下，用于寻址的地址总线只有20根，这种情况下大于1MB的地址空间是全部被置为0的。只有开启20～23号四条地址线，才能对1MB以上的地址空间进行寻址，从而进入32位模式。 通过一个循环来等待A20设备准备完毕：用in指令从0x64端口接受信息，如果不是代表准备完毕的信息则继续循环。 向0x64和0x60端口发送信号，打开A20地址线。 建立32位段虚拟内存与物理存储器的映射关系表：lgdt gdtdesc指令。 启动32位保护模式：用CR0_PE_ON与cr0寄存器的值做或运算，打开32位保护模式。cr0到cr3四个寄存器是系统控制寄存器，它们的值直接决定系统的运行状态。cr0控制的是处理器，因此可以通过修改其值来进入其他运行模式。 跳转到32位代码区的下一条指令。 第三阶段：修改段寄存器的值为32位区地址，初始化esp寄存器的值，建立C程序栈 第四阶段：进入main.c的bootmain函数，开始读取内核代码。 第五阶段：跳转到内核代码区，交还控制权。 习题解答Q: 处理器什么时候开始执行32位代码？哪条指令切换了处理器模式？ A：0x7c2a: mov %eax,%cr0指令切换了处理器模式，从随后的跳转指令开始，处理器开始执行32位代码。 Q：Bootloader执行的最后一条指令是什么？kernel执行的第一条指令又是什么? A：Bootloader执行的最后一条指令是向内核代码段跳转的指令0x7d71: call *0x10018，kernel执行的第一条指令是0x10000c: movw $0x1234,0x472。 Q：Bootloader是如何决定它要读取多少数据的？它从哪里获取的kernel大小信息？ A：Bootloader首先从内核代码区读取了长度固定的ELF头部，再从头部中获取了这个区域是否为ELF文件、数据段数量、每段的长度、起始地址等信息。 (课程网页在这一部分讲了一大堆ELF头和指针的知识，如果已经学过CSAPP第7章的话完全可以跳过。需要注意的是，6.828所采用的可执行目标文件代码 并非是位置无关代码 ，因而 链接器会将程序将加载到的内存位置写在文件中 。利用这一点，我们可以执行objdump -f &lt;filename&gt;命令，获取程序在内存中的入口位置。) Part 3 The kernel在内核被授予控制权后，它要做如下几件事： Virtual memory address mapping当我们观察bootloader程序的时候，我们可以发现它的 链接地址(指用objdump -h打印出来的ELF节头部信息中的LMA，linked memory address) 和 虚拟地址(指用objdump -h打印出来的ELF节头部信息中的VMA，virtual memory address) 是完全一致的；然而对于kernel，这两个地址却有着不小的差距。 操作系统内核常常会在非常高的虚拟地址空间(例如0xf0100000)运行，这是为了把比较低的虚拟地址空间留给用户进程使用。然而大部分机器没有这么多的内存，于是它们将虚拟地址0xf0100000映射到物理地址0x00100000。这样一来虽然内核所在的加载地址很高，它的实际加载地址却是位于RAM区域的最底端，挨着BIOS所在的ROM地址区域。 虚拟地址映射操作是由专门的硬件来完成的，要打开虚拟地址映射只需要对cr0寄存器设置CR0_PG标志，就像之前打开32位保护模式所做的那样。除此之外，为了能让虚拟地址映射正常工作，我们需要将页表的首地址装入cr3寄存器。 kernel被加载的地址为0x100000,因此它从此处开始运行。它所做的第一项工作就是打开虚拟地址映射，然后跳转到虚拟地址0xf010002f的位置，恰好对应于物理地址中下一条指令所在的位置。这样，内核就自然地实现了从物理地址到虚拟地址的转换。 Formatted printing to the console在完成虚拟地址映射之后，下一步是对终端进行格式化输入输出以创建交互式操作界面。 lib/printfmt.c中提供了输出函数的原型，kern/printf.c和kern/console.c则提供了有关内核输出和交互的函数。 Answer to Exercise 8 本题要求补全printfmt函数对于%o(8进制输出)的处理机制，只需要仿照下面十六进制的机制即可。 1234case 'o': num = getuint(&amp;ap, lflag); base = 8; goto number; 习题解答 Q：解释printf.c和console.c之间的接口，尤其是console.c中的哪个函数被如何用于printf.c。 A：console.c向printf.c提供了cputchar函数,它希望在调用printf.c中的输出函数时可以利用cputchar函数来输出每一个字符。printf.c遵守这个约定,以包含cputchar的外壳函数调用printfmt.c中的输出函数,保证了所有输出都按照console.c所规定的标准来输出。 Q：解释console.c中的这一段代码: 1234567if (crt_pos &gt;= CRT_SIZE) &#123; int i; memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t)); for (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++) crt_buf[i] = 0x0700 | ' '; crt_pos -= CRT_COLS;&#125; A： 这段代码来自cga_putc函数,这个函数是在CGA显示屏图形卡上打印字符的函数。crt_pos是一个整形全局变量,它的含义是目前光标在屏幕上的位置。阅读console.h的内容可以发现CRT_SIZE被定义为屏幕上能够容纳的字符个数,而CRT_COLS则是屏幕的宽度。 条件判断是为了确认当前光标的位置是否已经超出了屏幕底端。如果超出了，就把屏幕上第二行到最后一行的内容全部上移一行，并将空出来的位置用0x0700 | &#39; &#39;填满。 总而言之，这段代码是为了实现屏幕满了之后向上滚动的功能。 Q：单步调试如下代码： 12int x = 1, y = 3, z = 4;cprintf("x %d, y %x, z %d\n", x, y, z); 在对cprintf的调用中，fmt对应的实参是什么？ap呢？ 列出对cons_putc, va_arg和vcprintf的每一次调用，以及cons_putc的参数,va_arg中ap的指向和vcprintf的参数值。 A： fmt对应的实参是&quot;x %d, y %x, z %d\n&quot;，ap指向带有x，y和z的参数数组。 甚至不需要单步调试，自己阅读lib/printfmt.c就足够了。 Q：运行如下代码： 12unsigned int i = 0x00646c72;cprintf("H%x Wo%s", 57616, &amp;i); 解释输出结果。如果这段代码运行在大端序机器上而非小端序机器上，你会如何修改它来得到同样的结果？ A：输出结果是He110 World。前面的e110是57616在十六进制下的表示(因为使用了%x)，后面的rld是字符串输出的结果。int占4个字节而每个字符占一个字节，因而i所占的内存空间与一个长度为4的字符数组是相同的。这样一来，如果用i的地址去输出字符串，就会从i的地址开始按字符去读取内存中的数据，直到读到0为止。由于运行在小端序机器，0x72排在最前面一个字节，被解析成ASCII码值为0x72的r；接下来0x6c和0x64分别被解释为l和d。最后一个字节是0x00,正好是字符串终结符。 如果机器是大端序，只需要将i修改为0x726c6400即可，57616不需要改变。 Q：被cprintf(&quot;x=%d y=%d&quot;, 3);打印出的y值会是多少？为什么？ A：会是一个随机的整形数。因为cprintf解析到了两个%d符号，但ap的长度只有1,这导致第二个%d读到了一片未赋值的内存地址，其值自然是随机的。 The Stack(仔细读过CSAPP第三章的话汇编语言和程序栈这一块应该没问题了，就不说了) Answer to Exercise 9 Q：确定内核在什么时候初始化程序栈及程序栈的初始位置。内核是如何为栈保存空间的？ A：f010034: mov $0xf0110000, %esp：这一条指令初始化了栈指针，将程序栈建立于虚拟地址0xf0110000位置。从这个地址开始，程序栈随着程序运行向下增长。 ebp指针被称为“基指针”，它的作用是追踪每个函数的栈帧位置。每个被调用的C函数都要进行如下操作：将ebp寄存器的值压栈、将当前esp指针值拷贝到ebp寄存器。在返回之前，这个函数从栈中取出并恢复ebp寄存器的值。通过这种机制，任何时候ebp寄存器的值都指向正在执行的函数的栈帧头部，而栈帧头部的前一个数据节的值指向该函数调用者的栈帧头部，于是可以通过ebp链来还原函数调用链。 Answer to Exercise 10 这个Exercise的目的是让学生熟悉backtrace的操作和C的程序栈结构。在kernel中有一个自我递归的test_backtrace函数,通过对这个函数打上断点可以使用p $ebp获取每次调用的栈帧起始位置. 第一次调用:栈帧的起始位置为0xf010ffd8第二次调用:栈帧的起始位置为0xf010ffb8 可以看出这个函数的每个栈帧大小都是0x20,也就是32个字节，对于32位系统来说是八个数据。 使用x/xw命令查看从0xf010ffe0开始整个栈帧的结构。(因为32位系统每个数据是四个字节，所以使用x/xw来查看) x/xw 0xf010ffe0：0x00000005 按照栈帧的结构，这个位置应该是调用者压入栈内的参数。第一次对test_backtrace的调用的确只有一个实参5。 x/xw 0xf010ffdc：0xf01000f4 由于栈帧是向下的，这条指令其实查看的是上一个栈帧的最后一部分，也就是函数的返回地址，经验证的确指向调用者的下一条指令。 x/xw 0xf010ffd8：0xf010fff8 当前函数栈帧的第一部分，保存着上一个函数的基指针值(%ebp的值)，由于上一个函数已经是整个程序栈底部的函数了，这个地址向上就没有数据了，上个函数的基指针指向的是物理内存区的函数。 x/xw 0xf010ffd4：0x000100b4 被调用者保存的%esi寄存器的值 x/xw 0xf010ffd0：0xf011304c 被调用者保存的%ebx寄存器的值 x/xw 0xf010ffcc：0xf010004a 是test_backtrace中一行代码的地址 x/xw 0xf010ffc8：0x00000000 空的，没有数据 x/xw 0xf010ffc4：0x00000005 局部变量5 x/xw 0xf010ffc0：0x00000004 即将进行下一次递归调用，这是压入的参数4 再往下就是返回地址，然后就是下一个栈帧。总的来说，test_backtrace函数的栈帧结构就是这样。 完成了对栈帧结构的观察后，就可以利用观察结果去做一下任务了。Exercise 11要求我们实现一个mon_backtrace函数，它记录并打印出栈帧信息。inc/x86.h中提供了read_ebp()函数可以直接返回ebp寄存器的值。 输出格式规定如下： 123Stack backtrace: ebp f0109e58 eip f0100a62 args 00000001 f0109e80 f0109e98 f0100ed2 00000031 ebp f0109ed8 eip f01000d6 args 00000000 00000000 f0100058 f0109f28 00000061 Answer to Exercise 11 本题要求是按上面的要求修改kern/monitor.c中的mon_backtrace函数，并将其添加到指令集中。 对代码的修改如下： 12345678910111213141516171819202122232425262728293031// 第一处修改static struct Command commands[] = &#123; &#123; "help", "Display this list of commands", mon_help &#125;, &#123; "kerninfo", "Display information about the kernel", mon_kerninfo &#125;, &#123; "backtrace", "Display the structure of the stack", mon_backtrace &#125;,&#125;;// 第二处修改intmon_backtrace(int argc, char **argv, struct Trapframe *tf)&#123; // Your code here. cprintf("Stack backtrace:\n"); int ebp = read_ebp(); int eip = *(int *)(ebp + 4); int args[5]; for (int i=0;i&lt;5;i++) &#123; args[i] = *(int *)(ebp + 4*i + 8); &#125; cprintf(" ebp %08x eip %08x args %08x %08x %08x %08x %08x\n",ebp,eip,args[0],args[1],args[2],args[3],args[4]); while (1) &#123; ebp = *(int *)ebp; if (!ebp) break; int eip = *(int *)(ebp+4); int args[5]; for (int i=0;i&lt;5;i++) &#123; args[i] = *(int *)(ebp + 4*i + 8); &#125; cprintf(" ebp %08x eip %08x args %08x %08x %08x %08x %08x\n",ebp,eip,args[0],args[1],args[2],args[3],args[4]); &#125; return 0;&#125; Exercise 12要求我们升级这个函数，使其支持如下的输出格式： 1234567Stack backtrace: ebp f010ff78 eip f01008ae args 00000001 f010ff8c 00000000 f0110580 00000000 kern/monitor.c:143: monitor+106 ebp f010ffd8 eip f0100193 args 00000000 00001aac 00000660 00000000 00000000 kern/init.c:49: i386_init+59 ebp f010fff8 eip f010003d args 00000000 00000000 0000ffff 10cf9a00 0000ffff kern/entry.S:70: &lt;unknown&gt;+0 为了根据eip找到函数名，行数和文件名等一系列信息，kern/kdebug.c中提供了debuginfo_eip()函数，我们需要完整地实现debuginfo_eip()函数，并在mon_backtrace中调用这个函数来获得信息。 Answer to Exercise 12 在debuginfo_eip函数中有一些以__STAB_开头的宏常量,它们所代表的是ELF文件中.stab(在CSAPP中是.symtab)区的开头和结尾位置,以及.stabstr(在CSAPP中是.strtab)区的开头和结尾位置,它们是在链接过程中由kernel.ld定义的。 以下是修改内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// kern/monitor.cintmon_backtrace(int argc, char **argv, struct Trapframe *tf)&#123; // Your code here. struct Eipdebuginfo info; cprintf("Stack backtrace:\n"); // Parse the structure of the stack int ebp = read_ebp(); int eip = *(int *)(ebp + 4); int args[5]; for (int i=0;i&lt;5;i++) &#123; args[i] = *(int *)(ebp + 4*i + 8); &#125; // Print some information in restricted format. cprintf(" ebp %08x eip %08x args %08x %08x %08x %08x %08x\n",ebp,eip,args[0],args[1],args[2],args[3],args[4]); // Exercise 12, get the debuginfo by eip debuginfo_eip(eip, &amp;info); cprintf(" %s:%d: ",info.eip_file, info.eip_line); // info.eip_fn_name is a non-null-terminated string for (int i=0;i&lt;info.eip_fn_namelen;i++) cprintf("%c",*(info.eip_fn_name+i)); cprintf("+%d\n",eip - info.eip_fn_addr); // Backtracing while (1) &#123; ebp = *(int *)ebp; if (!ebp) break; int eip = *(int *)(ebp+4); int args[5]; for (int i=0;i&lt;5;i++) &#123; args[i] = *(int *)(ebp + 4*i + 8); &#125; cprintf(" ebp %08x eip %08x args %08x %08x %08x %08x %08x\n",ebp,eip,args[0],args[1],args[2],args[3],args[4]); debuginfo_eip(eip, &amp;info); cprintf(" %s:%d: ",info.eip_file, info.eip_line); for (int i=0;i&lt;info.eip_fn_namelen;i++) cprintf("%c",*(info.eip_fn_name+i)); cprintf("+%d\n",eip - info.eip_fn_addr); &#125; return 0;&#125;// kern/kdebug.cintdebuginfo_eip(uintptr_t addr, struct Eipdebuginfo *info)&#123; ... // Your code here. stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr); if (lline &lt;= rline) info-&gt;eip_line = stabs[lline].n_desc; else return -1; ...&#125; 至此Lab1结束。运行make grade，50/50大成功。 Lab 2 Memory Management在这个Lab中，我们需要实现操作系统的内存管理系统。内存管理系统包括两个部分： 物理内存调度：我们要实现一个以4096个字节大小的页为单位的内存分配器，它将空闲的内存分配给内核和用户，并释放使用完的内存。 虚拟内存映射 执行git checkout -b lab2 origin/lab2命令切换到lab2分支，执行git merge lab1合并在lab1所做的更改。 Lab2增加的文件有： inc/memlayout.h：定义描述虚拟内存空间的布局的函数，定义PageInfo结构体 kern/pmap.c和kern/pmap.h：实现inc/memlayout.h中定义的函数 kern/kclock.c和kern/kclock.h：与CMOS硬件沟通，读取PC的硬件信息 inc/mmu.h中记录了应当烧录于MMU单元中的逻辑代码，同样可能对这个lab有所帮助。 Background knowledge 由于虚拟内存是将很小的物理内存映射到很大的虚拟内存空间，这个映射关系需要一个输入地址和一个输出地址才能作用。物理地址是物理内存中真实的地址，可以直接由硬件寻址得到；虚拟地址/线性地址是物理地址通过转换得到的，用于虚拟内存空间索引的地址。 mmu.h中详细地介绍了线性地址的结构。大体上讲，线性地址分为三段： Page directory index：页目录的序号(10位) Page table index：页表的序号(10位) Page offset：地址在页内的偏移(12位) 从线性地址的三段式结构可以看出，每个页表包括1024(2的10次方)个页，每个页目录包括1024个页表，而每一页的大小是4096个字节(也就是4KB)。 3段加起来的总长度是32 bits，也就是4个字节，这代表着线性地址可以用一个int32变量表示。 我们可以使用宏命令来取出线性地址的各个段，或将线性地址映射为物理地址。在本lab中，虚拟地址似乎是特指物理地址+固定偏置值所映射到的地址。 在memlayout.h中可以查看到整个虚拟内存地址空间的分配，在此列出并加以解释： 0xf0000000以上：Remapped physical memory，物理内存的原样映射，这一部分为虚拟地址 0xefc00000以上：内核栈区域，存放各个CPU的内核栈。 0xef800000：内核内存区和用户内存区的分界线，这以上用户不可读写 0xef400000以上：页表区域 0xef000000以上：页区域 0xeec00000以上：当前进程的环境变量区域 0xeec00000：用户只读区和读写区的分界线，这以上用户只有读权限 1 PGSIZE：用户的异常栈 1 PGSIZE：用户栈，可以增长 一段留空内存 0x00800000以上：用户的堆区域和程序数据 以下：用户的符号表区域和空内存 Definitions guide6.828的代码充满了缩写这种使人不明所以的命名,且有些地方码风诡异,因而将一些可能用到的概念和缩写列举如下: V和P:带V的标识符指virtual,与内核虚拟内存有关；而带P的标识符往往指physical,与物理存储有关。如： kva:kernel virtual address的简写 pa:physical address的简写 la:linear address的简写 PT和PD：分别指page table和page directory。 U和K:带U的标识符指User，而带K的标识符指Kernel。如： UVPT：User virtual page table的缩写，是用户页表的开始地址。 UTOP：用户地址空间的上限 为了实现目标功能的代码，我们需要调用许多定义好的函数或者宏，为了方便查看和使用将一些可能需要使用的函数和宏列举如下： pmap.h: PADDR(addr):将虚拟地址addr转换为物理地址返回 KADDR(addr):将物理地址addr转换为虚拟地址返回 PTE_ADDR(addr):将物理地址addr中的权限位去掉 page2pa(PageInfo*):将PageInfo结构体转换为对应Page的物理地址 pa2page(addr):将物理地址转换为pages数组中的PageInfo page2kva(PageInfo*):将PageInfo结构体转换为对应Page的虚拟地址 mmu.h: PDX(la):将线性地址转换为页目录(page directory)的索引 PTX(la):将线性地址转换为页表的索引 Part 1 Physical page management在这个部分我们需要实现物理内存管理器。这个函数追踪一个由PageInfo结构体组成的链表(这个链表的节点代表着一页未分配的内存)，并负责物理内存的分配和回收。 要想完成这部分的任务，必须要提前了解虚拟内存系统的概念(可以参考操作系统专业教材或者计算机系统教材)，才能看懂并运用各种神奇的操作。 boot_alloc 这个函数是在建立虚拟内存系统过程中用来为数据结构分配内存空间的，在虚拟内存系统建立之后就会废弃。因而，其功能比较简单。 值得注意的是，这个函数首次调用的时候，会从内核区bss段的结束处开始分配内存块，具体的位置是通过extern从链接器那里得知的。首次调用情况下的代码已经被完成了，我们只需要照葫芦画瓢地完成之后调用时的代码即可。 这里所谓“内核区bss段的结束处”是指内核区中没有分配代码段和数据段的第一个位置，它在虚拟地址空间中的位置在0xf0000000以上的部分，也就是物理内存的映射区。从这里开始，我们开始建立用于管理虚拟内存的内核数据结构。 panic函数可以被当作printf的一个能够引发中断的版本。灵活利用它可以方便地调试系统。 12345678910// Allocate a chunk large enough to hold 'n' bytes, then update // nextfree. Make sure nextfree is kept aligned // to a multiple of PGSIZE. // // LAB 2: Your code here. if (!n) return nextfree; result = nextfree; nextfree = ROUNDUP((char *) (nextfree+n), PGSIZE); return result; mem_init 这个函数首先用之前实现好的boot_alloc函数分配了 一页 空闲内存，初始化之，并用一个kern_pgdir指针指向了这片内存的起始位置。这一片区域用来存放page directory。 接下来是我们的工作：为一个页数组pages分配内存。 pages数组存储了每个分页的信息，其索引和页的物理地址可以用函数相互转换。可以说，pages的每一个元素都唯一对应着一个物理页面。 12pages = (struct PageInfo *) boot_alloc(sizeof(struct PageInfo) * npages);memset(pages, 0, sizeof(struct PageInfo) * npages); 这样我们就已经为内存分配相关的内核数据结构分配好了空间。接下来，mem_init函数调用page_init函数，去初始化所有物理内存分页。这个步骤结束之后，所有内存相关操作都可以通过page开头的函数来完成。 page_init Lab中已经给出了示例代码，但是这段代码是不严谨的(它将所有物理内存页都标记为是free的)，有几处问题没有考虑到： 物理页面0应该标记为used。这是因为这一部分保存着BIOS数据结构和IDT(中断描述符表)，我们以后可能会用到这些结构。 之前讲到过的由于考虑到向后兼容性而留下的IO hole不应该被分配。 在IO hole之后就是extended memory部分，这一部分中的有些位置存放了内核代码和内核数据结构，因而这些位置不能标记为free。 我们的任务是修改代码，使其只将那些该标记为free的放进page_free_list。 考察memlayout.h中的PageInfo结构体，可以发现其属性pp_ref用于指示引用这一页的进程数量,而pp_link指向空闲链表中下一项的地址。对于要放入page_free_list的pages，我们将其pp_ref设定为0，并利用pp_link将其插入空闲链表。 本任务的难点在于如何确定Extended Memory中的哪一部分已经被Kernel所占用。观察之前的代码可以发现，boot_alloc是从kernel代码和数据段的结束位置开始分配内存的，而kernel代码段的起始位置是IO hole的结束位置(0x100000,参考Lab 1)，这意味着从IO hole到boot_alloc分配的最后一块内存末尾之间的所有内存都是被占用的。 而根据之前的两个函数，boot_alloc分配的最后一块内存应该就是页表的最后一块内存(也就是pages数组的末尾)，因此我们从pages的头地址开始向后应该就可以找到kernel占用内存区的末尾位置。 根据这些信息，可以修改代码如下： 12345678910111213141516171819202122232425262728voidpage_init(void)&#123; size_t i; // 1) First page, ignore it // 2) Base memory for (i = 1; i &lt; npages_basemem; i++) &#123; pages[i].pp_ref = 0; pages[i].pp_link = page_free_list; page_free_list = &amp;pages[i]; &#125; // 3) IO hole // Mention that npages_basemem = IOPHYSMEM / PGSIZE // IOPHYSMEM and EXTPHYSMEM is represented by B instead of KB, so div it by PGSIZE. // (Here is no operation, because we do not need to deal with occupied pages.) ; // 4) Extended memory // The question is where is the end of kernel segment. char* end_addr = (char *)envs + sizeof(struct Env) * NENV - KERNBASE; int end_index = (int)(ROUNDUP(end_addr, PGSIZE)) / PGSIZE; for (i = end_index; i &lt; npages; i++) &#123; pages[i].pp_ref = 0; pages[i].pp_link = page_free_list; page_free_list = &amp;pages[i]; &#125;&#125; page_alloc 这个函数就是很简单的链表操作，仔细阅读注释的内容即可正确实现： 12345678910111213141516171819struct PageInfo *page_alloc(int alloc_flags)&#123; // Fill this function in // Returns NULL if out of free memory if (page_free_list == NULL) return NULL; // Get a free page from page_free_list struct PageInfo* free_page = page_free_list; page_free_list = free_page-&gt;pp_link; // Init the free page free_page-&gt;pp_link = NULL; if (alloc_flags &amp; ALLOC_ZERO) memset(page2kva(free_page), 0, PGSIZE); // Return the free page to caller return free_page;&#125; page_free 同样没有什么难度，直接贴出代码。 12345678910111213voidpage_free(struct PageInfo *pp)&#123; // Fill this function in // Hint: You may want to panic if pp-&gt;pp_ref is nonzero or // pp-&gt;pp_link is not NULL. if (pp-&gt;pp_ref) panic("This page is still occupied by other processes."); if (pp-&gt;pp_link) panic("You can't free a freed page."); pp-&gt;pp_link = page_free_list; page_free_list = pp;&#125; Part 2 Virtual Memory在开始这一部分之前，先要对几个地址之间的转换有一个大概的了解。 Segments 在保护模式下，有关段的信息是非常复杂的。对于一个段来说，除了段基地址之外，还有段的大小，特权级，类型，是否被执行过，读写权限等等多种信息要保存。用于描述这些信息的数据项称为 描述符(Descirptor) 。 描述符一般用4个字来表述所有信息，具体的描述符结构如下图所示： 其中各个部分的作用： 第一个字：段的界限，也就是这个段的长度。需要注意的是一个段的长度是用20位来表示的，因此这个字表示的段界限是不完整的，需要和描述符中另一段数据拼接起来才是完整的段界限。 第二个字：段的基址，段在虚拟地址空间内的起始位置。由于虚拟空间地址是32位的，这个字同样无法表示完整的段基址，需要与另外两段数据进行拼接。 第三个字： 高字节分为如下几个字段： P：存在位，表示该描述符对应的段是否已经读入内存。 DPL：长度为两位，表示该段所属的特权级 1或0：记录段的类型是存储段还是系统段 TYPE：记录段的属性 如果是存储段，那么是代码段还是数据段 段的读写权限如何 A：访问位，记录段是否被访问过 低字节为段基址的16-23位。 第四个字： 高字节为段基址的24-31位。 低字节分为如下几个字段： G：粒度位，G=0说明段长度的单位是Byte，而G=1说明单位是page。 X：用于区分32位和16位访问方式。 O和AVL：保留位和系统专用位 LIMIT：段界限的16-19位 所有的描述符都储存在 描述符表 中。描述符表分为以下三类： LDT：局部描述符表。每个进程都有它自己的局部描述符表，存放在一个特定的系统段内。LDT中存放着对应进程的代码和数据段位置等信息。 GDT：全局描述符表。只有一个，存放着操作系统内核使用的描述符和所有系统段的描述符。通过GDT可以去索引所有的LDT。 IDT：中断描述符表。用于定位所有的中断处理程序。 用于索引描述符表的字段称为Selector，cs等段寄存器所存放的就是Selector。它由三部分组成： 最低2位：决定这个段的特权级 第三位：决定这个段的位置(0代表在GDT，1代表在LDT) 4-16位：这个段在描述符表中的索引 在这个Lab中，我们暂时不涉及内存的分段机制，因而GDT中每个描述符的base为0而limit为0xffffffff。在kernel代码段中我们已经建立了一个简单的页表(能够映射4MB大小的内存),现在我们需要做的是拓展这个页表以映射整个虚拟内存。 Pages在Background knowledge里面我们已经讲了线性地址的构成，现在为了能够完成下面的实验，需要进一步了解一些关于页目录和页表的知识。 在MMU取到一个线性地址la时，它会首先取出la中的 页目录索引部分 ，并用其与cr3中存放的页目录首地址结合去找到la所在的 页表首地址 。在此之后，MMU取出la中的 页表索引部分 ，与之前找到的页表首地址结合来找到la所对应的具体 页表项 。 在这个过程中，la所在的页目录表项被称为 DIR entry ，而它所在的页表表项被称为 Page table entry。Directory entry中存放的物理地址与la的页表索引部分的结合是Page table entry的地址，而page table entry中存放的物理地址与la的偏移部分的结合是la所对应物理页的地址。 每个PDE或者PTE的内容都是phyaddr和 权限位 的组合。因为PDE和PTE的内容都指向一个物理页的首地址，它们的最后12位是用不到的。这12位被内存管理系统用作权限位，每一位都代表一个特定的权限，管理系统通过将这些位置0或置1来设定这一页的权限。 Addresses Exercise 3 你可以在qemu-gdb中键入ctrl-a c来进入qemu的monitor。在这里，你可以用xp命令来查询指定物理地址的数据(xp指令的用法与gdb的x指令类似)。与此同时，在gdb中用x指令可以查询指定虚拟地址的数据。将存在映射关系的虚拟地址与物理地址存放的内容作对比，看看是否是一致的。 JOS的源代码定义了uintptr_t来存放虚拟地址，而physaddr_t用来存放物理地址。 Question Q:如果下面的代码是正确的,变量x的类型应当是uintptr_t还是physaddr_t? A:uintptr_t,因为C中的指针都是指向虚拟地址的. JOS内核有时需要读取或修改只知道物理地址的内存。例如，向页表添加映射可能需要分配物理内存来存储页目录，然后初始化该内存。但是，内核不能绕过虚拟地址转换，因此不能直接修改物理地址。这就是为什么我们要把物理内存用一个线性函数映射到虚拟内存中0xf0000000以上的区域:这方便了内核直接操作物理内存。PADDR和KADDR两个宏定义让我们可以很方便地实现物理地址和虚拟地址之间的转换。 page management我们知道，同一个物理页面可能会被映射到数个不同虚拟空间的数个虚拟页面，我们通过修改PageInfo结构体中的pp_ref属性来反映这一点。每当我们分配一个UTOP以下的页面，我们让该物理页面的pp_ref属性+1。(UTOP以上的页面属于内核，它们永远不应该被free，因而无需更改这个属性) 需要注意的是，我们在实现page_alloc函数时并没有让它去增加pp_ref属性值，因此调用page_alloc的函数需要 自行增加这个属性的值 。 pgdir_walk 这个函数接受一个线性地址和一个页目录，返回线性地址对应的页面所在页表的物理地址。为了达成这个目的，我们可以通过线性地址中的页目录索引部分去找到页目录中的对应页表地址。如果这个页表还没有被创建，且create参数为真，那就创建一个新的页表并返回它的物理地址。 根据函数前面的注释，MMU会同时检查页目录表项和页表表项中的权限位，因而我们对于页目录中新页表物理地址的权限可以把要求放宽松一点。 12345678910111213141516171819202122232425262728pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create)&#123; // Fill this function in // Find the page table where va locates. physaddr_t pgtab = pgdir[PDX(va)]; if (!pgtab) &#123; if (create) &#123; // Allocate a new page table. struct PageInfo* new_pt = page_alloc(ALLOC_ZERO); if (new_pt == NULL) return NULL; else &#123; new_pt-&gt;pp_ref++; // Leave permissions of pt more permissive // We allow users to read this page pgdir[PDX(va)] = page2pa(new_pt) | PTE_P | PTE_U | PTE_W; return KADDR(PTE_ADDR(pgdir[PDX(va)])+PTX(va)*sizeof(pte_t)); &#125; &#125; else return NULL; &#125; else &#123; // We need to return the address of page table **entry** // PTE_ADDR: get rid of the permission bits in `pgtab` // PTX(va)*sizeof(pte_t): find the 'PTX(va)'th element in a `pte_t` array. return KADDR(PTE_ADDR(pgtab)+PTX(va)*sizeof(pte_t)); &#125; &#125; boot_map_region 这个函数将一段指定的虚拟地址映射到同样长度的指定的物理地址。因为映射以页为单位，我们可以依次映射这段地址中的每一页： 123456789101112static voidboot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)&#123; // Fill this function in int page_num = size / PGSIZE; for (int i = 0; i &lt; page_num; i++) &#123; pte_t* pgtab = pgdir_walk(pgdir,(void*)(va+i*PGSIZE),1); *pgtab = (pa+i*PGSIZE) | perm | PTE_P; &#125;&#125; page_lookup 这个函数寻找va在pgdir中的页表地址和物理地址。依照注释完成,没有多大难度。 1234567891011121314struct PageInfo *page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)&#123; // Fill this function in pte_t* pgtab = pgdir_walk(pgdir, va, 0); // Page table address if (pgtab == NULL) return NULL; else &#123; if (pte_store != NULL) *pte_store = pgtab; return pa2page(PTE_ADDR(*pgtab)); &#125;&#125; page_remove 这个函数移除va指定的页。基本上都是在调用函数，只要认真阅读了注释即很简单。 1234567891011121314voidpage_remove(pde_t *pgdir, void *va)&#123; // Fill this function in pte_t *pg_pte; struct PageInfo* pgtab = page_lookup(pgdir, va, &amp;pg_pte); if (!pgtab) return; // This function frees the page automatically if refcount reaches 0. page_decref(pgtab); *pg_pte = 0; tlb_invalidate(pgdir, va);&#125; page_insert 这个函数将虚拟地址va所对应的页设定为pp。这个函数的一个很容易出错的边界条件是将一个 原本空闲的 page 连续插入两次 ，按正常的逻辑第二次插入应该不会有任何影响，但实现不当的话会出现问题。 如果先进行page_remove再增加引用数的话，首先在调用page_remove的时候这个page已经进入了page_free_list，但接下来我们接着又要用到这个page且没有经过page_alloc，这样一来这个page既在空闲链表中引用数又不为0，会成为一个bug。 根据注释的提示，有一种优雅的无需条件判断的方式可以解决这个问题。这种方式就是 将增加引用数的步骤提前 ，这样这个页面在page_remove之前引用数就是2，就不会在page_remove中被回收到page_free_list中。 1234567891011121314intpage_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)&#123; // Fill this function in pte_t* pgtab = pgdir_walk(pgdir, va, 1); if (pgtab == NULL) return -E_NO_MEM; pp-&gt;pp_ref++; if (*pgtab &amp; PTE_P) page_remove(pgdir, va); *pgtab = page2pa(pp) | perm | PTE_P; return 0;&#125; Part 3 Kernel address spaceJOS的地址空间被ULIM划分为两个部分：用户地址空间 和 内核地址空间 。后者大概拥有256MB的剩余空间可以使用。 由于用户区和内核区同在一个地址空间内，我们需要使用页表管理中的 权限位 来保证用户只能访问用户区的页。 常用的权限位： PTE_P: 页面存在 PTE_W: 该页是可写的 PTE_U: 该页可以由用户访问 用户不应有访问任何ULIM以上内存的权限,而内核应当能读写这一块区域。在UTOP和ULIM之间的区域是 只读区(对用户和内核都是) 。低于UTOP的内存区域权限由用户自行设置。 Initializing the Kernel Address Space Exercise 5 这个任务要求我们补全mem_init函数。 第一段要求我们把整个pages数组映射到UPAGE地址以上。 123// Cautious: we map the phyaddr of pages instead of their content// So we use PADDR here, not page2pa.boot_map_region(kern_pgdir, UPAGES, npages*sizeof(struct PageInfo), PADDR(pages), PTE_U); 第二段要求我们把内核栈映射到KSTACKTOP-KSTKSIZE到KSTACKTOP区域。 1boot_map_region(kern_pgdir, (KSTACKTOP-KSTKSIZE), KSTKSIZE, PADDR(bootstack), PTE_P | PTE_W); 第三段要求我们映射整个内核区域。 12unsigned kern_size = (unsigned)~0 - KERNBASE;boot_map_region(kern_pgdir, KERNBASE, kern_size, 0, PTE_P | PTE_W); 三段都是看着注释调函数即可，没有很大难度。不得不说6.828的注释仔细研究可以省去很多精力。 Questions Q：在这个过程中哪些PDE被填入了信息？它们对应哪些线性地址，又指向哪些物理地址？ A：被填入的PDE索引： 956-UPAGES，线性地址0xef000000,指向pages数组在物理内存中的首地址 957-UVPT，线性地址0xef400000,指向kern_pgdir在物理内存中的地址 959-KSTACK，线性地址0xefc00000,指向bootstack数组在物理内存中的首地址 960～1023-内核内存区，线性地址0xf0000000以上，指向物理内存地址0。 Q：既然我们把用户和内核的内存区域放在同一个地址空间中，到底是什么机制保护了内核内存不能被用户访问？ A：权限位PTE_U决定了一页能否被用户访问。 Q：这个操作系统能够支持多大的物理内存？为什么？ A：内存空间内能存放pages的空间是一个PTSIZE，也就是最多能够映射PTSIZE/sizeof(struct PageInfo)个页面，每页大小为4KB，因此总共能映射的物理内存大小为2GB。 Q：如果我们拥有能支持的最大的物理内存，管理这些内存需要多少空间开销？如何减少这些开销？ A：管理满载的512K个页面需要512个页表，每个页表占内存空间都是一个PGSIZE，总共就会有4MB左右内存用于页表储存。加上用于存放pages的4MB和页目录的4KB，总共会有8MB左右空间开销。如果把PGSIZE取大一点，这种开销就可以稍微减小。 Q：在我们刚打开分页机制的时候，程序还运行在低地址，控制流在什么时候跳转到KERNBASE以上？为什么在打开分页机制之后我们仍能够运行在一个低地址？ A：在打开分页的下一步，控制流就用jmp指令跳转到了KERNBASE以上的高地址。打开分页机制后仍能在低地址运行的原因是低地址和KERNBASE以上的高地址都被映射到同一片物理内存，这是为了保持兼容性。 完成上面的所有代码之后，运行make grade，70/70大成功。 Challenge 这个挑战的内容主要是为JOS的monitor加入一些实用的指令，以方便之后的调试过程，具体的指令细节可以自己调整和定制。增加指令后，要记得在monitor.h中添加声明。 我主要做了以下几条指令(下面是修改后的Commands数组)： 12 pageinfo 这个指令接受一个命令行参数。 pageinfo addr：打印出虚拟地址addr所在的页目录，页表，以及所在的物理页面，物理地址。 如果addr使用十六进制地址，必须在数字前面加上0x。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// Must include pmap.h in monitor.c#include &lt;kern/pmap.h&gt;intmon_pageinfo(int argc, char **argv, struct Trapframe *tf)&#123; // Cannot declare vars in switch-case statement. physaddr_t addr; pte_t* pte; switch (argc) &#123; case 1: cprintf("Error: too few arguments.\n"); return 0; case 2: addr = str2int(argv[1]); pte = pgdir_walk(kern_pgdir, (void *)addr, 0); if (!pte) &#123; cprintf("This address has not been mapped yet.\n"); return 0; &#125; if (!(*pte &amp; PTE_P)) &#123; cprintf("Exception: Page does not exist.\n"); return 0; &#125; cprintf("Mapping information of address %x:\n", addr); cprintf(" Page directory entry: %d\n", PDX(addr)); cprintf(" Page table entry: %d\n", PTX(addr)); cprintf(" Page physical address: %x\n", PTE_ADDR(*pte)); cprintf(" Physical address: %x\n", PTE_ADDR(*pte) + PGOFF(addr)); cprintf(" Page permission:\n"); if ((*pte &amp; PTE_U) &amp;&amp; (*pte &amp; PTE_W)) &#123; cprintf(" Readable and writeable by user and kernel\n"); &#125; else if ((*pte &amp; PTE_U)) &#123; cprintf(" Readable by user and kernel\n"); &#125; else if ((*pte &amp; PTE_W)) &#123; cprintf(" Readable and writeable by kernel\n"); &#125; else &#123; cprintf(" Readable by kernel\n"); &#125; return 0; default: cprintf("Error: too many arguments.\n"); return 0; &#125;&#125;intstr2int(char* str)&#123; int num = 0; int base = 10; if (*str == '0') &#123; if (*(++str) != 'x') base = 8; else &#123; base = 16; str++; &#125; &#125; if (base == 10 || base == 8) while (*str) &#123; num = num * base + *str - '0'; str++; &#125; else while (*str) &#123; if (*str &gt;= 'a' &amp;&amp; *str &lt;= 'f') num = num * base + *str - 'a' + 10; else if (*str &gt;= 'A' &amp;&amp; *str &lt;= 'F') num = num * base + *str - 'A' + 10; else num = num * base + *str - '0'; str++; &#125; return num;&#125; chperm 这个指令接受三个命令行参数。 chperm &lt;PDX&gt; &lt;PTX&gt; &lt;perm&gt;：修改&lt;PDX&gt;和&lt;PTX&gt;对应页面的权限。 &lt;perm&gt;的使用方法： +：增加一种权限 -：消除一种权限 w：对应于PTE_W u：对应于PTE_U p：对应于PTE_P 使用样例：chperm 960 256 -w 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// Change the permittions of a certain page.// chperm &lt;PDX&gt; &lt;PTX&gt; &lt;perm&gt;intmon_chperm(int argc, char **argv, struct Trapframe *tf) &#123; int pdx, ptx, perm = 0; char* ptr; int flag = 0; // 0 represents '-', 1 represents '+' pte_t* pgaddr = 0; switch (argc) &#123; case 4: pdx = str2int(argv[1]); ptx = str2int(argv[2]); ptr = argv[3]; pgaddr = pgdir_walk(kern_pgdir, (void *)(PGADDR(pdx,ptx,0)), 0); switch (*ptr) &#123; case '+': flag = 1; break; case '-': flag = 0; break; default: cprintf("Error: Illegal operation \'%c\'.\n", *ptr); &#125; switch (*(ptr+1)) &#123; case 'w': if (flag) *pgaddr = *pgaddr | PTE_W; else *pgaddr = *pgaddr &amp; (~PTE_W); break; case 'u': if (flag) *pgaddr = *pgaddr | PTE_U; else *pgaddr = *pgaddr &amp; (~PTE_U); break; case 'p': if (flag) *pgaddr = *pgaddr | PTE_P; else *pgaddr = *pgaddr &amp; (~PTE_P); break; default: cprintf("Error: Illegal operation \'%c\'.\n", *(ptr+1)); &#125; return 0; default: cprintf("Error: bad usage.\n"); return 0; &#125;&#125; man 虽然命名为man，但是其实这个命令的行为更像--help。 需要注意的是，每增加一条新的命令就要增加command_usage数组的内容。并且，这个数组中的元素顺序必须与commands数组中的顺序一致。 123456789101112131415161718192021222324252627282930313233char* command_usage[] = &#123; "help\nDisplay the list of commands", "exit\nLeave the monitor and shutdown", "kerninfo\nDisplay information about the kernel", "backtrace\nDisplay the structure of the stack", "pageinfo &lt;addr&gt;\nDisplay the information of the page virtual address &lt;addr&gt; locates", "chperm &lt;PDX&gt; &lt;PTX&gt; &lt;perm&gt;\nChange the permittion of the page with index &lt;PDX&gt; and &lt;PTX&gt;\n \&lt;perm&gt; is the combination of a symbol('+' or '-') and a permittion code. \In particular, '+' is for permittion addition and '-' is for permittion erasure.\n\Possible permittion codes:\n u: PTE_U\n p: PTE_P\n w: PTE_W\n", "man\nDisplay the usage of a command", &#125;;// Display the usage of a command.intmon_man(int argc, char **argv, struct Trapframe *tf) &#123; if (argc != 2) &#123; cprintf("Usage: man &lt;command&gt;\n"); return 0; &#125; for (int i = 0; i &lt; ARRAY_SIZE(commands); i++) &#123; if (strcmp(argv[1], commands[i].name) == 0) &#123; cprintf("Usage: %s\n", command_usage[i]); return 0; &#125; &#125; cprintf("Error: no such command.\n"); return 0;&#125; 在这一章的最后还有几个挑战，一个是实现一种不同的分页机制使用户可以不受限制地使用整个4GB内存空间，由于并没有什么主流操作系统使用这种模式就没写。另一个是实现一个类似于malloc/free堆内存分配的分配机制，过于麻烦，等有空再写这个吧。 Summarize总结一下JOS使用的内存管理机制： 目前整个操作系统由一个页目录——内核页目录(kern_pgdir)来维持，页目录的大小为一页，包括1024个条目。每个条目都是一个4字节的物理地址，指向对应的页表所在的物理内存地址。每个页表大小也是一页，同样包括1024个条目，每个条目指向对应的页所在的物理内存地址。 每个物理地址与一个线性地址唯一对应。线性地址的前10位和中间10位分别是这个地址所在物理页面的页目录索引和页表索引，最后12位代表这个地址在物理页面内的偏移量。 除此之外，内核还维护着一个pages数组。真正的page每个4KB，由整个物理地址空间平分；pages数组中的元素PageInfo大小8字节，记录着这个page的引用数和空闲链表中它的下一个元素的地址。pages数组中元素的索引可以线性地换算出对应page在物理内存中的首地址。 page_free_list指针是空闲链表的头指针。它指向pages数组中第一个空闲的元素。空闲链表中的其他元素可以由PageInfo中的指针来索引。 这个内存管理机制被外界调用的接口函数有： page_alloc：分配一块空闲的物理页，并将其对应的PageInfo结构体指针返回。注意调用者需要自行增加pp_ref的值。 page_free：释放一块被占用的物理页。 page_insert：将一块已分配的物理页与一个虚拟地址建立关系 Lab 3 User Environments在前两个Lab中，我们成功加载并运行了JOS内核，还建立了整个内核虚拟地址空间的内存映射，但这些都只是对内核的操作。在这个Lab里，我们要开始建立一个用户环境。换句话说，我们要建立一个用户进程，并使其受内核的监管。内核应当接受并处理所有用户进程发起的系统调用和引发的异常。 执行git checkout -b lab3 origin/lab3命令切换到lab3分支，执行git merge lab2合并在lab2所做的更改。这一步可能会出现conflict，解决之后重新commit即可。 Lab3增加的文件有： 文件名 文件功能描述 inc/ env.h 有关用户环境的一些声明和定义 trap.h 关于trap类异常处理的声明和定义(有关四种异常可以参考CSAPP第八章) syscall.h 关于系统调用处理的声明和定义 lib.h 用户使用的系统库 kern/ env.h/env.c 内核维持用户环境所需要的声明和定义 trap.h/trap.c 内核对trap类异常的接受和处理 trapentry.S 汇编语言编写的trap异常处理程序入口 syscall.h/syscall.c 内核对系统调用的接受和处理 lib/ Makefrag 用来构建obj/lib/libjos.a的makefile entry.S 汇编语言编写的用户进程入口 libmain.c entry.S调用的用于初始化用户环境的代码 syscall.c 用户环境的系统调用函数 console.c 用户模式下的 putchar 和 getchar实现, 用于提供console的I/O exit.c 用户模式下的 exit panic.c 用户模式下的panic user/ * 测试程序 除此之外，lab3更改了不少lab2中的文件。可以执行git diff lab2来查看具体的改动。 在这个Lab中，GCC提供的内联汇编特性非常有帮助。内联汇编的格式可以参考6.828提供的教程，也可以参考中文的博客。 Part A User Environments and Exception Handlinginc/env.h包含着对Env结构的定义。Env结构类似于PageInfo结构，只不过后者储存的是页面的信息而前者储存的是用户环境的信息。内核利用这些结构来管理所有用户环境。在这个Lab中我们只需要实现一个用户环境，但我们也要完成管理多个用户环境的机制，以支持以后的Lab功能。 在kern/inv.c中定义有三个变量: struct Env *envs：所有用户环境信息链表头指针 struct Env *curenv：当前的用户环境 static struct Env *env_free_list：空闲的用户环境链表头指针 JOS系统最多能够支持NENV个用户环境，这个常量的定义在inc/kern.h中，默认的值是10。在初始化时，envs数组会被初始化为NENV长度的链表。 注：在这个Lab中，用户环境和进程是指的同一个东西。 Environment State我们可以分析一下Env结构的内容： 123456789101112struct Env &#123; struct Trapframe env_tf; // Saved registers struct Env *env_link; // Next free Env envid_t env_id; // Unique environment identifier envid_t env_parent_id; // env_id of this env's parent enum EnvType env_type; // Indicates special system environments unsigned env_status; // Status of the environment uint32_t env_runs; // Number of times environment has run // Address space pde_t *env_pgdir; // Kernel virtual address of page dir&#125;; env_tf：这是一个Trapframe结构体，它负责在这个用户环境挂起的时候保存其所有寄存器值。可以观察一下Trapframe结构体的定义： 123456789101112131415161718struct Trapframe &#123; struct PushRegs tf_regs; uint16_t tf_es; uint16_t tf_padding1; uint16_t tf_ds; uint16_t tf_padding2; uint32_t tf_trapno; /* below here defined by x86 hardware */ uint32_t tf_err; uintptr_t tf_eip; uint16_t tf_cs; uint16_t tf_padding3; uint32_t tf_eflags; /* below here only when crossing rings, such as from user to kernel */ uintptr_t tf_esp; uint16_t tf_ss; uint16_t tf_padding4;&#125; 可以看到，所有x86的关键寄存器的值在这里都有保存(通用寄存器的值都保存在PushRegs结构内)。 env_link：指向空闲用户环境链表中的下一个元素 env_id：内核用于唯一地标识这个用户环境的描述符，也就是进程的pid。当用户环境被回收时这个id也会被回收，也就是说id和这个Env在链表中的位置是无关的。 env_parent_id：这个进程的父进程的id。 env_type：用于区分进程的类型(用户进程还是系统服务进程) env_status：当前用户环境的状态 ENV_FREE：位于env_free_list中 ENV_RUNNABLE：该进程可以运行，正在等待CPU的调度 ENV_RUNNING：该进程正在CPU上运行 ENV_NOT_RUNNABLE：该进程是活动的，但由于某些原因无法运行 ENV_DYING：该进程目前是僵尸进程 env_pgdir：当前用户环境使用的页目录地址 Allocating the Environments Array Exercise 1 你需要向mem_init函数中添加初始化envs数组的代码，就像之前初始化pages那样。此外，你还需要将初始化后的envs数组映射到UENVS地址以使用户能够查看它。 由于有了之前初始化pages的经验，这里使用相同的方法可以轻松完成任务： 12envs = (struct Env *) boot_alloc(sizeof(struct Env) * NENV);memset(envs, 0, sizeof(struct Env) * NENV); 1boot_map_region(kern_pgdir, UENVS, NENV*sizeof(struct Env), PADDR(envs), PTE_U); 运行后一看，为什么本来过了的check_page_free_list()失败了呢？百思不得其解，逆着逻辑流往前找，最终发现是因为之前在page_init函数中在计算内核空闲地址空间的起始位置时用到了pages，而现在我们在pages数组后面又分配了更多的空间给envs，原本空闲的内存变得不空闲了，但page_init的逻辑没有变，于是本来正确的函数出现了错误。改正方法如下： 12// char* end_addr = (char *)pages + sizeof(struct PageInfo) * npages - KERNBASE;char* end_addr = (char *)envs + sizeof(struct Env) * NENV - KERNBASE; Creating and Running Environments我们现在需要完善kern/env.c中的代码来运行一个用户环境。由于我们现在还没有构建文件系统，我们会让内核加载一个静态的二进制镜像(这个镜像是以ELF格式嵌在内核中的)。 Lab3的GNUMakefile在obj/user目录中生成了很多二进制镜像。kern目录中的Makefrag文件将它们利用linker的-b参数直接嵌入内核的可执行文件当中(不是以可重定位文件.o的形式，是将整个二进制文件原样嵌入)，内核可以在运行时索引并运行这些镜像。 Exercise 2 完成下列函数来初始化用户环境： env_init()：初始化所有envs数组中的元素并将它们加入env_free_list链表中。这个函数还应该调用env_init_percpu来配置关于分段机制的硬件。 env_setup_vm()：为新的用户环境初始化一个页目录并初始化这个用户环境的内核部分内存 region_alloc()：用于为用户环境分配物理内存 load_icode()：解析用户进程要跑的任务文件的ELF头，并将二进制文件加载到虚拟地址空间 env_create()：调用上面两个函数来为一个任务建立一个新的用户环境 env_run()：运行一个用户环境 这一部分编码涉及到比较多的错误码处理，在这里可以活用cprintf的%e转义字符：它可以打印出一个errorcode对应的错误信息。 首先是env_init函数。只要认真阅读过函数前面的注释，按部就班地来就没有什么难度： 12345678910111213141516voidenv_init(void)&#123; // Set up envs array // LAB 3: Your code here. for (int i = NENV - 1; i &gt;= 0; i--) &#123; envs[i].env_id = 0; envs[i].env_status = ENV_FREE; envs[i].env_link = env_free_list; env_free_list = &amp;envs[i]; &#125; // Per-CPU part of the initialization env_init_percpu();&#125; 随后是env_setup_vm函数。这个函数的作用是为这个用户环境建立整个虚拟内存系统。看上去很吓人，但注释中提示我们，所有用户环境在UTOP以上的虚拟内存空间都是内核虚拟内存空间中这一部分的副本，而UTOP以下的部分在初始化过程中全都可以置0，因此我们可以直接以kern_pgdir为模板来初始化e-&gt;env_pgdir的表项： 1234567// LAB 3: Your code here.// Set the page directoryp-&gt;pp_ref++;e-&gt;env_pgdir = page2kva(p);// Set up the virtual memory spacememcpy(e-&gt;env_pgdir, kern_pgdir, PGSIZE); 接下来是region_alloc函数，这个函数其实不写也行，主要是为了简化物理内存的分配过程。在load_icode函数中我们要频繁地为一段虚拟内存分配物理内存，这个函数就是为了简化这一过程而生的。 如果我们对之前Lab2中自己实现过的函数的功能和调用关系很熟悉的话，这个函数的实现会很简单。 1234567891011121314static voidregion_alloc(struct Env *e, void *va, size_t len)&#123; // LAB 3: Your code here. uintptr_t start_addr = ROUNDDOWN((uintptr_t)va, PGSIZE); uintptr_t end_addr = ROUNDUP((uintptr_t)(va + len), PGSIZE); for ( ; start_addr &lt; end_addr; start_addr += PGSIZE) &#123; struct PageInfo* rawpg = page_alloc(ALLOC_ZERO); if (!rawpg) panic("region_alloc: %e",-E_NO_MEM); page_insert(e-&gt;env_pgdir, rawpg, (void *)start_addr, PTE_U | PTE_W); &#125;&#125; 下一个函数load_icode的实现难度就比较大了，它会将目标ELF镜像文件加载到内存中，为此它需要解析ELF头的内容，这一步与bootloader所做的比较相似，可以参考boot/main.c中的实现；它还会为这个已经加载的二进制文件建立一个程序栈。 在inc/elf.h中已经定义好了ELF头和段头的结构： 12345678910111213141516171819202122232425262728struct Elf &#123; uint32_t e_magic; // must equal ELF_MAGIC uint8_t e_elf[12]; uint16_t e_type; uint16_t e_machine; uint32_t e_version; uint32_t e_entry; uint32_t e_phoff; uint32_t e_shoff; uint32_t e_flags; uint16_t e_ehsize; uint16_t e_phentsize; uint16_t e_phnum; uint16_t e_shentsize; uint16_t e_shnum; uint16_t e_shstrndx;&#125;; // ELF头的结构struct Proghdr &#123; uint32_t p_type; uint32_t p_offset; uint32_t p_va; uint32_t p_pa; uint32_t p_filesz; uint32_t p_memsz; uint32_t p_flags; uint32_t p_align;&#125;; // 段头部的结构 关于ELF文件结构的详细知识可以参考CSAPP的第7章链接部分知识，我们现在只需要知道，ELF头位于一个二进制文件的开头部分，而且通过解析ELF头的信息可以得到段头部表的位置和大小。通过解析每个段头部，我们又可以得知所有段的信息，从而将它们有选择性地加载到内存中。 这里可能需要解释一下6.828的诡异命名的含义：ph是指二进制文件中各个段的段头部结构体指针，其类型为struct Proghdr*。只要理解了这一层，按照注释就可以按部就班地完成这个函数了。 比较需要注意的一点是cr3寄存器值的切换。在这个函数执行之前当前运行的环境是kernel，因此cr3的值是kern_pgdir，如果我们直接用memcpy函数去加载binary就会将binary加载到内核地址空间而非用户环境地址空间。所以我们需要在加载binary之前先用lcr3函数切换cr3寄存器的值，在加载完之后再切换回kern_pgdir。 另一个问题是如何设置加载进内存的二进制程序的入口点。根据注释中的提示观察env_pop_tf函数可以发现，这个函数从env_tf结构中恢复了所有上下文寄存器的值，其中就包括tf_eip这个决定着下一条命令位置的寄存器，随后就执行iret汇编指令切换用户环境。这样一来，只要我们将(e-&gt;env_tf).tf_eip的值修改为二进制程序入口点的值，就可以让控制流自然地跳转到那个位置了。 但是二进制程序入口点的值是什么呢？这个值其实存放在ELF头中，就是e_entry这个结构体元素的值。 1234567891011121314151617181920212223242526272829303132333435363738394041static voidload_icode(struct Env *e, uint8_t *binary)&#123; // LAB 3: Your code here. struct Proghdr *ph, *eph; struct Elf* elf_ptr = binary; // The pointer to the binary's elf header // Check the type of the binary if (elf_ptr-&gt;e_magic != ELF_MAGIC) panic("This binary is not a valid ELF file!"); // Load each program segment ph = (struct Proghdr *)(binary + elf_ptr-&gt;e_phoff); eph = ph + elf_ptr-&gt;e_phnum; // As we need to load the binary into e's virtual memory, // we should change cr3 to e's page directory (or the binary // would be loaded to kernel's virtual memory). lcr3(PADDR(e-&gt;env_pgdir)); for (; ph &lt; eph; ph++) &#123; // Do what the hint told us to if (ph-&gt;p_type == ELF_PROG_LOAD) &#123; region_alloc(e, ph-&gt;p_va, ph-&gt;p_memsz); memcpy(ph-&gt;p_va, binary + ph-&gt;p_offset, ph-&gt;p_filesz); memset(binary + ph-&gt;p_va + ph-&gt;p_filesz, 0, ph-&gt;p_memsz - ph-&gt;p_filesz); &#125; &#125; // Change cr3 back to kern_pgdir. lcr3(PADDR(kern_pgdir)); // Set the entry point of the binary (e-&gt;env_tf).tf_eip = elf_ptr-&gt;e_entry; // Now map one page for the program's initial stack // at virtual address USTACKTOP - PGSIZE. // LAB 3: Your code here. region_alloc(e, USTACKTOP - PGSIZE, PGSIZE);&#125; 这个函数完成之后，剩下的两个函数就比较简单了。env_create函数直接按照注释中的要求调用函数即可： 1234567891011voidenv_create(uint8_t *binary, enum EnvType type)&#123; // LAB 3: Your code here. struct Env *new_env; int err = env_alloc(&amp;new_env, 0); if (err) panic("env_create: %e", err); load_icode(new_env, binary); new_env-&gt;env_type = type;&#125; 最后的env_run也按照注释的要求完成即可： 1234567891011121314151617181920voidenv_run(struct Env *e)&#123; // LAB 3: Your code here. // Step 1 if (curenv != NULL) &#123; if (curenv-&gt;env_status == ENV_RUNNING) curenv-&gt;env_status = ENV_RUNNABLE; else panic("env_run: The current process's status is not ENV_RUNNING."); &#125; // 1. curenv = e; // 2. curenv-&gt;env_status = ENV_RUNNING; // 3. curenv-&gt;env_runs++; // 4. lcr3(PADDR(e-&gt;env_pgdir)); // 5. // Step 2 env_pop_tf(&amp;curenv-&gt;env_tf);&#125; 由于我们还没有完成系统调用相关的处理代码，加载完成的binary并无法正常工作。在binary执行到系统调用那一步之后，CPU会发现它还不能处理这个中断，于是抛出一个一般保护错误(general protection fault)。然而这个保护错误目前不能被处理，于是CPU再抛出一个double fault异常，并发现这也不能被处理，最终放弃治疗并抛出triple fault异常，也就是我们之前在调试过程中常见的那个triple fault。 一个triple fault异常通常会引起系统重启，但为了方便debug，6.828修改了qemu使得它在triple fault的时候打印出所有寄存器的值和内存状态。 为了检验我们的工作是否正确完成，我们可以用qemu-gdb和gdb来进行调试。首先在env_pop_tf函数处打上断点并c到这个函数，si单步调试直到iret将控制流跳转到用户地址空间，这时可以发现gdb中的地址信息显示从0xf0000000以上变成了0x00800000以上，能进行到这一步说明我们对于用户地址空间创建的实现没有问题。 在0x800101处(系统调用的前一句指令)打一个断点，执行到这一句汇编指令。如果在执行到这里的过程中始终没有触发错误，说明我们Exercise 2的实现是没有问题的。 Handling Interrupts and Exceptions现在的情况是，一旦用户环境执行了系统调用，控制流是无法从内核返回给用户环境的。我们现在需要实现的是内核对于基本的异常和系统调用的处理，首先我们要熟悉x86的中断和异常机制。 Exercise 3 阅读80386 Programmer’s Manual中有关异常和中断处理的部分。 (如果已经阅读过CSAPP第八章异常控制流，有关这部分的内容会变得很易于理解。) 中断和异常都是受保护的控制流转移，也就是说这两个过程是受内核控制的。内核通过中断或异常来切换到内核态，以使得用户代码没有干预内核运行的机会。 Intel是这样定义异常和中断的： 中断(Interrupt)是处理器外部的设备向处理器发出的异步(asynchronous)信号引起的(典型的例子是IO)。 异常(Exception)是处理器本身执行的代码所触发的同步(synchronous)信号引起的，系统调用和错误都算做异常。 从这个定义我们可以看出，Intel对中断的定义和CSAPP一致，但异常的定义其实是包括了CSAPP中定义的陷阱(trap)，错误(fault)和终止(abort)。 为了保证这种控制流转移是受保护的，intel使用了两种机制： 中断描述符表(IDT)：处理器保证了当异常或中断触发时，控制流的转移位置是由内核而非触发异常的代码定义的。intel定义了256种异常，每一种异常有一个独一无二的异常号(直译是异常向量，但将一个数称为向量感觉会引起误解)，CPU以异常号为索引去中断描述符表中寻找对应的表项，从而进行对特定中断的处理。CPU可以从中断描述符表中获得： 指向中断处理程序首地址的eip值 用于处理中断的特权级所对应的CS寄存器值(能处理中断的只有0级和1级，在JOS中均为0级) 任务状态段(TSS)：在跳转到中断处理程序之前，CPU需要保存它的状态以便在处理完之后将控制权交还。但是这个保存状态的位置必须是用户特权级所不能访问的，否则恶意的用户代码就能够去干预内核的行为。为此CPU为异常处理程序建立了一个独立于用户栈之外的栈，在这个栈中处理器压入SS，ESP，EFLAGS，CS，IP等关键信息，并重新设置SS和ESP以将这个栈作为新的程序栈。 所有异常都使用0-31之间的32个异常号，而剩下的异常号通常对应于软件或硬件引发的中断。 现在我们来看一个例子：假设一个用户环境在执行一条代码的时候试图进行除零运算。 处理器根据TSS所定义的SS0和ESP0来切换程序栈，在JOS中它们分别对应着GD_KD和KSTACKTOP。 处理器将需要保护的上下文信息压入新的栈(先后是SS，ESP，EFLAGS，CS，EIP，有些时候还会压入errorcode)。 处理器根据除法异常的异常号(0)找到IDT[0]，并根据其内容设定新的CS：EIP 异常处理程序接管控制流并进行异常处理 值得注意的是，只有当从用户态进入内核态时CPU才会进行程序栈切换，如果在内核态下发生了中断或异常，CPU不会建立一个新栈，而是在已有的内核栈中先后压入EFLAGS，CS和EIP(有时压入errorcode)，然后进行控制流跳转，这为异常的嵌套提供了一种优雅的解决方式。 Setting Up the IDT在这个Lab中我们会建立能够处理异常和系统调用的IDT，inc/trap.h和kern/trap.h可以为我们的工作提供很多帮助，其中后者提供的定义只能由内核访问，前者的定义则可以由内核和用户共同访问。 注意：有些异常是被intel保留的，这意味着你不需要处理它们。 在trapentry.S中定义了每个中断或异常的处理程序，trap_init()函数应当用它们的地址来初始化IDT。每个处理程序都应当在栈上建立一个struct Trapframe，并以这个结构的指针为参数调用trap.c中的trap()函数。 Exercise 4 修改trapentry.S和trap.c来实现上面描述的功能。可能有帮助的宏定义有： trapentry.S中的TRAPHANDLER和TRAPHANDLER_NOEC inc/trap.h中的T_*宏定义们 你需要用这些宏为inc/trap.h中定义的每一个trap增加一个入口点。由于每个异常处理函数都会jmp到_alltraps，你还需要完成这段代码的实现。你的_alltraps需要完成这些工作： 向栈中压入数据，使栈的结构看起来像struct Trapframe(可以使用pushal指令) 将GD_KD加载到%ds和%es pushl %esp作为trap函数的参数 调用trap函数 你还需要修改trap_init()函数来初始化IDT，让它的每个表项指向trapentry.S中定义的一个入口点，在这个过程中SETGATE函数可能会有用。 首先观察trapentry.S中对两个宏的定义和注释，理解它们的作用。TRAPHANDLER接受两个参数name和num，定义一个名为name的全局的处理num所对应异常的异常处理函数；而TRAPHANDLER_NOEC与其唯一的区别就是后者会在压入异常号之前多压入一个32位的0。这个操作的用意是什么呢？ _alltraps定义了所有异常处理函数的公共部分，我们可以从要求中得知它的第一步就是要将一个Trapframe结构压入程序栈。这个结构的定义在之前遇到过，现在我们来仔细研究一下它的结构： 在之前的描述中我们已经知道在异常触发的时候处理器会帮我们切换好程序栈并压入一些必要信息，其中对于errorcode这一项，有些异常会压入，但有些异常不会压入。如果我们对所有异常一概使用TRAPHANDLER宏去处理，没有压入errorcode的异常的Trapframe就会向上“塌陷”，致使从trap number往下的所有数据错位。为了保持结构的完整性，我们需要对已经压入errorcode的异常使用TRAPHANDLER宏，而对没有压入的异常使用TRAPHANDLER_NOEC宏。 哪些异常压入过errorcode呢？通过查阅80380 Programmer’s Manual，可以发现一个Error-Code Summary，可以根据这个表给出的信息来选择应该用哪个宏。 在我们成功构造好Trapframe之后，下一步是修改ds和es的值，压入esp的值，最后call trap。只要熟悉AT&amp;T标准的语法和规范，这几步应该不算难。 trapentry.S的代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142.text/* * Lab 3: Your code here for generating entry points for the different traps. */TRAPHANDLER_NOEC(_divide, T_DIVIDE)TRAPHANDLER_NOEC(_debug, T_DEBUG)TRAPHANDLER_NOEC(_nmi, T_NMI)TRAPHANDLER_NOEC(_brkpt, T_BRKPT)TRAPHANDLER_NOEC(_oflow, T_OFLOW)TRAPHANDLER_NOEC(_bound, T_BOUND)TRAPHANDLER_NOEC(_illop, T_ILLOP)TRAPHANDLER_NOEC(_device, T_DEVICE)TRAPHANDLER_NOEC(_dblflt, T_DBLFLT)TRAPHANDLER(_tss, T_TSS)TRAPHANDLER(_segnp, T_SEGNP)TRAPHANDLER(_stack, T_STACK)TRAPHANDLER(_gpflt, T_GPFLT)TRAPHANDLER(_pgflt, T_PGFLT)TRAPHANDLER_NOEC(_fperr, T_FPERR)TRAPHANDLER_NOEC(_align, T_ALIGN)TRAPHANDLER_NOEC(_mchk, T_MCHK)TRAPHANDLER_NOEC(_simderr, T_SIMDERR)TRAPHANDLER_NOEC(_syscall, T_SYSCALL)/* * Lab 3: Your code here for _alltraps */_alltraps: pushw $0x0 pushw %ds pushw $0x0 pushw %es pushal movw $(GD_KD), %ax ; Note that ds and es can not be assigned straightly by immediates movw %ax, %ds movw %ax, %es pushl %esp call trap 在trap.c中的部分就比较简单了，只需要阅读一下SETGATE这个宏的具体定义(位于inc/mmu.h)，明确各个参数的作用就可以做了： 1#define SETGATE(gate, istrap, sel, off, dpl) gate：这个异常在IDT中的异常描述符 istrap：如果是异常则为1，中断则为0 sel：异常处理函数的数据段，这里显然是内核代码段GD_KT(各个段选择符的定义在inc/memlayout.h中有) off：异常处理函数首地址的偏移，这里可以使用对应的函数指针 dpl：这个异常处理函数能被什么权限级的进程显式调用(使用int指令) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// Declarationsvoid _divide();void _debug();void _nmi();void _brkpt();void _oflow();void _bound();void _illop();void _device();void _dblflt();void _tss();void _segnp(); void _stack(); void _gpflt(); void _pgflt(); void _fperr(); void _align(); void _mchk();void _simderr();void _syscall();voidtrap_init(void)&#123; extern struct Segdesc gdt[]; // LAB 3: Your code here. SETGATE(idt[0], 1, GD_KT, _divide, 0); SETGATE(idt[1], 1, GD_KT, _debug, 0); SETGATE(idt[2], 1, GD_KT, _nmi, 0); SETGATE(idt[3], 1, GD_KT, _brkpt, 3); SETGATE(idt[4], 1, GD_KT, _oflow, 0); SETGATE(idt[5], 1, GD_KT, _bound, 0); SETGATE(idt[6], 1, GD_KT, _illop, 0); SETGATE(idt[7], 1, GD_KT, _device, 0); SETGATE(idt[8], 1, GD_KT, _dblflt, 0); SETGATE(idt[10], 1, GD_KT, _tss, 0); SETGATE(idt[11], 1, GD_KT, _segnp, 0); SETGATE(idt[12], 1, GD_KT, _stack, 0); SETGATE(idt[13], 1, GD_KT, _gpflt, 0); SETGATE(idt[14], 1, GD_KT, _pgflt, 0); SETGATE(idt[16], 1, GD_KT, _fperr, 0); SETGATE(idt[17], 1, GD_KT, _align, 0); SETGATE(idt[18], 1, GD_KT, _mchk, 0); SETGATE(idt[19], 1, GD_KT, _simderr, 0); SETGATE(idt[48], 1, GD_KT, _syscall, 3); // Per-CPU setup trap_init_percpu();&#125; Questions Q：为什么我们要对每一个中断或异常使用一个单独的函数，而不是用一个函数处理所有中断？ A：CPU对于不同异常在错误码是否压入方面的处理是不一样且不可见的。 Q：评测系统希望softint生成一个异常13(一般保护)，但user/softint.c中的代码触发的是异常14(缺页异常)，为什么错误的代码能够得到正确的结果？如果user/softint.c真的触发了缺页异常，又会发生什么？ A：查看softint.c，可以发现它直接用内联汇编执行了int $14，强行触发一个缺页错误。根据缺页中断的定义和处理方式，缺页中断不能由用户进程显式触发(也就是其dpl为0)，因而softint试图触发它的操作非法，使操作系统抛出一般保护异常来处理这个非法行为。 一旦用户能够显式触发缺页错误，操作系统就会去根据触发中断的指令判断它所访问的内存位置，但这个缺页中断并非由访存指令引起，因而操作系统无法处理这个异常，可能会引起系统崩溃。 现在运行make grade，Part A 30/30大成功，这样Part A就结束了，下面进入Part B。 Part B Page Faults, Breakpoints Exceptions, and System Calls现在JOS已经有了基本的异常处理能力，但是我们需要继续完善它以让它支持一些更强大的功能。 Handling Page Faults缺页中断比大部分中断特殊，在缺页中断触发时，操作系统会将触发中断的指令储存到cr2寄存器中。我们在trap.c中提供了page_fault_handler()函数来处理缺页错误。 Exercise 5 修改trap_dispatch函数来将缺页异常派发给page_fault_handler()。 这是送分题啊同学们！ 12345678910111213141516171819static voidtrap_dispatch(struct Trapframe *tf)&#123; // Handle processor exceptions. // LAB 3: Your code here. if (tf-&gt;tf_trapno == T_PGFLT) &#123; page_fault_handler(tf); &#125; // Unexpected trap: The user process or the kernel has a bug. print_trapframe(tf); if (tf-&gt;tf_cs == GD_KT) panic("unhandled trap in kernel"); else &#123; env_destroy(curenv); return; &#125;&#125; 这个函数完成之后，执行make grade应该能拿到总分的前50分了。如果这其中有哪个test没有通过，最好先修好再继续做下面的部分。 The Breakpoint Exception断点异常是专门为调试器而准备的异常。调试器在源程序中插入断点时，其实是在断点位置的指令中插入了一句int $3代码(int $3只占1个字节，因此可以替换掉指令的OPCODE)，触发一个断点异常来让程序暂停。 在JOS中这个异常的功能略有不同，它可以唤醒JOS的monitor，并将这个monitor作为一个比较低配的debugger(高配还是低配其实是看之前Lab2中在monitor.c中实现了多少有用的函数)。panic函数就是一个使用了int $3的例子。 Exercise 6 修改trap_dispatch函数以让其支持断点异常的处理。 123456789101112131415161718192021222324static voidtrap_dispatch(struct Trapframe *tf)&#123; // Handle processor exceptions. // LAB 3: Your code here. switch (tf-&gt;tf_trapno) &#123; case T_PGFLT: page_fault_handler(tf); break; case T_BRKPT: monitor(tf); break; &#125; // Unexpected trap: The user process or the kernel has a bug. print_trapframe(tf); if (tf-&gt;tf_cs == GD_KT) panic("unhandled trap in kernel"); else &#123; env_destroy(curenv); return; &#125;&#125; Challenge 为monitor.c增加指令使其支持单步调试。 单步调试的开关是EFLAGS中的TF标志位。除了单步调试功能之外，这里我还写了一个打印寄存器的函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// Single-stepintmon_step(int argc, char **argv, struct Trapframe *tf) &#123; tf-&gt;tf_eflags |= 0x100; return -1;&#125;// Dump registersintmon_regs(int argc, char **argv, struct Trapframe *tf) &#123; if (argc != 2) &#123; cprintf("Error: incorrect number of arguments.\n"); return 0; &#125; cprintf("Registers:\n"); if (strcmp(argv[1], "base") == 0) cprintf( "eax: %09x ebx: %09x ecx: %09x edx: %09x\n\edi: %09x esi: %09x ebp: %09x esp: %09x\n", tf-&gt;tf_regs.reg_eax, tf-&gt;tf_regs.reg_ebx, tf-&gt;tf_regs.reg_ecx, tf-&gt;tf_regs.reg_edx, tf-&gt;tf_regs.reg_edi, tf-&gt;tf_regs.reg_esi, tf-&gt;tf_regs.reg_ebp, tf-&gt;tf_regs.reg_oesp ); else if (strcmp(argv[1], "seg") == 0) cprintf( "cs: %x\tds: %x\tss: %x\tes: %x\n", tf-&gt;tf_cs, tf-&gt;tf_ds, tf-&gt;tf_ss, tf-&gt;tf_es ); else if (strcmp(argv[1], "flags") == 0) cprintf( "CF=%d PF=%d AF=%d ZF=%d SF=%d OF=%d\nTF=%d DF=%d IF=%d\n", tf-&gt;tf_eflags &amp; 0x1, tf-&gt;tf_eflags &amp; 0x4, tf-&gt;tf_eflags &amp; 0x10, tf-&gt;tf_eflags &amp; 0x40, tf-&gt;tf_eflags &amp; 0x80, tf-&gt;tf_eflags &amp; 0x800, tf-&gt;tf_eflags &amp; 0x100, tf-&gt;tf_eflags &amp; 0x200, tf-&gt;tf_eflags &amp; 0x400 ); else if (strcmp(argv[1], "ip") == 0) cprintf("eip: %x\n", tf-&gt;tf_eip); else cprintf("Error: Invalid argument.\n"); return 0;&#125; TF置为1时会触发T_DEBUG中断，因此还要修改trap.c使其能够处理这种中断。 Questions Q：根据你初始化IDT的方式，测试文件可能会触发一个断点异常或一般保护异常，这是为什么？如何设置IDT才能正常地触发断点异常？什么样的错误设置会触发一般保护异常？ A：对dpl项的设置决定了测试文件会触发怎样的异常。测试文件是跑在用户进程下的，如果dpl为0，只有内核才能用int显式触发断点异常，那么测试文件的这个操作显然非法，会触发一般保护异常；只要将dpl设为3(用户权限级)，这个异常就可以被用户显式触发，测试文件就能够正常地行为了。 Q：简要描述一下各个测试程序，尤其是softint做了什么。 A：测试程序使用尽量简练的语句触发异常，但有些是通过错误操作间接触发异常，有些(比如softint)是直接用int指令触发异常。 System Calls有关系统调用的概念性知识在计算机系统和操作系统课程中讲的已经足够详细了，此处不再赘述。在JOS中，我们使用int $0x30来进行系统调用。调用号会被放在%eax，而%edx,%ecx, %ebx, %edi和%esi分别用来存放五个参数。系统调用的返回值放在%eax。 6.828在lib/syscall.c中提供了一个系统调用函数syscall()，它用内联汇编描述了上述过程。在完成任务的过程中可以参考它的写法。 Exercise 7 为内核增加系统调用的处理函数。你需要更改kern/trapentry.S和kern/trap.c的trap_init()函数。你还需要在trap_dispatch()中以正确的参数调用syscall()(注意是kern文件夹的syscall而不是lib中的！)处理系统调用，并将返回值通过%eax交还给调用者。 最后，你还需要实现kern/syscall.c中的syscall函数。确保当调用号无效的时候函数返回-E_INVAL。你需要通过调用内核函数处理inc/syscall.h中列出的所有系统调用。 在之前贴出的代码中已经将kern/trapentry.S和kern/trap.c的trap_init()函数修改到符合要求了，这里不重复贴了。修改后的trap_dispatch()代码如下： 123456789101112131415161718192021222324252627282930313233343536373839static voidtrap_dispatch(struct Trapframe *tf)&#123; // Handle processor exceptions. // LAB 3: Your code here. int32_t return_val; switch (tf-&gt;tf_trapno) &#123; case T_PGFLT: page_fault_handler(tf); return; case T_BRKPT: monitor(tf); return; case T_SYSCALL: return_val = syscall( tf-&gt;tf_regs.reg_eax, tf-&gt;tf_regs.reg_edx, tf-&gt;tf_regs.reg_ecx, tf-&gt;tf_regs.reg_ebx, tf-&gt;tf_regs.reg_edi, tf-&gt;tf_regs.reg_esi ); // 系统调用 if (return_val &lt; 0) panic("trap_dispatch: %e\n", return_val); tf-&gt;tf_regs.reg_eax = return_val; // 注意这里要放到tf的eax而非当前eax中！ return; // 注意这里要用return而非break，否则当前环境会被后面的代码销毁 &#125; // Unexpected trap: The user process or the kernel has a bug. print_trapframe(tf); if (tf-&gt;tf_cs == GD_KT) panic("unhandled trap in kernel"); else &#123; env_destroy(curenv); return; &#125;&#125; 接下来是syscall()函数。如果说lib/syscall.c中的syscall函数是用int来真正进行了系统调用，kern/syscall.c中的这个版本就是假的系统调用——它归根结底调用的其实是系统函数，这些系统函数再通过调用链最终抵达lib/syscall.c，进行真正的系统调用。 既然是假的系统调用，这个任务就不需要汇编，按照要求做就行了，没什么难度。 123456789101112131415161718192021222324// Dispatches to the correct kernel function, passing the arguments.int32_tsyscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)&#123; // Call the function corresponding to the 'syscallno' parameter. // Return any appropriate return value. // LAB 3: Your code here. // panic("syscall not implemented"); switch (syscallno) &#123; case SYS_cgetc: return sys_cgetc(); case SYS_cputs: sys_cputs((const char *)a1, a2); return 0; case SYS_getenvid: return sys_getenvid(); case SYS_env_destroy: return sys_env_destroy(a1); default: return -E_INVAL; &#125;&#125; 做完这一步之后，执行make grade进行测试，如果testbss仍然无法通过，说明你的实现存在问题。否则，执行make run-hello测试hello.c，如果其成功打印出hello world并随即触发一个page fault，说明我们的实现没有问题，可以继续。 User-mode Startup所有的用户程序是从lib/entry.S开始运行的。在进行一些初始化操作后，这些代码会调用lib/libmain.c中的libmain()函数。libmain()函数随机调用umain()，也就是user文件夹中某个测试程序的主函数。可以注意到hello.c中程序试图访问thisenv-&gt;env_id，这就是为什么它触发了page fault。 Exercise 8 修改libmain()函数以初始化全局指针thisenv，使其指向envs数组中代表当前用户环境的Env结构体(libmain()已经将envs映射到了UENV地址)。 你可以使用inc/env.h中的sys_getenvid调用。 你以为这是一道送分题，其实是我KENG哒！ 做题之前最好先研究一下env.h中的描述：sys_getenvid()返回的是envid_t数据类型，在env.h的定义中这个四字节数据有三部分： 最高位置零 最低10位用于在envs数组中作为索引 中间21位是Uniqueifier，用于记录这个环境当前是第几次运行 这样看来，如果直接用sys_getenvid()的返回值去当envs数组的索引，Uniqueifier会使索引值过大引发越界错误，所以应当将返回值用ENVX宏处理过后再用于索引。 1thisenv = &amp;envs[ENVX(sys_getenvid())]; 通过研究这道题涉及到的几个文件我们可以稍微了解到运行测试文件的机制。 Page faults and memory protection内存保护是操作系统的一个重要功能，它保证了一个有问题的程序不会破坏掉内核或其他用户环境的内存空间。操作系统的内存保护实现通常要依赖于硬件，因而它要时刻让硬件能够得知哪块内存有效而哪块无效。当程序进行非法的访问操作时，硬件会阻止这一行为并调用IDT中对应的异常处理程序。 一个例子是程序的栈扩充机制。在用户环境创建伊始，我们实现的内核只会为它分配一页大小的栈空间。当用户环境试图将esp减小到超过这一页的下限时，硬件会阻止这一行为并抛出一个异常，操作系统内核处理这个异常，分配一页新的栈空间，并将控制权返还给用户，这样这个操作就变的合法了。通过这种抽象，用户可以认为他有一个无限大小的栈。 在很多系统调用中，用户会向内核传递一个指向一段内存空间的指针，让内核向其中写入数据。这种机制可能会产生两个问题： 如果在内核解引用指针的时候触发了一个page fault，它需要一种机制来使它记得这个错误其实是由用户而非内核引发的。这很重要，因为内核缺页错误比用户缺页错误要严重的多：用户触发缺页错误只会暂停用户进程直到那一页被加载到内存，而内核触发缺页错误会使整个内核暂时停转。 内核在解引用之前需要明确用户对指针指向的区域是否有访问权限。内核本身的权限要大于用户，所以如果不经检查，对某些用户不能访问的区域的访问也不会触发gpflt。这可能被利用于攻击内核或获取信息。 如果我们处理好了这两个问题，内核其实不会因为用户指针的解引用发生page fault。如果它发生了，我们应当让内核panic。 Exercise 9 修改kern/trap.c，使内核在内核代码触发pgflt的时候panic。 阅读kern/pmap.c中的user_mem_assert函数，并实现user_mem_check函数。 修改kern/syscall.c来理智地检查系统调用的参数。 为了检查触发异常的是用户代码还是内核代码，可以检查Trapframe中的cs寄存器值。 第一步注意不要改错了地方，注释有提示我们应修改page_fault_handler函数。在之前关于段的介绍处已经提到了如何根据cs的值来判断特权级，这边直接贴出代码： 12345678910111213141516171819202122232425voidpage_fault_handler(struct Trapframe *tf)&#123; uint32_t fault_va; // Read processor's CR2 register to find the faulting address fault_va = rcr2(); // Handle kernel-mode page faults. // LAB 3: Your code here. // Kernel represents privilege level 0 if ((tf-&gt;tf_cs &amp; 0x3) == 0) panic("Error: page fault triggered by kernel."); // We've already handled kernel-mode exceptions, so if we get here, // the page fault happened in user mode. // Destroy the environment that caused the fault. cprintf("[%08x] user fault va %08x ip %08x\n", curenv-&gt;env_id, fault_va, tf-&gt;tf_eip); print_trapframe(tf); env_destroy(curenv);&#125; 第二步只要对Lab2各个函数的理解足够深就很简单： 12345678910111213141516171819intuser_mem_check(struct Env *env, const void *va, size_t len, int perm)&#123; // LAB 3: Your code here. uintptr_t firstpg = ROUNDDOWN((uintptr_t)va, PGSIZE); uintptr_t lastpg = ROUNDUP((uintptr_t)va + len, PGSIZE); for (; firstpg &lt; lastpg; firstpg += PGSIZE) &#123; pte_t* pg = pgdir_walk(env-&gt;env_pgdir, (void *)firstpg, 0); if (!((*pg &amp; (PTE_P | perm)) == (PTE_P | perm)) || firstpg &gt;= ULIM) &#123; if (firstpg &lt; (uintptr_t)va) user_mem_check_addr = (uintptr_t)va; else user_mem_check_addr = firstpg; return -E_FAULT; &#125; &#125; return 0;&#125; 第三步只需要调用第二步完成的函数即可： 12345678910111213static voidsys_cputs(const char *s, size_t len)&#123; // Check that the user has permission to read memory [s, s+len). // Destroy the environment if not. // LAB 3: Your code here. user_mem_assert(curenv, (void *)s, len, PTE_U); // Print the string supplied by the user. cprintf("%.*s", len, s);&#125; 完成这三步之后，执行make grade进行测试，80/80大成功，Lab 3正式完成。 Lab 4 Preemptive Multitasking在这个lab中你将要完成一个抢占式的(Preemptive)多进程管理系统。在Part A中，你需要实现一个使用轮询调度算法(round-robin)的伪多核CPU，并实现基本的进程管理系统调用；在Part B中，你需要实现一个fork()系统调用；最后在Part C中，你需要实现进程间通信(IPC, inter-process communicating)机制，以及一些硬件中断。 拉取、切换和合并分支的操作和之前相同，在之后不再重复。 Part A Multiprocessor Support and Cooperative Multitasking在这一部分，你需要首先将JOS扩展到支持多核处理，然后实现能够创建新进程的用户系统调用。你还需要实现轮询调度，在这种调度方式中下一个用户环境将在当前用户环境自愿让出CPU之后获取CPU控制权。 Multiprocessor Support我们要在JOS中实现的是对称多处理器模型(SMP, symmetric multiprocessing)，这个模型使所有的CPU对内存和IO等资源拥有平等的使用权。在启动阶段这些处理器可以分为两种：启动处理器(BSP)负责启动和初始化操作系统，而应用处理器(AP)在系统初始化完成后被BSP唤醒运行。 由哪个处理器来担任BSP是由BIOS和bootloader决定的。在我们的JOS中，到现在为止实现的所有代码都是在BSP上运行的。 在使用SMP的系统中，每个CPU都有一个自己的APIC单元(advanced programmable interrupt controller)，这个单元被CPU们用于互相传递中断信号，从而实现一定程度上的互相控制。APIC还会为它所在的CPU提供一个独一无二的标识符。本Lab中的APIC单元实现可以在kern/lapic.c中查看，有几个函数可能会用到： int cpunum()：返回当前正在运行的CPU的ID lapic_startap()：从BSP发送一个STARTUP信号给某个AP来唤醒它 apic_init()：在Part C中我们会编码LAPIC内置的计时器来支持抢占式调度 处理器们访问它们的LAPIC的方式被称为MMIO(memory-mapped IO)，在这种机制下物理内存的一部分与某些IO设备的寄存器是绑定的(硬件层面上)，因而用于访存的指令可以直接用于访问设备寄存器。LAPIC所在的虚拟内存地址位于第二个IO hole(0xFE000000以上)，我们无法用普通的内存映射去访问它。JOS在MMIOBASE处留下了4MB内存，这样我们才有机会去访问这些硬件。 Exercise 1 实现kern/pmap.c中的mmio_map_region函数。它会在kern/lapic.c的lapic_init函数中被调用。为了让对这个函数的测试能够正常运行，你还需要事先完成下一个Exercise。 这个函数将会从虚拟内存空间的MMIO区中分配一块新的内存，并将其映射到需求的物理地址。函数中定义的base是一个指向MMIO区最低空闲地址的static指针，分配内存要从这里开始，且分配完后要更新之。 由于这一片地址是设备存储器而非物理内存，我们需要告诉CPU缓存这片地址是不安全的，为此我们需要在映射内存时将权限位注明PTE_PCD和PTE_PWT。 12345678910111213141516void *mmio_map_region(physaddr_t pa, size_t size)&#123; static uintptr_t base = MMIOBASE; // Your code here: size = ROUNDUP(size, PGSIZE); if (base + size &gt;= MMIOLIM) panic("mmio_map_region: not enough memory"); // 注意这里不要忘记加PTE_W，不然在Exercise 4中会出现内核触发page fault的问题 boot_map_region(kern_pgdir, base, size, pa, PTE_PCD | PTE_PWT | PTE_W); base += size; return (void *)(base-size);&#125; Application Processor Bootstrap在启动各个AP之前，BSP应当首先收集各种系统信息(如：CPU的数目，它们的APIC ID，以及它们的LAPIC所在的MMIO地址)。kern/mpconfig.c中的mp_init()函数从BIOS内存区中的MP配置表中获取这些信息。 kern/init.c中的boot_aps()函数实现了AP的启动过程。AP们在实方式下启动(正如bootloader)那样，因而boot_aps()函数需要将AP的入口代码(位于kern/mpentry.S)拷贝到一个能在实方式下访问的内存地址。和bootloader不同的是，我们对AP入口代码存放的位置有一定的控制权：在JOS中我们把位置确定为MPENTRY_PADDR，但其实任何640KB下的未使用的页对齐的地址都是可以使用的。 之后，boot_aps()向每个AP的LAPIC发送STARTUP信号来启动它们，同时发送的还有每个AP的入口代码所存放的CS：IP位置。在进行一些简单的初始化之后，它将AP们置于保护模式，随后调用同在kern/init.c下的mp_main()函数。 在唤醒下一个AP之前，boot_aps()应当等待当前的AP将一个CPU_STARTED信号通过struct CpuInfo中的cpu_status域发送给它。 Exercise 2 阅读上面提到的三个函数，确保你理解了在AP启动过程中的控制流转移逻辑，然后改动kern/pmap.c中的page_init()函数来避免将MPENTRY_PADDR加入page_free_list，以使我们安全地在这里拷贝和运行AP的启动代码。 在系统的初始化过程中，boot_aps()函数被调用。在mpentry.S中已经使用.public声明了两个标签来定义代码段的开始和结束，boot_aps()利用这两个标签的地址来进行memmove操作，将AP要执行的代码拷贝到内存。接下来，它会设定AP使用的栈地址，并调用lapic_startap()函数来启动AP。最后，它用一个空转的while循环(过于dirty)来等待AP的状态变为CPU_STARTED。 AP启动之后，会开始执行已经加载的mpentry.S中的代码。执行完之后，AP已经从实方式转换为了保护模式，并跳转到了mp_main()函数。在这个函数中AP会切换页目录(切换至kern_pgdir)，初始化LAPIC、用户环境和中断处理，最后设定CpuInfo中的cpu_status字段来告知BPS它已经成功启动。 为了完成这个任务，我们要明确MPENTRY_PADDR的位置是物理内存区，因而修改的部分应当在base mem的初始化部分： 12345678910111213141516171819202122232425262728293031323334voidpage_init(void)&#123; // LAB 4: // Change your code to mark the physical page at MPENTRY_PADDR // as in use size_t i; // 1) First page, ignore it // 2) Base memory(需要改动的只有这一部分) int mmio_index = ROUNDUP(MPENTRY_PADDR, PGSIZE) / PGSIZE; for (i = 1; i &lt; npages_basemem; i++) &#123; if (i == mmio_index) continue; pages[i].pp_ref = 0; pages[i].pp_link = page_free_list; page_free_list = &amp;pages[i]; &#125; // 3) IO hole // Mention that npages_basemem = IOPHYSMEM / PGSIZE // IOPHYSMEM and EXTPHYSMEM is represented by B instead of KB, so div it by PGSIZE. // (Here is no operation, because we do not need to deal with occupied pages.) ; // 4) Extended memory // The question is where is the end of kernel segment. char* end_addr = (char *)envs + sizeof(struct Env) * NENV - KERNBASE; int end_index = (int)(ROUNDUP(end_addr, PGSIZE)) / PGSIZE; for (i = end_index; i &lt; npages; i++) &#123; pages[i].pp_ref = 0; pages[i].pp_link = page_free_list; page_free_list = &amp;pages[i]; &#125;&#125; 在完成这个任务之后，你的代码应当能够通过check_page_free_list测试，但会在check_kern_pgdir测试失败。 Question 比较kern/mpentry.S与boot/boot.S的代码。这两者同样是被加载到KERNBASE之上运行，为什么kern/mpentry.S的代码需要一个多余的宏MPBOOTPHYS来计算它的符号的绝对地址，而不是让链接器去填入这些地址？如果我们不使用这个宏，会发生什么？ 在Lab1对bootloader的研究中，我们可以发现bootloader的链接地址和虚拟地址是完全一致的。因而，链接器填入的各个符号的地址可以直接作为保护模式下的地址去使用。然而mpentry.S没有这一特性，它的链接地址是物理地址，而虚拟地址在内核区，不加转化的话系统根本无法找到代码的位置。 Per-CPU State and Initialization在编写多核操作系统的时候，区分每个CPU的私有状态(per-CPU state)和全局状态是非常重要的。kern/cpu.h在CpuInfo结构体中定义了大部分私有状态。cpunum()函数通过lapic信息来获取当前CPU在cpus数组中的索引，我们也可以使用thiscpu宏，它在展开之后是当前CPU的CpuInfo结构指针。 你需要注意以下私有状态： 每个CPU的内核栈 由于多个CPU可能会同时陷入内核，我们需要为每一个CPU设置一个单独的内核栈，以防不同CPU破坏彼此的栈结构。用于存储每个CPU内核栈的数据结构是percpu_stacks[NCPU][KSTKSIZE]数组，我们需要将这个数组中的每一项映射到虚拟内存空间的指定位置。 CPU 0的内核栈从KSTACKTOP开始向下增长，之后第n个CPU的内核栈从KSTACKTOP - n*KSTKGAP开始向下增长。 每个CPU的TSS和TSS描述符 每个CPU的TSS被储存在其CpuInfo中的cpu_ts中，而对应的TSS描述符被定义在GDT表项gdt[(GD_TSS0 &gt;&gt; 3)+i]中。定义在kern/trap.c中的全局ts变量不再有作用。 每个CPU的当前用户环境指针 每个CPU上正在运行的进程指针位于其CpuInfo中的cpu_env中。 每个CPU的寄存器值 所有寄存器(包括系统寄存器)都是CPU所私有的，因而用于初始化这些寄存器的函数(lcr3，lgdt，lidt等)需要对每个CPU执行一遍。env_init_percpu()和trap_init_percpu()的功能就在于此。 除此之外，如果在之前的Lab中你有设置其他的CPU私有的初始化函数，也要在这里对每个CPU执行。 Exercise 3 修改kern/pmap.c中的mem_init_mp函数以将CPU的内核栈映射到虚拟内存。 1234567891011121314151617static voidmem_init_mp(void)&#123; // LAB 4: Your code here: for (int i = 0; i &lt; NCPU; i++) &#123; boot_map_region ( kern_pgdir, KSTACKTOP - i * (KSTKGAP + KSTKSIZE) - KSTKSIZE, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W ); &#125;&#125; 在完成这个任务之后，我们的代码应当能够通过check_kern_pgdir()测试。 Exercise 4 在kern/trap.c中的trap_init_percpu()函数为BSP初始化了TSS和TSS描述符。它能在Lab3中正常工作，但在其他CPU上运行时会出错。用每个CPU的tss去取代这个函数中的全局变量ts，以使其能够正常工作。 需要改变的也就只有几个量：首先是ts要换成thiscpu-&gt;cpu_ts，然后就是TSS的selector要加一个cpuId&lt;&lt;3，还有就是CPU的栈地址需要改成新的。 123456789101112131415161718192021222324252627voidtrap_init_percpu(void)&#123; // LAB 4: Your code here: int cpuId = thiscpu-&gt;cpu_id; struct Taskstate* curts = &amp;thiscpu-&gt;cpu_ts; // Setup a TSS so that we get the right stack // when we trap to the kernel. curts-&gt;ts_esp0 = KSTACKTOP - cpuId * (KSTKSIZE+KSTKGAP); curts-&gt;ts_ss0 = GD_KD; curts-&gt;ts_iomb = sizeof(struct Taskstate); // Initialize the TSS slot of the gdt. gdt[(GD_TSS0 &gt;&gt; 3) + cpuId] = SEG16(STS_T32A, (uint32_t) (curts), sizeof(struct Taskstate) - 1, 0); gdt[(GD_TSS0 &gt;&gt; 3) + cpuId].sd_s = 0; // Load the TSS selector (like other segment selectors, the // bottom three bicurts are special; we leave them 0) ltr(GD_TSS0 + (cpuId &lt;&lt; 3)); // Load the IDT lidt(&amp;idt_pd);&#125; 在做这个任务的时候一开始犯了一个很低级的错误：在声明curts的时候，直接将其声明为了一个新的Taskstate结构而非结构指针，这直接导致之后的所有操作都没有真正地改变thiscpu-&gt;cpu_ts的值。更致命的是这个Exercise的检查机制并没有查出这个错误，导致这个错误直到Exercise 6才引发了原因不明的Triple fault，给debug工作带来了极大的困难。 这个故事告诉我们，写码需谨慎，三思而后行，不要过了测试就以为没事了 在完成这个任务之后，以CPUS=4的命令行参数运行make qemu，可以得到这样的输出： 123456789check_page_alloc() succeeded!check_page() succeeded!check_kern_pgdir() succeeded!check_page_installed_pgdir() succeeded!SMP: CPU 0 found 4 CPU(s)enabled interrupts: 1 2SMP: CPU 1 startingSMP: CPU 2 startingSMP: CPU 3 starting Locking在现在的代码中，AP在完成自己的初始化之后会进行一个无限循环(什么也不做)。在让它们进一步做出动作之前，我们需要先解决各个CPU在同时运行内核代码时会出现的竞争条件。说到竞争条件，我们首先想到的肯定是加锁——事实上，这里最简单的解决方法就是为内核加一个锁。 大内核锁是一个全局锁，任一个用户环境在陷入内核的时候都要先获取它，并在退出内核时释放它。在这个模型中，在用户模式中的进程可以在任一数量的CPU上并行运行，但同时只能有一个进程处于内核态。 kern/spinlock.h中提供了这个锁的实现kernel_lock和两个函数lock_kernel()与unlock_kernel()，用于方便我们的加锁与开锁操作。我们需要在四个地方使用内核锁： i386_init()：在BSP唤醒其他CPU之前加锁 mp_main()：在初始化AP之后获取锁，然后调用sched_yield()函数来运行用户环境。 trap()：在用户环境陷入内核之前获取锁(注意不要在内核触发中断的时候也试图获取锁死锁警告) env_run()：在切换到用户环境之前释放锁。 Exercise 5 按照上面的要求给内核在适当的位置加锁。 需要加锁的地方有四处： 12345678910111213141516voidi386_init(void)&#123; ... // Lab 4 multitasking initialization functions pic_init(); // Acquire the big kernel lock before waking up APs // Your code here: lock_kernel(); // Starting non-boot CPUs boot_aps(); ...&#125; 123456789101112voidmp_main(void)&#123; ... // Your code here: lock_kernel(); sched_yield(); // Remove this after you finish Exercise 6 // for (;;);&#125; 123456789101112131415voidtrap(struct Trapframe *tf)&#123; ... if ((tf-&gt;tf_cs &amp; 3) == 3) &#123; // Trapped from user mode. // Acquire the big kernel lock before doing any // serious kernel work. // LAB 4: Your code here. assert(curenv); lock_kernel(); ... &#125; ...&#125; 123456789voidenv_run(struct Env *e)&#123; ... // Step 2 unlock_kernel(); env_pop_tf(&amp;e-&gt;env_tf);&#125; 在完成Exercise 6之前，我们暂时还无法我们的解答是否正确。 Question 看上去大内核锁保证了同时只能有一个CPU在内核态运行，为什么我们还是需要将不同CPU的内核栈分开？描述一个不分开内核栈所可能导致的错误场景。 我们研究一下每个CPU开始跑用户环境时的代码： 在mpentry.S中，AP在打开分页机制之后切换了内核栈。如果在这里没有切换到一个独立的内核栈，可以看到接下来就是对mp_main的间接调用(和bootloader中的间接调用原理一致，这里的间接调用是因为刚刚打开分页机制，只有使用绝对地址跳转才能到达0xf0000000以上的高地址，如果直接调用则是相对寻址，仍留在低地址区)，这个调用会有压栈操作，且这个压栈操作发生在mp_main()中上内核锁之前。如果多个AP使用同一个内核栈，并行的压栈操作会引起race。 Challenge 大内核锁虽然方便，但完全限制了内核代码并行的可能性。现代的操作系统更多地使用细粒度锁(fine-grained locking)，也就是用不同的锁去保护不同的共享区域。请尝试用细粒度锁取代大内核锁，以实现JOS内核的并行化。 你可以使用自旋锁来保护以下共享区域： 页管理器 控制台驱动 调度器 你将在Part C中实现的IPC状态 鉴于现在实现细粒度锁可能会为之后的实验埋下潜在的bug，我决定在完成整个6.828之后再来做这个Challenge。 Round-Robin Scheduling你的下一个任务是实现对用户环境的轮询调度。 kern/sched.c中的sched_yield()函数负责从用户环境中选一个运行。它从当前在运行的环境开始在envs数组中循环寻找，找到第一个状态为ENV_RUNNABLE的环境并调用env_run()去运行它。 sched_yield()决不能在两个CPU上运行同一个用户环境。它可以通过环境的状态是否为ENV_RUNNING来辨认这个环境是否已经跑在某个CPU上。 用户环境可以使用sys_yield()系统调用来让内核用sched_yield()将另一个进程调度到CPU。 Exercise 6 在sched_yield()中实现上面描述的机制。别忘了修改syscall()函数来处理新的系统调用sys_yield()。 修改kern/init.c来让三个(或以上)的用户环境同时运行user/yield.c，然后分别以不同的CPU数目运行make qemu，观察结果。在所有进程结束退出之后，kernel monitor应当被唤醒。 由于最开始调用sched_yield的是i386_init()函数，curenv在第一次调用时为0，我们需要额外处理这种情况。其他部分基本照着上面的描述做就没什么问题。 12345678910111213141516171819202122232425262728293031voidsched_yield(void)&#123; struct Env *idle; // LAB 4: Your code here. envid_t curid, i; // Switch the environment if (curenv) &#123; curid = ENVX(curenv-&gt;env_id); i = (curid+1) % NENV; while (i != curid) &#123; if (envs[i].env_status == ENV_RUNNABLE) env_run(&amp;envs[i]); i = (i+1) % NENV; &#125; if (curenv-&gt;env_status == ENV_RUNNING) env_run(&amp;envs[i]); // Find a environment to run &#125; else &#123; for (i = 0; i &lt; NENV; i++) if (envs[i].env_status == ENV_RUNNABLE) &#123; env_run(&amp;envs[i]); &#125; &#125; // sched_halt never returns sched_halt();&#125; 修改syscall()函数的时候最好去看一下新的调用对应的调用号。 123456789101112131415161718192021222324252627int32_tsyscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)&#123; // Call the function corresponding to the 'syscallno' parameter. // Return any appropriate return value. // LAB 3: Your code here. // panic("syscall not implemented"); switch (syscallno) &#123; case SYS_cgetc: return sys_cgetc(); case SYS_cputs: sys_cputs((const char *)a1, a2); return 0; case SYS_getenvid: return sys_getenvid(); case SYS_env_destroy: return sys_env_destroy(a1); case SYS_yield: sys_yield(); return 0; default: return -E_INVAL; &#125;&#125; 最后是修改kern/init.c，为了让它运行user/yield.c三次，我们需要连续以user_yield(而非一开始默认的user_primes)调用ENV_CREATE函数三次： 123456789#if defined(TEST) // Don't touch -- used by grading script! ENV_CREATE(TEST, ENV_TYPE_USER);#else // Touch all you want. ENV_CREATE(user_yield, ENV_TYPE_USER); ENV_CREATE(user_yield, ENV_TYPE_USER); ENV_CREATE(user_yield, ENV_TYPE_USER);#endif // TEST* 全部完成后，我们以make qemu打开qemu，可以看到： 123456789101112131415161718192021222324252627Hello, I am environment 00001000.Hello, I am environment 00001001.Hello, I am environment 00001002.Back in environment 00001000, iteration 0.Back in environment 00001001, iteration 0.Back in environment 00001002, iteration 0.Back in environment 00001000, iteration 1.Back in environment 00001001, iteration 1.Back in environment 00001002, iteration 1.Back in environment 00001000, iteration 2.Back in environment 00001001, iteration 2.Back in environment 00001002, iteration 2.Back in environment 00001000, iteration 3.Back in environment 00001001, iteration 3.Back in environment 00001002, iteration 3.Back in environment 00001000, iteration 4.All done in environment 00001000.[00001000] exiting gracefully[00001000] free env 00001000Back in environment 00001001, iteration 4.All done in environment 00001001.[00001001] exiting gracefully[00001001] free env 00001001Back in environment 00001002, iteration 4.All done in environment 00001002.[00001002] exiting gracefully[00001002] free env 00001002 可以看到，单核模式下，各个用户环境是以轮询的方式依次被调度的。 以make qemu CPUS=2再次运行qemu，可以发现iteration的顺序被稍微打乱了。继续增加CPUS的个数到3，运行结果显示： 123456789101112131415161718192021222324252627Hello, I am environment 00001000.Hello, I am environment 00001001.Hello, I am environment 00001002.Back in environment 00001000, iteration 0.Back in environment 00001001, iteration 0.Back in environment 00001002, iteration 0.Back in environment 00001000, iteration 1.Back in environment 00001001, iteration 1.Back in environment 00001002, iteration 1.Back in environment 00001000, iteration 2.Back in environment 00001001, iteration 2.Back in environment 00001002, iteration 2.Back in environment 00001000, iteration 3.Back in environment 00001001, iteration 3.Back in environment 00001002, iteration 3.Back in environment 00001001, iteration 4.Back in environment 00001002, iteration 4.Back in environment 00001000, iteration 4.All done in environment 00001001.All done in environment 00001002.All done in environment 00001000.[00001001] exiting gracefully[00001001] free env 00001001[00001002] exiting gracefully[00001002] free env 00001002[00001000] exiting gracefully[00001000] free env 00001000 可以发现，三个用户环境在三个AP上可以完全并行运行。继续增加CPUS也不会改变这个结果。 Questions Q：在env_run函数的实现中你应该调用过lcr3()函数。在这个调用的之前和之后，你的代码都对函数的参数e进行了引用。为什么在系统的页目录改变过的情况下，我们仍能安全地对e解引用？ A：e是一个指向Env结构的指针，而所有的Env结构在虚拟内存空间中的映射地址都是UENVS-UPAGES的那片区域，这个区域在所有的用户环境中都是相同的，就算页目录切换了，e也只会指向相同的内容。 Q：在内核进行用户环境切换的时候，它必须保证旧用户环境的寄存器被妥善保存以便之后的恢复。这个过程是什么时候进行的？ A：用户环境申请环境切换是通过系统调用进行的，这就一定会触发中断从而进入trapentry.S中，系统会在那里在栈上构建出一个Trapframe并赋给用户环境的env_tf属性，从而保存用户环境的寄存器。如果是内核自己唤醒一个用户环境，curenv应该是NULL，也就没什么好保存的了。 Challenge 用一个不那么简单的调度策略取代我们现在使用的轮询调度，比如UNIX风格的可调整的优先调度，或者更复杂的彩票调度(给每个进程发一定数量的彩票，每次调度都开票并切换到中彩的那个进程)或步幅调度。 改进Env结构以使其能够保存处理器的浮点数相关状态，并更改相关代码以使这些状态能够正确地被保存和复原，以使JOS支持浮点操作。FXSAVE和FXRSTOR操作也许会有帮助。 同理，这种改进型的挑战留到整个6.828完成之后再做。 System Calls for Environment Creation虽然现在你的内核已经可以在不同用户环境之下自由切换，但所有的进程仍然是在i386_init()函数中由内核一次创建的。我们应当实现能让用户环境自行创建新进程的系统调用。 UNIX系统提供了fork()调用作为进程创建工具。它会将父进程的整个地址空间完整地拷贝给子进程，因而创建之初两个进程唯一的区别是pid和ppid。在之后，由于两个进程的地址空间不共享，它们的地址空间会逐渐出现差别。 我们在这里需要实现一个不同的(更加原始的)系统调用集： sys_exofork()：这个调用创建一个近乎空白的进程——它的用户部分地址空间是空的，而且它不能运行。两个环境在一开始会享有相同的寄存器状态。在父进程中，这个调用会返回子进程的pid(或一个负数错误码)；在子进程它会返回0。(由于子进程的状态是不可运行，其实这个调用不会在子进程中返回，除非父进程手动改变它的状态) sys_env_set_status()：用于设置一个进程的状态为RUNNABLE或者NOT_RUNNABLE。这个调用用于在子进程的初始化完成之后将其标记为可以运行。 sys_page_alloc()：分配一块物理内存并将其映射到指定进程的指定地址。 sys_page_map()：将一个进程的一块内存映射拷贝给另一个进程，从而实现两个进程之间的共享内存 sys_page_unmap()：取消一个进程中某个地址的内存映射 在以上所有函数中，进程号0代表着当前进程。kern/env.c中的envid2env()函数包含了这种转换机制。 Exercise 7 实现之前描述的五个系统调用，并确保syscall()函数会调用它们。 现在，在你使用envid2env()的时候，可以直接将checkperm参数置为1。如果你发现有的系统调用参数无效，应当返回-E_INVAL。 sys_exofork()的难点应该就在如何让子进程的这个系统调用返回0上。我们在上一个Lab中知道，在父进程发出系统调用请求之后会触发中断，控制流转移到trap.c，并进入trap_dispatch()函数。我们可以发现对系统调用返回值的处理是在这里进行的，方式是设置env_tf中的eax寄存器值。 我们应该注意到，进行系统调用的只有父进程，子进程本身是没有发生中断的，它只会从其地址空间中eip所指定的代码段开始继续运行。因此，整个trap.c或syscall.c的处理是不会影响到子进程的，我们可以直接将子进程tf中的eax设置为0，而在sys_exofork()中返回子进程的pid，把父进程的返回值交给trap_dispatch()来处理。 1234567891011121314151617181920static envid_tsys_exofork(void)&#123; // LAB 4: Your code here. struct Env* new_env; int err; err = env_alloc(&amp;new_env, curenv-&gt;env_id); if (err &lt; 0) return err; new_env-&gt;env_status = ENV_NOT_RUNNABLE; new_env-&gt;env_tf = curenv-&gt;env_tf; // we don't need to change new_env's ip here // since the ip of curenv points to the caller code at 0x8000e0 new_env-&gt;env_tf.tf_regs.reg_eax = 0; return new_env-&gt;env_id;&#125; sys_env_set_status()不难实现，仔细读一下注释和envid2env函数的定义就可以了。 123456789101112131415161718static intsys_env_set_status(envid_t envid, int status)&#123; // LAB 4: Your code here. struct Env* env; int err; if (status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE) return -E_INVAL; err = envid2env(envid, &amp;env, 1); if (err &lt; 0) return err; env-&gt;env_status = status; return 0;&#125; 接下来的三个函数也没什么难点，主要考察对注释中细节的考量和对之前Lab中自己实现的函数的熟悉程度以及英语阅读理解能力。 123456789101112131415161718192021222324252627282930313233static intsys_page_alloc(envid_t envid, void *va, int perm)&#123; // LAB 4: Your code here. int err; struct Env* env; struct PageInfo* pg; // Inappropriate va if ((uintptr_t)va &gt;= UTOP || (uintptr_t)va % PGSIZE) return -E_INVAL; // Inappropriate perm if (!(perm &amp; (PTE_U | PTE_P)) || perm &amp; ~PTE_SYSCALL) return -E_INVAL; err = envid2env(envid, &amp;env, 1); // Inappropriate envid if (err &lt; 0) return -E_BAD_ENV; pg = page_alloc(ALLOC_ZERO); // Out of memory if (pg == NULL) return -E_NO_MEM; err = page_insert(env-&gt;env_pgdir, pg, va, perm); // Failed to insert page if (err &lt; 0) &#123; page_free(pg); return err; &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344static intsys_page_map(envid_t srcenvid, void *srcva, envid_t dstenvid, void *dstva, int perm)&#123; // LAB 4: Your code here. int err; struct Env* srcenv; struct Env* dstenv; struct PageInfo* pg; pte_t* pg_ptr; // Inappropriate va if ( (uintptr_t)srcva &gt;= UTOP || (uintptr_t)srcva % PGSIZE || (uintptr_t)dstva &gt;= UTOP || (uintptr_t)dstva % PGSIZE ) return -E_INVAL; // Inappropriate perm if (!(perm &amp; (PTE_U | PTE_P)) || perm &amp; ~PTE_SYSCALL) return -E_INVAL; // Inappropriate envid err = envid2env(srcenvid, &amp;srcenv, 1); if (err &lt; 0) return -E_BAD_ENV; err = envid2env(dstenvid, &amp;dstenv, 1); if (err &lt; 0) return -E_BAD_ENV; // Page not exist pg = page_lookup(srcenv-&gt;env_pgdir, srcva, &amp;pg_ptr); if (pg == NULL) return -E_INVAL; // Page-permission if (!(*pg_ptr &amp; PTE_W) &amp;&amp; (perm &amp; PTE_W)) return -E_INVAL; // Page-insertion err = page_insert(dstenv-&gt;env_pgdir, pg, dstva, perm); if (err &lt; 0) return -E_NO_MEM; return 0;&#125; 1234567891011121314151617181920static intsys_page_unmap(envid_t envid, void *va)&#123; // LAB 4: Your code here. int err; struct Env* env; // Inappropriate environment err = envid2env(envid, &amp;env, 1); if (err &lt; 0) return -E_BAD_ENV; // Inappropriate page if ((uintptr_t)va &gt;= UTOP || (uintptr_t)va % PGSIZE) return -E_INVAL; page_remove(env-&gt;env_pgdir, va); return 0;&#125; 完成之后，运行make grade应该能看到Part A的dumbfork测试通过。至此Part A结束。 Challenge 为JOS添加一些系统调用以读取curenv的所有重要状态，或对这些状态进行设置。这种系统调用可以用于实现进程的checkpoint与restore。 在实现这些系统调用之后，编写一个用户程序，它创建一个子进程并运行一段时间，然后获取这个子进程的checkpoint，再在子进程继续运行一段时间之后进行restore。通过这种机制，你可以不断重播一个子进程的某一执行过程。 Part B Copy-on-Write Fork我们现在采取的fork策略是在产生新进程的同时将整个父进程的地址空间中所有页的内容拷贝到子进程中，而这是非常低效的方式。尤其是，子进程一般只会使用父进程地址空间中的一小部分内容。 因而，现代Linux操作系统采取的策略一般是让新创建出的子进程与父进程共享内存直到它们中的一个真正去改变共享的一块内存。这种广为人知的策略被称为“写时复制”。 写时复制的详细机制是，在fork操作执行后只将父进程的页目录拷贝给子进程(而不拷贝页的内容)，同时将所有的已共享的页面标记为只读的。这样一来，当两个进程之一试图去访问这块内存时，就会触发一个page fault，内核判断出这个错误是因为写时复制引发的，于是它为那个引发错误的进程分配一块内容相同的可写的新页面并将引发错误的地址重新映射到这个页面上。 接下来你需要以一个用户库函数的方式实现上面描述的fork()。不将其作为内核函数的目的是让内核保持简洁，而且用户可以以修改库函数的方式更方便地去定制自己需要的fork()版本。 User-level page fault handling为了实现用户级的写时复制，我们首先需要让用户具有获知和处理由写权限问题引发的Page fault的能力。 要赋予用户进程这种权限，我们需要为Env结构增加一个成员——env_pgfault_upcall，它是一个函数指针，指向用户进程提供的一个page fault处理函数。为了让用户能够向内核注册这个处理函数，我们提供了新的系统调用sys_env_set_pgfault_upcall。 Exercise 8 实现sys_env_set_pgfault_upcall系统调用。这是一个危险的系统调用，因此一定要在查找目标环境的时好好利用权限检查参数。 实现完系统调用函数之后一定不要忘记把它的入口加到syscall函数里，这点很重要。(我才不会说我直到Exercise 11才发现自己没修改syscall函数) 123456789101112131415static intsys_env_set_pgfault_upcall(envid_t envid, void *func)&#123; // LAB 4: Your code here. int err; struct Env* env; err = envid2env(envid, &amp;env, 1); if (err &lt; 0) return -E_BAD_ENV; env-&gt;env_pgfault_upcall = func; return 0;&#125; Normal and Exception Stacks in User Environments在正常情况下，用户环境所使用的程序栈应当是USTACKTOP开始向下增长的用户栈，但如果用户环境需要去处理一个page fault，它就必须切换栈。我们可以让JOS去建立一个新的异常处理栈，并替用户进程将程序栈自动切换到这个异常栈。 JOS早就为这个栈规划好了位置：它从UXSTACKTOP开始向下增长，最大大小为一个PGSIZE。用户的PGFLT处理函数应当用系统调用来调整内存映射关系使其正确，然后通过一小段汇编代码返回到原来的栈。 用户异常栈默认是未分配内存的，因此所有想要使用这个异常栈的进程都需要自己使用sys_page_alloc()系统调用来为这个栈分配内存。 Invoking the User Page Fault Handler你现在需要修改kern/trap.c中的异常处理函数来以用户提供的方法处理缺页异常。我们将错误发生时用户环境所处的状态称为异常时状态(trap-time state)。 如果用户环境没有提供异常处理程序，内核像往常一样直接销毁用户进程；否则，内核在用户异常栈上建立一个UTrapframe，并让用户进程在异常栈上运行处理程序。 如果用户进程在处理缺页错误的期间再次触发了缺页错误，不要重新从UXSTACKTOP开始建立异常栈，而是在当前的异常栈上压入一个32位空数据，然后建立新的UTrapframe。(要检查发生缺页错误时用户进程是否在处理缺页错误，只需检查tf-&gt;tf_esp是否位于UXSTACKTOP-PGSIZE和UXSTACKTOP-1之间，包括边界)。 Exercise 9 完善page_fault_handler()以实现上面描述的机制，注意做好对异常栈的权限检查。 这个任务的重点是搞清楚curenv-&gt;env_tf、tf和utf三个Trapframe之间的关系。 回顾之前实现的env_run函数可以发现，curenv-&gt;env_tf是用于在这个进程被调度时恢复其上下文。我们需要在这个系统调用中将控制权转交给用户进程，并让其执行它所注册的异常处理函数，这就需要分别修改curenv-&gt;env_tf中的eip和esp为异常处理函数的首地址与用户异常栈中UTrapframe后的地址。 从tf到utf其实就是内核的中断处理程序将控制权交给了用户进程，中间并没有发生其他的中断，因而tf和utf的含义作用都差不多相同，完全可以将tf的大部分信息原样拷贝给utf。 回顾trap函数可以发现，tf在此时与curenv-&gt;env_tf指向的是相同的东西，也就是修改两者其实是等效的。换句话说，我们必须注意修改curenv-&gt;env_tf和引用tf的值两个操作的先后顺序，因为在进行前者后tf的值也会改变。 另外，要注意不要每次都用user_mem_assertion去检查整个UXSTACK的权限，而应该每次只检查用户是否有对utf所在的一小片栈内存的写权限。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758voidpage_fault_handler(struct Trapframe *tf)&#123; uint32_t fault_va; // Read processor's CR2 register to find the faulting address fault_va = rcr2(); // Handle kernel-mode page faults. // LAB 3: Your code here. // Kernel represents privilege level 0 if ((tf-&gt;tf_cs &amp; 0x3) == 0) &#123; print_trapframe(tf); panic("Error: page fault triggered by kernel."); &#125; // LAB 4: Your code here. struct UTrapframe *utf; struct Trapframe *curtf = &amp;curenv-&gt;env_tf; uintptr_t stack_addr; // If no handler provided, skip this and destroy the environment. if (curenv-&gt;env_pgfault_upcall != NULL) &#123; if (tf-&gt;tf_esp &gt;= UXSTACKTOP - PGSIZE &amp;&amp; tf-&gt;tf_esp &lt;= UXSTACKTOP - 1) stack_addr = tf-&gt;tf_esp - 4 - sizeof(struct UTrapframe); // Nested page fault else stack_addr = UXSTACKTOP - sizeof(struct UTrapframe); // Usual page fault // Check user's permittion of the exception stack user_mem_assert(curenv, (void *)stack_addr, sizeof(struct UTrapframe), PTE_U | PTE_W); // push a UTrapframe utf = (struct UTrapframe *)(stack_addr); utf-&gt;utf_eflags = tf-&gt;tf_eflags; utf-&gt;utf_eip = tf-&gt;tf_eip; utf-&gt;utf_err = tf-&gt;tf_err; utf-&gt;utf_esp = tf-&gt;tf_esp; utf-&gt;utf_regs = tf-&gt;tf_regs; utf-&gt;utf_fault_va = fault_va; // Set entry point curtf-&gt;tf_eip = (uintptr_t)curenv-&gt;env_pgfault_upcall; curtf-&gt;tf_esp = stack_addr; // Rerun curenv env_run(curenv); &#125; // Destroy the environment that caused the fault. cprintf("[%08x] user fault va %08x ip %08x\n", curenv-&gt;env_id, fault_va, tf-&gt;tf_eip); print_trapframe(tf); env_destroy(curenv);&#125; User-mode Page Fault Entrypoint接下来我们要完成的是在curenv-&gt;env_pgfault_upcall中注册的异常处理程序。这是一段汇编程序，它负责调用C处理函数来处理异常，并在处理完成之后将控制权直接返还给触发中断的代码。 Exercise 10 实现lib/pfentry.S中的_pgfault_upcall过程。 关于调用C程序进行中断处理的汇编代码已经被6.828提供了，我们需要考虑的是如何以恰当的状态返回异常时eip。我们现在可以调度的资源是一个位于栈上的UTrapframe，以及随着上下文的恢复越来越少的可用寄存器。本任务的主要难点是，如何在不影响通用寄存器状态的情况下同时进行栈的切换和控制流的转移。 在即将跳转回异常时eip的时候，我们已经恢复了所有通用寄存器的值和esp的值，这代表着我们既无法利用jmp进行跳转(这需要一个目标地址，而我们不能用寄存器储存这个地址)，又无法直接用ret返回(会改变esp指针的值)。一个自然的解决方案是，在切换栈之前先将异常时eip装载到异常时栈的顶端，并在切换栈的时候将esp的值减小0x4，最后使用ret返回的时候就会取出异常时eip作为返回地址，并使esp的值增大0x4，这样就正好达到了我们的目的。 对于一般的缺页异常，由于栈顶以上是空的，这样做自然没有风险；对嵌套的缺页异常，由于我们之前在两个UTrapframe之间压入了一个32位的空数据，这个padding正好可以装下这个异常时eip。这就是之前我们要压入这个空数据的原因。 12345678910111213141516171819202122232425262728293031// LAB 4: Your code here.movl 0x28(%esp), %eax // trap-time eipsubl $0x4, 0x30(%esp)movl 0x30(%esp), %ebx // trap-time espmovl %eax, (%ebx) // push trap-time %eip onto trap-time stackaddl $0x8, %esp// Restore the trap-time registers. After you do this, you// can no longer modify any general-purpose registers.// LAB 4: Your code here.popaladdl $0x4, %esp// Restore eflags from the stack. After you do this, you can// no longer use arithmetic operations or anything else that// modifies eflags.// LAB 4: Your code here.popfl// Switch back to the adjusted trap-time stack.// LAB 4: Your code here.popl %esp// Return to re-execute the instruction that faulted.// LAB 4: Your code here.ret Exercise 11 实现lib/pgfault.c中的set_pgfault_handler()函数。 这个函数无非就是给之前实现的系统调用套了层壳，并且在进行系统调用之前首先为UXSTACK分配内存。没什么好说的，按照注释完成即可。 12345678910111213141516171819voidset_pgfault_handler(void (*handler)(struct UTrapframe *utf))&#123; int r; if (_pgfault_handler == 0) &#123; // First time through! // LAB 4: Your code here. if ((r = sys_page_alloc(0, (void *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W)) &lt; 0) panic("set_pgfault_handler: %e", r); &#125; // Save handler pointer for assembly to call. _pgfault_handler = handler; if ((r = sys_env_set_pgfault_upcall(0, _pgfault_upcall)) &lt; 0) panic("set_pgfault_handler: %e", r);&#125; 到此为止，运行make grade应当能够通过faulttree之前的所有测试。如果faultalloc和faultallocbad测试出了问题，很可能是没有理解tf和curenv-&gt;env_tf之间的关系；如果faultnostack及其后面的测试出了问题，很可能是user_mem_assertion的调用参数有问题。 Challenge 拓展你的内核实现，使得除了pagefault以外的其他中断也能够由用户来自定义处理程序。 Implementing Copy-on-Write Fork在实现了用户级别的pagefault处理逻辑之后，我们就可以利用这些系统调用来实现一个完整的、写时复制的fork调用了，6.828已经在lib/fork.c中提供了这个函数的框架。 与dumbfork不同的是，fork并不会将页面本身拷贝到新进程，而是拷贝页面的映射关系。fork只有在有进程试图去修改某个页面的时候才会真正地将页面拷贝过来。 fork的基本逻辑如下： 父进程使用之前实现了的set_pgfault_handler()函数来将pgfault函数安装为缺页中断处理程序。 父进程调用sys_exofork()来创建一个子进程。 父进程对每一个UTOP以下的可写的或写时复制的页面调用duppage函数，这个函数会把一个页面以写时复制权限(PTE_COW)映射到子进程中，并将其以写时复制权限重新映射到父进程。 这里的先后顺序很重要，因为xxxxx 以写时复制权限映射是指，取消权限PTE_W以使其不可写，但加上权限PTE_COW以使其区别于普通的只读页。 用户异常栈不能通过这种方式被映射，你需要为子进程分配一个新的页面作为它的异常栈。 fork也需要处理那些不是可写的或写时复制的页面。 父进程为子进程设置相同的pagefault处理程序入口。 父进程将子进程标记为可运行的。 每当其中一个进程试图写一个权限为写时复制的页面时，都会触发pagefault。pgfault处理函数的逻辑如下： 检查错误号是否为FEC_WR(是否是写操作导致了中断)，并检查引发中断的页面的PTE是否是写时复制的。 如果是，分配一个新页面并将原页面的内容拷贝过去，然后将新页面以可读可写权限映射到合适的位置，取代原来的映射。如果不是，panic。 由于fork函数是用户进程执行的函数，它并没有使用pgdir_walk等内核函数的权限和途径。在用户的角度，无论是页目录还是页表都是不可见的。然而，我们又需要对页目录表项的权限位进行判断。JOS采用了一种巧妙的机制来让用户进程们也能访问到pte和pde，那就是UVPT机制。 我们知道，每个4GB虚拟地址空间对应一个页目录，一个页目录包含1024个页表，每个页表有1024页，每页的大小是4KB，最终形成4GB地址空间。在解析一个线性地址时，MMU会跟据其PDX，PTX和OFFSET三个部分依次去在页目录和页表中进行索引。 UVPT是页目录中的一个特殊的表项，它指向的是页目录自身。假设UVPT的索引值是V，如果我们用一个PDX和PTX都是V的线性地址去进行解析，就会发现由于在页目录中对第V个表项的索引仍然是页目录本身的地址，这个地址最终解析出的就是页目录的物理地址。同理，如果PDX为V而PTX不为V，则会解析出各个页表的地址。通过这种方式，用户可以在UVPT内存区中访问到页目录和各个页表。 Exercise 12 按照上面描述的逻辑完成fork()、duppage()和pgfault()三个函数。 memlayout.h中已经根据上面对UVPT机制的定义为我们声明好了uvpd和uvpt两个数组，其中uvpd的内容是所有页表的地址，索引是PDX(addr)；uvpt的内容是页目录中所有的页表表项，所以这里不是用PTX(addr)而是PGNUM(addr)为索引。 对地址的映射分为两步：首先，对于0到USTACKTOP的部分，也就是不包含UXSTACK的整个用户地址空间，我们依次对每一页调用duppage进行映射。注意在映射之前不仅要检查这一页是否有PTE_P | PTE_U，还要检查其所在的页表是否有PTE_P。然后，调用sys_page_alloc系统调用为UXSTACK分配新的内存。 另外需要注意的是，对子进程设置pagefault处理程序是不能用set_pagefault_handler的，而调用sys_env_set_pagefault_handler调用是需要以_pgfault_upcall而不是pgfault为参数的，这个区别很重要。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546envid_tfork(void)&#123; // LAB 4: Your code here. // uvpt and uvpd are defined in memlayout.h: // pte_t uvpt[]; // pde_t uvpd[]; int err; uintptr_t addr; envid_t envid; extern void _pgfault_upcall(); set_pgfault_handler(pgfault); envid = sys_exofork(); if (envid &lt; 0) return envid; if (envid == 0) &#123; // We are the child. // Fix thisenv as we did i dumbfork.c and return 0 thisenv = &amp;envs[ENVX(sys_getenvid())]; return 0; &#125; // We are the parent. for (addr = 0; addr &lt; USTACKTOP; addr += PGSIZE) &#123; if ((uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_U)) &#123; duppage(envid, addr / PGSIZE); &#125; &#125; if ((err = sys_page_alloc(envid, (void *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W)) &lt; 0) return err; if ((err = sys_env_set_pgfault_upcall(envid, _pgfault_upcall)) &lt; 0) return err; if ((err = sys_env_set_status(envid, ENV_RUNNABLE)) &lt; 0) return err; return envid;&#125; 我们将检查页面权限的步骤放到了duppage函数中，这与要求略有不同但效果是一样的。由于是对同一个页面进行映射，这里需要使用的是sys_page_map调用。这个调用可以用来建立一个物理页面到两个虚拟地址空间的映射，也可以用于一个虚拟空间内某个页面的重新映射。 123456789101112131415161718static intduppage(envid_t envid, unsigned pn)&#123; int r; void *pg = (void *)(pn * PGSIZE); if (uvpt[pn] &amp; PTE_W || uvpt[pn] &amp; PTE_COW) &#123; if ((r = sys_page_map(0, pg, envid, pg, PTE_P | PTE_U | PTE_COW)) &lt; 0) return r; if ((r = sys_page_map(0, pg, 0, pg, PTE_P | PTE_U | PTE_COW)) &lt; 0) return r; &#125; else &#123; if ((r = sys_page_map(0, pg, envid, pg, PTE_P | PTE_U)) &lt; 0) return r; &#125; return 0;&#125; 注释中提示我们pgfault函数只需要三个系统调用，需要仔细考虑我们需要哪三个调用。 123456789101112131415161718192021222324252627282930313233343536373839static voidpgfault(struct UTrapframe *utf)&#123; void *addr = (void *) utf-&gt;utf_fault_va; uint32_t err = utf-&gt;utf_err; int r; // Check that the faulting access was (1) a write, and (2) to a // copy-on-write page. If not, panic. // Hint: // Use the read-only page table mappings at uvpt // (see &lt;inc/memlayout.h&gt;). // LAB 4: Your code here. uintptr_t fault_page = ROUNDDOWN((uintptr_t)addr, PGSIZE); if (!( (err &amp; FEC_WR) &amp;&amp; (uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_COW)) ) panic("Page fault at a non-copy-on-write page."); // Allocate a new page, map it at a temporary location (PFTEMP), // copy the data from the old page to the new page, then move the new // page to the old page's address. // Hint: // You should make three system calls. // LAB 4: Your code here. if ((r = sys_page_alloc(0, PFTEMP, PTE_P | PTE_U | PTE_W)) &lt; 0) panic("pgfault: failed to alloc page PFTEMP."); memcpy(PFTEMP, (void *)fault_page, PGSIZE); if ((r = sys_page_map(0, PFTEMP, 0, (void *)fault_page, PTE_P | PTE_U | PTE_W)) &lt; 0) panic("pgfault: failed to remap the faulted page."); if ((r = sys_page_unmap(0, PFTEMP)) &lt; 0) panic("pgfault: failed to unmap the faulted page.");&#125; 实现这三个函数后，代码应当能够通过Part B部分的所有测试。至此Part B结束。 Challenge 实现一种特殊的共享内存的fork：sfork。这种fork会使父子进程共享除栈以外的所有内存空间，只对栈区进行写时复制处理。你可以修改forktree和pingpong两个测试来使用sfork取代fork，你可能会发现能提供thisenv功能的一种新方式。 实现对系统调用的批处理，以减少连续多次系统调用所带来的陷入和离开内核开支。你需要修改系统调用接口来使其支持这个特性，然后修改fork函数以利用这个特性。 Part C: Preemptive Multitasking and Inter-Process communication (IPC)在这一部分你需要实现进程的抢占式非合作调度和进程间的显式消息传递。 Interrupt discipline试着运行user/spin测试程序，我们可以发现用户进程的一个死循环就可以导致整个系统都无法得到CPU的控制权。由于轮询调度的局限性，如果用户进程不主动给出控制权，其他进程和内核就无法获取CPU，这个情况显然不是理想的。我们需要扩展JOS内核以支持外部的硬件中断，以使内核能够从一个运行中的进程那里夺回控制权。 在Lab3中我们处理了各种处理器异常，也就是trap，而设备引起的外部中断IRQ还没有被处理。共有16个可能的IRQ，它们以0-15的顺序被分别映射到IDT中的IRQ_OFFSET-IRQ_OFFSET+15区域。IRQ_OFFSET被选定为一个让IRQ和处理器异常不会重叠的值，以避免一个IDT表项要处理两个中断这样的冲突。 控制外部设备中断的是EFLAGS寄存器中的IF标志位，为了简单起见，我们只在用户模式下允许外部设备中断，而在进入内核的时候关闭外部中断。我们需要保证FL_IF标志在用户环境开始运行时被设置，这样在中断到来时才会经过CPU被我们的处理程序所处理。在此之前，外部中断一直是被屏蔽的。 Exercise 13 修改kern/trapentry.S和kern/trap.c来恰当地处理IRQ们，然后修改env_alloc函数以保证用户进程在能接受外部终端的状态下运行。需要注意，所有IRQ都不会压入error code。 另外，取消sched_halt()函数中sti的注释，这样空闲的CPU就不会屏蔽中断。 由于之前已经写过对trap的处理，这里要写的也是异曲同工。代码难度不大又比较分散，这里就不贴了。 在这个Exercise中一个需要注意的点是关于SETGATE的参数。由于我们要在进入内核时将FL_IF标志重置为0以关闭外部中断，所有能够进入内核的GATE(不管是trap还是interrupt)都要将istrap参数设置为0。这点与注释中对istrap的阐述有所区别，注释的意思似乎是这个参数用于区分是trap还是interrupt，但由于JOS采用了比较简单的外部中断使用策略，只要进入内核就应该关闭外部中断，而istrap参数的真正作用其实是开启和关闭IF标志位，所以我们应当将所有SETGATE函数的istrap参数设置为0。如果不这么做的话，代码无法通过trap函数中的assert(!(read_eflags() &amp; FL_IF));断言。 在完成这个Exercise之后，试着去运行一个包含硬件中断的test可以发现内核会打印出设备中断的Trapframe。 Handling Clock Interrupts为了防止某一个用户进程一直霸占着CPU，我们应重新对硬件进行编程以使其周期性地产生时钟中断以使控制流回到内核，从而调度给另一个进程。 6.828已经在init.c的i386_init函数中写好了对lapic_init和pic_init的调用，它们会设定好产生中断的时钟。我们只需要完成处理这些中断的代码即可。 Exercise 14 修改trap_dispatch函数，使其在接收到一个时钟中断时调用sched_yield去运行另一个用户进程。 加一个case即可(不要漏看了前面的注释，要调用lapic_eoi来通知cpu出现了中断)： 123case IRQ_OFFSET+IRQ_TIMER: lapic_eoi(); sched_yield(); 完成这个任务后，运行make grade应该能拿到65/80的成绩。 Inter-Process communication (IPC)在之前我们一直将注意力集中在保持一种“每个进程都独占CPU”的抽象上面，但操作系统的另一个重要功能是允许各个进程之间进行通信。IPC是进程间交互的强大支持，UNIX的管道机制就是其典型应用。 在JOS中我们不会去涉及一些复杂的进程间通信模型，而是将通信机制简化为两个系统调用：sys_ipc_recv和sys_ipc_try_send。进程用这种机制传递的信息由两部分组成：一个32位整数和一个可选的页面映射。传递页面映射显然可以传递比一个32位整数更多的信息，而且它提供了一种实现共享内存的方便方式。 Sending and Receiving Messages当一个用户进程要接受信息的时候，它会进行sys_ipc_recv系统调用。这个调用会将进程挂起直到任何一个其他进程向其发送信息。这里的“任何一个”是指发送该信息的进程不需要和这个用户进程有任何关系。换句话说，之前在Part A中实现的权限检查并没必要应用到这里，因为一个进程并没法通过发送信息让另一个进程运行失常。 要发送一个信息，进程必须以目标进程的envid和要发送的值为参数调用sys_ipc_try_send。如果目标进程在等待接受状态，这个调用会发送这个值并返回0；否则，它会返回-E_IPC_NOT_RECV来说明情况。 如果sys_ipc_recv的参数是一个UTOP下的虚拟地址dstva，说明接收者希望接受一个页面。当收到页面后，这个调用会将收到的页面映射到dstva，并覆盖掉之前的映射。同理，如果sys_ipc_try_send的参数是一srcva，它会将目前映射在srcva的页面发送给目标进程，同时自己保持原有的映射不变。只要两个进程之一没有声明要发送的是页面，就不会有页面被发送。 在IPC完成后，内核会设置接收者的Env结构的env_ipc_perm成员： 没有接受页面：0 接收到的页面权限为perm：perm Exercise 15 根据上面描述的逻辑实现两个IPC系统调用和包装它们的库函数，并在systemcall函数中添加对这两个调用的处理逻辑。当在这两个调用中使用envid2env函数时，可以将checkperm参数设为0。 要完成这个任务，注释很重要。只要将6.828提供的注释搞清楚了，大部分难点就都被解决了。 另外需要注意的是，在之前Lab3的实现中我们可能对一些不会出现的情况进行了panic处理(比如，env_run调用时当前进程状态不是ENV_RUNNING；syscall函数返回值不为0等)，在这里这些异常情况可能不再异常，因而我们可能会需要取消一些panic语句。 两个系统调用的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344static intsys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)&#123; // LAB 4: Your code here. struct Env* target_env; struct PageInfo* pgptr; pte_t* page; // Bad environment if (envid2env(envid, &amp;target_env, 0) &lt; 0) return -E_BAD_ENV; // Target env is not recving if (target_env-&gt;env_ipc_recving == 0) return -E_IPC_NOT_RECV; // We are at least able to send a value target_env-&gt;env_ipc_recving = 0; target_env-&gt;env_ipc_value = value; target_env-&gt;env_ipc_from = curenv-&gt;env_id; // We need to send a page if ((uintptr_t)srcva &lt; UTOP &amp;&amp; target_env-&gt;env_ipc_dstva != (void *)~0) &#123; if ((uintptr_t)srcva % PGSIZE) return -E_INVAL; if (!(perm &amp; (PTE_U | PTE_P)) || perm &amp; ~PTE_SYSCALL) return -E_INVAL; pgptr = page_lookup(curenv-&gt;env_pgdir, srcva, &amp;page); if (!page) return -E_INVAL; if ((perm &amp; PTE_W) &amp;&amp; !(*page &amp; PTE_W)) return -E_INVAL; if (page_insert(target_env-&gt;env_pgdir, pgptr, target_env-&gt;env_ipc_dstva, perm) &lt; 0) return -E_NO_MEM; target_env-&gt;env_ipc_perm = perm; &#125; else target_env-&gt;env_ipc_perm = 0; target_env-&gt;env_status = ENV_RUNNABLE; target_env-&gt;env_tf.tf_regs.reg_eax = 0; return 0;&#125; 123456789101112131415161718static intsys_ipc_recv(void *dstva)&#123; // LAB 4: Your code here. if ((uintptr_t)dstva &lt; UTOP) &#123; if ((uintptr_t)dstva % PGSIZE != 0) return -E_INVAL; curenv-&gt;env_ipc_dstva = dstva; &#125; else curenv-&gt;env_ipc_dstva = (void *)~0; curenv-&gt;env_ipc_recving = 1; curenv-&gt;env_status = ENV_NOT_RUNNABLE; sched_yield(); return 0;&#125; 包装两个系统调用的库函数代码如下，注意这里注释提示我们选择一个不为0的特殊va来表明我们不希望传递页面映射，这里其实UTOP以上的va都是符合要求的，简单起见我们使用0xffffffff，也就是~0作为这个地址。 1234567891011121314151617181920212223242526272829303132int32_tipc_recv(envid_t *from_env_store, void *pg, int *perm_store)&#123; // LAB 4: Your code here. int err; // We use ~0 to indicate that no page should be sent. if (pg == NULL) err = sys_ipc_recv((void *)~0); else err = sys_ipc_recv(pg); // The system call failed if (err &lt; 0) &#123; if (from_env_store) *from_env_store = 0; if (perm_store) *perm_store = 0; return err; &#125; if (from_env_store) &#123; *from_env_store = thisenv-&gt;env_ipc_from; &#125; if (perm_store) &#123; *perm_store = thisenv-&gt;env_ipc_perm; &#125; return thisenv-&gt;env_ipc_value;&#125; 123456789101112131415161718voidipc_send(envid_t to_env, uint32_t val, void *pg, int perm)&#123; // LAB 4: Your code here. int err; while (1) &#123; if (!pg) err = sys_ipc_try_send(to_env, val, (void *)~0, perm); else err = sys_ipc_try_send(to_env, val, pg, perm); if (err == 0) return; else if (err == -E_IPC_NOT_RECV) sys_yield(); else panic("ipc_send: %e", err); &#125;&#125; 完成之后，别忘了在syscall函数中添加对新的系统调用的判断。 运行make grade，80/80大成功，至此Lab 4结束。 Challenge 修改sys_ipc_try_send()调用的接口，使得ipc_send()函数不使用循环也能实现相同功能。请确保你的实现可以处理多个进程同时试图向一个进程发送消息的情况。 素数筛只是多进程消息传递的妙用之一，请阅读这篇论文的666-667页，然后试着实现矩阵乘法的应用。 Doug McIlroy的幂级数计算器是另一个经典的应用，请阅读这篇论文的661-683页，实现一个幂级数计算器并计算$sin(x+x^3)$的幂级数。 运用这篇论文中阐述的一些技术去优化我们的内核设计，使JOS的消息传递机制更加高效。 Lab 5: File system, Spawn and Shell在这个lab中，我们需要实现加载和运行磁盘上的可执行文件的系统调用spawn。我们还需要改进我们的内核和库函数，使得我们能在控制台上运行一个shell。为了实现这一点，我们还将实现一个简单的文件系统。 在开始之前，我们需要重新运行Lab4的primes、pingpong和forktree三个测试并确保它们的结果仍然是正确的。由于我们还没实现Lab5的一些函数，我们需要注释掉lib/exit.c中的close_all();和kern/init.c中的ENV_CREATE(fs_fs, ENV_TYPE_FS);(并在测试结果正确之后取消注释)。 如果测试无法通过，执行git diff lab4来查看是什么导致了测试失败。修正这些错误直到测试能够通过，在此之前不要开始做Lab5。 Part A File system preliminaries我们要实现的这个文件系统远比UNIX使用的文件系统简单，但是它已经足以支持分层目录结构下的创建、读写、删除等操作。由于JOS是一个单用户操作系统，这个文件系统并没有实现用户权限管理、符号链接、时间戳与设备文件。 On-Disk File System Structure大多数UNIX文件系统将可用的磁盘空间分为两部分：inode区和data区。UNIX文件系统给每一个文件分配一个inode，其中包含了这个文件的重要元数据，如它的stat属性和指向文件内容存放地址的指针。data区则被分割成了更大的(一般是8KB以上)数据块，文件系统会在这些数据块里面存储文件数据和目录元数据。每个目录包含着指向目录中各个文件inode的指针。如果多个目录都包含有指向一个文件inode的指针，那么这个文件被称为是硬链接的。 我们的文件系统使用的是一种简单得多的结构：我们根本不使用inode，而是将所有目录下文件和子目录的元数据直接存储在这个目录的数据区。 无论是文件还是目录，其数据都是分散在磁盘中不相邻的数据块中的，文件系统隐藏了这些细节，只向用户提供读写文件数据的接口。我们的文件系统允许用户直接读取文件夹元数据，这就意味着用户可以自行实现目录扫描而不需要借助额外的系统调用。这种设计的缺点在于用户程序的编写方式与文件系统的数据存储格式挂钩，一旦我们修改了文件系统的实现，所有用户程序也必须重写。 Sectors and Blocks事实上大多磁盘并不能实现字节粒度上的读写，因而它们使用sector作为其读写单位。在JOS中，每个sector的大小是512字节。文件系统则使用block作为其读写单位，每个block必须包含整数个sector。现代的文件系统一般使用比较大的block，因为存储空间越来越大，而以更大的空间粒度又更方便管理。JOS使用的block大小为4096个字节，和虚拟内存中的page大小相同。 Superblocks文件系统经常会在一些特定的位置(比如磁盘的开始或结束处)保留一些数据块来存储描述文件系统整体属性的数据，比如块大小、磁盘大小、根目录位置、上一次挂载时间等。这些块被称为Superblocks。 我们的文件系统只包含一个superblock，也就是磁盘上的block 1，其结构由inc/fs.h中的Super结构来描述。(在Lab1中我们已经知道磁盘的第一个block一般用来存放bootloader和分区表，因而文件系统一般不会去使用block 0) 为了提高文件系统的容灾性，大文件系统一般会使用分布在磁盘各个位置的数个Superblock，这样当某一个Superblock被破坏后，文件系统还能使用其他的来进行恢复。 File Meta-datainc/fs.h中的File结构是描述文件属性的元数据结构，其中包含了文件的名字，属性，大小和组成文件的数据块位置。由于我们并没有使用inode，这些元数据都储存在目录下，在我们访问文件时它们会同时存在于内存和硬盘中。 f_direct数组存储着10个数据块的序号，如果文件的大小小于40KB，这十个数据块就足以存储这个文件；否则，我们还需要分配一个额外的数据块来专门储存更多的数据块序号。这样的一个数据块可以存储1024个额外的数据块序号，也就是说在这种方式下的文件最大可以为4GB。 Directory versus Regular file目录文件和普通文件的区分方式是File结构体中的type属性。文件系统对两者的管理方式是完全相同的，只不过对其中数据结构的解析方式有所区别：目录文件会被解析成为目录下所有文件的File结构数组。文件系统中根目录文件的File结构位于Superblock中。 Part B The File System这个Lab并不要求我们独自实现整个文件系统，而只需要实现磁盘读写，磁盘数据块的分配，文件偏移的映射和几个系统调用。正因为如此，我们必须熟悉6.828提供的部分代码。 Disk Access到现在为止，我们的内核还没有实现任何对硬盘的访问机制。传统的操作系统会在内核中包含一个磁盘接口驱动并向用户进程提供系统调用接口来访问它，但我们采用一种更轻量的办法，即将磁盘驱动作为用户级文件系统环境的一部分。也就是说，我们使用一个特殊的文件系统进程来进行与磁盘的交互。 我们的实现基于polling和PIO而非磁盘设备中断，因为中断驱动的设备驱动需要我们进行额外的中断处理，并将其分派到正确的进程，这是比较复杂的。 EFLGS寄存器中的IOPL标志位是用来控制是否允许保护模式下的代码进行设备IO操作的。通过控制这个标志位，内核可以控制各个用户进程对IO设备的访问权限。在我们的设计中，只有文件系统进程有权访问IO设备。 Exercise 1 i386_init函数通过向env_create函数传递ENV_TYPE_FS参数来创建一个文件系统进程。请修改你的env_create实现使得文件系统进程拥有设备IO权限而其他进程没有。 需要注意四个常量FL_IOPL_x的含义：x所对应的二进制数就是IOPL位将被赋予的值，因而这里我们应当使用FL_IOPL_3。 12345678910111213141516171819voidenv_create(uint8_t *binary, enum EnvType type)&#123; // LAB 3: Your code here. struct Env *new_env; int err = env_alloc(&amp;new_env, 0); if (err) panic("env_create: %e", err); load_icode(new_env, binary); new_env-&gt;env_type = type; // If this is the file server (type == ENV_TYPE_FS) give it I/O privileges. // LAB 5: Your code here. if (type == ENV_TYPE_FS) new_env-&gt;env_tf.tf_eflags |= FL_IOPL_3;&#125; 通过观察GNUMakeFile可以发现，这个lab中以obj/kern/kernel.img作为disk 0而obj/fs/fs.img作为disk 1。在这个实验中我们不能修改disk 0，如果你因为一些原因弄坏了两块磁盘中的一块，可以执行rm obj/kern/kernel.img obj/fs/fs.img和make将两块磁盘重置。 Question 为了保证用户环境切换的时候IO权限设置能够正常地保存，你还需要做些什么？为什么？ 什么都不用做，因为IO权限是由寄存器决定的，而用户环境切换时原有寄存器的值会保存在旧用户环境的tf中，而加载入新用户环境tf中的值，所以其实IO权限是始终跟着用户环境走的。 Challenge 实现一个中断驱动的磁盘访问机制，你可以将其放在内核中或文件系统进程，或甚至为其新建一个专门的进程。 The Block Cache在我们的文件系统中，我们只需要在虚拟内存系统的帮助下实现一个很简单的块缓存。实现块缓存的代码位于fs/bc.c。 我们的文件系统被限制为只能处理3GB大小的磁盘。我们在文件系统进程的虚拟内存空间中留出一块3GB的空间(从0x10000000(DISKMAP)到0xD0000000(DISKMAP+DISKMAX))来映射这块磁盘。我们可以使用diskaddr函数来将磁盘块的序号转换为其在文件系统进程中的映射地址。 由于将整个磁盘读入文件系统进程需要相当长的时间，我们需要实现demand paging机制，即我们只有在触发pagefault时才分配对应的页并从磁盘中拷贝相应的数据。 Exercise 2 实现fs/bc.c中的bc_pgfault和flush_block两个函数。需要注意的细节有： bc_pgfault函数是一个pagefault处理程序，我们可以用Lab4中实现的机制安装它。 注意ide_read的单位是sector而不是block。 flush_block会在必要的时候将一个块写入磁盘。这里的必要是指，当且仅当这个块已经被映射而且是“dirty”的时候。 CPU会在一个页面被修改时将其pte加上一个PTE_D位，表示它是“dirty”的。 在完成操作后，函数应当洗掉页面上的PTE_D标志。 实现bc_pgfault的时候别忘了先在进程里分配好页面，不然user_mem_assert通不过。 1234567891011121314151617181920212223242526272829303132333435static voidbc_pgfault(struct UTrapframe *utf)&#123; void *addr = (void *) utf-&gt;utf_fault_va; uint32_t blockno = ((uint32_t)addr - DISKMAP) / BLKSIZE; int r; // Check that the fault was within the block cache region if (addr &lt; (void*)DISKMAP || addr &gt;= (void*)(DISKMAP + DISKSIZE)) panic("page fault in FS: eip %08x, va %08x, err %04x", utf-&gt;utf_eip, addr, utf-&gt;utf_err); // Sanity check the block number. if (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks) panic("reading non-existent block %08x\n", blockno); // LAB 5: you code here: // We have 8 sectors per block if (sys_page_alloc(0, ROUNDDOWN(addr, PGSIZE), PTE_P | PTE_U | PTE_W) &lt; 0) panic("bc_pgfault: sys_page_alloc failed."); if (ide_read(8*blockno, ROUNDDOWN(addr, PGSIZE), 8) &lt; 0) panic("bc_pgfault: ide_read failed."); // Clear the dirty bit for the disk block page since we just read the // block from disk if ((r = sys_page_map(0, addr, 0, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; 0) panic("in bc_pgfault, sys_page_map: %e", r); // Check that the block we read was allocated. (exercise for // the reader: why do we do this *after* reading the block // in?) if (bitmap &amp;&amp; block_is_free(blockno)) panic("reading free block %08x\n", blockno);&#125; 1234567891011121314151617voidflush_block(void *addr)&#123; uint32_t blockno = ((uint32_t)addr - DISKMAP) / BLKSIZE; if (addr &lt; (void*)DISKMAP || addr &gt;= (void*)(DISKMAP + DISKSIZE)) panic("flush_block of bad va %08x", addr); // LAB 5: Your code here. if (va_is_mapped(addr) &amp;&amp; va_is_dirty(addr)) &#123; if (ide_write(blockno*8, ROUNDDOWN(addr, PGSIZE), 8) &lt; 0) panic("flush_block: ide_write failed."); if (sys_page_map(0, addr, 0, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL) &lt; 0) panic("flush_block: sys_page_map failed."); &#125;&#125; 完成这两个函数后，运行make grade应当能通过check_bc，check_super和check_bitmap三个测试。 Challenge 在我们现在的实现中，当一个块由于pagefauly被读入内存后，它会永远驻留内存。试着实现一个驱逐机制(eviction policy)，将那些不常用到的块从内存中清除掉。CPU会通过设置PTE_A来表示一个页面是否被访问过，可以利用这一点。小心那些dirty的块。 The Block Bitmap在fs_init函数设置好bitmap指针之后，我们就可以将bitmap视为一个块数组，每个元素对应着从diskblock 2开始的一个块。 Exercise 3 以free_block为模板实现fs.c中的allock_block函数，它会找到bitmap中一个空闲的块，将其标识为used，然后返回块序号。在返回之前我们还需要使用flush_block将更新后的bitmap写入磁盘，以保证文件系统的一致性。 虽然这个文件系统用来标识一个块是否空闲的方式有些诡异，但是参考free_block函数就可以知道具体的方式。 123456789101112131415intalloc_block(void)&#123; // LAB 5: Your code here. for (int i = 2; i &lt; super-&gt;s_nblocks; i++) &#123; if (block_is_free(i)) &#123; bitmap[i / 32] &amp;= ~(1&lt;&lt;(i%32)); flush_block(bitmap); return i; &#125; &#125; return -E_NO_DISK; &#125; 完成这个任务后，运行make grade应当能通过alloc_block测试。 File Operations6.828在fs/fs.c中提供了一系列函数，以让我们能够管理File结构，扫描和管理目录，解析绝对路径等。确保你在进行下面的任务之前仔细阅读过这些代码。 Exercise 4 实现file_block_walk和file_get_block两个函数。前者会找到文件中第n个块在物理磁盘中的序号，后者则会进一步找到其在文件系统进程中的虚拟地址。 根据前面我们对文件结构的理解，我们知道需要分别处理n在f_direct数组内和indirect block中两种情况。这个函数的难点主要在新内存块的分配上面，这部分细节特别容易出错。 分配一个新的内存块需要三步： 调用alloc_block函数分配一个块，并检查返回值 调用memset函数将块的内容清零 调用flush_block函数将新的块写入磁盘 1234567891011121314151617181920212223242526272829303132333435static intfile_block_walk(struct File *f, uint32_t filebno, uint32_t **ppdiskbno, bool alloc)&#123; // LAB 5: Your code here. int blockno; if (!ppdiskbno) panic("file_block_walk: ppdiskbno equals 0"); if (filebno &gt;= NDIRECT + NINDIRECT) return -E_INVAL; if (filebno &lt; NDIRECT) &#123; // f-&gt;f_direct[] *ppdiskbno = &amp;f-&gt;f_direct[filebno]; &#125; else &#123; // f-&gt;f_indirect if (f-&gt;f_indirect == 0) &#123; if (alloc) &#123; // Alloc an indirect block for f if ((blockno = alloc_block()) &lt; 0) return -E_NO_DISK; f-&gt;f_indirect = blockno; memset(diskaddr(blockno), 0, BLKSIZE); flush_block(diskaddr(blockno)); &#125; else return -E_NOT_FOUND; &#125; else blockno = f-&gt;f_indirect; *ppdiskbno = diskaddr(blockno) + 4 * (filebno - NDIRECT); &#125; return 0;&#125; file_get_block主要需要注意的问题是如果调用file_block_walk返回了0，我们还需要为这个位置分配一个新的block。 123456789101112131415161718192021222324252627intfile_get_block(struct File *f, uint32_t filebno, char **blk)&#123; // LAB 5: Your code here. uint32_t *pdiskbno; int err = file_block_walk(f, filebno, &amp;pdiskbno, 1); if (err &lt; 0) return err; // If f has not alloced such block, alloc one for it. if (!(*pdiskbno)) &#123; *pdiskbno = alloc_block(); memset(diskaddr(*pdiskbno), 0, BLKSIZE); flush_block(f); flush_block(diskaddr(*pdiskbno)); &#125; if (blk) &#123; *blk = (char *)diskaddr(*pdiskbno); &#125; return 0;&#125; 现在运行make grade的话，你应当能通过testfile之前的所有测试，以及testfile测试本身。 Challenge 文件系统可能因为我们的一些操作而被损坏，比如重启或系统崩溃。试着实现soft update(软更新)或journalling(系统日志)来让文件系统不会因崩溃而损坏，并描述一些新系统能抵抗的崩溃场景。 The file system interface我们现在已经在文件系统进程内部实现了一些关键的功能，但我们还需要提供一些接口以让其他进程也能够使用这些功能。由于其他进程不能直接调用文件系统进程中的函数，我们将会通过建立在IPC机制基础上的RPC(remote precedure call)机制来实现这些接口。 下图是一个RPC的过程： read根据指定的文件描述符将控制流分发给对应的设备读函数，在这里是用来读取磁盘上文件的devfile_read。 devfile_read和其他devfile_函数们共同构成了文件系统接口的客户端，它们的工作方式是类似的，即构造一个请求结构体，调用fsipc函数发送IPC请求，并处理得到的回应。 接口的服务端主体是serve函数，它用一个无限循环不停地试图通过IPC得到一个请求，一旦得到就把请求分发给对应的处理函数，然后通过IPC将返回值发送回去。 处理函数解包请求，调用file_read函数去进行读操作。 还记得我们在Lab4中实现的IPC机制吗？一个IPC操作可以传输一个32位整数和一个页面映射。在这里，我们以RPC请求的服务种类编号作为请求类别，并将请求的所有参数储存在一个union中，将union所在的页面通过IPC发送给文件系统进程。在客户端，我们要共享的页面位于fsipcbuf；在服务端，我们将发送过来的页面映射到fsreq。 请求结果的返回也要借助IPC。大多数RPC只需要返回一个返回码即可，像FSREQ_READ和FSREQ_STAT这样要返回数据的会将数据写到客户端发送来的页面上，由于这个页面是共享的，这就自然地实现了数据传送。FSREQ_OPEN还会额外发送一个Fd page给客户端。 Exercise 5 实现fs/serv.c中的serve_read函数。就像上面说过的，它只需要解析请求报文，以合适的参数调用file_read函数，并将返回值发送回去即可完成任务。你可以参考serve_set_size函数以了解解析报文的方式。 阅读一下fs.h中对struct fsipc的定义，基本知道哪个参数该填什么，然后照着serve_set_size依葫芦画瓢就行了。需要注意的是在之前的描述中官方并没有仔细解释OpenFile结构的含义，最好在开始做之前根据注释研究清楚这个结构各个成员的意义。 OpenFile结构用来标记一个已经打开的文件： 12345678910111213141516struct OpenFile &#123; uint32_t o_fileid; // file id struct File *o_file; // mapped descriptor for open file int o_mode; // open mode struct Fd *o_fd; // Fd page&#125;;struct Fd &#123; int fd_dev_id; off_t fd_offset; int fd_omode; union &#123; // File server files struct FdFile fd_file; &#125;;&#125;; o_fileid：文件的id o_file：存放文件元数据的File结构指针 文件名，大小，类型，内容等等 o_mode：文件的打开方式 o_fd：文件描述符结构指针 fd_dev_id：标识这个文件的设备类型 fd_offset：文件指针目前所在的偏移位置 fd_omode 在完成下面两个任务的时候，不要忘了修改文件指针的位置。 12345678910111213141516171819202122intserve_read(envid_t envid, union Fsipc *ipc)&#123; struct Fsreq_read *req = &amp;ipc-&gt;read; struct Fsret_read *ret = &amp;ipc-&gt;readRet; struct OpenFile *file; int r; if (debug) cprintf("serve_read %08x %08x %08x\n", envid, req-&gt;req_fileid, req-&gt;req_n); // Lab 5: Your code here: if ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;file)) &lt; 0) return r; if ((r = file_read(file-&gt;o_file, ret-&gt;ret_buf, req-&gt;req_n, file-&gt;o_fd-&gt;fd_offset)) &lt; 0) return r; file-&gt;o_fd-&gt;fd_offset += r; return r;&#125; Exercise 6 实现fs/serv.c中的serve_write函数和lib/file.c中的devfile_write函数。 serve_write和serve_read是完全类似的，devfile_write也可以参考其他类似的函数。需要注意的是在抄的时候也要带着理智，要注意函数的真正功能如何。 1234567891011121314151617181920intserve_write(envid_t envid, struct Fsreq_write *req)&#123; if (debug) cprintf("serve_write %08x %08x %08x\n", envid, req-&gt;req_fileid, req-&gt;req_n); // LAB 5: Your code here. int r; struct OpenFile *file; if ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;file)) &lt; 0) return r; if ((r = file_write(file-&gt;o_file, req-&gt;req_buf, req-&gt;req_n, file-&gt;o_fd-&gt;fd_offset)) &lt; 0) return r; file-&gt;o_fd-&gt;fd_offset += r; return r;&#125; 1234567891011121314151617static ssize_tdevfile_write(struct Fd *fd, const void *buf, size_t n)&#123; // LAB 5: Your code here int r; fsipcbuf.write.req_fileid = fd-&gt;fd_file.id; fsipcbuf.write.req_n = n; memcpy(fsipcbuf.write.req_buf, buf, n); if ((r = fsipc(FSREQ_WRITE, NULL)) &lt; 0) return r; return r;&#125; 完成这两个任务后，运行make grade应当能拿到150分中的90分。 Part C Spawning Processes6.828已经提供了spawn函数的实现(lib/spawn.c)，它会创建一个新的子进程，将一个二进制文件从文件系统加载到进程中，然后让子进程开始运行。spawn相当于一个fork后接一个exec。 我们选择spawn而不是exec来实现，因为它不需要那么多内核的帮助。思考一下如果要实现用户级的exec调用需要做哪些事，为什么它更难。 Exercise 7 spawn函数要依赖于新的系统调用sys_env_set_trapframe来初始化新创建的进程。实现这个系统调用，并在syscall中增加对其的处理。 spawn函数的难点已经全被实现好了，我们要实现的这个调用比较简单。 12345678910111213141516171819202122232425static intsys_env_set_trapframe(envid_t envid, struct Trapframe *tf)&#123; // LAB 5: Your code here. // Remember to check whether the user has supplied us with a good // address! struct Env* env; int err; err = envid2env(envid, &amp;env, 0); if (err &lt; 0) return err; if (!tf) panic("sys_env_set_trapframe: tf is null"); env-&gt;env_tf = *tf env-&gt;env_tf.tf_eflags &amp;= ~FL_IOPL_3; env-&gt;env_tf.tf_eflags |= FL_IF; env-&gt;env_tf.tf_cs |= 3; return 0;&#125; 完成这个函数后，运行make grade应当能够通过spawn via spawnhello测试。 Challenge 实现Unix风格的exec函数。 实现mmap风格的内存映射文件，并修改spawn使其能直接从ELF文件映射页面到内存。 Sharing library state across fork and spawn我么知道，UNIX系统下“万物皆文件”，因而管道、IO设备等也都在文件的范畴内。在JOS中，每一种设备都有属于自己的Dev结构，lib/fd.c在这个基础上实现了类UNIX的通用文件描述符接口。每个Fd结构都会指出它设备的类型，大多数函数都只是简单地将操作分发到相应Dev结构中的函数。 lib/fd.c还在每个应用进程的虚拟地址空间建立一个文件描述符表，其地址从FDTABLE(0xd0000000)开始。这个地址保留了一页来保存32个文件描述符，因而每个应用最多也就只能同时打开32个文件。每个文件描述符也在FILEDATA开始的区域拥有一个自已的“数据页”。 由于文件描述符的状态是保存在用户进程的内存空间中的，在fork函数创建的新进程中这些描述符是写时复制的，所以文件状态是被复制了而非共享了。这样一来进程无法去访问不是它们自己打开的文件，管道也无法通过fork去工作。另一方面，spawn产生的新进程在开始运行时是没有打开任何文件的。 我们应当修改fork函数来将一些内存区域标记为共享的。比起强行规定一些区域来作为共享内存，我们可以像PTE_COW一样用页表项中的标志位来决定哪些页是共享的。inc/lib.h中将PTE_SHARE规定为该标志，如果pte有这个标志，它在fork或spawn中应当被直接拷贝到新的内存空间中。 Exercise 8 修改lib/fork.c中的duppage函数来支持上面描述的机制。如果一个pte有PTE_SHARE标志，就直接将映射关系拷贝过去即可。同样地，实现lib/spawn.c中的copy_shared_pages，它应当遍历当前内存空间中全部的页表项，拷贝所有标有PTE_SHARE的映射关系。 为了让新的映射关系保持原来映射中的权限，我们需要用PTE_SYSCALL作为逻辑掩码来取到原来的uvpt[pn]中的权限位： 123456789101112131415161718192021static intduppage(envid_t envid, unsigned pn)&#123; int r; void *pg = (void *)(pn * PGSIZE); if (uvpt[pn] &amp; PTE_SHARE) &#123; if ((r = sys_page_map(0, pg, envid, pg, uvpt[pn] &amp; PTE_SYSCALL)) &lt; 0) return r; &#125; else if (uvpt[pn] &amp; PTE_W || uvpt[pn] &amp; PTE_COW) &#123; if ((r = sys_page_map(0, pg, envid, pg, PTE_P | PTE_U | PTE_COW)) &lt; 0) return r; if ((r = sys_page_map(0, pg, 0, pg, PTE_P | PTE_U | PTE_COW)) &lt; 0) return r; &#125; else &#123; if ((r = sys_page_map(0, pg, envid, pg, PTE_P | PTE_U)) &lt; 0) return r; &#125; return 0;&#125; 注意uvpt数组的索引应当是PGNUM(addr)而不是PTX(addr)。 123456789101112131415161718static intcopy_shared_pages(envid_t child)&#123; // LAB 5: Your code here. int err; uintptr_t addr; for (addr = 0; addr &lt; USTACKTOP; addr += PGSIZE) &#123; if ((uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_SHARE)) if ((err = sys_page_map(0, (void *)addr, child, (void *)addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; 0) return err; &#125; return 0;&#125; 完成这一步之后，代码应当能通过testpteshare和testfdsharing两个测试。 Part D The Keyboard Interface要让一个shell能够工作，我们首先要能向里面打字。到现在为止，我们所进行的输入仅仅是在内核monitor中才能被接受。6.828已经在kern/console.c中实现了键盘和串口的驱动，现在你需要把这些驱动连接到系统的其他部分。 Exercise 9 在kern/trap.c中调用kbd_intr函数和serial_intr函数来分别处理IRQ_KBD中断和IRQ_SERIAL中断。 123456case IRQ_OFFSET+IRQ_KBD: kbd_intr(); return;case IRQ_OFFSET+IRQ_SERIAL: serial_intr(); return; 运行make run-testkbd测试，试着输入几行字，如果有回显则说明功能正常。 Part E The Shell运行make run-icode可以运行6.828提供的shell，我们应当能够在其中运行这些指令： 12345echo hello world | catcat lorem | catcat lorem | numcat lorem | num | num | num | num | numlsfd 注意我们现在的shell使用cprintf函数来进行打印，这会将所有信息直接打印到屏幕，也就是说我们无法进行输入输出的重定向。我们可以使用fprintf来将信息打印到特定的fd，printf是一个打印到fd 1的快捷操作。 Exercise 10 修改user/sh.c中的shell实现，使其支持&lt;重定向。 对照下面的&gt;重定向实现和注释即可完成。 12345678910// LAB 5: Your code here. if ((fd = open(t, O_RDONLY)) &lt; 0) &#123; cprintf("open %s for read: %e", t, fd); exit(); &#125; if (fd != 0) &#123; dup(fd, 0); close(fd); &#125; break; 完成以上所有任务后，运行make grade，150/150大成功，至此lab5结束。 Challenge 完善你的Shell。可以添加的内容包括但不限于： 后台进程，如ls &amp; 串行指令，如make &amp;&amp; rm -rf ./output/ 指令历史记录 tab补全 Ctrl-C结束进程 And more]]></content>
      <categories>
        <category>Academic or Technical</category>
        <category>Operating System</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用自己建造的DockerImage创建k8s容器]]></title>
    <url>%2Fblog%2F2018%2F11%2F24%2F%E7%94%A8%E8%87%AA%E5%B7%B1%E5%BB%BA%E9%80%A0%E7%9A%84DockerImage%E5%88%9B%E5%BB%BAk8s%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[用自己建造的DockerImage创建k8s容器本篇文章记载了定制k8s容器以满足实验需要的具体方法，以供参考。 构建需要的DockerFilekubernetes的Pod是以docker容器为基础的，因此每个pod在创建时都需要提供一个基础的容器镜像。因此，要定制一个符合我们需求的Pod，就需要先定制容器镜像。 Docker提供的定制镜像的方式是 Dockerfile 。关于Dockerfile的具体写法参见Reference 「示例」这是一个简单的CounterImage的DockerFile： 123FROM ubuntu # 每个DockerFile必须在开头用FROM语句指明其母镜像COPY counter.sh /etc/ # COPY指令可以将目标文件拷贝到镜像内的目标目录中RUN chmod +x /etc/counter.sh # RUN指令让目标镜像执行指定指令 用DockerFile建造DockerImage写好DockerFile之后，执行docker build指令来构建镜像。 关于docker build的参数问题 -f &lt;filepath&gt; 指定DokcerFile的位置，默认在当前目录下寻找DockerFile -t &lt;tag&gt; 为创建的镜像指定tag，tag格式一般是&lt;repo&gt;/&lt;imagename&gt;:&lt;version&gt; 执行完毕之后，构建好的DockerImage可以用docker images查看到。 用kubectl创建pod用kubectl构建pod需要用yaml或json文件指定pod的属性。 「示例」这是用于运行CounterImage实例的Pod配置文件 123456789101112131415161718192021222324apiVersion: v1 # 指定k8s版本，一般是v1kind: Pod # 指定要创建的对象的类型，这里是Podmetadata: # 元数据，指定Pod信息 name: testpod # 指定Pod的名称 annotations: # 一些必要的注释，可以用于传递信息spec: # 一些其他信息 containers: # 指定Pod使用的基础镜像 - name: testcontainer # 指定将要创建的容器名称，这个不重要 image: drac/counter:v1 # 指定使用的镜像名称，这里使用刚刚创建的镜像名 imagePullPolicy: "IfNotPresent" # 由于刚刚的镜像并没有上传到远程仓库中，这里需要指定镜像拉取策略为优先使用本地镜像 command: # 指定容器要运行的指令 - "etc/counter.sh" ports: # 指定容器对外开放的端口 - containerPort: 8086 hostPort: 8086 tolerations: # 这个属性与node的taints有关，由于master节点默认不能调度pods，这里要设置一些tolerations - key: "node.kubernetes.io/not-ready" operator: "Exists" effect: "NoSchedule" - key: "node-role.kubernetes.io/master" operator: "Exists" effect: "NoSchedule" 写好配置文件之后，就可以用kubectl create -f &lt;配置文件名&gt;来创建pod了。]]></content>
      <categories>
        <category>Academic or Technical</category>
        <category>Computation Virtualization</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在archlinux上单机搭建kubernetes]]></title>
    <url>%2Fblog%2F2018%2F11%2F04%2F%E5%9C%A8archlinux%E4%B8%8A%E5%8D%95%E6%9C%BA%E6%90%AD%E5%BB%BAkubernetes%2F</url>
    <content type="text"><![CDATA[kubernetes单机搭建流程由于工作需要，今天试着在archlinux主机上搭建了k8s。网上完全没有针对archlinux系统的配置教程，因此踩了很多坑，现将archlinux下的搭建流程记录如下。 具体流程环境配置 docker：k8s中担任container职责的依赖，必须安装 sudo swapoff -a：k8s的运行不支持内存交换，所以要关掉swap分区 ss和privoxy：提供代理环境(k8s的镜像源多是google，而google相关网站大部分被GFW墙掉了) 注意：privoxy的监听端口应配置为8008(kubeadm的默认端口) 安装依赖手动编译kubernetes对内存要求过高，OOM了3次，只好另寻他途。 幸运的是，kubeadm,kubectl,kubelet,kubernetes-cni四项依赖的bin文件都有AUR包，可以用yaourt或者yay来下载。在下载时注意选择二进制文件(即&lt;name&gt;-bin)并提前打开privoxy代理映射。 (注意：这几个包的镜像源服务器都不支持axel，所以请将yay的下载工具换为wget) 初始化集群首先要设置docker的代理(这里的代理端口设置与privoxy的设置保持一致)： 1234567891011121314# 创建conf文件mkdir -p /etc/systemd/system/docker.service.dsudo vim /etc/systemd/system/docker.service.d/http-proxy.conf# 在新建的conf文件中加入如下内容[Service]Environment="HTTP_PROXY=http://127.0.0.1:8008/"# 创建conf文件sudo vim /etc/systemd/system/docker.service.d/https-proxy.conf# 在新建的conf文件中加入如下内容[Service]Environment="HTTPS_PROXY=http://127.0.0.1:8008/"# 重启servicesudo systemctl daemon-reloadsudo systemctl restart docker 执行sudo kubeadm init --pod-network-cidr=10.244.0.0/16，根据显示的提示信息补全依赖，启动service后再次执行。 在init成功后根据显示的提示信息创建config文件。 执行kubectl get pods --all-namespaces，如果正常显示pods信息则说明正常。 接下来安装网络模块(这里使用的是flannel，当然其他模块也可以，只是要在init的时候指定相应的pod-network-cidr)，执行： 1kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/bc79dd1505b0c8681ece4de4c0d86c5cd2643275/Documentation/kube-flannel.yml 安装好flannel模块之后，如果/etc/cni文件夹没有被创建，coredns无法正常创建容器，可以在root身份下执行 1234mkdir -p /etc/cni/net.d/cat &lt;&lt;EOF&gt; /etc/cni/net.d/10-flannel.conf&#123;"name":"cbr0","type":"flannel","delegate": &#123;"isDefaultGateway": true&#125;&#125;EOF 来进行配置。 这里如果出现问题可以参考这篇博客 执行watch kubectl get pods --all-namespaces，等待一到两分钟，所有pods状态都为running则说明安装成功。(期间各种crash都是有可能的，耐心等待它自己重启即可) 部署服务搭建大成功，接下来只要部署具体的service就可以了。 常见问题及解决方案 非root用户使用kubectl时出现错误 错误信息： 1Unable to connect to the server: net/http: TLS handshake timeout 状态：暂未解决 折中方案：将config文件放在root目录的.kube目录下，用sudo运行kubectl flannel网络模块安装之后coredns无法正常创建容器 错误信息： 1Failed create pod sandbox: rpc error: code = Unknown desc = [failed to set up sandbox container &quot;dd087d2655e98a25040f7b041e23dffa59aa52206b921e481ad20781d1de4320&quot; network for pod &quot;coredns-86c58d9df4-gtrt4&quot;: NetworkPlugin cni failed to set up pod &quot;coredns-86c58d9df4-gtrt4_kube-system&quot; network: failed to find plugin &quot;portmap&quot; in path [/opt/cni/bin], failed to clean up sandbox container &quot;dd087d2655e98a25040f7b041e23dffa59aa52206b921e481ad20781d1de4320&quot; network for pod &quot;coredns-86c58d9df4-gtrt4&quot;: NetworkPlugin cni failed to teardown pod &quot;coredns-86c58d9df4-gtrt4_kube-system&quot; network: failed to find plugin &quot;portmap&quot; in path [/opt/cni/bin]] 解决方案： 12345sumkdir -p /etc/cni/net.d/cat &lt;&lt;EOF&gt; /etc/cni/net.d/10-flannel.conf&#123;&quot;name&quot;:&quot;cbr0&quot;,&quot;type&quot;:&quot;flannel&quot;,&quot;delegate&quot;: &#123;&quot;isDefaultGateway&quot;: true&#125;&#125;EOF Pod无法正常创建Container，出现netplugin error 错误信息： 1Failed create pod sandbox: rpc error: code = Unknown desc = failed to set up sandbox container &quot;81e89630eeb39a5c7b24e330082af265d3cd4480c83664316df3bd92fcfaaa91&quot; network for pod &quot;testpod&quot;: NetworkPlugin cni failed to set up pod &quot;testpod_default&quot; network: &quot;cni0&quot; already has an IP address different from 10.244.0.1/24 解决方案： 1234567891011121314# kubeadm reset 过程systemctl stop kubeletsystemctl stop dockerrm -rf /var/lib/cni/rm -rf /var/lib/kubelet/*rm -rf /etc/cni/ifconfig cni0 downifconfig flannel.1 downifconfig docker0 downip link delete cni0ip link delete flannel.1systemctl start kubeletsystemctl start docker# kubeadm init 过程]]></content>
      <categories>
        <category>Academic or Technical</category>
        <category>Computation Virtualization</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Golang练习笔记]]></title>
    <url>%2Fblog%2F2018%2F10%2F29%2FGolang%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Golang练习笔记本文是在进行A TOUR OF GO网站上的练习时所做的笔记，其逻辑顺序与该网站的练习顺序一致。 BasicsPackages与C基于文件不同，Go语言是基于包的，每个Go程序都由包组成。一般来说，一个包内的所有源码文件会放在同一个文件夹下，而这个文件夹的名字会与包的名字一致。 之所以说Go语言基于包，是因为在一个包内的函数和变量(不管它们是否在同一个文件下)是位于同一个作用域下的，也就是说一个文件内的函数可以访问另一个同包文件下的变量。 在编译执行的时候，程序会从main包的main函数开始执行。 Declaring每个Go源码文件必须以一句package声明开始，这个声明指定了这个文件所属的包名。 Importing正如在C语言中包含其他文件，我们也可以在Go语言中包含其他包。可包含的包路径默认是/usr/lib/go/src，我们可以直接到这个路径下去阅读我们所包含的包的源码。 包的包含使用的是import声明，包名是以包路径为基准的相对路径。如： 1234import ( "fmt" "io/ioutil") 包含的是ioutil和fmt两个包。 Go语言推荐的码风是像示例中这样用一个列表来表示要包含的所有包，而非使用很多条import声明(虽然那样是合法的)。 另外，包含了的包一定要使用，否则无法通过编译。一般gofmt工具会自动帮我们去掉没有用过的包。 ExportingGo的变量和函数权限管理是通过它们的名字来进行的。一个首字母大写的标识符被称为Exported，即它可以被其他import了这个包的包所访问到。相应的，首字母小写的标识符只能在所在的包中被访问，即使其他包包含了这个包也不能访问到该标识符。 FunctionsGo的函数可以返回多个值，这是它与C语言函数的最大区别。它的声明格式为： 123func &lt;name&gt;(&lt;param&gt; &lt;paramtype&gt;, [...]) ([retval] &lt;rettype&gt;, [...]) &#123; [...]&#125; Go使用了函数式编程的一些思想，它允许用户将函数作为值来对待。一个函数类型的字面量就是将一个函数的函数名去掉后的部分。 ReturningGo函数的返回有两种形式：一种是只在返回值区域声明返回值的类型，使用return语句来传递返回值(像C那样)；而另一种则是在返回值区域声明返回值名称和类型，通过在函数体中修改返回值名称对应的变量来进行返回值传递，这时return语句后可以不跟任何东西(不推荐这样做，会减小可读性)。 前一种返回机制的优先级要高于后一种，例如： 12345func foo() (x, y int) &#123; x = 1 y = 2 return y, x&#125; 这个函数会返回2 1而不是1 2。 Params对于同类型的参数，有一种简写的方式： 1(x int, y int) &lt;=&gt; (x, y int) 对slice类型参数的改变会影响到函数外。 ClosuresGo允许进行函数闭包(闭包的意思是一个函数能访问不在其内部声明的变量)。官网给出的例子是： 123456789101112131415161718192021package mainimport "fmt"func adder() func(int) int &#123; sum := 0 return func(x int) int &#123; sum += x return sum &#125;&#125;func main() &#123; pos, neg := adder(), adder() for i := 0; i &lt; 10; i++ &#123; fmt.Println( pos(i), neg(-2*i), ) &#125;&#125; 在这个例子中adder函数就返回了一个闭包函数，此例子的运行结果为 123456789100 01 -23 -66 -1210 -2015 -3021 -4228 -5636 -7245 -90 由结果可以发现，一个闭包函数在调用后对母函数中变量的影响是持久性的，母函数中的变量不会在母函数返回后被立即垃圾回收。但是，一个母函数返回的两个闭包函数中访问的母函数变量是独立的两个变量，互相不会影响。 Methods我们可以为一个数据类型(一般是结构，也可以是其他类型)声明它的方法，从而实现类似于类的效果。声明的方式就是在函数名前面加上一个Receiver变量声明。这样一来，我们就可以用&lt;dataTypeInstance&gt;.&lt;method&gt;的方式调用方法了。 注意，Receiver是值传递，也就是只有当Receiver是指针时我们才能在方法内修改调用者的值。在我们需要修改调用者的值时建议将所有Receiver写成指针形式，而在调用者应保持只读时建议将Receiver写成原类型。无论调用者本身是类型t还是*t，都可以用相同的语法调用t或*t的方法。 Go语言允许一个值为nil的Receiver调用方法，因此最好做好对调用者的检查。 VariablesDeclarationGo语言的变量有多种声明方式。 显式声明：var &lt;name&gt; &lt;datatype&gt;，最规范的声明方式，指定了变量的类型 初始化声明：在显式声明的基础上加上了初始化语句，此时可以省略变量类型 短声明：&lt;name&gt; := &lt;value&gt;，只能用在函数内 当一个变量被未初始化地显式声明时，它的值为其类型对应的零值： 数字族：0 布尔类型：false 字符串：&quot;&quot; slice，map，struct，pointer：nil DataTypesfmt.Printf函数中的%T转义可以打印出一个变量的类型。 Go不支持隐式类型转换，显式类型转换的方式与C相同。 Basic types bool string 整型族 有符号类：int，int8，int16，int32，int64 无符号类：uint，uint8，uint16，uint32，uint64，uintptr byte：等价于uint8 rune：用于表示unicode，等价于int32 float32和float64 complex64和complex128 Consts常量可以用const关键字取代var来进行声明。 数字常量会默认采用族里的最高精度类型。 PointersGo的指针不支持算术操作。 Structs声明格式： 1234type &lt;name&gt; struct &#123; &lt;name&gt; &lt;type&gt; ...&#125; 与C不同，Go的结构体指针和结构体本身访问元素的方式都是.。(C的指针会使用-&gt;操作符) 结构体常量的格式为&lt;sturctName&gt;{[kvList]}，如： 12345678910type People struct &#123; Name string Age int&#125;var ( x = People&#123;"Drac", 18&#125; // 依次赋值，必须写全每个成员 y = People&#123;Name: "Lisa"&#125; // 可以为结构成员的名字指定值，此时可以缺省某些成员 z = People&#123;&#125; // 也可以不写任何成员，将所有值初始化为零值) Interfaces接口类型是一个方法的集合。 1234type &lt;name&gt; interface &#123; &lt;names&gt;(&lt;params&gt;) &lt;retType&gt; ...&#125; 一个接口类型可以被赋值为任何实现了接口中包含的所有方法的数据类型实例。 一个接口实例本质上是(value, type)的二元组，两者都可以被改变。因此就算一个接口被一个nil结构体赋值，它的值也不是nil而是(nil, &lt;structName&gt;)。未初始化的接口值为nil，此时不能用这个接口调用任何方法。 要检查一个接口的类型，我们可以使用这样的语法： 1t, ok := &lt;interfaceVar&gt;.(&lt;typename&gt;) 如果不加ok直接赋值的话，若&lt;typename&gt;与&lt;interfaceVar&gt;当前真正的类型不一致就会panic。 空的接口interface {}可以被赋为任何类型的任何值，因而可以作为泛型使用。此时，可以使用一个type-switch结构来处理： 12345678switch v := &lt;interfaceVar&gt;.(type) &#123; case int: ... case string: ... default: ...&#125; 这种结构会将v初始化为&lt;interfaceVar&gt;的value成员，而根据其type成员来选择case。 Errorserror是一种特殊的内建类型，其为nil表示正确，否则表示有错误发生。它定义了自己的String函数，因而可以直接用%v来打印。 注意error其实是一个接口，任意一个定义了Error()方法的类型都能被赋给error。 Arrays &amp; Slices数组类型写作[&lt;n&gt;]&lt;type&gt;，初始化方式类似于结构体。 切片类型写作[]&lt;type&gt;，作用方式类似于Python的数组。 需要注意的是切片是对底层数组的引用，因此在切片初始化时底层数组就已经建立好了，之后无论如何改变切片的size底层数组是不变的，这个切片始终在取底层数组的某一部分。 slice具有两个属性，分别可以用len()和cap()获得： len：slice本身的长度 cap：slice开头到底层数组结尾的长度，即slice可扩展的最大长度 slice对应的零值是nil。 扩展slice可以使用append(&lt;slice&gt;, &lt;element&gt; [, &lt;element&gt; ...])函数，它返回扩展后的slice。如果原始数组不够大，这个函数会自动扩展原始数组。 Mapsmap类型的声明方式为map[&lt;keyType&gt;]&lt;valType&gt;，一个未初始化，值为nil的map是不含任何键也不能添加任何键的。要想创建可以修改的map需要使用make来构造或进行初始化。 初始化map的格式与结构体类似，只不过需要指定每个键值对。 删除一个键值对的方式是delete(&lt;map&gt;, &lt;key&gt;)。 可以用&lt;val&gt;, &lt;err&gt; := &lt;map&gt;[&lt;key&gt;]的方式来取map的成员： 如果&lt;key&gt;存在于&lt;map&gt;中，则&lt;err&gt;为true且&lt;val&gt;为对应的值。 如果&lt;key&gt;不存在于&lt;map&gt;中，则&lt;err&gt;为false且&lt;val&gt;为零值。 Channelschan类型用于在不同goroutine之间传递信息。在声明时必须带上它要传递的变量类型。 假设我们有一个名为ch的channel，则&lt;-ch的值为接收到的信息，ch &lt;- &lt;value&gt;表示发送信息，且前者在后者执行之前一直处于阻塞状态。 使用make(chan c, &lt;bufSize&gt;)可以声明一个buffer channel，这样发送端在缓冲区满之前都不会阻塞。 发送端用close()函数可以显式地关闭一个channel，而接收端可以用for i := range &lt;chan&gt; {}来从channel中取值循环直到channel被关闭。 Make operatorGo中用来构建高级数据类型的内建函数为make。 slice：make([]&lt;type&gt;, &lt;len&gt; [, &lt;cap&gt;]) map：make(map[&lt;keyType&gt;]&lt;valType&gt;) chan：make(chan &lt;dataType&gt; [, &lt;bufSize&gt;]) Control flowLoopGo只支持一种循环：for循环。Go的for循环与C的区别主要有： for与大括号之间的部分不需要加括号 无论循环体多简单大括号都不能省略 在省略init和post两个语句时可以省略分号 可以使用range操作符来在循环中遍历切片： 1for i, v := range list &#123; ... &#125; // i for index, v for value 注意，修改这里的v并不会影响切片中对应元素的值！这里只是简单的值传递而非引用传递。 IfGo的if风格与for类似。除此之外，if语句可以在cond前加一个init语句(两个语句之间用;隔开)，init语句中声明的变量作用于限于这个if块内。如： 123if i := foo(a, b); i &lt; lim &#123; return i&#125; SwitchGo的switch语句功能很强大，与C的区别主要在于： 只会运行选中的case，不需要break语句 case判断条件不需要是常量，也不需要是整数 语法风格的区别类似于if 不带条件的switch适合用来取代长if-else串。 Defer用defer调用的函数会在调用者函数返回时执行。 所有defer的函数会被依次压栈，在执行时再依次出栈执行。 Gogo &lt;funcCall&gt;可以为一个函数开启一个goroutine。 SelectGo原生支持IO多路复用，其格式如下： 1234567select &#123; case &lt;expr&gt;: ... case &lt;expr&gt;: ... [default:]&#125; 与switch不同，select在其中一个&lt;expr&gt;能够运行之前处于阻塞状态，然后去执行第一个可执行的case。如果有多个case可执行，它会随机挑一个。如果select中有default条件，它会在其他case都不可执行时执行。 LibraryfmtStringerfmt包中的各种print类函数都支持以一个Stringer接口作为参数，这个接口要求需要打印的变量类型定义有String() string方法，这个方法将这个变量类型的值变为一个字符串。例如，int类型的String函数类似于itoa函数。在使用%v转义打印这种变量时，如果定义了String函数就会自动调用之，否则就会按照Go内置的打印方式来打印。 在实现String函数时我们常常要借助fmt.Sprintf函数，它返回一个按照格式字符串和参数生成的字符串。另外，我们需要注意这个方法应与数据类型本身而非其指针绑定。]]></content>
      <categories>
        <category>Academic or Technical</category>
        <category>Languages</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LilyPond制谱教程]]></title>
    <url>%2Fblog%2F2018%2F10%2F01%2FLilyPond%2F</url>
    <content type="text"><![CDATA[代码写谱 - LilyPond教程说到五线谱制作，大多数人最先想到的一定会是界面简洁，功能强大的Overture。然而，作为一个使用键盘的工作效率大于鼠标的人，我更希望使用一款以写码的方式制谱的软件，而lilyPond完美地满足了我的要求。它的功能之强大比起Overture更胜一筹，制谱效率也让人十分满意。 为了方便自己日后查阅并向更多人推广这个工具，特此将我的学习过程整理成教程留存。教程大部分的内容都是来自lilyPond的官方文档，如果更愿意阅读英文可以直接查阅官方的文档。 环境配置与使用方法安装lilyPond编译环境lilyPond隶属于GNU项目，所以不出意外的话使用所有Linux发行版的官方包管理程序都可以下载到。比如，在Archlinux下，只需要执行pacman -S lilypond。Windows版本则可以到lilyPond的官网下载。 渲染出乐谱lilyPond项目中有数个不同功能的二进制文件，其中lilypond专门用来将.ly文件渲染为乐谱文件。在作谱的时候，我们首先按照lilypond的语法来编辑.ly文件，再使用lilypond &lt;file&gt;来渲染乐谱。 lilypond默认渲染出的乐谱文件格式为pdf，可以通过调整参数来自定义输出格式。 配置MIDI播放环境Linux下的midi播放器可以使用timidity++(Archlinux的aur仓库中有)，不过由于一般linux系统下不会自带音源，我们需要自己下载并配置midi音源才能播放lilypond输出的midi文件。 AUR仓库中有几款不错的音源，比如Freepats或soundfont-fluid，我个人倾向于后者。执行yay soundfont-fluid可以直接将这个音源安装到本机，安装完成之后修改/etc/timidity++/timidity.cfg，取消其中的soundfont一行的注释，将其内容改为soundfont /usr/share/soundfonts/FluidR3_GM.sf2，保存即可完成对音源的配置。 Part 1 基本记号乐句在lilyPond语法中，每一段乐谱都被称为一个musicexpr，也就是”音乐表达式”。每个musicexpr都是由一对大括号括起来的一组音符声明，在大括号前可以增加一些对这个musicexpr的描述。 在之后的部分，为了方便书写，我将musicexpr统一翻译为乐句。 乐句的嵌套每个乐句都可以对其内容进行一定的设定，如果要将几种设定同时施加到一个乐句上就需要进行乐句的嵌套了。乐句的嵌套本质上可以看成是对数个乐句施加了一层新的属性。 乐句的赋值我们可以在lilypond中声明一些变量，并用\变量名的方式去引用它们。变量的声明格式为变量名 = 乐句。在我们引用一个变量时，它所指向的乐句将会在引用位置展开。 音高音高声明lilypond语法中的音高以小写英文字母为基准音高，由后缀来决定音高的调整。常用的后缀有： 每多一个,表示在基准音的基础上低一个八度，&#39;则表示高一个八度。 is后缀表示升号(sharp)，es后缀表示降号(flat)。对于重升和重降，只需要重复这两个后缀即可。 表示节奏的后缀，几分音符就是数字几。 例如，cis&#39;&#39;4表示一个四分音符时值的高音C-sharp。 在乐句中使用音高声明在乐句中，每一个音高声明都唯一对应着一个音符。每个乐句都是由一连串音高声明和一些描述性声明所组成的，lilypond会自动按照这个乐句的拍号(默认为4/4拍)划分小节。我们建议将每一个小节写为乐句中的一行，这样更方便我们日后读谱。 和弦如果要声明一个和声或和弦，只需要用尖括号括起和弦中的各个音符即可。q声明代表复制前一个和弦声明。 绝对音高和相对音高控制绝对音高和相对音高的描述分别是\absolute和\relative。\absolute &lt;musicexpr&gt;所声明的乐段中所有音高标记都以低音C为基准音，这也是没有音高声明的乐段所默认采用的校准方式。\relative &lt;basepitch&gt; &lt;musicexpr&gt;所声明的乐段中音高的计算方式则比较复杂： 如果一个音符后没有八度改变后缀，它所在的八度会被选为一个能使它与上一个音符的音程小于五度的八度。 八度改变后缀会将音符的音高在第一条规则计算出的音高基础上提高或降低一个八度。 第一个音符的音高按照第一条规则与&lt;basepitch&gt;音高相关。 涉及到和弦后的计算方式更加复杂，这边不予详述，可以参考官方文档中的描述。 虽然相对音高的计算比较复杂，但如果熟练之后应用相对音高会非常便利。我们在之后 高音和低音谱号描述性语句\clef可以用于指定和切换谱号。在一个小节的声明之前插入一句\clef声明可以指定从这个小节开始往后的小节所在的谱号。\clef bass会将谱号设定为低音谱，而\clef treble则会设置为高音谱。没有\clef声明的小节默认采用高音谱号。 另外两种谱号，中音和次中音谱号分别对应于\clef alto和\clef tenor。更多的谱号可以参考官方文档的1.1.3节。 升号与降号在之前已经讲过升降号的声明，但没有涉及到还原号，这是因为还原号是不需要特殊声明的。在lilypond中，没有进行升降号声明的音符都会被处理为标准音高，也就是说cis c会被渲染为一个升C后接一个还原C，而不是两个升C，这和五线谱中升降号保持的法则是不同的。不过，渲染出的乐谱仍按五线谱标准显示。 如果想要在不需要还原号的位置强行显示还原号，可以在对应的音符后加!符号。如果要为变音记号加上括号，可以在对应的音符后加?符号。 设置调号在一个小节前使用\key声明可以决定从这个小节开始往后部分的调号。调号由一个音高声明和一个大小调声明组成。大小调声明可以是\major(大调)或者\minor(小调)。 一个调号声明的例子：\key bes \major声明一个降B大调调号。 需要注意的是调号声明仅会打印出一个调号，并不会有其他的作用。 转调声明有些时候我们需要将一段乐谱进行转调，如果一个个音符去修改未免工作量过大。乐句声明\transpose为我们提供了一种便利的转调方式。嵌套在带有\transpose声明的乐句内的所有乐句都会按照这个声明规定的转调方式进行转调。 \transpose声明的格式为\transpose &lt;basepitch&gt; &lt;nextpitch&gt;，渲染器会计算&lt;basepitch&gt;和&lt;nextpitch&gt;之间的音程，并将整个乐句中嵌套的所有乐句中的所有音符向上移一个等长的音程，同时改变这些乐句中的调号(如果声明过)。 高八度和低八度记号\ottava &lt;scale&gt;声明可以用于添加高八度和低八度记号。&lt;scale&gt;的取值为#x，其中x为升高或降低的八度个数。如果x为正整数则表示升高，否则表示降低，为0表示还原到原来的高度。 需要注意的是，这个记号并不会改变音符的实际音高，因此如果在应用记号后不手动调整音高，音符就会在谱面上做相应的调整以适应原来的音高。 下面是一个例子： 123456789\relative c&apos; &#123; \key d \minor d4 a&apos; g2 \ottava #1 f&apos;4 g a c8 a \ottava #0 g,4 f e2 ~ e4 f2 ~ f4&#125; 渲染出的谱面是这样的： 节奏音符时值正如之前说过的，在音符声明后加数字可以声明一个对应时值的音符，如b4声明四分音符，g32声明三十二分音符等等。在数字后面加.可以在音符后加浮点，其时值增加规则和乐理知识中相同。 如果未加声明，后面的音符会自动继承前面音符的时值。如，c4 d e f会渲染出四个连续的四分音符。 \autoBeamOn和\autoBeamOff可以打开或关闭切分音之间的自动连线。自动连线机制默认是打开的。 三连音声明三连音或多连音均可以使用\tuplet声明。其格式为\tuplet &lt;fraction&gt; { &lt;notes&gt; }，其中&lt;fraction&gt;是一个分式，分母为整个tuplet的总时值，分子为等分的份数。例如，5/4声明一个平分四分音符的五连音。 需要注意的是，&lt;note&gt;中的音符一定要标定对应的时值。如果要声明一个平分四分音符的三连音，就必须将&lt;note&gt;中的音符声明为8分音符，否则渲染会出现偏差。 拍号的声明一个乐句的默认拍号是4/4拍，但我们可以使用\time声明显式地修改拍号。\time N/M可以将乐句的拍号修改为N-M拍(有基本乐理知识的人应该都明白N-M拍是什么意思，这边不予详述)。 \defaultTimeSignature和\numericTimeSignature可以用于两种拍号表示方式的切换。 如果我们声明了一个比较奇怪的节奏型(比如《哈德曼的妖怪少女》的7/8拍)，lilypond默认的符尾连接方式会失效，需要我们手动设置，否则所有时值小于等于八分音符的音符符尾全都不会相连，如： 12345\relative c&apos; &#123; \time 7/8 a&apos;8 f d \tuplet 3/2 &#123;c&apos;4 bes c&#125; a8 f d gis e cis gis&apos;&#125; 手动设置的方式是在\time后面加一个#&#39;(&lt;pattern&gt;)记号。&lt;pattern&gt;是一连串数字，这些数字将每个小节中的音符依次分为大小等于每个数字的组，同组间的音符会有符尾连接，如： 12345\relative c&apos; &#123; \time #&apos;(3 4) 7/8 a&apos;8 f d \tuplet 3/2 &#123;c&apos;4 bes c&#125; a8 f d gis e cis gis&apos;&#125; 隐式地改变音符的时值有些时候我们希望在改变音符时值的同时不影响乐谱的外观，这时我们可以在一个音符声明的后面加一个*x/y后缀，其中x/y是一个分数，代表改变后的时值(/y部分可以缺省)。 连音线连音线只能连接两个相同音高的音符。在两个这样的音符之间加一个~即可为它们加上连音线。 如果需要给被小节线分隔的两个音打上连音线，我们可以利用lilypond的自动切割功能，即在第一个音符处声明一个时值等于两个音符时值之和的音符，lilypond会自动将其切割为两个被连音线连接的跨小节音符。 当两个和弦声明被连音线连接时，和弦中所有等音高的音符会被连音线连接，而不同音高的不会。 更多关于连音线的线条形式或曲线属性的设置可以参考官方文档中的说明。 休止符一般的休止符由字母r和表示时值的后缀组成。如果用s取代r，则可以声明一个不可见的休止符。 速度标志一般的乐谱开始位置都会有一个标志来表示乐谱的演奏速度，这种标志可以用于设定节拍器，因而称为Metronome mark。\tempo声明可以用于声明这种标志。 \tempo最常见的用法是后跟&lt;duration&gt; = &lt;speed&gt;，其中&lt;duration&gt;是一个表示速度标记中左边那个音符时值的数字，&lt;speed&gt;是速度标记中右边那个数字。另一种没有那么精确的用法是\tempo &quot;&lt;text&gt;&quot;，其中&lt;text&gt;可以是各种用于描述速度的标记，如Allegreto(快板)。这两种用法可以混用，混用时速度标记会被小括号括起来。 弱起小节在一些乐曲中第一个小节是不完整的：我们使用弱拍作为乐曲的开始而非惯用的强拍。在这种情况下，需要使用\partial &lt;duration&gt;来声明这个不完整的小节，其中&lt;duration&gt;是小节更改后的长度。 特殊的小节线我们可以通过\bar &quot;&lt;symbols&gt;&quot;声明来显式地声明一个小节线。这个小节线不受自动小节划分的限制，可以安放在任何位置。我们可以通过&lt;symbols&gt;来显式定义小节线的样式，&lt;symbol&gt;由几种字符组成： : 代表小节线中的冒号，一般与重复小节线有关 . 代表粗小节线，与重复小节线和终止线有关 | 代表普通小节线 大部分小节线都可以用这三种符号的排列来表示。 装饰音在一个音符声明前加上\grace标记可以让这个音符成为装饰音。如果要声明多个连续的装饰音，可以用大括号将这些音符括起，在大括号前加\grace。 增强表现力的符号增强表现力的符号一般绑定在某个音符上，其声明形式为&lt;note&gt;\&lt;symbol&gt;，其中&lt;note&gt;是一个音符声明，&lt;symbol&gt;是特定的标号。 表示处理方式常用的加在单个音符上的标号有\staccato(跳音符)，\fermata(延音符)，\accent(重音符)，\trill(颤音符)等。完整的符号表可以参照官方文档。 除了标准声明形式之外，还有一些常用的简写来减轻我们的工作量，比如-&gt;与\accent等效，-.与\staccato等效。 表示音符强弱与音符绑定的强弱符也可以用这个形式来声明，其对应的symbol与强弱符在谱面上的标号一致，如\pp或\sf。渐强渐弱符需要一个起点音符和一个终点音符：起点音符与\&gt;或\&lt;绑定，终点音符与\!绑定。另一种形式的渐强渐弱符只需要在起点绑定一个\cresc或\dim标号即可。 连唱线连唱线开始位置的音符需要加一个(后缀，而结束位置的音符需要加一个)后缀。连唱线可以嵌套。 琶音琶音的声明用于和弦。在一个和弦后绑定\arpeggio记号可以在这个和弦上加琶音线。 颤音之前提到过的\trill记号用于声明在单个音符上方的颤音符tr，另一种有起止位置的颤音符可以以开始音符绑定\startTrillSpan，结束音符绑定stopTrillSpan的方式声明。 复调用&lt;&lt; &gt;&gt;括起来的两个或以上的乐句可以并行演奏，这种记谱方式称为polyphony(复调)。 如果不加显式的标记，这些乐句会被默认地放入同一个声部中，这通常会导致音符在乐谱中的碰撞，从而使某些音符渲染失败或不正常渲染。通常在进行复调作谱时，会用这几种方式将几个乐句安排到不同的声部中： 在每个乐句的内部开始位置加一个\voiceOne～\voiceFour的声明以指明这个乐句属于哪个声部，同时在每个乐句的前面增加\new Voice声明，为它们分别创造新的声部。 在乐句之间加入\\记号，这样lilypond会自动为这些乐句分配不同的声部。 乐器记号\new或\context声明被用于声明一组乐谱。 最基本的乐器是Staff，\new Staff可以声明一组最简单的钢琴五线谱。除了普通的Staff之外，还有DrumStaff，RhythmicStaff等乐谱格式可以使用。 乐谱组绝大部分器乐乐谱都需要乐谱的分组，比如钢琴谱的左右手，交响乐谱的各种乐器。用之前提到过的复调记号就可以实现乐谱的分组： 1234&lt;&lt;\new Staff &#123;...&#125;\new Staff &#123;...&#125;&gt;&gt; 效果如图： 可以在复调记号之前使用乐谱组声明来改变乐谱的外观： 1234\new StaffGroup &lt;&lt; \new Staff &#123;...&#125; \new Staff &#123;...&#125;&gt;&gt; 效果如图： 也可以使用钢琴谱声明： 1234\new GrandStaff &lt;&lt; \new Staff &#123;...&#125; \new Staff &#123;...&#125;&gt;&gt; 效果如图： 乐器属性可以在\new Staff声明之后紧跟一个\with {}声明块来描述这个乐器的属性。例如： 123\new Staff\with &#123; instrumentName = #&quot;Piano &quot;&#125; &#123; c d e f &#125; 可以在乐谱前显示Piano字样。 文本在音符上下方添加文本在一个音符声明上方添加文本可以使用^&lt;text&gt;，如果是下方则为_&lt;text&gt;，这和LateX的语法是相同的。&lt;text&gt;可以是简单的文本常量&quot;aslkdj&quot;，也可以是一些复杂的表达式，比如\markup语句块。 也可以用\mark &lt;text&gt;声明在音符之间的位置上方添加文本。 Markup语句块\markup {...} 可以声明一个Markup语句块。你可以在Markup语句块中用各种LaTeX语法来格式化文本。常用的标记大致有： 改变字体格式 \bold \italic \underline \super (上标) \sub (下标) \smallCaps 改变字号 \huge \teeny \normalsize \fontsize #&lt;num&gt; 排版 \column {}：其中的元素只能是\line {} \center-column \line {}：其中放置一行文本 字体 \sans \typewriter \roman 更多标记可以参考官方文档。 Part 2 特殊记号踏板\sustainOn和\sustainOff声明可以用来控制钢琴的踏板。 Part 3 IO乐谱的输出每段乐谱在输出时必须被包装在一个\score {}块中。除了乐谱部分，我们还可能需要一个\header {}块，在这个块中我们可以指定title = &quot;...&quot;，composer = &quot;...&quot;以及subtitle = &quot;...&quot;等。 一个\bookpart {}块代表乐谱本中的一部分，每个这种块中必须包含一个\header和一个\score块。 Appendix 乐理名词翻译Pitch 音高 octave 八度 bass 低音 treble 高音 chord 和弦 accidental 变音记号 sharp 升 flat 降 natural 还原 interval 音程 major 大音程 minor 小音程 augmented 增音程 diminished 减音程 Rhythm 节奏 duration 时值 tuplet x连音 tie 连音线 measure 小节 bar 小节线 metronome 节拍器 rest 休止符 grace 装饰音 Expression 表现 dynamic 强弱符 slur 连唱线 Arpeggio 琶音 trill 颤音 polyphony 复调]]></content>
      <categories>
        <category>Academic or Technical</category>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ArchLinux下的软件安装]]></title>
    <url>%2Fblog%2F2018%2F07%2F11%2FArchLinux%E4%B8%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Archlinux下的软件安装方式总结虽然Archlinux既有稳定的官方镜像源又有完善的aur社区，仍然有一些软件是我们通过这两种方式无法安装的。今天就来总结一下Archlinux下所有的安装方式，让我们能方便舒适地使用所有软件。 pacmanpacman是Arch官方的包管理工具。这里能下载到的都是Arch官方支持的软件，因此很多软件是无法从这种途径获取的。 找到需要的软件包有些时候我们会发现有的软件依赖的二进制文件并没有被安装，导致软件无法运行。想要查找一个二进制文件所在的pacman软件包，可以使用pkgfile工具。使用方法是pkgfile &lt;文件名&gt;。它会输出这个文件所在的软件包名。 pacman的使用方式 常用参数 -S 后面跟软件包名，与镜像源同步，一般使用这个参数安装新的软件包或升级旧的软件包。 -U 后面跟一个文件名，通过下载到本地的安装包安装软件 -R 后面跟软件包名，卸载这个软件并删除软件包 -Syu 俗称 滚Arch ，进行全面的系统更新 定制pacman下载工具pacman的配置文件是/etc/pacman.conf。在这个文件中我们可以对pacman的行为进行自定义。 常用的自定义项 改变pacman的镜像源：修改/etc/pacman.d/mirrorlist文件内容 改变pacman使用的下载工具：修改XferCommand变量的值 /usr/bin/curl -C - -f %u &gt; %o pacman默认使用curl作为下载工具 /usr/bin/wget --passive-ftp -c -O %o %u wget是一款非常优秀的单线程下载工具，功能比curl更为强大 /usr/bin/axel -o %o %u axel是一款多线程下载工具，速度比前两者要快，推荐设置它为pacman的默认工具。 注意：wget和axel需要提前用pacman安装。 yaourt/yay官方支持的软件毕竟是有限的，很多我们需要的第三方软件并没有官方提供的支持。在这种时候，Archlinux丰富而强大的aur社区就体现出其威力了——我们可以很方便地从aur社区下载别人制作好的应用软件包或二进制文件，还可以将自己制作的软件包发布在这个社区上(关于发布方式的细节不在这里讨论)。 从aur社区下载软件包所需要的工具是yaourt(现在yaourt已经停止更新了，取而代之的是yay)。使用pacman可以安装yaourt，使用yaourt可以安装yay。 yaourt/yay的使用方式与pacman类似，yaourt可以用-S参数来下载并安装软件包。如果不加参数，yaourt会在aur库中搜索所有名字与给出的名字相近的软件包或二进制文件，并以表的形式列出，供用户选择。下载到的二进制文件会默认保存在当前目录中。 定制yaourt/yay下载工具yaourt和yay的配置文件都是/etc/makepkg.conf。 修改下载工具的方式与pacman类似，只不过修改的是DLAGENTS变量。修改时可以直接删除这个变量原来的所有值，改为DLAGENTS = (&#39;http::/usr/bin/wget --passive-ftp -c -O %o %u&#39;,&#39;https::/usr/bin/wget --passive-ftp -c -O %o %u&#39;) AUR的其他使用方式有些时候yay会出现玄学问题，即明明远端的aur包是存在的，在试图拉取的时候却报404。这种时候，我们可以在AUR仓库中搜索这个包的名字，找到其git地址，并使用git clone直接将其拉取到本地。 拉取完成之后，可以在PKGBUILD文件所在的位置执行makepkg命令来安装这个包。如果仍然出现下载错误，就复制PKGBUILD中source变量指明的下载地址并用wget去手动下载，并在下载完成之后修改source变量的值为这个包在本地的路径，再次执行makepkg就可以了。 通过下载好的软件包安装如果一个软件既无法通过pacman下载又无法通过aur库得到，那就只能手动安装了。首先我们要通过各种渠道获取软件的安装包(GitHub/wget/软件官网/其他)，随后的操作要视软件包而定。 软件是单文件(二进制文件)这种情况最简单，没有软件包，直接把二进制文件移动到/usr/bin文件夹下即可(注意要加sudo)。 软件包中有安装脚本大多软件会在软件包中放一个命名为install.sh(或其他名字)的安装脚本。在这种情况下，可以直接执行sh install.sh或./install.sh来安装软件。(最好结合软件的READ.ME或官方说明安装) 其他情况如果安装脚本不能在Arch下正常运行，那就只好手动拆包安装了。这种时候可以搜索一下各种后缀的软件包的格式，然后手动将二进制文件，lib文件和其他配置文件cp到需要的位置完成安装。 downgrade和前面几种方式不同，downgrade是一种给软件包降级的方式。使用这个工具可以很方便地回滚软件包等级，从而解决一些可能存在的依赖问题。 执行yay downgrade命令可以直接从aur仓库安装downgrade工具。 使用downgrade工具需要root权限。使用方式：sudo downgrade &lt;软件包&gt;]]></content>
      <categories>
        <category>Academic or Technical</category>
        <category>ArchLinux and Shell</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MakeFile学习笔记]]></title>
    <url>%2Fblog%2F2018%2F05%2F02%2FMakeFile%2F</url>
    <content type="text"><![CDATA[MakeFile学习笔记学习资料：GNU make官方文档 BasisRulesMakeFile最重要的元素是rule，也就是构造规则。一条规则有这样的形式： 1234&lt;target&gt;:&lt;prerequisites&gt; &lt;recipe&gt; &lt;recipe&gt; ... Target一个目标可以是： 一个文件的名字 一个标识符，且标识符的名字不应与MakeFile所在文件夹下的文件名重合 不加标注的话，MakeFile会优先将目标识别为文件名。如果要显式地将目标指定为标识符，需要在这一条规则前面加一条.PHONY: &lt;ident&gt;指令，其中&lt;ident&gt;是要指定的标识符。 Prerequisites前置条件是创建目标所需要的文件列表。这个列表中的文件之间用空格隔开。 只有在前置条件中的某一个(或多个)文件发生过改变后，这条规则才会执行&lt;recipe&gt;们，否则无事发生。 当然，在&lt;recipe&gt;存在的情况下，前置条件是可以缺省的，这样只要执行这条规则就会执行&lt;recipe&gt;。 Recipes每一条recipe都是一条shell指令。这条规则在自身被执行的时候依次执行它们。 注意： Make用以区分多条recipe的是tab符。也就是说，只要在每条recipe前面加一个tab符就可以了。如果想改用其他符号来标志，也可以设置.RECIPEPREFIX变量。 不同的recipe在不同的shell中执行，因此很多环境变量可能会不共享。 recipe是可以缺省的。当我们的object是*.o文件时，make会默认以cc -c *.c作为这条规则的recipe。与此同时，这个*.c文件还会自动被加入前置条件。 另外，当我们需要将一个长行分割为几行的时候，可以用\去连接它们。 Processing Rules一个MakeFile中优先被执行的规则是第一条不以.开头的规则。 当make执行一条规则的时候，如果它的前置条件有着属于自己的规则，那么它会先去执行这个前置条件所依赖的规则。如果一条非默认规则不被任何规则所依赖，它就无法被单纯的make指令执行。 一种巧妙的用法，如果前置条件是一个非文件target，那么执行这条规则时就会顺带无条件执行这个前置条件对应的规则。 Variables我们可以使用&lt;ident&gt; = &lt;content&gt;来声明一个变量。不过说是变量其实这更像一个宏。 要引用一个变量，我们需要使用这样的格式：$(&lt;ident&gt;) 我们可以在执行make的时候以&lt;ident&gt;=&lt;value&gt;(注意中间不能带空格)的形式预先声明变量的值，以这种方式声明的参数值会覆盖在makefile中的变量赋值。 如果使用了一个既没有在makefile中初始化又没有在命令行中赋值的变量，那么这个变量就会被忽略。 Including我们可以使用include &lt;filenames&gt;来将其他文件(通常是子文件夹下的makefile)包含进来。 使用include时，如果make无法找到指定的文件或文件夹，就会报错并退出。-include命令可以让make直接忽略找不到的文件，不进行报错和退出。 AdvancedEchoingmake默认会打印出每一条执行的recipe，这种行为称为回声。 如果要让make只执行不打印，就需要在这条recipe前面加上@符号。 一般来说，我们只会在注释和echo指令前面加@。 Wildcardmake使用bash风格的通配符。如，*.&lt;suffix&gt;指代所有的.&lt;suffix&gt;文件。 也可以用%来进行模式匹配，一条带有%的匹配表达式会被替换为所有符合这条表达式的规则。 Valuing为了避免引起歧义，变量的赋值有四种方式： =：惰性赋值，用到被赋值的变量时再根据赋值者的当前值进行赋值，可以递归 :=：在运行前直接根据最近一次赋值进行展开，运行后不再改变 ?=：只有被赋值者当前没有值时才会赋值 +=：相当于append Automatic Variables $@：指代当前构建的目标 $&lt;：指代第一个前置条件 $?：指代比目标更新的所有前置条件 $^：指代所有前置条件 $*：指代%匹配到的部分 @D：目标的目录部分 Control Flowmake使用与bash相似的语法完成条件判断和循环。 比较常用的条件判断语句有： 12345678# Type 1ifeq (&lt;var/imm&gt;, &lt;var/imm&gt;) &lt;command&gt;endif# Type 2ifndef &lt;var&gt; &lt;command&gt;endif]]></content>
      <categories>
        <category>Academic or Technical</category>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSAPP学习笔记]]></title>
    <url>%2Fblog%2F2018%2F04%2F12%2FNote%20of%20CSAPP%2F</url>
    <content type="text"><![CDATA[CSAPP Note Taking 这是阅读《深入理解计算机系统》一书时所做的学习笔记。 Chapter 1 计算机系统漫游首先从“hello.c”文件开始讲起。 Unix-like系统下有两个重要概念： 只由ASCII字符构成的文件为文本文件，其余皆为二进制文件 系统中所有信息都是由一串bits构成的。区分它们的不同方式在于它们的上下文。 有关C语言 C语言是贝尔实验室的研究员在1969-1973年间创建的。 ASCI标准在1989年由美国国家标准学会颁布。 C语言是为了开发UNIX而设计的，由是，它是系统级编程的首选。但它缺乏对一些抽象的显式实现（如异常，类，对象），因此在应用级编程方面弱于C++与JAVA等语言。 编译系统1hello.c -预处理-&gt; hello.i -编译-&gt; hello.s -汇编-&gt; hello.o -链接-&gt; hello 执行这四个阶段的程序（预处理器，编译器，汇编器，连接器）共同构成了 编译系统 。 预处理 ：对源程序中所有 # 打头的语句进行处理 编译 ： 将处理过的源程序翻译为汇编程序 汇编 ： 将汇编程序翻译为机器语言，并打包成为 可重定位目标程序 链接 ： 将标准库函数所在的 .o文件 链接到hello.o并生成 可执行目标文件 有关GNU项目 GNU（GNU‘s not UNIX）是一个免税慈善项目，它的目标是开发一个完整的开源系统。 GNU环境包括 EMACS,GCC,GDB,编器，链接器，处理二进制文件的一些工具以及其他部件（~~然而不包括内核，内核是LINUX独立发展的~~） 它是现代 开放源码运动 的思想起源。 计算机系统的硬件组成总线总线是在系统的各个部件之间传递信息的渠道，通常被设计为传送定长的字节块。 xx位系统的含义: xx代表的是这个系统的基本属性：字长 ,即总线一次传送信息的最小单位。比如，64位系统代表字长是64个位，也就是8个字节。 字长不仅是总线传送信息的最小单位，还是内存中数据单元的一种单位。 I/O 设备I/O设备通过适配器或控制器与I/O总线相连。 控制器与适配器的区别 控制器是设备本身或者系统主板上的芯片组; 适配器是插在主板插槽上的卡。 主存主存由一组 动态随机存取存储器 芯片组成。 处理器中央处理单元，简称处理器，是解释执行储存在主存中指令的引擎。 程序计数器处理器的核心是一个大小为一个字的存储设备 - 程序计数器，它保存主存中某条指令的地址。处理器读出主存中的指令，执行指令，再更新程序计数器使其指向下一个指令。 算数逻辑单元算数逻辑单元（ALU）用于计算数据和地址值。 高速缓存系统将信息在磁盘，I/O，主存，处理器间来回移动的时间开销过大，一种解决方式是高速缓存。 高速缓存：作为暂时的集结区域，存放处理器近期可能需要的信息。 高速缓存的分级： * 一级高速缓存：访问速度与大小和寄存器相当 * 二级高速缓存：大小要大很多，但是速度也要慢一些 * ...以此类推 操作系统操作系统的基本功能： 防止硬件被失控的应用程序滥用 向应用程序提供简单一致的机制来控制复杂的硬件设备 有关Unix20世纪60年代末，由于当时开发的Multics操作系统过于复杂，贝尔实验室的研究员用 机器语言 写了一个简单易用的操作系统，并在1970年将其命名为“UNIX”。 1973年，UNIX内核被用C重新构建 1974年，UNIX正式对外发布 80年代中期，为了防止Unix厂商所加入的新特性导致的不兼容问题，IEEE研发了 POSIX标准。 操作系统提供的抽象表示1.进程进程是操作系统对一个正在运行的程序的一种抽象。 无论是在单核还是多核系统，操作系统看起来并发地执行多个进程，是通过在进程间切换实现的。这种切换称为 上下文切换 。 关于 上下文切换 ： 操作系统保持跟踪进程运行所需的所有状态信息。这种信息称为 上下文 。 上下文包括程序计数器（PC）和寄存器的当前值，以及主存的内容。 上下文切换就是保存当前进程的上下文并恢复新进程的上下文，然后递交控制权。 进程的切换是由操作系统的 内核（kernel） 管理的。 在应用程序进行系统调用时，控制权移交给内核 内核执行被请求的操作并将控制权返还给应用程序。 2.线程每个 _进程_ 由许多个更小的执行单元 线程 组成，它们共享进程代码和全局数据。 多线程的优势所在： 多线程比多进程更容易共享数据 线程一般比进程更为高效（开销更小） 3.虚拟内存虚拟内存提供了一个假象：每个进程都在独立地使用主存。对每个进程来说，它们所看到的主存是一样的，它们所看到的主存称为 虚拟地址空间 。 虚拟地址空间的结构：（地址由高到低） 内核所用的虚拟内存 用户栈（向下增长） 「预留区域」 动态链接库映射到内存中的区域（向上增长） 「预留区域」 malloc申请的堆内存（向上增长） 读/写数据 只读数据和代码 4.文件文件 就是字节序列。在UNIX系统中万物皆文件，包括各种I/O设备。 计算机网络从一个单独的系统来看，网络可以视为一个I/O设备。 Chapter 2 信息的表示与处理数字革命的基础之一就是 二进制表示法 。当我们把位组合在一起，我们就可以表示任何一个有限集内的元素。 对于二进制表示数字来讲，三种表示最为重要: Unsigned code ：传统的二进制表示法，表示大于等于零的数字 two’s-complement code ：补码，可以表示有符号的整数 floating-point code ：浮点数编码，可以（近似地）表示所有实数 由于编码的位数有限，当结果超出表示范围时就会发生 溢出 。 对于整数来说，溢出并不影响运算的性质。 举个例子：以不同的先后顺序计算200×300×400×500,溢出结果是一样的。 但对于浮点数来讲，其数学性质截然不同。 再举个例子：计算 （0.1+1e20）-1e20 得出的结果是0.0,但先计算1e20-1e20则会得出正确结果 这说明浮点数的表示只是近似的。 了解计算机上数字的运算对于提高程序的可移植性和减少漏洞都是有帮助的。 C语言标准的发展 在C语言被开发出来之后，各种标准化组织在为C语言标准化作出努力。1989年，ASCI C标准推出。 1990年，国际标准化组织从美国国家标准协会手中 接锅，开发了ISO C90标准，跟ASCI C的内容基本一致。 1999年，ISO C99标准发布，引入了一些新的数据类型。 在2011年的C11标准中，增加了更多的数据类型和特性。 信息存储一般来讲，计算机 可寻址 的最小单位就是字节。要进行位操作，需要一些其他特殊的手段。 十六进制表示法1 × 十六进制数 == 4 × 二进制数 == 4 × bits == 0.5 × byte 这个换算一定要搞清楚。（不同进制之间是次方关系而非乘法关系） 熟练掌握二进制数和十六进制数之间的转换 对于十六进制对应的四个二进制位来说，一个十六进制数就是1,2,4,8的有机组合。 对于位串来说，每四个二进制数组成一个十六进制数。 字数据大小之前讲到过 虚拟地址空间 ，每个程序运行时都会从主存分配一个地址从零开始的虚拟地址空间，这个空间（一般来说）就是它们能够使用的最大主存。 之前还讲到过 字长 ，它的含义是 ALU（CPU中的算数逻辑单元） 一次运算能够处理的最大位数，所以也是总线一次能够传递的最大位数。 那么由于操作系统一般是用指针去进行虚拟地址空间中的寻址的， 一个指针的最大大小 也就决定了 虚拟地址空间的最大大小 。而指针身为数据类型的一种，它的大小是受ALU算力的限制的。 也就是说， 计算机字长 决定 指针数据的标称大小 ，从而决定 虚拟地址空间的最大大小 。由于每一个指针值都对应着虚拟地址空间中的一个字节，一个 w位 的机器的虚拟地址空间最大为 2^w-1 。 为避免程序在不同位系统间切换时数据类型默认大小不同带来的问题，C99标准加入了固定大小的数据类型，比如 int32_t 和 int64_t 。 寻址和字节序大端序 和 小端序 ：最低有效字节（一个数中最右边的）在前为小端序，反之为大端序。 大部分Intel兼容机都采用小端序。 这两个名词起源于 格列佛游记 中小人国的大端派和小端派。 在一些特定的情景（如网络数据传输，字节级操作）中，大小端序的区别可能会导致错误，需要注意。 表示字符串 由于char型变量使用的是单字节，文本型数据在跨平台方面要强于二进制数据 ：它不受字大小和字节序区别的干扰。 字符编码缘起（参考知乎于洋的回答）： 最开始的 ASCII编码 标准涵盖了 控制码（0x00-0x20） 与用于显示的字符，共128个，每个字节对应一个ASCII码。 由于一个字节最多可以表示256种状态，人们添加了 扩展字符集 ，用来表示一些特殊字符（如某些非英文国家的字母，数学和制表符号等） 由于中文汉字过多，中国采用了两个字节对应一个字符的编码方式-GB2312，一个字节的值不大于127则仍是ASCII码（称为 半角字符 ），大于127则与后一个字节共同表示一个字符（称为 全角字符 ）。 后来该协议又有扩展，不再要求后一个字节的值大于127,此次更新的方案称为 GBK标准。 再之后ISO出手了，制定了 UNICODE标准 ，规定用所有字符都用两个字节表示。 为了网络数据传输的方便，一系列 UTF编码规则 被制定出来（UTF-8代表一次传输一个字节）。UTF标准规定可以用1～4个字节来表示一个字符 位运算C标准并没有规定在位右移时是采用 算术右移 （也就是高位补有效位）还是 逻辑右移 （也就是高位一律补0），所以导致了一系列可移植性问题（不过一般来说，编译器一律采用算术右移）；但是java用&gt;&gt;和&gt;&gt;&gt;的区别很好地区分了两种移位的判定。 整数表示无非就是两种主要表示形式：signed和unsigned，signed又一般用补码表示。 补码的计算原理补码的最左边一位是负权位，如果该整数占w位，那么它的值是-2^(w-1)。补码的计算就是非补码位表示的正值加上补码位负权表示的负值。 补码的符号扩展为了保持补码表示的数值不变，补码在扩展时在左边补’1’，原码则是补’0’。因此，一个补码在左边加任意x个1,正如十进制数左边加零一样，其值不变。 补码的截断和原码一样，都是去高位留低位，然后根据低位表示的值求出截断后的值。 非补码的数据表示在系统级编程和网络编程当中，经常会需要用一个变量代表一串没有数学意义的位。这种时候，补码特殊的负权位会带来一些不必要的麻烦，于是我们可以使用unsigned值来代替。 这里介绍signed和unsigned间隐式类型转换可能带来的漏洞： 现在有一个读出缓冲区中信息的函数，这个缓冲区中有些信息是隐私信息，不允许阅读。 为防止这个函数被用来读出不该读的东西，该函数被设置为从可读信息的开始处开始阅读，阅读长度为一个int参数，函数会实现判定其大小是否超出了可读范围。 然而，这个函数调用的用来复制缓冲区中一段信息的系统函数中长度参数的类型为size_t(它被定义为unsigned int) 那么如果有人心怀不轨，将-1作为参数传入，作为int它能通过函数的检验，但在这个函数调用系统函数来复制缓冲区中的信息时，-1就会被隐式类型转换换为unsigned int类型，由于-1的二进制位最左边为1,此时它的值就会变成一个特别大的整数。 这样，这个人就成功读到了本来不应该被他读到的信息。 整数运算整数运算所产生的大部分漏洞都是溢出所导致的。因此，要格外注意可能引发溢出的情形。 unsigned int的运算 无符号数加法的溢出 溢出的处理规则：舍弃最高位 溢出的判定方法：如果加法得数小于两个加数中的任意一个，则该结果是溢出的。 溢出的应用：阿贝尔群 概念：任取一个无符号数a，必定存在另一个无符号数b使a+b的结果为0。 原理：a+b的值正好为2^w 补码的运算 补码加法的溢出 如果是正溢出，得数为 原得数 - 2^w 。 如果是负溢出，得数为 原得数 - 2^w 。 溢出的判定方法：如果两个负数相加得到了正数，则发生了负溢出；反之，则为正溢出。 补码的非 注意：非和补不是一个东西，非是-，补是～ 补码取非就是简单的求反加一 还有一种方法就是找到二进制表示中 从右到左第一个值为‘1’的位 ，然后对 这一位左边的所有位 取反。 补码的乘法 先直接计算乘积，将其截断后由无符号数转换为补码形式。 这里比较难，之后可以翻回来看一下 对于整数乘法的优化一般的整数运算（如加减，移位）只需要一个时钟周期，但整数乘法比它们慢的多，需要数个时钟周期来完成。为了提高计算效率，编译器采用了一项重要的优化：用 移位和加法运算的组合 来代替。 易得， 对一个数乘以2的n次方 相当于 将这个数进行n位左移 （这两种方式在溢出时得到的结果也是等价的）。 而任意一个整数都可以由 数个2的k次方的和 表示。 于是，由乘法分配律，一个数乘一个常数因子就等价于将若干个它的左移结果相加。 更好的是，有时可以用减法进一步减小计算量。 对于整数除法的优化在大多数机器上，整数除法比乘法还要慢，大概需要30多个时钟周期。因此，采用与乘法的优化相似的思路来进行优化。 但与乘法不同的是， 移位优化 只能适用于 $x|(2^k)$ 的情形。(|是离散数学中的符号，意思是能够整除) 整数除法的舍入问题我们知道，整数的除法结果应该是 向零取整 的（无论正数还是负数），然而直接采用移位法进行除法运算会导致 向下取整 的舍入结果。这个问题需要得到解决。 为了解决这个问题，需要引入 偏置数 作为修正。 对于正数的除法，直接移位即可 对于负数的除法，先进行偏置，再移位。 偏置的方式：将原来的数加上 $(1&lt;&lt;k)-1$ 后再移位，k是将要移动的位数。 解析：以除以16来说明。 当除以16时，应该右移4位，因此k=4 $(1&lt;&lt;k)-1$ = 0b1111 如果将要右移的四位全为0,说明可以整除，则加上0b1111后不进位，移位后结果不变 如果将要右移的四位不全为0,说明有小数部分，则一旦加上0b1111一定会进位，于是结果比向下取整大1,也就实现了向零取整的效果。 因此，采用如下表达式来计算 $\frac x {(2^k)}$ : 1( x &lt; 0 ? x + (1 &lt;&lt; k) - 1 : x) &gt;&gt; k 浮点数现在被普遍采用的一种浮点数表示方式为 IEEE浮点格式 。它在1985年前后由IEEE（电气和电子工程师协会）推出。 IEEE小数的结构IEEE标准表示的小数由以下几部分组成： 符号：用一个二进制位来表示小数的正负 尾数：用小数字段frac编码一个范围为 1~2-epsilon 的二进制小数 阶码：用阶码字段exp对这个浮点数加权，权重为2的E次幂 对于单精度浮点数而言，exp占8位，frac占23位；对于双精度浮点数而言，exp占11位，frac占52位 三类浮点数根据exp的值的情况可以将浮点数分为三类（以float为例）： 当exp不为0且不为255时这是最普遍的情况。 在这种情况下，阶码字段是以偏置形式表示的无符号数。其偏置值为 2^(k-1)-1 ，从而将 1～2^k-2 的无符号正数映射到了 -2^(k-1)+2 ~ 2^(k-1)-1 (对于单精度浮点数而言，这个映射区间就是 -126～127 )。 而小数字段frac表示小数点后的位，也就是说小数点（等价地）位于整个小数字段的左边，小数点的左边则 默认为1 。这样，frac表示的就是一个大小为1.xxxxxx……的小数。 当exp为0时这种数称为 非规格化形式 的数。 此时阶码字段的值为 1-偏置值 ，而小数字段小数点左边改为 默认为0 。 非规格化数的用途： 表示+0.0与-0.0 表示极为接近0.0的值 当exp=255,也就是阶码字段全为1时：此时该浮点数表示的是一个特殊值。 frac字段全为0时：表示无穷，无穷的符号由符号位决定。 frac字段不为0时：表示 NaN(Not a Number) 当运算结果既不是实数又不是无穷时使用NaN来代替。（如：sqrt(-1)，∞-∞等） 有些时候用以表示未初始化的数据 这种设计的优点 经过精心设计，这种表示方法使得浮点数在增大时其位级表示的变化规律和整数增大时是一样的。 这对于排序工作的优化起到了相当大的作用，因为比较的时候不需要进行浮点运算。 浮点数的运算浮点数的舍入运算IEEE标准定义了四种不同的舍入方式。 向偶数舍入（也就是向最近的数舍入） 这是最通用的方法，也就是人们常说的“四舍五入”。 对二进制数来讲，一个数的奇偶由最右边的二进制位决定，我们倾向于在舍入后让最低位为0。 向零舍入 向上舍入 向下舍入 浮点数的算术运算与整数的运算相似，浮点数算术运算也构成了 阿贝尔群 。但要特别注意的是，就像之前所说的， 浮点数运算不满足结合律和分配律 ，这是舍入所造成的。 缺少这两个运算基本属性让浮点运算给编程者们带来了很多麻烦，它使得很多判定变得十分麻烦。 然而，由于浮点数特殊的溢出判定，它具有补码运算和无符号数运算不具有的 单调性 。 浮点数与其他数据类型的转换 int -&gt; float：不会溢出，但是可能会被舍入 int/float -&gt; double：可以完整保留精确数值 double -&gt; float：可能溢出也可能会舍入 float/double -&gt; int：不出意外值会向零舍入，但有可能发生 浮点溢出 ，产生 整数不确定值 （对于Intel兼容机，它被定义为0b10000……0） Chapter 3 程序的机器级表示在高级语言如此发达和完善的今天，为什么还要学习汇编语言? 通过阅读汇编代码，我们能够理解编译器优化代码的原理，从而找出代码中隐含的低效率。 有些时候，高级语言的抽象层会隐藏我们想要了解的程序运行时行为。 了解漏洞的产生与防御恶意攻击需要了解机器级代码表示。 x86-64：Intel兼容机使用的机器语言 x86-64缘起Intel系列处理器俗称x86，经历了一个漫长的发展过程。其中，后面的处理器可以兼容前面的机器程序。 8086（1978）：它是第一代单芯片16位处理器之一，它的变种8088是第一代IBM兼容机的心脏 8087（1980）：浮点协处理器，与8086或8088一同工作，进行浮点运算 80286（1982）：增加了更多寻址模式，是MS Windows最初的使用平台 i386（1985）：体系结构升级到32位，这是Intel第一台全面支持Unix操作系统的处理器。它所增加的 平坦寻址模式 至今仍被大部分Linux和Windows机型使用。 i486（1989）：将浮点单元集成到了处理器芯片 Pentium系列（1993-2004）：不断扩展指令集，引入了SSE：增加了新的处理整数和浮点数向量的指令，增加了新的数据类型。在04年的Pentium 4E实现了超线程。增加了EM64T，它是对AMD提出的 IA32 的64位扩展的实现，被人们称为x86-64. Core 2（2006）：Intel第一个 多核微处理器 ，但是不支持超线程。 Core i7（2008）：同时支持多核处理和超线程，引入了SSE的扩展AVX，增加了更多的指令和指令格式。 研究汇编程序编码 对于机器级编程来讲尤为重要的两种抽象 指令集架构（ISA） 它定义了处理器状态，指令的格式，以及每条指令对状态的影响 大多数ISA（包括x86-64）将指令的执行抽象为顺序执行，但其硬件实现其实是并发的，只不过有措施保证其执行顺序与ISA规制的相同。 + __虚拟地址空间__ * 存储器系统的实际实现是将多个存储器和操作系统结合起来。 汇编代码的表示很接近于机器语言，但是它使用了文本这种更适合人类阅读的表示方法。 x86的代码和原始C代码差别很大，一些在C语言中不显示的硬件状态都会体现出来： 程序计数器：用 %rip 表示，给出内存中要执行的下一条指令的地址。 整数寄存器：包含16个位置，分别储存64位的值。 记录重要的程序状态 保存临时数据，如过程参数，局部变量，函数返回值 条件寄存器：用来实现控制或数据流中的条件变化 需要用到的调试工具 GCC编译器 gcc：执行GCC的bash命令 -Og：指定优化方式，以防过于高级的优化使源代码和汇编代码差距过大不便于研究。 -S：只进行预处理和编译过程，生成汇编代码 .s文件 。 -c：只进行预处理，编译，汇编过程，生成二进制文件 .o文件 。 -masm = &lt; format &gt;：指定生成汇编代码的格式。 GDB调试器 objdump -d &lt; file name &gt;：反汇编器，根据机器代码生成对应的汇编代码 x86-64机器代码的特性 x86-64的指令长度为1-15个字节不等。其中，常用或操作数少的指令占字节数较少，反之较多。 从某个给定位置开始，可以唯一地将字节解码成为机器指令。 代码格式以内容如下的 test.c 文件为例：123456long mult2(long,long);void multstore(long x,long y,long* dest) &#123; long t=mult2(x,y); *dest=t;&#125; 将其编译之后产生的 test.s 文件内容如下所示：123456789101112131415161718192021.file "test.c" .text .globl multstore .type multstore, @functionmultstore:.LFB0: .cfi_startproc pushq %rbx .cfi_def_cfa_offset 16 .cfi_offset 3, -16 movq %rdx, %rbx call mult2@PLT movq %rax, (%rbx) popq %rbx .cfi_def_cfa_offset 8 ret .cfi_endproc.LFE0: .size multstore, .-multstore .ident "GCC: (GNU) 8.1.0" .section .note.GNU-stack,"",@progbits 所有以 ‘.’ 开头的行都是指导 汇编器 和 链接器 工作的伪指令 具体语句的作用： pushq %rbx：将rbx寄存器中保存的值压入程序栈 movq %rdx，%rbx：将rdx中的值(dest指针)传递给rbx call：调用函数，函数的返回值保存在寄存器rax中 movq %rax，（%rbx）：将返回值赋给dest指针 popq %rbx：恢复rbx寄存器中原有的值 ret：该函数返回 两种不同的汇编代码格式 ATT格式：这是根据 AT&amp;T公司 命名的汇编格式，是GCC，OBJDUMP等工具的默认格式 Intel格式：Intel文档和Microsoft的工具使用的都是Intel格式。 两种格式的主要区别有： Intel格式省略了操作指令后指定大小的”q”字符与寄存器名前面的”%”。 Intel用不同的方式来描述内存中的位置。 两者列出操作数的顺序相反。 在C程序中插入汇编代码C语言缺乏一些特定API或操作符来访问一些机器特性。 比如：在x86-64处理器每一次执行算术或逻辑运算时，都会设置一个表示奇偶的称为 PF 的1位条件码的值，从而储存这个结果的奇偶性信息。而C语言要想得到这个信息需要至少7次移位、掩码和逻辑运算。 在C程序中插入汇编代码有两种方式: 将一个完整的函数单独编写到一个汇编文件中，再用GCC将它和另一个C代码生成的.s文件合并 利用GCC的内联汇编（asm指令）在C代码中插入少量汇编代码。 数据格式由于是从16位系统扩展成32位的，Intel将16位数据类型称为“字”。因此，32位数据类型就称为“双字”，64位就是“四字”。 x86-64对于基础数据类型的大小如下定义（括号内为汇编代码中的后缀）： 普通类型（后缀仅表示操作数大小）： char（b）：1字节 short（w）：2字节 int（l）：4字节 long（q）：8字节 pointer（q）：8字节 浮点类型： float（s）：4字节 double（l）：8字节 两种类型使用的指令和寄存器完全不同，所以后缀相同也无妨。 访问信息操作一个x86-64的CPU包含一组（16个）储存64位值的 通用目的寄存器 。每个寄存器都有特殊的用途，它们的名字便反映出这些不同的用途。 16个寄存器的用途（从左到右分别是8字节，4字节，2字节，1字节对应的寄存器名） %rax %eax %ax %al Accumulator，常用于置放返回值 %rbx %ebx %bx %bl Base，常用于存放地址 %rcx %ecx %cx %cl Count，常用于计数 %rdx %edx %dx %dl Data，常用于存放数据 %rsi %esi %si %sil 源变址寄存器 %rdi %edi %di %dil 目的变址寄存器 %rbp %ebp %bp %bpl 栈帧头指针 %rsp %esp %sp %spl 栈指针 %r8,%r9 %r8d,%r9d %r8w,%r9w %r8b,%r9b 扩展寄存器 %r10，%r11 同理 同理 同理 扩展寄存器 %r12～%r15 同理 同理 同理 扩展寄存器 当寄存器中被存入新的变量时的约定： 若存入的是1,2字节的值，则不改变寄存器中剩余字节 若存入的是4字节的值，则将剩余字节置为0 操作数指示符操作数指示出指令需要的原数据值，以及放置结果的位置。 操作数可以被分为三种类型： 立即数（immediate）：通过 $Imm 的格式表示常数，Imm为任意C-style数 寄存器（register）：直接用寄存器名将寄存器中的部分位作为操作数 内存引用 ：根据计算出的地址访问内存中的某个位置，格式为 [Imm]（[rb]，[ri]，[s]） Imm：立即数表示的偏移量，缺省表示不偏移 rb：基址寄存器，缺省则无基址 ri：变址寄存器，缺省表示无变址寻址 s：比例因子，必须为1,2,4或8，缺省默认为1 计算规则：最终的内存地址为 rb + s*ri + Imm 数据传送指令MOV S,D 效果：将S中的储存值移动到D S（源操作数）：指定一个寄存器或者内存地址中的立即数 D（目的操作数）：指定一个寄存器或内存地址 注：x86-64规定两者不能同时为内存地址 可能的操作数组合： movl $0x4050,%eax — 立即数-&gt;寄存器 移动4个字节 movw %bp，%sp — 寄存器-&gt;寄存器 移动2个字节 movb （%rdi，%rcx），%al — 内存-&gt;寄存器 移动1个字节 movb %-17,（%rsp） — 立即数-&gt;内存 移动1个字节 movq %rax，-12（%rbp） — 寄存器-&gt;内存 移动8个字节 特殊指令：movabsq 常规的movq指令只能以 32位补码 形式作为源操作数，然后将其扩展成为64位的值放入目的位置 而movabsq指令能以任意的 64位立即数值 作为源操作数，但 只能以寄存器作为目的位置 其他的数据传送指令 MOVZ：有两个后缀，分别指定源大小和目的大小。缺少的位用0填充。 movzlq指令并不存在，因为它完全可以被更简单的movl所取代。（想想4字节的填充特性） MOVS：和上面相似，但缺少的位用源操作数的最高位填充。 cltq指令：将%eax中的值符号扩展到%rax中，没有操作数。 一些常见的错误 movb %0xF,(%ebx) Since address in 64-bits os should be 8-bytes, use %ebx(a 4-bytes register)’s value to index is dangerous and should not be allowed. movl %rax,(%rsp) movl 必须以四字节大小的寄存器号作为其源操作数。 movl %eax,%rdx movl 必须以四字节大小的寄存器号作为其目的操作数。 入栈出栈指令PUSH &lt; register &gt;: 将一个寄存器中的值压入程序栈。 POP &lt; register &gt;: 弹出程序栈顶元素并移入指定寄存器。 出入栈指令的实现（以四字后缀为例）: pushq: subq $8,%rsp 含义：%rsp(程序栈指针寄存器)的值减小8(因为程序栈从上往下增长)。 movq &lt; register &gt;,(%rsp) popq: movq (%rsp),&lt; register &gt; addq $8,%rsp %rsp的值增大8 对于用户程序来说，栈内元素的地址是透明的，也就是说可以直接以 %rsp 为基准指针去访问栈内的第n个元素。 算术和逻辑操作加载有效地址LEA(load effective address)指令：将一个有效地址记录到一个寄存器中。 使用方法： 基本用法(以四字为例)：leaq &lt; effective address &gt; &lt; target register &gt; 可以用于简单的算术操作：利用内存地址的计算法则来实现简单计算。如： 寄存器%rdx的值为x 命令 leaq 7(%rdx,%rdx,4), %rax 即是计算5x+7. 一元算术运算 INC 自增 DEC 自减 NEG 取负 NOT 取补 一元算术运算的操作数可以是 寄存器 或 内存位置 。运算符后缀决定了进行该运算的位数。如：incq就是四字自增，notb就是低字节取补。 二元算术运算 ADD 加 SUB 减 IMUL 乘 XOR 异或 OR 或 AND 与 二元算术运算相当于是C语言中的 ～=运算 (～代表一个运算符)。如：SUB S,D 相当于 D-=S 这些运算的第一个操作数可以是 立即数、寄存器或内存位置，而第二个操作数只能是 寄存器或内存位置 移位运算 SAL，SHL 左移 SAR 算术右移 SHR 逻辑右移 注意 移位运算在运算符后先后给出两个操作数，分别代表移位量和要移位的数 移位量可以是一个 立即数 ，也可以是 单字节寄存器%cl 的值 运算符后缀决定的是取%cl的后几位作为移位量。 特殊算术操作 imulq指令和mulq指令 imulq指令有两种含义。 作二元操作符：将两个64位操作数相乘得到一个 64位 的值，并寄存在后一个操作数的位置。 作一元操作符：将操作数与%rax储存的值相乘得到一个 128位 的值，并储存在%rdx(高64位)和%rax(低64位)中。 这两种含义中乘法均为补码乘法。 mulq指令和imulq的第二种含义相似，只不过它做的是无符号乘法。 idivq和divq指令 这两种指令与上面的两种用法类似，只不过是除法加取模运算。 idivq指令将%rdx(高64位)和%rax(低64位)表示的128位有符号数作为被除数，而操作数作为除数，得到的 整数商 储存在%rax中，余数储存在%rdx中。 由于一般来说被除数是64位的，所以可以 将被除数放在%rax中 ，再使用 cqto 指令将符号位扩展。 cqto指令没有操作数，它自动读出%rax的符号位并将符号位扩展覆盖到%rdx。 控制操作条件操作条件码寄存器除整数寄存器之外，CPU还维护一组 条件码寄存器 。它们描述 最近一次 算术或逻辑操作的属性。常用的条件码有： CF 进位标志 显示操作有没有造成操作数最高位发生进位 ZF 零标志 显示操作的结果是不是0 SF 符号标志 显示操作的结果是不是负数 OF 溢出标志 显示补码操作有没有造成正溢出或负溢出 只有 lea指令 不会改变条件码寄存器。 有两种指令只设置条件码而不改变其他寄存器的值： CMP 求出两个操作数之差(ATT格式是右减左)，并以此为结果设置条件码 TEST 以两个操作数按位与的结果设置条件码 对条件码的访问x86-64通过 SET指令 实现对条件码的直接设置。 set指令是一个单元操作指令集，每条指令的功能取决于set的后缀。所有set指令共同的功能是将某一个 条件码寄存器 的值(或某些值的组合)储存到操作数表示的 单字节寄存器 中 set指令共有(含义解释按上一次操作为a-b): sete(setz) - ZF setne(setnz) - ~ZF sets,setns - SF,~SF setl(setnge) - SF^OF setle(setng) - (SF^OF)|ZF setg(setnle) - ~(SF^OF)&amp;~ZF setge(setnl) - ~(SF^OF) setb(setnae) - CF setbe(setna) - CF | ZF seta(setnbe) - ~CF &amp; ~ZF setae(setnb) - ~CF 用条件控制来实现条件分支控制的条件转移：传统方式，先判断条件是否满足，而后根据判断结果将控制流转移到代码段的某个位置继续执行。 JMP指令 直接使用：操作数是一个label，在代码段中有标记。 12345 movq $2333 %rax jmp .L1 leaq 8(%rdx,%rax) # 这一句被跳过了.L1: # L1是label ret 还有一种使用方式是间接跳转：jmp *&lt;寄存器或内存地址&gt; 取出小括号内储存的值作为label。 条件使用：以j+后缀构成，后缀的使用规则和set指令集类似。 跳转指令的编码方式 PC-relative：将目标指令的地址与jmp指令后一句指令地址的差编码，可以为1,2,4个字节 绝对地址：直接将目标指令的绝对地址编码，用4个字节指定。 CMOV指令先将条件满足和不满足的两种情况下的操作都做完，随后判断条件是否满足，并根据判断结果采用两种情况下操作得出的结果中的一种。 与SET，JMP相似，CMOV指令也是带有指定后缀的指令集。每条CMOV指令都有两个操作数，当后缀所指定的条件满足时，CMOV指令会执行与MOV指令相同的功能。 源和目的值支持单字节以外的任意大小，这个大小可以由寄存器的型号看出，指令本身不给出。 两种条件控制方式的比较现代处理器使用的是 流水线策略 ，即将要执行的指令序列填充进流水线，并同时做一条流水线上的所有工作。当遇到条件分支时，处理器只能预测控制流的走向而去完成那一个分支的工作，而这就意味着一旦预测失误，处理器就必须放弃之前对那一个分支做出的所有工作，并重新填充流水线。这会浪费非常多的时间。而数据条件转移就不存在这个问题。 然而，不是所有条件表达式都可以用条件传送来编译。更重要的是，由于这种处理方式会事先进行两种情况下的操作，如果其中某一种在某种条件下会产生副作用或者错误，那就会导致非法的行为。与此同时，如果两种条件下的计算量都比较大的话，无论怎样编译器都会白白浪费很多资源。 循环操作 对于dowhile循环的实现： 123456func: ... # ....Loop: # do &#123; ... # ... &lt;judging&gt; # &#125;while j** .Loop # (condition) 对于while循环的实现： 12345678func: ... jmp .Test # 一上来先跳到后面的条件判断部分.Loop: # 循环体 ....Test # 条件判断部分 &lt;judging&gt; j** .Loop # 如果满足条件则回到循环体 12345678func: ... &lt;judging&gt; # 先判断是否不符合条件 j** .Done # 如果不符合，直接结束循环.Loop: ... # 循环体 &lt;judging&gt; j** .Loop # 如果符合条件则回到循环体 对于for循环的实现 123for (init;judge;iteration) &#123; body_statement;&#125; 可以等效为12345init;while(judge) &#123; body_statement; iteration;&#125; switch操作这边要用到跳转表，等学了表再回来看 过程过程提供了一种封装代码的方式，用一组指定的参数和返回值实现某种功能。常见的过程有函数，方法，子例程，处理函数等等。 在过程调用中，需要牵涉到以下机制： 传递控制：调用者要将程序计数器设置为被调用者的起始地址，待调用结束后被调用者又要交还控制权。 传递数据：参数和返回值需要在两块代码间进行交流。 分配内存：局部变量需要临时分配内存，在返回前又要释放这些内存。 运行时栈C语言调用机制的一个关键特性在于使用了栈提供的 后进先出 内存管理原则。 对于局部变量而言，这种机制保证了它可以在作用范围内始终有效，在作用范围外被安全回收：某个过程在入栈时申请了局部变量，则它所调用的所有其他过程都在它之后入栈，在它之前出栈，而它申请的变量在它自身出栈时才销毁。 运行时栈的调度机制 当某一个过程所需要的空间超出了寄存器能提供的范围，就会在栈上分配空间。这一部分空间称为 过程的栈帧 。 在这个过程被调用时，它的栈帧会被事先分配好。在这个空间内它可以申请局部变量，设置它所调用的其他过程的参数，保存寄存器的值。有些情况下栈帧的长度会变化，但大部分时候帧的长度是固定的。 一个过程在调用另一个过程时，它会先在寄存器内分配参数；如果六个参数寄存器不够用，多出的参数会被保存在栈帧内。在被调用者分配栈帧之前，调用者会将返回地址压入自己的栈，以指明被调用者返回时调用者的继续执行位置。 如果所有局部变量都可以保存在寄存器中，且这个过程不会调用任何其他过程，这个过程便不会分配栈帧。 转移控制 控制的转移使用的指令是 call 指令和 ret 指令。 call 的使用方式与 jmp 类似，可以直接接&lt;Label&gt;也可以接&lt;*被调用者的起始地址&gt;来间接调用。 call指令会将后一条指令的地址压栈，并将PC(%rip)设置为被调用者的起始地址。 ret指令会保存弹出栈的值，并将PC(%rip)设置为这个值。 数据传送 当参数的数目小于等于六个时，全部参数通过寄存器传递。调用者在执行call指令之前需要将实参填充到对应的寄存器中，被调用者需要使用参数时则只需从寄存器中取数据。 若参数的数目大于六个，多余的数据压入运行时栈。 所有数据的以八字节(四字)为最小单位存储。 参数的顺序是越靠近栈顶的参数越靠后。被调用者可以通过栈顶指针运算来访问这些参数。 参数区域在返回地址区域之前，所以访问时要从 %rsp+8 开始访问。 分配内存有些时候，寄存器不足以满足过程的需要，因此需要在运行时栈上位局部变量分配内存： 寄存器不够用 对一个局部变量进行取地址操作，此时这个局部变量必须有内存地址 局部变量是数组或结构体 分配局部内存的方式 减小栈顶指针%rsp的值 将局部变量的值填充入因为栈顶指针减小而多出来的栈空间内 通过栈顶指针运算访问局部变量 在ret执行之前增大栈顶指针的值，释放内存 寄存器使用为了避免不同过程中新的寄存器值覆盖旧的寄存器值带来损失，x86-64有一套寄存器使用规范。 被调用者保存寄存器：%rbx,%rbp,%r12~%r15 被调用者有义务在自身返回时保证这些寄存器的值与被调用时相同。 被调用者可以选择不改变这些寄存器中的值。 如果必须改变，可以先将其值压栈，在返回前再将旧值从栈中取回寄存器中。 压栈的寄存器值所处的部分称为“保存的寄存器”部分，位于局部变量区域之前。 调用者保存寄存器：除%rsp以外的其他寄存器 任何过程都可以修改这些寄存器的值。 递归实现由于函数栈的性质，递归调用自身和调用其他函数并没有什么区别，递归的实现可谓水到渠成。 数组C语言的数组实现与汇编语言相当接近，因此可以使用头指针和内存运算方便地实现数组。 数组元素a[i+j]的汇编形式：j(a,i,q) a为储存着数组头指针的寄存器或内存位置 i为变量，可以是循环变量 q是数组元素的数据类型大小，可以用sizeof得出 j是常数，用于定址索引 高维数组的储存 C语言对高维数组采取行优先的线性存储。 对于大小为R行C列的数组a来说，a[i][j]的地址应该是(iC+j)size + a 对变长数组的处理 由于数组存储的线性性，不事先知道数组的列数就无法表达第二行开始的数组元素。 因此需要将数组的大小n也作为参数传入才能处理 结构体结构的各个字段通过结构的头指针和字段大小构成的偏移量来访问。机器代码不包含关于字段名字或者字段声明的信息。 联合同理，只不过结构在访问字段时其指针偏移量需要加上该字段前面所有字段的偏移量，而联合每个字段都以联合的头指针为起点。 .align &lt; num &gt; 这个指令可以保证指令后的数据都以num个字节为单位进行数据对齐。 内存越界引用和缓冲区溢出为了对抗Buffer attack，内存系统的设计者使用了这样几种机制： 地址空间布局随机化采用这种方式，每次运行时程序所使用的运行时栈，堆内存，全局变量区以及代码段都会随机被储存在内存的不同区域，这样就避免了一些简单而重复的攻击 针对这种机制，黑客可以在攻击代码之前插入一段很长的nop操作，这样只要随机化过的栈地址与这段nop操作有重合，程序的执行就会沿着这一系列的nop滑到攻击代码。 栈破坏检测程序在每次运行时首先随机产生一个canary值，并储存在栈帧中一个空余的位置(一般在变量区之后)。在返回之前，程序会取出并检查这个canary有没有被改变。如果被改变了，那么程序会异常中止。 GCC会根据一个函数是否容易被进行栈溢出攻击来决定是否要进行这种检测。如果不想使用这种检测，可以在编译时加上-fno-stack-protector选项。 限制可执行代码区域将只需要读写的内存区和可执行的内存区分开，可以有效避免注入攻击。 浮点数操作浮点数使用的寄存器AVX浮点体系结构允许浮点数储存在16个YMM浮点数寄存器中。 16个寄存器的名称分别为ymm0-ymm15，长度均为32个字节。但是float只使用最低的四个字节，double只使用最低的八个字节。 汇编代码通常用xmm0-15来引用这些寄存器。xmm是ymm的后16个字节。 浮点数的操作命令 移动操作 vmovss - 移动单精度数 vmovsd - 移动双精度数 vmovaps，vmovapd - 移动封装好的已经对齐的单精度（双精度）数，一般用于寄存器之间的传送 转换操作 vcvttss2si - 单精度数转整数 vcvttsd2si - 双精度数转整数 第一个操作数是储存浮点数的寄存器，第二个操作数是储存结果整数的寄存器。 这两个操作会进行自动的 截断 而非四舍五入。 转成四字整数只需要在指令后面加后缀q即可 vcvtsi2ss - 整数转单精度数 vcvtsi2sd - 整数转双精度数 这两个操作是三操作数操作，前一个是整数寄存器，后两个一般写同一个浮点寄存器。 vunpcklps，vmovddup - 交叉存放两个寄存器中的字 vcvtpd2psx，vcvtps2pd - 单双精度之间的转换 算术运算 算术运算是由运算名和后缀组成的。 运算名代表运算的种类： vadd：加法 vdiv：减法 vmul：乘法 vdiv：除法 vmax：最大 vmin：最小 sqrt：开方 后缀：ss表示单精度操作，sd表示双精度操作 操作数的数量视操作而定。除了开方之外，所有操作都有三个操作数：前两个进行运算，结果存在第三个中。 位运算 vxorps，vxorpd 位级异或 vandps，vandpd 位级与 位级操作是同时对两个寄存器中的所有128位同时进行进行操作，并将结果储存在第三个操作数中 比较操作 vucomiss 单精度比较操作，结果是S2-S1 vucomisd 双精度比较操作，结果一样 jp 当比较的对象不可以比较时跳转 过程中的浮点数 浮点数使用 %xmm0 来储存返回值 浮点数的传参最大数量是 八 个，多出的参数要出存在栈中 所有xmm寄存器都是调用者保存的 浮点常数的定义和使用 编译器必须为所有的浮点数常量值分配内存空间，然后代码从内存空间读入。 123456789101112Doubletest: vmulsd .LC0(%rip),%xmm0,%xmm0 # 通过程序计数器和标号的结合去引用内存中的浮点数常量 ret.LC0: .long 3435973837 # double低位4字节的十进制表示 .long 1073532108 # double高位4字节的十进制表示Floattest: vmulss .LC1(%rip),%xmm1,%xmm0 ret.LC1: .long 1065353216 # float编码的十进制表示 Chapter 4 处理器体系结构处理器要处理的指令被编码为由一个或者多个字节序列组成的二进制格式。一个处理器支持的 指令集和指令的编码方式 称为这个处理器的 指令集体系结构(ISA) 。 不同的处理器家族所使用的ISA是不兼容的，但是同一家族内的各型号处理器一般使用同种ISA。 在本教材中，我们使用一种比较简单的指令集，称为Y86-64. Y86-64 ISA程序员可见的状态指令集能够修改与读取的那些处理器组成部分称为 程序员可见状态 。 Y86-64的状态包括以下部分： 15个64位寄存器：比x86-64少了一个%r15 程序计数器PC：存放当前指令的地址 条件码CC：有三个条件码，比x86-64少了进位符CF 内存：用 虚拟地址 引用内存位置，它是物理地址的一组字节映像。 程序状态码：用来处理程序异常以防系统崩溃 Y86-64指令集由于Y86-64是简化版的x86-64指令集，因此有很多限制。 只能操作 八字节大小的整数 寻址方式：基址+偏移量，不支持变址寻址，更不支持变址伸缩 不允许在内存地址之间移动数据，不允许将立即数直接写入内存 x86-64的限制它也一样具有 我们需要实现以下指令： 移动指令(movq被分成了四个单独的指令) irmovq 获取一个立即数(立即数移动到寄存器) rrmovq 寄存器间的值传递 mrmovq 从内存中读数据 rmmovq 向内存中写数据 条件和运算指令：操作数只能是寄存器，不能是内存寻址 addq subq andq xorq 跳转指令(由于条件码少了一个CF，无符号数的比较无法实现) jmp 直接跳转 jle &lt;= jl &lt; je = jne != jge &gt;= jg &gt; 条件传送指令(同样不支持无符号数) 函数调用指令 call 返回地址入栈并将PC的值设为目标地址 ret 返回地址出栈并将PC的值设为返回地址 程序栈操作指令 pushq popq 停止指令：停止指令的执行 halt 处理器停止，状态码设置为HLT 指令集编码123456789101112131415161718192021 指令名 操作数 操作数2 指令编码halt 0 0nop 1 0rrmovq rA rB 2 0 rA rBirmovq V rB 3 0 0xF rB Vrmmovq rA D(rB) 4 0 rA rB Dmrmovq D(rA) rB 5 0 rA rB DOPq rA rB 6 fn rA rBjXX Dir 7 fn DircmovXX rA rB 2 fn rA rBcall Dir 8 0 Dirret 9 0pushq rA A 0 rA 0xFpopq rA B 0 rA 0xF附注fn：编码的功能部分(见附表：指令集功能码表)rA，rB：寄存器(见下面的寄存器码)Dir：jmp类和call指令的目标地址D：偏移量V：立即数 12345678910111213141516171819202122指令集功能码表OPq类 addq 60 subq 61 andq 62 xorq 63jXX类 jmp 70 jle 71 jl 72 je 73 jne 74 jge 75 jg 76cmov类 rrmovq 20 cmovle 21 cmovl 22 cmove 23 cmovne 24 cmovge 25 cmovg 26 编码规范 每条指令的第一个字节表明指令的具体类型 前四位是 代码部分 ，表示指令的种类 后四位是 功能部分 ，表示指令是大类中的哪一个 rA和rB都是寄存器，用一个范围在0到E之间的 寄存器标识符 表示。 %rax—0 %rcx—1 %rdx—2 %rbx—3 %rsp—4 %rbp—5 %rsi—6 %rdi—7 %r8—-8 %r9—-9 %r10—A %r11—B %12—-C %r13—D %r14—E 不需要–F 由于小端序的问题，八字节长的立即数，偏移量和地址都要反序书写。也就是说一个指令(以rmmovq $0x12345678,%rax为例)的完整编码是 40 F0 78 56 34 12 00 00 00 00. RISC与CISCCISC，也就是复杂指令集计算机，是比较早发展起来的一种计算机。它们的指令集比较庞大，指令类型多样，功能强大，对硬件的要求和复杂度都很高。为了开发一种能用较少硬件实现的指令集，RISC(精简指令集计算机)成为了人们的研究对象。 RISC的主要特点是指令少而简单，编码方式固定(所有指令都用4字节编码)，寻址方式简单，因而执行速度很快，对硬件要求很小。但因为本来应该由条件码和内存引用承担的一部分工作现在要全部让寄存器来承担，所以这种指令集需要很多性能优良的寄存器，最多有32个。 异常处理 状态码可能的值 AOK—1：表示程序运行正常 HLT—2：执行了halt指令 ADR—3：遇到了非法地址 INS—4：执行了非法指令 在遇到异常的时候，完善的架构会调用一个异常处理函数来处理特定的异常。但在Y86-64这里，我们只简单地让程序停止运行。 伪指令以“.”开头的词是汇编器伪指令。它们用来告知汇编器调整地址。 标号的作用 在汇编语言程序中，不缩进而后跟冒号的 标号 用以指定一个内存地址。通过引用这个标号，指令可以获得这个标号所在代码段位置的内存地址。 汇编器伪指令 .pos &lt; addr &gt; 指定一个地址，这条指令之后的代码从这个地址开始存放。 .align &lt; num &gt; 指定对齐方式 硬件控制语言HCL要实现一个数字系统，需要三个主要的组成部分：位运算函数的组合逻辑，存储位的存储器单元，以及更新存储位信息的时钟信号。 HDL 是描述硬件的一种文本表示，典型的例子是Verilog语言，其语法类似于C。而 HCL 只表达硬件的控制部分，需要翻译成Verilog之后结合一些其他Verilog代码来产生HDL描述，从而生成对应的硬件。 逻辑门和组合电路将很多逻辑门组合在一起，就可以构成 计算块 ，称为 组合电路 。 构建这样的电路有几个限制： 每个逻辑门的输入必须连接到以下选项之一： 系统输入 某个存储单元的输出 某个逻辑门的输出 逻辑门的输出不能连接在一起，否则可能造成信号紊乱。 这个网必须是无环的。 我们可以通过构造HCL表达式的方式来设计这样的组合电路。例如： 位相等判断器：(a&amp;&amp;b)||(!a&amp;&amp;!b) 多路复用器(选择器):(s&amp;&amp;a)||(!s&amp;&amp;b) HCL表达式与C表达式的区别： HCL表达式只对单个位进行操作，可能的值只有0和1,可能的操作只有与或非，因此情况简单，需要进行的操作比较少；而C中的True可以是任一个非0的数，且同时操作一整个字，这样要达到相同的功能就会更加复杂(见datalab中的多路复用器位实现) HCL表达式的变量和值都是动态更新的 C表达式有部分求值的特性，而HCL没有。 字级别的组合电路在HCL语言中，我们把表达式定义为 bool 型，而字级的 信号 不论大小都为 int 型。 在画字级电路时，用虚线表示布尔信号结果，而用中等粗度的线表示携带字的每个位的线路。 多路复用函数是用 情况表达式 来描述的。其通用格式如下： 1234567word Out = [ select_1 : expr_1; select_2 : expr_2; ... select_k : expr_k; 1 : expr_default # 如果前面的都没选中则执行这个]; 与C中的多路复用不同的是，这里只要有一个条件满足就会跳过剩下的。 算术逻辑单元(ALU)是一种很重要的组合电路。它有一组控制输入和一组参数输入，根据控制输入的不同，ALU会对参数做不同的操作，然后输出结果。 集合关系判断集合关系的通用格式是: iexpr in {expr1,…exprn} 如果iexpr在集合内有出现，则表达式的值为真，否则为假。 存储器与时钟组合电路只会接受输入，传送输出而不会存储任何信息。因此，为了产生 时序电路 ，必须引入按位存储信息的设备。 存储器设备 寄存器(这里指硬件上的物理寄存器) ：是CPU的一部分，存储单个位或者单个字。 寄存器的值随着时钟周期更新。 随机访问存储器 ：存储多个字，用地址来决定读写哪个字。具体的例子包括： 处理器的 虚拟内存系统 (也就是我们通常讲的内存):操作系统辅助硬件使CPU能够访问一个很大地址空间中的任意一个字。 在需要读得时候，将write位输入设为0，将address字设置好，等一个时钟周期，在时钟发信号之后就可以在data字接收到输出。如果出现错误，error位会设为1,否则为0. 在需要写的时候，将write位输入设为1，同样地设置address值，并设置输入值到data，等一个时钟周期，再查看error位有没有出现错误。 寄存器文件(就是我们通常说的寄存器的总和)：由所有物理寄存器组成的寄存器阵列构成。 寄存器文件被划分为数个 程序寄存器 。这些程序寄存器的 标识符 就代表着它们在寄存器文件中的地址。 寄存器文件有两个 读端口 和一个 写端口 。每个端口都有一个地址输入(用来指定程序寄存器)，另外读端口还有一个读数据输出，写端口还有一个写数据输入。 Y86-64的顺序实现顺序实现处理器(SEQ)是非常低效的，因为它要在一个时钟周期内完成一条指令的全部步骤。但是，SEQ是开发流水线化处理器必不可少的一个中间过程。 将指令划分阶段绝大部分指令都遵循以下的操作序列： 取指令(fetch)：根据程序计数器的值从内存中读取指令内容。 首先读取代表指令种类的两个四位部分，辨别指令类型 根据指令类型决定的数据长度读取剩下的数据。 译码(decode)：这个阶段从寄存器文件读入至多两个操作数。 执行(execute)：算术逻辑单元执行指令，进行数学和逻辑运算，改变栈指针，设置或检验条件码。 访存(memory)：将运算结果写入内存或从内存读出数据。 回写(writeback)：写入最多两个数据到寄存器文件 更新PC(update)：更新程序寄存器的值 SEQ硬件结构采用SEQ顺序式设计，时基发生器需要将一条指令整个完成的时间作为时钟周期。 硬件对指令六个步骤的配合 取指令： 读程序计数器的值，以其为地址取内存中保存的指令。 PC增加器同时计算下一条指令的地址valP并保存。 译码：寄存器文件有两个读端口，从这两个端口分别读入两个寄存器的值 两个端口的设计保证了这一步骤能够在一个时钟周期内完成 执行：ALU接受输入，进行操作，传递输出 由于Y86-64的计算命令过于简单，所有操作能在一个时钟周期内完成。 访存：从数据内存读入或者写出一个内存字 写回：寄存器文件有两个写端口 一个用来写入ALU的计算结果 一个用来写入从内存中读出的值 PC更新：程序计数器的新值可能是： 下一条指令的地址valP(一般情况) jXX或call指令指定的指令地址(指令是call或jXX时) 从内存读入的返回地址(指令是ret时) SEQ时序控制SEQ的实现包括 组合逻辑 和 两种存储器(时钟寄存器和随机访问存储器)。 组合逻辑不需要时序控制，只要输入产生变化，变化会以光速通过逻辑网进行传播。在小型电路中，对指令内存的访问可以看成和组合逻辑一样的操作；而大型电路可以使用特殊的时基发生器来达到类似的效果。 而对于程序计数器，条件码寄存器，数据内存和寄存器文件，它们通过一个时钟信号来控制，这个信号会触发向寄存器和数据内存的写操作。 组织计算有一个原则：从不回读，也就是处理器不需要为了完成一条指令而去读因为这条指令更新过的状态。 如pushq指令，它既要使用%rsp的值又要更新%rsp的值，这种情况下为了这个原则要把使用这个步骤放在更新前面。分步来看，首先在执行阶段指令计算%rsp+8并保存，然后访存阶段用%rsp的值去写内存，写回阶段再将%rsp+8的值写回%rsp中。 另外的一个例子是CC的更新。没有指令会同时改变CC的值和使用CC的值，因此任何指令试图读CC的之后它的值都是已经更新的。 SEQ的HCL实现 用作HCL参数的常数预定义 指令代码 IHALT INOP IRRMOVQ IIRMOVQ IRMMOVQ IMRMOVQ IOPL IJXX ICALL IRET IPUSHQ IPOPQ FNONE 默认功能码 寄存器 RRSP %rsp的寄存器ID RNONE 表示无寄存器参与 ALUADD 加法运算的功能 状态码 SAOK 正常 SADR 地址异常 SINS 操作异常 SHLT Halt 取指令 以PC为起始地址，从内存中读出10个字节 如果地址不合法，就舍弃后9个字节，并将第一个字节设置为nop指令，同时产生一个 imem_error信号 ，传递到下一步骤 从第一个字节中取得icode与ifun值，并进行一系列逻辑判断，判断结果传递至下一步骤 instr_valid：该指令是否为合法的Y86-64指令 need_regids：该指令是否包含寄存器字节 need_valC：该指令是否包含常数字 这三个判断使用一个HCL中的 集合关系判断 就可以实现。 根据icode与ifun值产生 alufun 信号并传递到执行阶段 标号为“Align”的硬件单元处理后面的九个字节 if need_regids : 将第二个字节分开分别放入 rA 和 rB 指示符，后八个字节作为常数字 else : 将第二个到第九个字节作为常数字 PC增加器计算生成valP PC值为p，need_rigids值为r，need_valC值为c 则valP = p + r + 8c + 1 译码和写回阶段 寄存器文件的两个读端口和两个写端口都各有两个输入(或一个输入一个输出)：一个地址输入表示寄存器的编号，一个数据输入输出表示读写的数据。两个读端口的地址输入是 srcA 和 srcB ，两个写端口则是 dstE 和 dstM (分别存放计算结果和内存中取出的值)。 根据icode值，通过逻辑控制填入两个读端口(或者写端口)的地址输入 当遇到popq %rsp指令时，两个写端口的目标将会是同一个寄存器。这时需要在两个写端口之间确定一个优先级。为了让从内存中读出的值能存到%rsp，让 dstM优先级更高 ，也就是冲突的时候不写入dstE。 执行阶段 将两个操作数填入ALU 前一个操作数填valB 后一个操作数根据情况填valA或常数C或8，-8 产生一个信号 set_cc 判断操作是否为OPq，不是则没必要更新条件码寄存器。 标号为“cond”的硬件单元根据条件码CC和icode，ifun值判断是否需要跳转或条件传送。判断结果作为一个 Cnd信号 传递给下一个步骤 ALU进行计算，计算结果是 valE 访存阶段 读写控制模块根据icode的值判断是应该读还是应该写。 地址控制模块根据icode的值判断内存地址是valA还是valE 数据控制模块根据icode的值判断数据是valA还是valP(返回地址) 进行读写操作，读出的值为 valM 根据数据内存产生的 dmem_error 信号及之前产生的三种信号设置程序的stat状态码 更新PC阶段 控制模块根据Cnd信号和icode值判断采用valC，valM，valP中的哪一个作为新的PC值 SEQ的HCL实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173# 由于HCL语言不像HDL那样有着对硬件本身的封装，这里使用一些类似于类的语法来表示硬件# 程序开始运行# 取指令word p = PC.read(); # 读出PC中的值if p == SADR： word ins = INOP; bool imem_error = 1; # 如果PC中储存的地址不合法，产生imem_error信号并将指令设置为nopelse： word ins = MEM.read(baseptr=p,size=10); # 以p为基址在内存中读出10个字节 int icode,int ifun = SPLIT.split(ins[0]); # 指令的第一个字节被split硬件单元解析 bool instr_valid = ***; # 这个判断就是依次判断每个可能的icode对应的ifun是否符合，过于长这里不写了 bool need_regids = icode in &#123;IRRMOVQ,IIRMOVQ,IMRMOVQ,IRMMOVQ,IOPQ,IPUSHQ,IPOPQ&#125;; bool need_valC = icode in &#123;IIRMOVQ,IMRMOVQ,IRMMOVQ,IJXX,ICALL&#125;; # 这两个判断看一下哪些指令需要常数字段和寄存器字段就好了 if need_regids： int rA,int rB = ALIGN.align(ins[1]); if need_valC： word valC = ALIGN.align(ins[2:10]); # 如果指令需要寄存器就从第二个字节中读出 # valC同理，都由align硬件单元读出 else： int rA = 0xF; int rB = 0xF; if need_valC： word valC = ALIGN.align(ins[1:9]); # 反之，如果不需要寄存器就将两个寄存器值都设为0xF，即无寄存器 # 这样valC就会存放在指令的2到9字节。 word valP = p + need_regids + 8*need_valC; # valP代表下一条指令的地址# 译码word srcA = [ icode in &#123;IRRMOVQ,IMRMOVQ,IOPQ,IPUSHQ&#125; : rA; # 需要读rA寄存器的值时 icode in &#123;IPOPQ,IRET&#125; : RRSP; # 这里与后面访存阶段的访问联系 1 : RNONE; # 默认情况是没有寄存器需求]; # srcA一般用来提供运算的第二个参数word srcB = [ icode in &#123;IRMMOVQ,IOPQ&#125; : rB; # 需要读rB寄存器的值时 icode in &#123;IPUSHQ,IPOPQ,ICALL,IRET&#125; : RRSP; 1 : RNONE;]; # srcB提供运算的主参数与rsp地址信息word valA = REG.read(srcA);word valB = REG.read(srcB);# 从寄存器文件中读出对应的值并保存为valA和valB# 执行word aluA = [ icode in &#123;IRRMOVQ,IOPQ&#125; : valA; # 寄存器rA的值直接作操作数 icode in &#123;IIRMOVQ,IMRMOVQ,IRMMOVQ&#125; : valC; # 内存与寄存器之间的移动需要计算地址加偏移量，所以将valC作操作数 icode in &#123;ICALL,IPUSHQ&#125; : -8; icode in &#123;IRET,IPOPQ&#125; : 8; # 这几个指令涉及对栈地址的计算，以8为单位进行增减，需要用到ALU计算]; # 辅助操作数word aluB = [ icode in &#123;IRMMOVQ,IOPQ&#125; : valB; # 寄存器rB的值直接做操作数或需要做地址运算 icode in &#123;IMRMOVQ&#125; : valA; # 寄存器rA的值需要做地址运算 icode in &#123;ICALL,IRET,IPUSHQ,IPOPQ&#125; : valB; # 这些时候valB的值是%rsp寄存器的值，作为栈基址操作数 icode in &#123;IIRMOVQ,IRRMOVQ&#125; : 0; # 保留aluA的值不受操作影响]; # 主操作数word alufun = [ icode == IOPQ : ifun; 1 : 1; # 除了在使用IPOQ指令时，所有时候ALU都是当加法器用的，其对应的alufun值为1]; # 操作类型bool set_cc = icode in &#123;IOPQ&#125;;# 如果指令是IOPQ，还要设置条件码int cc = ALU.calculate(aluA,aluB,func=alufun);# ALU进行运算并返回条件码if set_cc: CC.set(cc); # 设置条件码bool Cnd = COND.gencnd(CC.get())# 生成Cnd信号，传输给写回阶段# 访存word mem_addr = [ icode in &#123;IRMMOVQ,IMRMOVQ,ICALL,IMRMOVQ&#125; : valE; # 正常状态的地址都要经过ALU的计算成为valE icode in &#123;IRET,IPOPQ&#125; : valA; # 这边是与译码部分联系]; # 确定内存访问的地址bool mem_read = icode in &#123;IMRMOVQ,IPOPQ,IRET&#125;;bool mem_write = icode in &#123;IRMMOVQ,IPUSHQ,ICALL&#125;;# 确定指令要求的访存方式是读还是写word mem_data = [ icode in &#123;IRMMOVQ,IPUSHQ&#125; : valA; # 从寄存器中获取写入值 icode == ICALL : valP; # CALL指令要写入的是返回地址，也就是下一条指令的地址valP。]; # 确定读写的数据try: if mem_read: valM = MEM.read(baseptr=mem_addr,size=8); if mem_write: MEM.write(baseptr=mem_addr,data=mem_data); # 读写数据except: bool dmem_error = 1;word stat = [ imem_error || dmem_error : SADR; !instr_valid : SINS; icode == IHALT : SHLT; 1 : SAOK;];STAT.set(stat);# 判断程序运行状态并更新状态码# 写回word dstE = [ icode in &#123;IIRMOVQ,IOPQ&#125; : rB icode in &#123;IRRMOVQ&#125; &amp;&amp; Cnd : rB # 这里要包含一下条件传送的情况 icode in &#123;IPUSHQ,IPOPQ,ICALL,IRET&#125; : RRSP 1 : RNONE] # 需要写入计算结果时word dstM = [ icode in &#123;IMRMOVQ&#125; : rB icode in &#123;IPOPQ&#125; : rA 1 : RNONE] # 需要写入访存结果时REG.write(dstE,data=valE);REG.write(dstM,data=valM);# 进行写回# 更新PCword new_pc = [ icode == ICALL : valC; # 调用函数则直接跳到函数起始地址 icode == IJXX &amp;&amp; Cnd : valC; # 条件跳转需要判断条件 icode == IRET : valM; # 读取返回地址 1 : valP; # 正常情况下就到下一句指令];PC.set(new_pc);# 更新PC# 指令执行完毕，回到开头，开始执行下一条指令... 流水线化原理流水线化的重要优点就是增加了系统的 吞吐量 ，也就是单位时间内能够服务顾客的数量；但缺点是会稍稍增加对单独顾客的 延迟(处理某一阶段需要的时间) ，因为每个顾客都要经历每个步骤，不管它需不需要某些步骤。 在硬件设计中，只需要将整个过程划分为数个步骤，在每两个步骤之间插入储存中间结果的寄存器，就可以实现SEQ的流水线化。 流水线化的局限性 不一致的划分 如果流水线上的几个步骤所需要的延迟差距较大，由于流水线的时钟周期必须适应延迟最长的那个步骤，整个流水线的效率都会被拖慢，造成很大的资源浪费。 对硬件设计来说，划分延迟相差不大的阶段是一件比较难的事。 流水线过深的惩罚 比起顺序执行，流水线化执行需要在它划分的每两个阶段之间插入一组流水线寄存器，以储存中间结果。在这组寄存器上的读写也会产生延迟，而当流水线过深(也就是划分阶段过多)时，这些延迟会拖慢整体的吞吐量。 为了减轻这个惩罚，现在的流水线寄存器延迟已经很小。 带反馈的流水线化系统对于条件控制的条件码处理，以及PC的更新和寄存器的更新，这些都属于 反馈路径 ，每一条指令产生的变化都会反馈给下一条指令。 然而在流水线系统中，这个处理会带来危险。我们知道由于流水线化的进行，每个阶段执行的时候与它同时执行的前一个阶段就不是它所在指令的阶段，而是后一个指令的阶段了。这样如果仍然使用原来的反馈机制，就会导致一个指令的反馈信息反馈到了之后的指令那里。 设计流水线化的Y86-64处理器 重新安排计算阶段 为了避免反馈机制被流水线化干扰，有必要调整一下各个阶段的内容与顺序。 一个可能的改进是移动计算PC阶段，使其在一个时钟周期的开始时作用而不是在时钟周期结束。在每个时钟周期开始时，根据状态寄存器中的值动态地计算PC值。 这种策略称为 电路重定时 ，它是指在不改变电路逻辑的情况下调整一个系统的状态表示。电路重定时通常用来平衡流水线各阶段之间的延迟。 插入流水线寄存器 在各个阶段之间插入流水线寄存器并对信号重新排列，得到PIPE-处理器结构。 五个流水线寄存器的职能 F 保存程序计数器的预测值 D 保存icode,ifun,rA,rB,valC,valP等指令信息 E 保存从寄存器文件中读出的值及计算得出的srcA、srcB、dstE、dstM信息，传递icode,ifun,valC信息 M 保存计算结果valE与状态码Cnd，传递icode，dstE，dstM信息 W 保存将要写回寄存器的valE和valM以及写回地址dstE和dstM 将dstE和dstM一直传递到这一步的目的是保证写回地址和写回数据匹配。 在流水线化系统的一个时钟周期中，状态码的值stat是随时会变化的。这要求我们仔细地处理stat的值。对于寄存器中储存的stat值，我们使用D_stat,E_stat,M_stat,W_stat来表示；对于阶段中的stat值，我们改用小写字母前缀表示。 PC值的预测 除了条件转移类指令和ret指令，我们都可以在解析一条指令的同时准确地得知PC的下一个值，从而在下一个阶段PC读入新一条指令之前更新PC的值。因此，通过预测PC值，大部分指令都可以做到每个时钟周期发射一条指令。 对于条件转移类指令，根据条件码PC既有可能是valC(跳转),又有可能是valP(不跳转)。因此，如果预测发生错误，我们需要设计完善的修正错误的机制。 猜测分支的方向并根据猜测取指的技术称为 分支预测 。PIPE-简化了预测过程，即我们总是预测将要将valC作为PC的新值。 由于分支预测发生错误会极大影响程序性能，条件传送 一般比 条件跳转 要更好一些。 对于ret指令，由于PC的新值有近乎无限种可能性，我们放弃预测，转而暂停流水线的运行直到PC的值有确定的结果。 在一些硬件设计中，会有一个程序员不可见的硬件栈，它在每次函数call的时候将返回地址压栈，而在每次ret指令时从栈顶弹出一个地址作为新的PC值。 Streamline Hazard 根据相邻指令之间的反馈方式，Hazard可以分为Data Hazard和Control Hazard两类。 Data Hazard Data Hazard的类型 寄存器：一条指令要改变某个寄存器，但在写回阶段之前另一条指令读取了该寄存器的值。 程序计数器：错误的预测和ret的影响 内存：如果程序在访存阶段修改代码部分内存，会引起之后的指令取指出错。我们简单地禁止程序修改自身代码段来避免这种情况。除此之外，由于内存读写发生在同一阶段，不同指令之间不会发生冲突。 条件码寄存器：不会发生Hazard。 状态寄存器stat：采用多状态码机制。 如何避免Data Hazard的发生 Stalling(暂停)：暂停一条或多条指令(通过插入bubble)，直到Hazard的条件不再满足。 Forwarding(转发)：对于某些情况，可以直接将将要写回寄存器的结果转发至另一条指令的读寄存器端口。这样可以大幅减少需要的暂停时间。 load interlock：将暂停和转发技术合理地结合起来，基本可以实现高吞吐量。 Control Hazard 当处理器无法通过取指阶段的指令去预测下一个指令的地址时会发生控制冒险。 Control Hazard的处理措施 ret：使用Stalling策略 jxx：使用Cancel策略。设当前指令为指令1,则它在执行阶段就可以通过状态码CC的设置判断之前的预测是否发生了失误。如果发生失误，由于指令2和指令3还分别在译码和取指阶段而没有进行任何数据写操作，它们对程序状态其实是没有影响的。于是，我们重新设定PC值，并用bubble取代指令2和指令3剩余的阶段，以消除错误带来的影响。 异常处理 在Y86-64处理器模型中，我们主要处理三种内部异常： halt指令 由非法指令和有非法功能码组合的指令引起的异常 取指和数据读写使用了非法地址 引起异常的指令称为 异常指令 。在异常触发之后，一个完整设计过的操作系统会调用异常处理程序，但在简化模型中处理器会直接停止并设置状态码。 对于优先级问题，在流水线中位置最深的指令引发的异常优先级最高。 当处于访存或者写回阶段的指令引发异常时，流水线控制逻辑应当立即禁止处理器或内存的更新。 控制逻辑处理器的控制逻辑处理其他机制无法处理的四种情况： Data Hazard ret语句 预测失误 异常 处理它们的主要方式是插入气泡(bubble)，也就是将某些步骤的icode设置为INOP，并用RNONE填充流水线寄存器；以及暂停(stalling)，就是禁止流水线寄存器更新状态以将指令阻塞在某个阶段。 控制逻辑机制 序号 条件 F D E M W 1 处理ret语句 Stall Bubble -&gt; -&gt; -&gt; 2 Regid/Memory Hazard Stall Stall Bubble -&gt; -&gt; 3 预测错误的分支(E中发现) -&gt; Bubble Bubble -&gt; -&gt; 4 1,3的组合情况(同时) Stall Bubble Bubble -&gt; -&gt; 完整的Y86-64流水线化处理器PIPE的HCL实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251# 可以发现PIPE的实现与SEQ是大部分一致的，只是在信号前加入了前缀# 大写的前缀代表寄存器中的值，小写的前缀代表产生的信号&gt;&gt;&gt; 取指和PC Selection# 控制逻辑，对于F阶段只有Stall的可能bool F_stall = # 寄存器/内存 Hazard E_icode in &#123;IMRMOVQ,IPOPQ&#125; &amp;&amp; E_dstM in &#123;d_srcA,d_srcB&#125; || IRET in &#123;D_icode,E_icode,M_icode&#125;; # RET指令# 解析阶段，与SEQ基本没有区别word p = PC.read(); # 读出PC中的值if p == SADR： word f_ins = INOP; bool imem_error = 1; # 如果PC中储存的地址不合法，产生imem_error信号并将指令设置为nopelse： word f_ins = MEM.read(baseptr=p,size=10); # 以p为基址在内存中读出10个字节 int f_icode,f_ifun = SPLIT.split(ins[0]); # 指令的第一个字节被split硬件单元解析 bool instr_valid = ***; # 这个判断就是依次判断每个可能的icode对应的ifun是否符合，过于长这里不写了 bool need_regids = icode in &#123;IRRMOVQ,IIRMOVQ,IMRMOVQ,IRMMOVQ,IOPQ,IPUSHQ,IPOPQ&#125;; bool need_valC = icode in &#123;IIRMOVQ,IMRMOVQ,IRMMOVQ,IJXX,ICALL&#125;; # 这两个判断看一下哪些指令需要常数字段和寄存器字段就好了 if need_regids： int f_rA,f_rB = ALIGN.align(ins[1]); if need_valC： word f_valC = ALIGN.align(ins[2:10]); # 如果指令需要寄存器就从第二个字节中读出 # valC同理，都由align硬件单元读出 else： int f_rA = 0xF; int f_rB = 0xF; if need_valC： word f_valC = ALIGN.align(ins[1:9]); # 反之，如果不需要寄存器就将两个寄存器值都设为0xF，即无寄存器 # 这样valC就会存放在指令的2到9字节。 word f_valP = p + need_regids + 8*need_valC; # valP代表下一条指令的地址# 对于PC值的运算word f_predPC = [ f_icode in &#123;ICALL,IJXX&#125; : f_valC 1 : f_valP]; # 预测PC的值f_predPC =&gt; F_predPC # 将预测结果存入流水线寄存器Fword f_pc = [ M_icode == IJXX &amp;&amp; !M_Cnd : M_valA; # 预测发生错误的情况，根据M寄存器储存的值判断 W_icode == IRET : W_valM; # ret指令 1 : F_predPC # 大多数情况，预测模块给出的值都是正确的]; # 确定PC的值，为取出下一条指令作准备# 信号的传递f_icode =&gt; D_icodef_ifun =&gt; D_ifunF_stat += (imem_error,instr_valid) =&gt; D_statf_rA =&gt; D_rAf_rB =&gt; D_rBf_valC =&gt; D_valCf_valP =&gt; D_valP&gt;&gt;&gt; 译码和写回# 控制逻辑，这里可能会发生Stall或Bubblebool D_stall = E_icode in &#123;IMRMOVQ,IPOPQ&#125; &amp;&amp; E_dstM in &#123;d_srcA,d_srcB&#125;;bool D_bubble = (E_icode == IJXX &amp;&amp; !e_Cnd) || # 预测出现失误的情况 !(E_icode in &#123;IMRMOVQ,IPOPQ&#125; &amp;&amp; E_dstM in &#123;d_srcA,d_srcB&#125;) &amp;&amp; IRET in &#123;D_icode,E_icode,M_icode&#125;; # 处理RET指令# 译码部分与SEQ大部分一致word d_srcA = [ D_icode in &#123;IRRMOVQ,IRMMOVQ,IOPQ,IPUSHQ&#125; : D_rA; D_icode in &#123;IPOPQ,IRET&#125; : RRSP; 1 : RNONE;];word d_srcB = [ D_icode in &#123;IRMMOVQ,IOPQ&#125; : D_rB; D_icode in &#123;IPUSHQ,IPOPQ,ICALL,IRET&#125; : RRSP; 1 : RNONE;];word d_dstE = [ D_icode in &#123;IIRMOVQ,IOPQ,IRRMOVQ&#125; : D_rB; D_icode in &#123;IPUSHQ,IPOPQ,ICALL,IRET&#125; : RRSP 1 : RNONE]; # 写回阶段的地址计算放在了译码阶段word d_dstM = [ icode in &#123;IMRMOVQ&#125; : D_rB icode in &#123;IPOPQ&#125; : D_rA 1 : RNONE]; # 初步的地址计算word d_rvalA = REG.read(d_srcA);word d_rvalB = REG.read(d_srcB);# 由于PIPE对valA和valP有个合并机制，这里读出的并不是最终的valA# 合并信号valA和valP的依据是，只有call和跳转指令需要valP的值，而它们都不会需要valA# 在这个阶段要处理数据转发，转发源有五个，需要分情况讨论word d_valA = [ D_icode in &#123;IJXX,ICALL&#125; : D_valP; d_srcA == e_dstE : e_valE; # Forwarding，直接接受上一条指令execute阶段的计算结果 d_srcA == M_dstM : m_valM; # Forwarding，接受上上条指令memory阶段的读内存结果 d_srcA == M_dstE : M_valE; # Forwarding，接受上上条指令memory阶段进行前还未写回的计算结果 d_srcA == W_dstM : W_valM; d_srcA == W_dstE : W_valE; # Forwarding，接受上上上条指令在写回之前W寄存器中储存的访存和计算结果 1 : d_rvalA; # 没有Forwarding，直接采取寄存器中读出的valA];word d_valB = [ d_srcB == e_dstE : e_valE; # Forwarding，直接接受上一条指令execute阶段的计算结果 d_srcB == M_dstM : m_valM; # Forwarding，接受上上条指令memory阶段的读内存结果 d_srcB == M_dstE : M_valE; # Forwarding，接受上上条指令memory阶段进行前还未写回的计算结果 d_srcB == W_dstM : W_valM; d_srcB == W_dstE : W_valE; # Forwarding，接受上上上条指令在写回之前W寄存器中储存的访存和计算结果 1 : d_rvalB; # 没有Forwarding，直接采取寄存器中读出的valA];# 信号传递D_stat =&gt; E_statd_icode =&gt; E_icoded_ifun =&gt; E_ifund_valC =&gt; E_valCd_valA =&gt; E_valAd_valB =&gt; E_valBd_srcA,d_srcB,d_dstE,d_dstM =&gt; E_srcA,E_srcB,E_dstE,E_dstM&gt;&gt;&gt; 执行# 控制逻辑，只会出现Bubblebool E_bubble = E_icode in &#123;IMRMOVQ,IPOPQ&#125; &amp;&amp; E_dstM in &#123;d_srcA,d_srcB&#125; || (E_icode == IJXX &amp;&amp; !e_Cnd)# 这部分实现基本与SEQ无异word e_aluA = [ E_icode in &#123;IRRMOVQ,IOPQ&#125; : E_valA; # 寄存器rA的值直接作操作数 E_icode in &#123;IIRMOVQ,IMRMOVQ,IRMMOVQ&#125; : E_valC; # 内存与寄存器之间的移动需要计算地址加偏移量，所以将valC作操作数 E_icode in &#123;ICALL,IPUSHQ&#125; : -8; E_icode in &#123;IRET,IPOPQ&#125; : 8; # 这几个指令涉及对栈地址的计算，以8为单位进行增减，需要用到ALU计算]; # 辅助操作数word e_aluB = [ E_icode in &#123;IRMMOVQ,IOPQ&#125; : E_valB; # 寄存器rB的值直接做操作数或需要做地址运算 E_icode in &#123;IMRMOVQ&#125; : E_valA; # 寄存器rA的值需要做地址运算 E_icode in &#123;ICALL,IRET,IPUSHQ,IPOPQ&#125; : E_valB; # 这些时候valB的值是%rsp寄存器的值，作为栈基址操作数 E_icode in &#123;IIRMOVQ,IRRMOVQ&#125; : 0; # 保留aluA的值不受操作影响]; # 主操作数word e_alufun = [ E_icode == IOPQ : E_ifun; 1 : 1; # 除了在使用IPOQ指令时，所有时候ALU都是当加法器用的，其对应的alufun值为1]; # 操作类型# 设置条件码，这里要小心异常触发的情况bool set_CC = !(m_stat in &#123;SADR,SINS,SHLT&#125;) &amp;&amp; !(W_stat in &#123;SADR,SINS,SHLT&#125;) &amp;&amp; E_icode == IOPQ ;# 如果memory和writeback阶段的指令触发了异常，任何对条件码的修改都应该中止。word e_valE, int cc = ALU.calculate(e_aluA,e_aluB,func=e_alufun);if set_cc: CC.set(cc);bool e_Cnd = COND.gencnd(CC.get());# 进行计算，设置条件码# 信号传输E_stat =&gt; M_state_icode =&gt; M_icodee_Cnd =&gt; M_Cnde_valE =&gt; M_valEE_valA =&gt; M_valAe_dstE =&gt; M_dstEE_dstM =&gt; M_dstM&gt;&gt;&gt; 访存# 控制逻辑，这部分需要处理异常bool M_bubble = m_stat in &#123;SADR,SINS,SHLT&#125; || W_stat in &#123;SADR,SINS,SHLT&#125;;# 这一部分与SEQ相同word mem_addr = [ M_icode in &#123;IRMMOVQ,IMRMOVQ,ICALL,IMRMOVQ&#125; : M_valE; M_icode in &#123;IRET,IPOPQ&#125; : M_valA;];bool mem_read = M_icode in &#123;IMRMOVQ,IPOPQ,IRET&#125;;bool mem_write = M_icode in &#123;IRMMOVQ,IPUSHQ,ICALL&#125;;# 确定读写数据的步骤被省略了，因为之前已经将valA和valP进行了merge操作try: if mem_read: m_valM = MEM.read(baseptr=mem_addr,size=8); if mem_write: MEM.write(baseptr=mem_addr,data=M_valA);except: bool dmem_error = 1;# 信号传输m_stat += dmem_eroor =&gt; W_statM_icode =&gt; W_icodeM_valE =&gt; W_valEm_valM =&gt; W_valMM_dstE =&gt; W_dstEM_dstM =&gt; W_dstM&gt;&gt;&gt; 写回# 在下一个时钟周期开始之前，handle一下异常bool W_stall = W_stat in &#123;SADR,SINS,SHLT&#125;; 示意图 改进的空间 多周期指令 整数乘法需要3-4个时钟周期完成，而整数除法更是需要64个周期。对于这样的多周期操作，必须调整流水线的设计以适应其运行时间。 与存储系统的接口 在PIPE设计中，我们假设取指单元和数据内存的读写都可以在一个时钟周期内完成(但这显然是不可能的)。 通过高速缓存和翻译后备缓冲器(将物理地址翻译为虚拟地址)，可以将数据内存读写的速度尽可能降低到一个时钟周期以内。 对于高速缓存不命中和pagefault异常触发等问题，可以使用stall来等待数据就位。 Chapter 5 优化程序性能绪论 编写高效程序的要素 合适的算法和数据结构 写出适于编译器优化的代码 不同的语言优化的难度是不同的，越灵活的语言越是难以优化。 程序员应当在代码性能和代码可读性之间作出权衡。 使用并行计算的策略 编译器优化的局限性编译器的优化级别编译器会对其在编译过程中做的优化工作量做一个分级。以GCC为例，参数-Og表示使用基本的优化，-O1到-O3则代表着越来越大的优化量。 优化量越大，程序的效率一般会越高，但程序和源程序的差距也越大，越难以调试。企业采用的优化标准一般是-O2级，本书采用的级别是-O1. 保证优化的安全性为了避免优化前后程序的行为出现差异，编译器被限制为只能做出“安全”的优化。这就意味着编译器能做的改动更小，程序员的优化显得更为重要。 不安全的优化大致有以下几种： Memory aliasing在对指针的目标值进行操作的过程中，可能出现两个指针指向同一个内存地址的情况，这种状况称为 内存别名使用(Memory aliasing) 。编译器必须假设两个不同的指针可能指向同一位置，这就大大限制了可以作出的优化。 例如，执行下面代码段： 123*ptr1 = 3000;*ptr2 = 1000;x = *ptr1; 如果两个指针指向不同的位置，那么x无疑等于3000,但如果反之，由于逻辑顺序，x等于1000。考虑到可能出现二义性的后果，编译器不能产生类似这样的代码段(除非源程序有意为之)。 函数调用同一个函数，以同样的参数调用，其返回的值可能不同，这是过程式语言的一大弱点，即所谓的side effect。这就导致了，编译器无法把以几次函数调用的返回值为操作数的多次操作化简为一次操作，比如不能把f()+f()化简为2*f()。 度量程序的性能对于线性类复杂度的程序，我们引入 每元素周期数(CPE) 作为度量标准。每元素周期数指的是输入每增加一个元素，程序所多消耗的时钟周期数。本质上讲，也就是复杂度公式中n项的参数。 对循环过程进行的优化代码移动将在循环过程中结果不会改变的操作移到循环外进行，这个过程称为 代码移动(code motion) 。编译器在遇到函数调用或内存访问的情况下不敢进行代码移动，因为它们可能产生side effect。这种时候就需要程序员宏观地修改代码进行代码移动。 代码移动是一项简朴易懂但十分有效的优化。虽然看似有经验的程序员都能够自动完成这项工作，但大型项目中也不乏由于没有进行代码移动而导致的效率危机。 减少过程调用是应该进行更多的封装，使程序更加模块化和易于复用还是减少过程的调用，直接操作底层数据结构一直是一个保受争议的问题。对于C程序员来说，灵活地操作底层数据结构虽然会增大程序崩溃的几率，但可以大大提高程序的运行效率(因为减少了不必要的条件检查)。 消除不必要的内存引用众所周知，内存读写比寄存器的读写要慢的多。因此，在循环过程中用临时变量存储计算中间结果要大大优于每次都进行内存读写。尽量消除不必要的内存读写可以大大提高程序性能，尤其是在循环结构中。 利用硬件特性进行的优化现代处理器的微体系结构已经相当发达，这使得汇编语言指定的行为与机器实际的行为大相径庭。由于 指令级并行 的存在，现代处理器同时对多条指令进行求值，通过hazard消除技术避免副作用，并通过巧妙的安排让执行结果看上去像是顺序执行的。 在上一章对处理器流水线结构设计的了解中，我们知道要避免Hazard必须满足前后两条指令之间没有依赖关系，否则无论如何后一条指令都必须在前一条指令执行完后才能执行。一系列操作之间的依赖性导致的性能瓶颈称为 延迟界限(latency bound)，而处理器本身算力所导致的性能瓶颈称为 吞吐量界限(throughput bound) 。 现代微处理器设计与之前的流水线顺序处理器不同，现代处理器是乱序处理的，也就是说指令执行顺序甚至不一定与机器语言中规定的相同。为了达成这个目的，处理器分为两部分：指令控制单元(ICU) 和 执行单元(EU) 。前者负责读出指令序列并生成操作，后者执行这些操作。 ICU会从指令高速缓存中取指令，并利用分支预测技术来决定下一个指令从哪里取出。每取出一个指令，ICU都将其拆分成一个个单元操作，并将单元操作们输送给EU，再由EU中的多个操作单元并行执行各种单元操作。 功能单元的性能功能单元的性能从三个方面衡量：延迟(latency)，发射时间(issuetime)，容量(capacity)。 延迟表示运算需要的总时间，而发射时间表示开始执行一次运算后到开始执行下一次运算所需要的时间。在完全顺序执行的情况下两者应该相等，但由于流水线化的设计，一条指令可以在上一条结束前就开始执行，这使得发射时间大大减小了。发射时间为1的操作称为完全流水线化操作，这种操作的两次之间必须是完全无依赖的。 容量则表示了能执行一个操作的功能单元数。一个处理器的 吞吐量 由功能单元的发射时间和容量决定，其具体值为 capacity/issuetime。 关键路径将操作全部分解为基本操作，理清寄存器的占用与操作之间的依赖关系之后，便可以找出所有依赖链中最长最粗的一条，这条操作链就是关键路径。关键路径的长度和单位长度耗时直接决定着延迟界限，也就是程序性能。 循环展开将原循环过程中的每两次循环合并为一次来书写循环体，这种修改称为 循环展开 。 循环展开有如下好处： 减少了条件判断和迭代量计算的次数 提供了变化代码，减少关键路径上操作的机会 在不改变关键路径操作的情况下，循环展开能将性能改善到逼近延迟界限的程度。 优化等级-O3会使GCC自动使用循环展开优化。 提高并行性这一部分，《串并行算法与数据结构》已经讲的足够清楚了。 其他的制约因素寄存器溢出虽然程序的并行度可以提高，但是处理器的寄存器数量是有限的。如果我们只顾着提高并行度，建立更多的临时循环变量，寄存器就可能发生不够用的情况。这时，处理器会在程序栈甚至内存中存放临时变量，这样甚至会使程序性能变得更低。 预测错误处罚分支预测技术的错误处罚代价是很大的，因为要抛弃所有正在运行的指令和结果并跳回到新位置重新开始。很难帮助处理器避免预测错误，因为其预测逻辑不为程序员所见。但是，如果能够尽量用 条件数据传送 来取代 条件控制转移 命令，就可以大大减少分支预测错误的处罚，因为数据传送一般不涉及控制流跳转问题，发生错误只需要更改结果即可。 对于GCC来说，用条件操作计算值并用值更新程序状态会编译出条件数据传送，而直接用条件操作改变程序状态则会编译出条件控制转移。因此，在一些关键位置改变代码风格可以大大降低错误预测的开销。 程序分析工具gprofgprof以二进制可执行文件为参数，它记录输入的程序执行过程中每个函数所花的时间。 Chapter 6 存储器层次结构存储技术随机访问存储器(RAM)随机访问存储器分为两类：静态的(SRAM)和动态的(DRAM)。SRAM比DRAM更快(1000倍)，常常用作高速缓存。 SRAM由双稳态存储单元组成。每个单元都是一个六晶体管电路，它只有两种稳态值，只要有电，就算受到扰动也会迅速回归到稳态值上去。 DRAM由C很小的电容组成，用对电容的充电或无电表示1和0。DRAM存储器单元对扰动非常敏感，一旦电压被扰乱便无法恢复。 内存条的存储结构每一块DRAM芯片的存储位被组织成同样大小的 单元 ，每个单元一般含有若干个字节的信息。单元在DRAM芯片中以矩阵形式排列，每个单元都有其唯一的可以被索引的地址。 DRAM芯片通过 引脚 和外界沟通，一块芯片有8个data引脚，用以传递一个字节的信息；还有若干个addr引脚，用以索引具体的单元。每个芯片还有一个行缓冲区。 所有的DRAM芯片都连接到一个内存控制器上，内存控制器可以同时向每个DRAM芯片发送一位。在需要读取的时候，控制器首先将需要读取的地址转换成DRAM中的行和列索引，随即向每个DRAM芯片的addr发送一个相同的行索引，让其将对应的行复制到行缓冲区中；然后发送一个列索引，从每个芯片中取到目标单元值，最后内存控制器整合所有的单元值并输出。 非易失性存储器只读存储器(ROM)PROM存储器(programmable read-only memory)只能被编程一次，它由能用高电流熔断的熔丝组成。EPROM(erasable PROM)和EEPROM(electrical EPROM)则可以多次编程。 存储在ROM中的程序称为 固件(firmware) 。它包括一些基本的输入输出函数和计算机系统启动所必需的程序。 磁盘Chapter 7 链接Compiler driver大多数需要编译的语言都会提供一个 编译器驱动程序(Compiler driver) ，以C语言为例，这个程序会依次调用预处理器，编译器，汇编器和链接器，将源代码转换为二进制文件。 当我们使用gcc去将多个互相关联的文件编译为一个二进制文件时，这些源文件的预处理、编译和汇编过程都是分别进行的，而在最后的链接过程中被合为一体。 当我们运行可执行文件时，shell调用加载器，将文件内容拷贝到内存中并将控制流转移到二进制文件开头。 静态链接静态链接器所接受的 可重定位目标文件 由各种不同的代码和数据节组成，其中每一节都是一个连续的字节序列。指令、未初始化的全局变量和初始化过的全局变量分居不同的section。 链接器要完成的主要任务是： 符号解析：将目标文件中的每个每个符号引用和其符号定义关联起来。 重定位：将每个符号引用指向其对应的符号定义的内存位置。 注意：链接器进行重定位的依据是汇编器所产生并记录在目标文件中的重定位条目。其自身并不做过多工作。 目标文件目标文件有三种： 可重定位目标文件：无法直接执行，但包括所有数据和代码的文件 可执行目标文件：经过链接，可以直接复制到内存中执行的文件 共享目标文件：可以动态地加载到内存中进行运行或链接的可重定位目标文件 可重定位目标文件现代Linux系统下的目标文件格式一般为 ELF(Executable and Linkable format) 格式。下表大致地描述了一个ELF可重定位目标文件的组成格式。 ELF头 .text .rodata .data .bss .symtab .rel.text .rel.data .debug .line .strtab 节头部表 灵活地使用linux下的readelf工具可以有很大帮助。 ELF头ELF头记录着一个目标文件的基本信息。其内容如下： 描述系统 字长 和 字节序 的一个16字节序列 ELF头的大小 目标文件类型 机器类型 节头部表的位置 节头部表中条目的大小和数量 节头部表节头部表位于目标文件的末端，它记录了ELF文件中每个节的大小和位置。 节在ELF头和节头部表之间的部分都是节。一个典型的ELF文件包括如下节： .text 已编译程序的机器代码 .rodata 只读数据，包括声明中用到的常量和switch跳转表等 .data 已经初始化的全局变量和静态变量(局部变量在程序栈中) .bss 未初始化或初始化为0的全局和静态变量，它们不占据任何实际空间。 .symtab 存放着在程序中定义和引用的函数和全局变量信息的符号表 这个符号表只在链接或调试过程中有用 可以使用strip命令去掉目标文件中的符号表 .rel.text和.rel.data 分别是函数和全局变量的重定位表，链接器根据其中储存的信息去制作symtab .debug 一个调试符号表，以-g选项调用编译器才会产生这张表，是调试所需要的 .line 同样以-g选项调用才会产生，用于将行数映射到机器指令 .strtab 一个字符串表，包括.symtab和.debug节中的符号名和各种节头的名字 除了这些节以外，还有没有列入节头部表的几个 伪节 ： ABS 不该被重定位的符号 UNDEF 外部符号 COMMON 和.bss类似，COMMON包括未初始化的全局变量，其余归.bss。 符号表在链接器的上下文中有三种不同的符号： 全局符号：由一个模块定义，被其他模块引用的符号，如非静态函数和全局变量。 外部符号：由其他模块定义，被本模块引用的符号。 局部符号：被一个模块定义且只被其本身引用的符号，包括静态的函数和全局变量。 在C中，源文件扮演模块的角色。用static声明的函数和变量可以视为private的，而不加static的则可以视为pubilc的。 .symtab节中的符号表表项是下面的结构体： 12345678struct &#123; int name; // 指示表项的名称字符串在.strtab中的位置 char type:4; // 4bits数据，表示该表项是函数还是变量(或者其它类别) char binding:4; // 4bits数据，表示该表项是本地还是全局的(或者其它类别) long value; // 指示表项的初始化位置距离初始化节起始位置的偏移量 long size; // 每个表项指向的量所占的字节数 short section; // 表项所属的节在节头部表中的位置(或伪节的名称)&#125;; 可执行目标文件可执行目标文件的结构与可重定位目标文件大致相同： ELF头 段头部表 .init .text .rodata .data .bss .symtab .debug .line .strtab 节头部表 ELF头中多出了程序的入口点，即第一条指令地址这一信息。.init节定义了一个初始化函数。由于可执行文件已经完成重定位，它不再需要.rel节。 从.init到.rodata段是只读段，存放代码段；.data和.bss是读写段，存放数据；剩下的位置不加载到内存，多数情况下用于调试。 段头部表指示各个代码/数据段的位置。 可执行目标文件的加载加载的过程是由加载器来完成的。加载器首先根据段头部表将各个字节段拷贝到内存的相应位置，然后跳转到程序的入口点，也就是_start函数的地址。这个函数是所有C程序的入口点，_start函数会调用系统启动函数来初始化执行环境并调用main函数。main函数返回后，它接受并处理返回值。 符号解析多重定义的全局符号Linux将未初始化的全局变量规定为弱符号，而函数和初始化的全局变量是强符号。 当出现同名的强符号时，报错 当出现同名的强符号和弱符号时，选择强符号 当出现同名的弱符号时，随机选择一个 后两条规则会导致一些不易察觉的错误。比如，一个文件中定义了一个未初始化的x和一个操作x的函数，而另一个文件中定义了一个初始化过的x，那么函数的执行就可能在另一个文件编写者不知道的情况下改变x的值。 静态库编译系统提供一种机制，将所有相关的目标文件打包成为一个单独的文件，称为静态库。当链接器构造出一个目标文件时，它只会拷贝静态库中被引用的部分。 在编译指令中加上静态库文件的名字可以将这个库作为链接器的输入之一。使用静态库可以减少程序员在源文件中进行include的头文件数。 静态库以一种称为 存档(archive) 的特殊文件格式存放在磁盘中。存档文件由后缀.a标识。 ar工具可以将几个.o文件打包成为一个静态库。 当将静态库作为gcc的参数时，要注意目标文件和库文件的顺序。一般来说，依赖源放在后面。 重定位重定位过程合并输入模块，并为每个符号分配运行时地址。 重定位分为两步： 重定位节和符号定义：在这个过程中，链接器将所有相同类型的节进行合并，为它们中的每个条目重新分配运行时内存地址，并更新ELF头和节头部表的信息。完成这一步后，程序中每条 指令 和每个 全局变量 都具有唯一的运行时内存地址。 重定位符号引用：修改代码节和数据节中对每个变量或函数的引用，将它们指向正确的运行时地址。完成这一步需要借助可重定位目标文件中的 重定位条目 。 重定位条目汇编器会将每个遇到的引用分别放在等量的重定位条目中，以此告诉链接器如何在目标文件合并时修改这个引用。代码和已初始化数据的重定位条目分别存放在.rel.text和.rel.data中。 重定位条目的格式如下： 123456struct &#123; long offset; // 需要被修改的引用在节中的位置 long type:32; // 重定位类型 long symbol:32; // 被修改的引用应该指向的符号在符号表中的位置,用于标识引用对象 long addend; // 对最终重定位位置所做的调整&#125;; 重定义类型有32种，其中最常见的有两种： R_X86_64_PC32 重定义一个使用相对寻址的引用 R_X86_64_32 重定义一个使用绝对寻址的引用 对于相对寻址来说，由于在重定位过程中所有模块中的节都已经合并，可以知道引用源和引用对象处于同一个.text节中。这样一来，只需要知道引用对象的地址，就可以通过offset和addend计算出所需要的相对变址，也就是源和对象代码之间的距离。 而绝对寻址更加简单，只需要将引用对象的地址和addend的加值作为绝对地址来重定位即可。 addend项的作用是抵消掉处理器流水线的影响。在相对寻址中，处理器根据当前PC的值和变址来计算应当跳转到的位置。然而当处理器在执行调用指令(比如call)时，此时的PC值其实是下一条指令的地址。因而，此时需要在变址中加入addend值来进行修正，addend值应设置为两条指令之间地址差的相反数。对于绝对寻址，addend一般设置为0. 动态链接库动态链接库是一个目标模块，可以加载到任意的内存地址并与内存中的程序链接。这个过程是由 动态链接器 来完成的，称为动态链接。动态链接库在LINUX下以.so为后缀，而在windows下则以DLL文件为格式。 对于使用了动态链接库的目标文件，链接器会额外创建一个.interp节来包含动态链接器的路径。在加载器加载和运行可执行目标文件时，它会识别这个节，并加载和运行这个动态链接器。 动态链接器被加载后，将需要的共享库加载到指定内存段，并建立目标程序与共享库之间的链接，最后将控制传递给目标程序。 如果要在编写程序时指定共享库，可以使用&lt;dlfcn.h&gt;。如果要创建共享库，可以使用gcc参数gcc -shared -fpic -fpic参数会指定生成 位置无关代码(Position-Independent Code) 这种代码可以加载而无需重定位，是为了解决动态链接加载问题而设计的。 位置无关代码(PIC)动态链接的一个问题在于，进程该如何定位加载到内存中的动态链接库代码。如果为每一个动态链接库分配一块指定的内存，既不方便动态链接库的修改与更新，又会使系统的可用资源减少。 PIC利用了加载的一个特性，即加载到内存中的数据段和代码段之间的距离是 运行时常量 。它在每个数据段开始的位置创建一个 全局偏移量表(GOT) ，这个表的每一项都与数据段中对全局变量或函数的引用关联。在加载时，动态链接器会重定位GOT的每一项，使其指向本模块或其他模块中的引用对象定义/初始化位置。 然而，动态链接库中的函数有可能数量巨大，如果所有函数都交由GOT和动态链接器处理，程序的加载过程将会变得极其耗时。为了解决这个问题，GNU采用一种叫做 延迟绑定 的机制，将过程地址的重定位推迟到第一次调用该过程的时间点。 延迟绑定需要GOT和另一种数据结构 —— 过程链接表(PLT) 的辅助。GOT是数据段的一部分，而PLT是代码段的一部分，它的每个表项都是一个16字节代码段，对应一个函数调用。在初始化GOT的时候，所有对函数引用的GOT都指向其函数对应的PLT的第二个指令。 PLT[0]对应动态链接器的入口，用于跳转到动态链接器；PLT[1]对应_start函数，之后的条目则对应用户所声明的函数。而GOT的前两个条目包含动态链接器的参数信息，其后的条目则依次对应PLT中相应函数的入口。由于数据段与代码段之间的距离是运行时不变量，GOT的每个表项GOT[i]与PLT中的PLT[i-2]之间的距离是固定的。 在一个函数第一次被调用时，它的运行时地址被解析： 程序进入这个函数对应的PLT条目 PLT条目第一指令是跳转指令，跳转目标是该函数对应GOT所指向的地址 由于GOT的初始值为PLT第二个指令，此时控制来到PLT第二个指令 第二个指令将函数ID压栈，第三个指令跳转到PLT[0] PLT[0]通过GOT[1]将动态链接器参数压栈，并通过GOT[2]跳转到动态链接器入口 动态链接器通过两个参数确定函数所在的动态库模块并找到其加载到的内存位置 动态链接器用这个位置重写GOT中该函数表项的值 动态链接器将控制转交给这个函数 而之后的调用就会简单很多，因为GOT中关于这个函数的表项已经被重写为正确的地址了，PLT可以直接通过这个地址跳转到函数入口。 库打桩机制Linux链接器支持打桩机制，它允许用户截取对系统函数的调用，取而代之地调用一个与这个函数原型完全相同，但内容自由定义的函数。 编译时打桩以对malloc.h文件进行打桩为例： 首先，在调用了malloc函数的源文件所在文件夹下创建一个malloc.h文件，并在其中将对malloc的调用重新定向： 12#define malloc(size) fake_malloc(size)void *fake_malloc(size_t size); 自行编写一个.c文件，将你想要让malloc函数做的事情写进去，并用gcc将其编译为.o文件： 1gcc -c &lt;xxx&gt;.c 用gcc进行编译时打桩 1gcc -I. &lt;源文件&gt;.c &lt;xxx&gt;.o 由于指定了-I.参数，C预处理器会优先在当前文件夹中搜索malloc.h文件，于是打桩成功，计划通！ 链接时打桩gcc的一组参数可以用于打桩： -Wl,&lt;option&gt;参数：将option作为参数传给链接器。option中的空格要替换为逗号来写。 --wrap &lt;token&gt;参数：链接器参数，将token解析为__wrap_&lt;token&gt;，并将__real_&lt;token&gt;解析为token。 利用这两个参数，可以自定义__wrap_&lt;token&gt;函数，在其中定义自己的函数，再使用__real_&lt;token&gt;来调用原本的token函数。最后，使用gcc -Wl,--wrap,&lt;token&gt;参数来编译。 运行时打桩通过设置LD_PRELOAD环境变量的值为一个目录，可以使动态链接器在搜索默认目录的动态库之前先搜索指定目录下的动态库。通过这个特性可以轻松地实现运行时打桩。 工具总结 AR 用于创建和修改静态库 STRINGS 列出一个 可执行文件 中所有可以打印的字符串 STRIP 用于删除符号表 NM 列出一个 可执行文件 的符号表信息 SIZE 列出可执行文件中节的信息 READELF OBJDUMP LDD 列出一个可执行文件需要的共享库 Chapter 8 异常控制流控制流会在很多种情况下发生变化：跳转，函数调用，返回都属于正常的控制流变化，在源程序的控制之内；但系统状态的变化也会引起一些控制流突变，我们将这些控制流变化统称为 异常控制流(Exceptional Control Flow) 。 在硬件层，硬件可能会因为预料外或不合规定的状态变化而抛出异常；在操作系统层，内核经常将控制权在不同进程之间转移；在应用层，进程之间的信号通信可以让程序回避栈规则进行跳转。 异常异常(Exception) 是异常控制流的一种形式。在任何情况下，如果 处理器 检测到有反常事件发生，它就会通过一张叫做 异常表(exception table) 的跳转表进行一个间接过程调用(也就是异常)，将控制权转交到这个异常所对应的异常处理程序。 异常处理程序完成处理后，有三种情况: 控制权回到异常抛出时正在执行的指令 控制权转交给引发异常的下一条指令 终止被中断的程序 系统中可能的每种类型的异常都分配了惟一的一个 异常号 。硬件层面的异常号由处理器设计者来规定，软件层面的异常号由操作系统内核设计者来规定。异常号是异常表的索引，在触发一个异常时，处理器取出 异常表基址寄存器 的值，与(异常号×异常表表项的大小)做加法，得到异常表对应表项的地址。 异常的函数调用和普通函数调用有一些区别： 异常调用的返回地址不一定是正在执行指令的下一条指令 处理器会把一些额外的状态量压入栈中 如果控制从用户转到内核，所有项目被压入内核栈而不是程序栈 异常处理程序运行在系统态 异常的类别异常可以分为如下四类： 类别 原因 行为 返回 中断(Interrupt) IO设备的信号 异步 返回到下一条指令 陷阱(trap) 有目的地引发 同步 返回到下一条指令 故障(fault) 潜在的可恢复的错误 同步 返回到下一条或当前指令 终止(abort) 不可恢复的错误 同步 不返回 InterruptIO设备在完成某个读取或写入过程后，就会向处理器的一个引脚发出信号，并将异常号放到系统总线。处理器会在执行完一条指令之后发觉引脚电位的变化，读取异常号并调用对应的异常处理程序来进行下一个IO操作。处理程序返回时，控制权交给下一条指令，使源程序的行为不受影响。 Trap陷阱通常用来进行 系统调用 。在操作系统学习中已经对系统调用过程有了够多的了解，此处不予详述。 Fault当一个故障发生时，异常处理程序会首先试图去修复这个故障。如果修复成功，控制权会回到引起故障的指令并重新执行它；否则，异常处理程序会调用内核中的abort例程并终止引起异常的程序。 Abort终止是确定无法恢复的错误，因而会直接终止引发异常的程序。 常见的异常 0-除法错误：除法发生的错误属于硬件层面故障，但Linux系统不会试图恢复，而是直接abort。 13-段错误：对未定义内存区域的引用或对只读文本段的写操作引发的故障，是相当常见的故障。Linux系统同样会直接将段错误进行abort处理，产生大家常常看到的Segmentation fault错误。 14-缺页错误：指令所引用的虚拟地址所对应的物理页面不在内存中。这种情况是惰性加载的产物，在存储技术中相当常见。异常处理程序会将物理页面加载进内存，并返还控制权。 18-机器检查：致命的硬件错误，属于abort类型。 Linux的系统调用在汇编语言中，%rax寄存器包含系统调用号，%rdi，%rsi，%rdx等寄存器包含最多6个参数的情况下，syscall指令会发起一次系统调用。 进程进程提供给应用程序的关键抽象有二： 一个独立的逻辑控制流 一个独立的虚拟地址空间 逻辑控制流抢占式的任务调度中，所有的进程会轮流获取CPU的使用权。在这种抽象中，若干个进程可以看做是同时在运行，这种现象称为 并发 。而如果两个进程真正在不同的处理器核上运行，那么它们则被称为是 并行 的。 私有地址空间对于每个进程来说，它的地址空间结构是相同的： 系统态和用户态这一部分详见操作系统课程的相关内容 系统调用的错误处理这一部分详见《UNIX系统编程》 进程控制同样详见《UNIX系统编程》 fork指令fork()系统调用创建当前程序的一个子进程，宏观上来看在这个调用之后子进程会从下一条指令开始与主进程并发运行相同的代码。区分主进程和子进程的方式是fork的返回值——在父进程中返回值是子进程的pid，在子进程中返回值为0。 这个指令的特点有： 调用一次，返回两次。为了理清多次fork所创建的进程关系，通常需要画进程图。 父进程与子进程并发执行 子进程的地址空间是父进程的副本，但又与父进程相互独立。 子进程的回收子进程在返回或终止后并不会马上被内核清除，它会一直保持一个已终止的状态直到被它的父进程回收。这种未被回收但已经中止的进程被称为 僵尸进程 。父进程回收子进程后，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程。 如果父进程在它的子进程被回收之前终止,init进程会接管子进程,成为它的养父，并最终回收这些僵尸进程。但是，由于僵尸进程也会占用系统内存等资源，每个进程都应当回收它们的子进程，这就要用到waitpid函数了。它会使进程等待目标子进程终止，并马上回收这个子进程。如果当前没有子进程，这个函数返回-1并设置错误码。 pid_t waitpid(pid_t pid, int *statusp, int options) pid:指定要等待的子进程pid。如果这个值为-1,就等待所有子进程。 options: 改变函数默认的执行模式，如果为0则不改变。waitpid默认会挂起进程来等待子进程终止，并返回已终止子进程的pid。 WNOHANG: 立即返回而不等待子进程终止，若没有子进程终止则返回值为0 WUNTRACED: 不仅返回已终止子进程的PID，还返回被停止子进程的pid。 WCONTINUED: 挂起直到子进程终止或一个被停止的子进程收到信号继续执行 statusp: 用于存放返回的子进程的状态信息，wait.h中的宏可以解析这些信息。 waitpid(-1,NULL,0)会回收所有子进程中最先结束的子进程，然后返回。 加载和运行程序execve函数可以在当前进程的上下文中加载并运行一个程序。 int execve(char* filename, char* argv[], char* envp[]) 其中filename和argv不必解释，envp指向一个环境变量字符串数组，每个字符串都是“name=value”格式的键值对。 getenv函数可以根据环境变量中的name在环境变量数组中搜索并返回对应的value字符串指针。如果找不到则返回NULL。setenv和unsetenv则可以修改环境变量。 信号信号是一种消息，内核使用信号来通知进程系统中发生的事情。可以执行man 7 signal来查看linux系统支持的信号种类。 传递信号由两个步骤组成： 内核通过更新目标进程上下文中的某个状态，向一个进程 发送信号 目标进程对信号做出的反应被称为 接受信号 一个发出但没有接受的信号被称为 待处理信号 ，每种类型的信号在 同一时间只能存在一个待处理信号 ，在这个信号被接受之前的同类型新信号会被丢弃。每个信号只能被接受一次。 进程组每个进程都只属于一个进程组，进程组由一个pgid来标识。用户进程可以通过getpgrp函数获取自己所在的进程组ID，通过setpgid改变自己或者其他进程的进程组。在setpgid(pid,pgid)函数中，如果pid为0则指定自身，如果pgid为0则用pid指定的PID作为进程组ID。 信号的发送linux系统下的/bin/kill文件可以向其他的进程发送信号。 使用方式：kill -&lt;sig&gt; &lt;pid&gt; 其中sig指定发送的信号种类，而pid指定发送目标。负的pid会将信号发送给进程组中的每个进程。 类似地可以发送信号的函数有signal.h库中的kill函数,它的使用规范与/bin/kill相近；unistd中的alarm函数也可以在sec秒后向调用进程发送一个SIGALRM信号。 键盘输入如ctrl-C也会向当前作业的进程组发送信号。 信号的接受当一个进程 从内核模式切换回用户模式 时，它会检测进程的待处理信号集合，如果集合为空则将控制流转移给下一条指令，否则 强制 这个进程接受这个信号。 进程对于每个信号都有一种默认反应，大多是终止，转储内存，挂起或忽略。我们可以通过使用signal.h中的signal函数来修改默认行为。(SIGKILL和STGSTOP信号是无法更改的) sighandler_t signal(int signum, sighandler_t handler) 返回值：如果失败返回SIG_ERR，可以用于检验是否成功 signum：指定要监测并处理的信号 handler：指定处理信号的函数 SIG_IGN：忽略这个信号 SIG_DEL：取消对信号默认行为的更改 自定义的函数 调用这个函数会改变当前进程在其剩余生命周期内对某个信号的行为。 信号的阻塞sigprocmask函数可以显式地阻塞一些信号。 int sigprocmask(int how, sigset_t* set, sigset_t* oldset) how：指定对两个set的操作 SIG_BLOCK：阻塞所有set中的信号 SIG_UNBLOCK：解除对所有set中信号的阻塞 SIG_SETMASK：将阻塞集合变成set oldset：之前的阻塞信号集合会保存在这里 sigset的使用方法是，首先声明一个sigset，再使用辅助函数(sigemptyset,sigaddset,sigdelset)进行构造。 信号处理程序的编写信号处理程序与主程序并发运行，因而它很容易引起race condition。因此，我们只能在信号处理函数中使用 异步安全 的函数，而printf，scanf，malloc和exit等函数都不在此列，因而输出基本靠write。 还有一种精简信号处理程序的方式是只在程序中改变全局变量的值，然后立即返回，将所有的处理过程留给主程序。 除此之外，任何可能被信号处理程序修改的全局变量都应该使用volatile前缀和sig_atomic_t类型，前者保证这个变量不会被缓存，后者保证对这个变量的所有读写都是原子操作。 最后，处理程序有义务保存调用时errno的值，并在返回时将其重置。 另一个需要注意的问题是，由于未被处理的信号同时每种只能存在一个，当我们发现有一个未被处理的信号时很可能有 不止一个 信号已经到达。比如，我们在一个模拟shell行为的程序中监听SIGCHLD信号，每接受到一个SIGCHLD就回收相应的子进程。如果在handler处理第一个SIGCHLD的过程中又有两个新的SIGCHLD到达，那么其中的一个就会被丢弃。 为了解决这个问题，我们需要用一个不断执行waitpid直到返回-1的循环来取代对waitpid操作次数的计数。 信号处理的兼容性在不同的Unix系统上，signal函数的行为可能不一致。为此，我们可以显式地调用sigaction函数来设定默认行为。 信号处理的常见问题及解决方案任务列表管理中的race condition问题有一个经典的案例：父进程通过fork创建一个子进程并将其添加到任务列表中，并在接受到SIG_CHLD信号之后将其从任务列表中移除。然而由于某些状况，子进程在被创建之后立即退出。在这个案例中，系统的控制流是这样变化的： 父进程发出请求创建子进程，控制流陷入内核 内核创建子进程并移交控制权 子进程退出，控制权回到内核，内核向父进程发送一个SIG_CHLD信号 需要注意的是这个时候父进程还并没有拿回控制权，因而它并不知道子进程已经终止。但它在接收到SIG_CHLD信号的时候会马上调用对应的handler去从任务列表中移除子进程，而当时任务列表中甚至还没有这个子进程！ 为了解决这个问题，处理程序应当在创建子进程之前阻塞SIG_CHLD信号，并在添加完任务之后再取消这个阻塞。这样就实现了并发进程之间的同步。 显式地等待信号另一个例子是，父进程在创建一个子进程之后需要等待其返回再进行下一步操作。判断等待何时结束显然要依靠SIG_CHLD信号的接受和处理，但在等待的过程中应该做什么呢？ sigsuspend(const sigset_t *mask)函数可以解决这个问题。它包括了用mask取代原有的阻塞集合、等待某个信号到达和恢复原有的阻塞集合三个操作，但不同于分别进行这三个操作的是，这个函数是 原子的 。 常见的处理机制是，父进程阻塞SIG_CHLD信号并创建子进程，然后调用sigsuspend函数来取消阻塞并等待SIG_CHLD信号，在接受信号之后恢复阻塞并继续执行之后的指令。 非本地跳转有一种方式可以让用户程序摆脱一般函数的调用-返回逻辑，直接将控制流跳转到一个指定位置，并设定当时的 系统环境 (系统环境是指程序计数器，栈指针，通用寄存器的值等信息)。 int setjmp(jmp_buf env)函数可以在当前的位置设定一个跳转坐标，并将当前的系统环境保存在env变量中，之后挂起等待跳转。如果用户程序在其他位置调用了longjmp(jmp_buf env, int retval)函数，控制流就会跳转到setjmp的调用位置，恢复env所保存的环境，然后setjmp函数返回，返回值为retval。 需要注意的是，setjmp函数的返回值不能被用来赋值，只能用于判断。 操作进程的工具 strace：打印一个正在运行的程序以及它的子进程所做的系统调用轨迹 ps：列出所有进程 pmap：显示进程的内存映射 top/htop：类似于任务管理器 Chapter 9 虚拟内存虚拟内存提供了三个重要的能力： 在主存中只保留活动区域，高效地利用了主存 它为每个进程分配了一致的地址空间，简化了内存管理 每个进程拥有了自己独特的地址空间，内存空间因而不会受到破坏 物理寻址和虚拟寻址计算机的主存系统被组织成一个由M个连续字节组成的一个数组。每个字节都有一个唯一的 物理地址 。现代操作系统的主存一般使用 虚拟地址 来访问，CPU上的内存管理单元(Memory Management Unit, MMU)可以将虚拟地址翻译成物理地址。 物理地址的最大值与物理主存有关，其值等于物理主存的容量。虚拟地址的最大值与计算机系统的寻址位数相关，其值等于2的x次幂，其中x是寻址位数(如32和64)。 虚拟内存作为缓存主存可以看作是对磁盘上数据的缓存。和存储器层次结构中的其他缓存一样，磁盘中的数据被分割成块，这些块作为主存和磁盘之间的数据传输单元。 虚拟内存系统将虚拟内存划分为大小相同的 虚拟页(VP) ，这些虚拟页就是数据传输的单元。所有的虚拟页被内存管理系统分为三个不相交的子集： 未分配的：这个VP在虚拟内存系统中还没有写入数据，不占用物理磁盘空间 未缓存的：这个VP已经被写入了一部分数据，但它所对应的物理内存中尚未缓存这些数据 已缓存的：VP和物理内存中都已经存储了数据 缓存的组织结构我们将主存与CPU之间的三层高速缓存称为 SRAM缓存 ，将虚拟内存系统对应的缓存(主存)称为 DRAM缓存 。一般来说，DRAM比SRAM慢数百倍，而比磁盘快十万倍。这样一来，DRAM缓存不命中的开销就变的非常之大。不仅如此，从磁盘的扇区开始读第一个字节的开销比阅读连续字节大得多。 DRAM的这些特性决定了它的组织结构： 虚拟页很大，通常是4KB-2MB，这样对缓存发起的请求不命中的概率会比较小，缓存也就不需要进程该行回到效率低下的磁盘去寻求对请求的回应。 替换策略更精密，因为替换错了虚拟页的开销非常大。 使用回写而不是直写。 回写：系统先将数据写入缓存，在需要时再写回磁盘 直写：系统将数据同时写入缓存和磁盘 分页表虚拟内存系统必须能够确认一个VP是否缓存在DRAM中。如果是，还要明确它在真实物理内存中的位置。在缓存不命中时，系统必须判断这个页在磁盘中的位置，然后从物理内存中选择一个牺牲页，并用磁盘中的页取代这个牺牲页。 物理内存中的 页表(page table) 负责将虚拟页映射到物理页。页表是一个由 PTE(page table entry) 构成的数组，每个PTE都由一个有效位和一个n位地址字段所构成，操作系统用虚拟地址作为索引来找到虚拟页对应的PTE。 有效位：表明该虚拟页当前是否已经被缓存 如果有效位为1,那么地址字段存放这个虚拟页所对应的物理页的物理地址 如果有效位为0 如果地址是空地址，说明这个页还没有被分配。 如果这个页被分配了但未被缓存，这个地址会存放它在磁盘中的位置。 如果地址翻译硬件发现一个需要访问的VP是未被缓存的,它就会抛出一个 缺页异常(page fault) ，从而调用内核中的异常处理程序来选择一个牺牲页，并将磁盘中的页复制到牺牲页的位置。如果牺牲页已经被改动了，异常处理程序会先将其写回磁盘当中(回写式策略的体现)。 缺页异常缓存好需要的VP之后，将控制流交还给导致缺页的指令，使其重新执行一遍。这一次，由于VP已经被缓存，缺页异常就不会发生。 页的生命周期在创建新页的时候，操作系统在磁盘上开辟一片区域，并让一个废弃的PTE指向这个区域。程序所有对这一页虚拟内存的操作会首先被缓存到物理内存DRAM上。当这一页成为牺牲页的时候，回写策略会将这一页更新的所有内容写回磁盘中对应的区域。 虚拟内存作为内存管理工具操作系统会为每个进程分配一个相同的页表，也就是说每个进程都有一个一致的地址空间。按需的页面调度使这种设计成为可能，这对内存的使用和管理产生了深远的影响。 简化链接：由于所有进程的内存结构都是一样的，链接器可以使用完全相同的工作逻辑去生成可执行文件，而且这些可执行文件是独立于物理地址中数据和代码的位置的。 简化加载：在向内存中加载可执行文件或者共享库时，调度系统为代码和数据段分配虚拟页，将它们标记为未被缓存的虚拟页，并将PTE指针指向磁盘中的相应位置。这样，代码和数据按需调用，节省了很多加载无用数据的时间和空间。 简化共享：不同进程的PTE可以指向同一个磁盘区域，这样它们就实现了自然的文件共享。 简化内存分配：当用户进程申请额外内存时，可以从磁盘中随机映射等量的内存块。 虚拟内存作为内存保护工具在PTE中增加几个许可位使得内存的权限控制变得异常简单。一般来说，许可位会包括SUP(进程是否必须运行在root下)，READ和WRITE等。 如果一个进程违反了这种条件，CPU就会引发一个异常。这种异常一般会以段错误的形式进行报错。 在编写C语言程序时常常出现的segmentation fault错误就是因为内存访问越界，从而触发了这个异常。 地址翻译首先列出一些常用的地址翻译符号： 形式上来讲，地址翻译是一个N元素的虚拟地址空间和一个M元素的物理地址空间中元素之间的映射。MMU利用页表来实现这种映射。 CPU中的 页表基址寄存器 指向当前页表。 n位的虚拟地址分为两个部分： 虚拟页号(n-p位) 虚拟页面偏移(p位) 而m位的物理地址也分为两个部分： | 物理页号(m-p位) | 物理页面偏移(p位) | 在进行映射的时候，MMU将虚拟页号作为索引去找到对应的PTE，从而找到对应的物理页号；而由于物理页和虚拟页的大小是相同的，虚拟页面偏移可以直接作为物理页面偏移。这样，我们就得到了一个物理地址。 内存映射Linux可以将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这片内存区域的内容，这种机制称为内存映射。虚拟内存区域可以映射为如下两种类型的对象中的一种： 普通文件：一个区域可以映射到一个磁盘中的连续部分，覆盖一个普通Linux文件。文件区被分为页大小的片，每一片都与一个PTE相关联。当缺页中断被触发时，触发中断的那一片文件会被读入内存。 匿名文件：匿名文件是一个抽象的文件，它的内容完全是二进制零。当CPU请求映射到匿名文件的内存区域时，就直接用二进制零覆盖牺牲页面。这种情况下，内存与磁盘之间并没有实质的数据交换。 共享对象与私有对象对于一个共享对象，它可以同时被多个进程所引用和修改，而且这些修改对所有共享它的进程都是可见的。因此，一个被多进程共享的对象只需要在物理内存中保留自己的一个副本，让各个进程的PTE都指向这个副本即可。 而对于私有对象，操作系统使用了一种 写时复制(copy-on-write) 技术，即对于被多个进程分别私有占有的一个对象，一开始只保留它的一个物理内存副本；直到其中的一个进程试图对这个对象进行写操作时，才触发一个异常来复制这个对象并将新副本分配给那个进程。 写时复制机制充分利用了珍贵的内存空间。 有了这种机制，我们就可以理解fork在创建子进程时的行为了。fork创建新的子进程时，它会继承父进程的地址空间，数据结构等信息，而这些信息都可以通过写时复制机制来进行存储，这样创建新的子进程的开销就会变得很小。 而对于二进制可执行文件的加载和运行，就需要分别映射共享内存区域和私有区域，并最后转交控制权。映射完成后的进程内存空间结构如下图： 用户级内存映射mmap函数可以在虚拟内存中创建一片区域并将一个对象映射过去。munmap可以取消这种映射。 动态内存分配动态内存分配主要指堆内存。它紧接着未初始化变量区，并向上生长。 堆顶指针称为brk，它决定着堆的大小。分配器将堆看作一些大小不同的块来维护。每个块都是一个内存片，要么是已分配的，要么是空闲的。分配器有两种风格： 显式分配：比如C语言的malloc和free，还有C++的new和delete。 隐式分配：典型的有Java，Lisp和ML的垃圾回收。 隐式空闲链表一个简单的堆块的数据结构格式是这样的： 一个头部，包括块大小信息和标识这个块是否被分配的信息 有效载荷(malloc返回的地址是这个区域的开始地址) 填充部分，为了使块大小固定的填充物 这样，我们就将堆块组织成为一个序列。它们由头部中的堆块大小信息隐式相连。 放置策略当应用请求一个字节块时，分配器搜索空闲链表以找到一个大小足够的块。这个搜索过程有几种策略可以选用： 首次适配：每次都从头开始搜索 下一次适配：从上次结束的位置开始 最佳适配：每次都遍历链表，找到最合适的块 对于链表式的存储来讲，最佳适配显然有些慢了。但是利用更加精细的数据结构，我们可以做到让最佳适配的时间和空间复杂度都做到很低。 空闲块分割如果没有很合适大小的空闲块，系统会将一个大空闲块切开，从而得到一个合适大小的块。 合并空闲块对于空闲块分割产生的碎片的合并问题，有立即合并和推迟合并两种策略。我们假设使用立即合并，但其实大部分快速的分配器都会使用推迟合并。 由于隐式链表是单向的，如果要合并一个前面的块就很不方便。knuth提出了一种解决方法，即在每个块的最后增加一个头部的副本，称为脚部。这样，每个块都可以通过访问前面块的脚部来确定前面一个块的大小，从而实现合并。 有一种对脚部空间占用率的优化，它利用了脚部和头部的最后部分是定长标志位的特性。由于已分配的堆块显然不能合并，完全可以将已分配堆块的脚部用于存放数据，只留下最后的标志位。空闲块通过判断标志位判断前面的块是否已分配，从而决定是否可以合并。这样就大大缩减了脚部所占用的空间。 分离的空闲链表如果使用最佳适配策略，一个使用单向空闲链表的分配器需要与空闲块数量成线性关系的时间来分配。一个流行的减小分配时间的策略是使用 分离存储 的策略，就是维护多个空闲链表，其中每个链表的块大小都在某个小范围内。 分配器维护着一个空闲链表数组，每个大小类都是数组的一个元素，当分配器需要一个大小为n的块时，它就搜索对应的空闲链表，如果搜索不命中则去搜索下一个链表，以此类推。 分离存储策略有几十种不同的实现，这里简单介绍两种。 简单分离存储在这种存储策略下，每个空闲链表中的块大小 完全一致 ，且一般为2的次幂。分配的时候，分配器用常数时间找到大小大于需求且最接近需求的空闲链表，并直接取出第一块，不做分割地分配给请求者。释放的时候，只需要简单地将释放出的内存块挂到相应大小的链表开头即可。如果链表为空，就申请一片大内存，等分为这个链表对应大小的块并做一条新链表。 这种策略的时空复杂度都是最小的。然而，显而易见的会引起严重的碎片化问题。 分离适配这种策略下，每个链表的块大小属于一个范围。在分配时，分配器会在相应大小范围的链表内做首次适配，一旦适配完成就取出那个块，分割出与申请大小相等的一部分来授予申请者，剩余的插入与剩余部分大小对应的空闲链表内。这种策略显著提高了空间利用率。 垃圾收集垃圾收集器使程序员从手动释放内存的枷锁中解放出来。它以某种策略定期识别垃圾内存块，并调用free去自动释放它们。 垃圾收集器将内存视为一个有向图。这个图分为 堆节点 和 根节点 ：堆节点代表着堆内存块，根节点代表着在堆外部的存储，如寄存器和其他内存区域。 任何时候，如果存在着从根节点到一个堆节点的路径，就代表这个堆节点能被访问到，于是它是可用的；但如果一个堆节点无法从根节点抵达，那它显然无法被外部访问，是垃圾内存块。垃圾回收器定期地释放这些不可达节点并返还给空闲链表，来实现垃圾回收。 一种经典的算法称为Mark&amp;Sweep。它首先从所有的根节点出发去进行图遍历，并标记所有能够到达的堆节点；然后遍历所有的堆节点，回收掉那些没有被标记的节点。 C程序中可能引发的与内存相关的错误间接引用坏指针对于某些接受一个地址并将结果写入该地址的函数，传入的地址参数显然可能非常危险。如果在这里传入了一个保护区域的地址，程序会引发异常并退出；如果正好传入了一个可读写区域的地址，那这个函数就会将输出写到这个区域内。这会覆盖掉这片区域本来的内容。 读未初始化的内存堆内存不会被自动初始化为0,因此需要手动设置。 栈缓冲区溢出buffer attack的原理，之前在第三章有过描述。 新手常犯的错误 假设变量和指针大小相同 搞错运算符优先级 在函数已经返回后试图用指针引用函数内的局部变量 引用野指针(已经被释放过的指针) 不调用free引起内存泄漏]]></content>
      <categories>
        <category>Academic or Technical</category>
        <category>Operating System</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[GCC所支持的内联汇编标准解析]]></title>
    <url>%2Fblog%2F2018%2F03%2F12%2FGCC%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%2F</url>
    <content type="text"><![CDATA[GCC所支持的内联汇编标准解析我们都知道C与汇编语言的混合编程可以通过在C中调用汇编编写的函数来进行，但有些时候我们只需要执行一两句汇编语句，这种时候专门写一个汇编文件就显得过于臃肿了。GCC提供的内联汇编可以为我们解决这个问题，只是它的语法标准着实有些复杂。为了方便之后查阅，在这里做一下语法规范总结。 内联汇编的基本语法如下： asm(&quot;&lt;asm instruction&gt;&quot;:[output_list]:[input_list]:[clobbered_list]) 其中，用&lt;&gt;括起来的部分是必须要有的；用[]括起来的部分是可以缺省的。如果缺省部分之后有未缺省的部分，必须保留缺省部分前的那个冒号；否则，可以省略缺省部分前的冒号。 各个部分的含义分别为： &lt;asm instruction&gt;：一条AT&amp;T标准的汇编指令 在这条汇编指令内部，可以在其中使用%0，%1，%2……等标记，分别对应后面参数列表中的第n个参数。GCC会按照后面的constraints为这些参数分配存储空间或者常量。 在汇编指令中直接使用寄存器需要用%%进行对%的转义，如eax寄存器应写成%%eax。 可以包括多个字符串，具体格式如： 1234asm("&lt;instruction&gt;\n\t" "&lt;instruction&gt;\n\t" ... "&lt;instruction&gt;"); \n\t和换行都很重要，这是为了让GCC能知道接下来是一条新的汇编指令。 [output_list]：由一系列&lt;output&gt;参数构成，参数之间用,隔开，其中&lt;output&gt;格式为&quot;&lt;type&gt;&quot;(&lt;param&gt;)。 &lt;type&gt;：表示GCC为这个参数分配的变量类型。对于输出操作数来说，&lt;type&gt;由一个=与一个字母组成，其中=代表这个操作数是输出操作数，而字母可以是： m：内存 r：由GCC分配寄存器 i：立即数 f：浮点寄存器 F：浮点数立即数 a/b/c/d：分别对应%eax~%edx四个寄存器和它们的子寄存器 S：%esi及其子寄存器 D：%edi及其子寄存器 &lt;param&gt;：这个参数所关联的C变量，由于是输出参数所以必须是左值。 [input_list]：与[output_list]相似，具体有区别的细节有： 对于&lt;type&gt;来说，它只由一个字母组成，不包括前面的=。 输入操作数的&lt;type&gt;也可以是一个数字n，表示这个操作数和第n个参数匹配。这个机制用于输出和输入共用一个寄存器的情况。 &lt;param&gt;不需要是左值。 [clobbered_list]：由一系列以,隔开的字符串组成，这些字符串指出了在这个汇编操作中受到了影响的存储空间。这是为了提示GCC在内联汇编之后的语句中谨慎使用这些改变了的存储空间，以免发生预期之外的错误。字符串可以是： 一个寄存器的标准写法，如：&quot;%eax&quot; &quot;cc&quot;：代表指令影响到了条件码 &quot;memory&quot;：代表指令改变了内存 我们还可以在asm后面加上一个volatile关键字来防止GCC对这条内联汇编所做的优化。如果在关键位置不加volatile，很多时候我们可能会因为GCC的优化而对程序的运行结果摸不到头脑。]]></content>
      <categories>
        <category>Academic or Technical</category>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[借助WSL在Windows下使用GCC等GNU工具]]></title>
    <url>%2Fblog%2F2018%2F03%2F01%2F%E5%80%9F%E5%8A%A9WSL%E5%9C%A8Windows%E4%B8%8B%E4%BD%BF%E7%94%A8gcc%2F</url>
    <content type="text"><![CDATA[借助WSL在Windows下使用gcc虽然大部分时候的编码工作都可以在Linux下进行，但很多时候我们也需要在windows下进行对C语言源代码的编译运行。在被mingw的CreateProcess not found错误搞得心态爆炸之后，我卸载了辣鸡mingw，改为使用WSL(Windows Subsystem for Linux)来作为替代品。 安装WSL打开Microsoft App Store搜索WSL，选择适合的发行版进行安装即可。(不得不说Windows的一键式傻瓜安装还是很方便的) 配置WSL环境在运行WSL应用之后首先要设置登录名和密码，设置完成后即可进入子系统。(在这里使用的是Ubuntu) 由于系统自带的镜像源下载速度过于缓慢，需要更换镜像源为国内的源。(在更换之前一定要检查自己使用的Linux发行版的版本，并与镜像源网站上提供的版本号对比，不然很可能会出现依赖冲突) 执行sudo vim /etc/apt/sources.list命令编辑配置文件，镜像源参见Ubuntu Wiki。 保存之后，执行sudo apt-get update升级镜像源即可。 安装gcc执行sudo apt-get build-essential安装GNU工具。安装完毕后，即可使用GCC来编译C语言源程序。 WSL与Windows文件系统的交流Windows系统的所有磁盘分区都会以分区符为其名称保存在WSL的/mnt文件夹下。WSL已经做好了文件系统的转换，因此只需要在/mnt目录下工作即可。]]></content>
      <categories>
        <category>Academic or Technical</category>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[VPS+ShadowSocks实现科学上网]]></title>
    <url>%2Fblog%2F2018%2F01%2F19%2FVPS-ShadowSocks%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[使用VPS和ss搭建属于自己的梯子如果说购买VPN是把身家性命都托付给服务提供商的话，用VPS自己搭建梯子可谓把命运捏在了自己的手中。就算这一台服务器被封禁了，我们也可以用十几分钟轻松地搭好另一台，从而继续科学上网。为了加快搭建一台服务器的速度，我决定在服务器上放一个傻瓜式教程，以便有意外时能按部就班快速搭好一架梯子。 购买VPS服务器VPS的提供商有不少，很多人用的是Vultr，不过这里拿DigitalOcean做例子。学生党可以在GitHub上申请一个Student Pack，能白嫖一台能使用接近一年的服务器。 用申请了Student Pack的邮箱登录DigitalOcean，创建新的Droplet。配置选最低的即可，系统最好选择Centos 7.x，机房位置个人建议新加坡，速度比较快也不容易被爆破。在创建的时候如果能添加一个sshkey的话之后配置起来会方便很多，不过不添加也无所谓。 添加sshkey的方法在主机上直接使用ssh-keygen -t rsa -b 4096 -C &quot;&lt;YourComment&gt;&quot;生成sshkey，将保存位置下的id_rsa.pub文件内容粘贴到点击New SSH key后弹出的框内，并输入一个喜欢的名字即可。 这里必须保持保存位置是~/.ssh/目录本身，否则使用ssh远程登录的时候会出现Permission Denied 配置VPS服务器点击创建按钮之后稍等片刻，进度条满之后一台主机就创建完成了。使用ssh root@&lt;主机的IP地址&gt;远程登入到VPS系统中，此时假定使用的是Centos 7.x发行版： 先后执行 123yum install python-setuptoolseasy_install pippip install shadowsocks 安装完成之后编辑/etc/shadowsocks.json文件： 12345678910&#123; "server":"0.0.0.0", "port_password":&#123; "&lt;YourPort&gt;":"&lt;PortPasswd&gt;", "&lt;AnotherPort&gt;":"&lt;AnotherPasswd&gt;" # ... &#125;, # 连接端口和密码设置 "timeout":300, # 超时设置 "method":"aes-256-cfb" # 加密方式设置&#125; 随后执行ssserver -c /etc/shadowsocks.json -d start启动ss服务端即可。 配置ss客户端根据自己的系统发行版安装shadowsocks即可。配置文件和服务端类似： 1234567891011&#123; "server":"&lt;VPS的IP地址&gt;", "server_port":&lt;在VPS上设置的端口&gt;, "local_address":"127.0.0.1", "local_port":&lt;对本地开放的代理端口&gt;, "password":"&lt;和VPS端口对应的密码&gt;", "timeout":300, "method":"aes-256-cfb", # 加密方式应与服务端保持一致 "plugin":"&lt;你所使用的插件，没有则省略这一项&gt;", "plugin_opts":"&lt;插件的启动参数，没有则省略这一项&gt;"&#125; 执行ss-local -c &lt;配置文件绝对路径&gt;打开ss客户端。 安装插件如果是Google/Firefox浏览器的话，直接按照教程安装SwitchyOmega插件即可科学上网。]]></content>
      <categories>
        <category>Academic or Technical</category>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[GDB常见用法总结]]></title>
    <url>%2Fblog%2F2018%2F01%2F18%2FGDB%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[GDB常见用法总结GDB是Linux系统下一款非常强大的调试工具，熟练掌握的话其功能远远不限于调试。本文总结了一部分GDB的常见用法，以供参考。 基本操作 b &lt;breakpoint&gt; 设置断点 &lt;breakpoint&gt;可以是函数名，可以是行数，也可以是具体地址。使用地址的时候，要在十六进制地址前面加上一个*标记。 delete命令可以删除断点 s 让程序单步执行一条C指令，遇到函数调用则进入(需要编译时带-g参数) si 让程序单步执行一条asm指令，遇到函数调用则进入(不带-g也可以) si &lt;N&gt; 让程序执行&lt;N&gt;条asm指令，包括函数内的和函数外的。 n 让程序单步执行一条C指令，不进入函数调用 ni 让程序单步执行一条asm指令，不进入函数调用 r 运行程序 在r后面可以添加命令行参数，这样运行程序就相当于在shell中用同样的命令行参数来运行。 c 让程序继续运行直到遇到下一个断点。 p 打印目标信息。 阅读内存系统内容 x/[num][opt][len] &lt;addr&gt; [num]：将要打印出的连续内存单元的数量 [opt]：打印出数据的格式 i 指令 x 十六进制数据 d 十进制数据 o 八进制数据 t 二进制数据 c 字符数据 f 浮点数数据 [len]：每个内存单元包含的字节数 b：单字节 h：双字节 w：四字节 g：八字节 backtrace 查看程序栈中每个栈帧的信息 设定输出格式 set print pretty 改善数组和结构体的输出格式 layout asm 改变输出格式为汇编窗口 info系命令 info registers 打印出寄存器信息 info frame 打印出当前栈帧的详细信息 info local 打印出当前栈帧中的局部变量]]></content>
      <categories>
        <category>Academic or Technical</category>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Shellscript学习总结]]></title>
    <url>%2Fblog%2F2018%2F01%2F10%2Fshellscript%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Shellscript学习总结Shell是Linux下重要的工具语言，活用shell可以有效地提高我们在Linux下的工作效率。本文将总结Shellscript的学习过程，以供复习和参考。 Shellscript的语法规范你可以在Shellscript脚本中执行任意可以在LinuxShell下执行的指令。除了这些指令以外，Shellscript还提供一些额外的语法来实现一些高级语言特性。 shellscript类别声明在一个Shell脚本的开头，编写者应当声明支持该脚本语法的shell程序位置。 格式：#!&lt;path&gt;，其中&lt;path&gt;是可执行文件的具体路径。 变量shell是弱类型语言，所有变量可以无需声明直接赋值。在需要引用变量的时候，需要在它前面加上$。 注意：变量声明时，在变量名和等号以及等号和表达式之间都不要加空格，否则变量名会被识别为命令 如果要将一段指令的输出结果赋给变量，可以用$()将指令括起来。 系统变量 $&lt;n&gt; 脚本的第&lt;n&gt;个命令行参数 $# 脚本的参数个数 $? 上一个指令的返回值 输入变量read var从标准输入读入一个变量。 条件判断Shell中条件语句的基本语法如下： 1234567if [ &lt;condition&gt; ]; then &lt;command&gt;elif [ &lt;condition&gt; ]; then &lt;command&gt;else &lt;command&gt;fi elif和else都是可以省略的。 一对中括号可以换成test语句。 需要注意的是，如果&lt;condition&gt;是数值判断，用(( ))会比[ ]更方便，因为双小括号中可以直接使用C中的数值比较操作符，且引用变量名的时候不需要加$。 注意：一定不要省略中括号两边的空格 接下来重点总结一下&lt;condition&gt;项的写法。 逻辑表达式 -a：逻辑与，等价于&amp;&amp; -o：逻辑或，等价于|| !：逻辑非 =：相当于C中的== -gt：相当于&gt; -ge：相当于&gt;= -lt：相当于&lt; -le：相当于&lt;= 文件判断常用的文件类判断命令如下： -d &lt;DIR&gt; 如果&lt;DIR&gt;是目录则为真 -e &lt;FILE&gt; 如果&lt;FILE&gt;存在则为真 -s &lt;FILE&gt; 如果&lt;FILE&gt;存在且大小不为0则为真 -r/w/x &lt;FILE&gt; 如果&lt;FILE&gt;存在且可读/可写/可执行则为真 -L &lt;FILE&gt; 如果&lt;FILE&gt;存在且为符号链接则为真 更多的命令可以Google。 指令语句如果if后面是一条指令的话，shell会判断这个指令进程的返回值，如果为0(未发生错误)则控制流进入then，否则进入else。 循环for循环for循环的标准语法为： 123for &lt;var&gt; in &lt;arg1&gt; &lt;arg2&gt; ... &lt;argn&gt; do &lt;command&gt;done 其中&lt;var&gt;会被分别赋予&lt;arg1&gt;到&lt;argn&gt;的值 这里的&lt;arg&gt;们可以用一个arglist替换，如for file in ./* do ...可以遍历当前文件夹下的文件。 break和continue与C语言类似，不予详述。 Shell的功能使用输入输出重定向在Unixshell中，我们用0代指stdin，1代指stdout，2代指stderr。重定向符其实就是对这三个设备进行操作，将本应该输入/输出到这三个设备的数据重定向到其他文件。 重定向符事实上可以算是双目算符，但有的操作数可以缺省。比如，&gt;的默认左操作数是stdout(1)，那么在一条指令后加上&gt;file则相当于将要输出到stdout的数据重定向到了file文件中。为了区分stdout的1和名字为1的文件，在重定向符使用标准输入输出文件作为操作数时，要在其前面加上&amp;。 比如，2&gt;&amp;1意为将stderr重定向到stdout，1&gt;&amp;2就是反过来。 在输出重定向时，一个特殊的文件是/dev/null，它是一个只写文件，这意味着将输入重定向到/dev/null就相当于丢弃了所有输出。 退出进程exit命令用于退出当前进程。exit 0为正常退出，exit 1为非正常退出。]]></content>
      <categories>
        <category>Academic or Technical</category>
        <category>ArchLinux and Shell</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用dot语言和Doxygen提高绘图效率]]></title>
    <url>%2Fblog%2F2018%2F01%2F10%2F%E4%BB%A3%E7%A0%81%E7%BB%98%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[用dot语言和doxygen提高绘图效率作为关山口某报告大学的学子，本人一直以来深受各种报告的荼毒。实验报告要画流程图，课设报告要画函数调用图和关系图……如果用一般的画图工具去一个个画实在是太累人了。为了从繁重的制图工作中解脱出来，dot语言被提上了学习日程。 dot语言dot语言是一种类似于TeX的用代码生成图形的脚本语言。它可以非常方便地生成有向图或无向图，并定制各个节点/边的属性。 dot语言环境的配置要想将dot脚本渲染成图片或pdf，必须安装graphviz。Arch的aur仓库中就有这个工具包，直接执行yay graphviz即可安装。 为了更好的编码体验，建议在VSCode中安装两个插件 - Graphviz Preview和Graphviz (dot) language support for Visual Studio Code。这样我们就可以不再使用笨拙的graphviz原生GUI而改用VSCode来编写dot脚本了。 dot的语法图的声明123&lt;type&gt; &lt;name&gt; &#123; &lt;stmt_list&gt;&#125; dot中的图声明类似于C中的结构。&lt;type&gt;可以是graph(无向图)或者digraph(有向图)，&lt;name&gt;代表图形的名字，命名规则与C语言一致。&lt;stmt_list&gt;由各种声明和设定语句构成。 属性声明1&lt;object&gt; [ &lt;attr_list&gt; ] &lt;name_list&gt; 属性声明可以设置一种&lt;object&gt;(graph|edge|node)的属性。&lt;attr_list&gt;决定了具体的属性，由数条由空格隔开的&lt;attr&gt;组成，每条&lt;attr&gt;都是一个赋值表达式，每个属性的可能取值可以参考DOT documentation。 如果缺省&lt;name_list&gt;的话，这条属性会施加在所有这一类objects上；否则，就会施加在&lt;name_list&gt;所指定的几个object上。 位置越靠后的属性声明优先级越高。 示例： 1node [shape = "doublecircle" fixedsize=true width = 0.5] int float ident char 点声明由于dot语言的点可以不加声明直接使用，点声明通常可以缺省。点声明的格式与属性声明类似，只不过把object换成了点的名称。 边声明1234// 有向图：&lt;node1&gt; -&gt; &lt;node2&gt; &lt;attr_list&gt;// 无向图：&lt;node1&gt; -- &lt;node2&gt; &lt;attr_list&gt; 可以在&lt;node1&gt;和&lt;node2&gt;的后面加上:&lt;dir&gt;，其中&lt;dir&gt;决定边的起点或终点在node上的位置，其值为8个方向缩写之一，如n或sw。 示例： 10:n -&gt; 0:s [label = "test" ] 注释dot的注释与C语言格式相同。 doxygen文档系统Doxygen是一种开源跨平台的，以类似JavaDoc风格描述的文档系统，完全支持C、C++、Java、Objective-C和IDL语言，部分支持PHP、C#。注释的语法与Qt-Doc、KDoc和JavaDoc兼容。Doxygen可以从一套归档源文件开始，生成HTML格式的在线类浏览器，或离线的LATEX、RTF参考手册。 简而言之，Doxygen是一种项目文档生成器：它通过对项目源代码和注释的解析去生成一份这个项目的帮助文档。Doxygen的主要功能有二： 生成一个源代码中带有指定格式注释的项目的帮助文档 解析一个没有注释的项目的代码结构，并可以以图形化的形式表示 关于doxygen的使用细节可以参考官方文档。 doxygen的安装由于在之前已经安装过graphviz，这边只需要执行yay doxygen安装doxygen即可正常使用。 doxygen的使用生成配置文件在工作目录下执行doxygen -g可以生成一个文档系统配置文件。doxygen根据这个配置文件的设置来决定如何去生成帮助文档。参数-s可以让生成的配置文件不带有帮助性的注释，在-g后可以跟一个参数来决定配置文件的名字。 修改配置文件现在列出配置文件中一些常用的属性： 项目全局属性 DOXYFILE_ENCODING：将要生成的文档的编码方式，一般为默认的UTF-8 PROJECT_NAME：项目名，将会显示在生成的文档的左上角 PROJECT_NUMBER： 项目的版本号，会显示在项目名旁边 PROJECT_BREIF：项目的简介，会显示在项目名下面 PROJECT_LOGO：项目logo文件的路径，空则没有logo OUTPUT_DIRECTORY：输出文件存放的路径 ALLOW_UNICODE_NAMES：设定为YES则支持所有Unicode字符，否则只支持ASCII码。默认为NO OUTPUT_LANGUAGE：输出文件使用的语言 TAB_SIZE：tab键的长度 语言支持所有以OPTIMIZE_OUTPUT_FOR_打头的属性都是与项目语言有关的，一般你的项目是由什么语言编写的就将什么语言对应的属性设置为YES。 Doxygen原生地支持Markdown语法，在注释中以markdown语法写出的代码会被自动渲染。如果想要关掉这一功能，可以将MARKDOWN_SUPPORT设置为NO。 文档生成 EXTRACT_ALL：如果设置为YES，所有对象(函数，类，结构等)都会被解析并加入到文档，尽管有的对象可能并没有可以被识别的注释。这个选项对于没有按规则注释的项目很有作用。 EXTRACT_PRIVATE：如果设置为YES，所有private属性也会被解析，否则不会 EXTRACT_PACKAGE：如果设置为YES，所有package中的对象也会被加入文档 EXTRACT_STATIC：如果设置为YES，所有static对象也会被解析，否则不会 其余几条以EXTRACT打头的属性的作用类似。 输入INPUT属性应当设置为输入文件所在的具体路径。通过修改FILE_PATTERNS可以使Doxygen只识别那些特定后缀的文件。如果设置RECURSIVE为YES，INPUT路径对应的同文件夹下和深层文件夹中的所有文件都会被加入文档。 如果不想解析特定的几个文件，可以通过设置EXCLUDE或EXCLUDE_SYMBOL等属性将他们排除在外。 IMAGE_PATH用于告诉Doxygen在哪里找到你在文档中引用的图片。 函数调用关系图生成Doxygen使用dot语言来生成关系图，因而需要将HAVE_DOT选项设置为YES，并将DOT_PATH属性的值设置为Graphviz的二进制文件所在文件夹路径。最后，将CALL_GRAPH和CALLER_GRAPH选项设置为YES即可在最终的文档中生成关系图。 编写源代码的注释三种注释类型Doxygen只能识别特定格式的注释块，并将其内容加入到文档中。每个代码中的对象都可以有两种可选的注释：brief注释和detailed注释。对于函数和方法，还有第三种in-body注释。 对象对应的detailed注释必须写在对象的正上方，并与对象的第一行之间没有空行。 下面列出一些可以被Doxygen识别的detailed注释格式(这边以C风格为例)： 123/** * JavaDoc Style，重点是第一行最后的星号 */ 123/*! * Qt Style，与前一种不同的是星号换成了！ */ 123////// 这种情况下，第一行的三个/是必需的，之后每多一行都要以///开头，直到遇到空行。/// 第三个/也可以换成！ 如果要使用brief注释，有这样几种方式： 在detailed注释块中使用\brief声明，在声明之后的注释直到空行(或以*开头的行)为止都是brief注释。 如果JAVADOC_AUTOBRIEF属性开着，每个detailed注释块的第一句注释都会自动称为brief注释。 只占有一行的以///开头的注释会成为brief注释。 如果要对一个单独的变量或其他成员进行注释，可以在变量声明后跟一个注释，并在这个注释的开始处增加一个&lt;字符。如： 1int sample; ///&lt; Brief description after member 注释块中的声明我们可以在注释块中使用各种声明来实现更强大的功能： \param: 为对象的参数提供注释 \return: 为对象的返回值提供注释 \sa: 即see also, 一般包含与该对象相关联的对象名 如果不想将注释块直接放在要注释的对象上方，也可以将其放在其他地方，同时在注释中用声明来指定这个注释的归属对象。这种声明包括： \struct to document a C-struct. \union to document a union. \enum to document an enumeration type. \fn to document a function. \var to document a variable or typedef or enum value. \def to document a #define. \typedef to document a type definition. \file to document a file. \namespace to document a namespace. \package to document a Java package. \interface to document an IDL interface. 对于其他语言的注释格式，可以继续参考官方文档。]]></content>
      <categories>
        <category>Academic or Technical</category>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Deeper in C]]></title>
    <url>%2Fblog%2F2017%2F12%2F24%2FC%2F</url>
    <content type="text"><![CDATA[Deeper in C我们通常说学校教的C语言“是假的”，无非就是因为其内容过于浅显，其标准又不甚优雅。这篇博客就是为了总结一些在系统编程中学到的“真正的C”的知识，记录下这个“go deeper in C”的过程。 KeywordsPrefixesStatic提到C语言的前缀关键字，static应当是用途最广，用法最多的一个。无论是在系统编程还是算法题中，都能看到这个关键字的身影。根据其修饰的关键字的种类与位置的不同，static的作用会有很大差异。 Static local variables这应该是C语言课程必讲的用法。一个声明为static的局部变量会被存储在全局的静态变量区，因而具有全局变量的特点，从声明开始到程序结束不会被回收。它与一般全局变量的区别在于作用域。 Static global variables静态的全局变量根据其所在的位置，其意义也是有区别的： 在.c文件中：其作用类似于C++类中的private，可以让这个全局变量无法被外部文件通过extern引用。经过测试，对带有static标识的变量的extern语句是无效的，如果引用之会引起链接器报错。 在.h文件中：这个带有static标识的变量会在每个引用了该头文件的.c文件中创建一个自己的副本，不同文件之间对该变量的写操作不互相影响。 Static functions按照C语言编程规范，函数的定义大部分时候会放在.c文件当中，此时静态函数的作用类似于C++的private函数，仅能被本文件中的函数调用。但有些时候(尤其是系统编程中)我们也会违反常规地在.h文件中定义一个静态函数，原因如下： 在C语言编程规范中，我们应该把函数声明放在头文件，而在每个具体的.c文件中进行实现，这是因为一般的函数定义放在头文件时会引起函数体被每个.c文件都包含一次，造成空间上的浪费，还有可能由于头文件之间的交叉包含而引起重复定义的错误。而使用static函数就不会有这个问题，因为它的代码是存在静态区的，所有引用这个头文件的.c文件都会引用同一个静态区中的同一段函数代码，因而就不会产生浪费的问题。 那为什么我们不按照编程规范，只在某一个.c文件中进行实现而在头文件中以声明的方式将其公开呢？这是因为在某些情境下这种机制是必要的： 这个函数会被很多文件用到，如果放在一个有很多函数定义的.c文件中会给链接带来麻烦(我们需要为了那一个函数在链接时指定一整个.o文件)，但为其单独定义一个.c文件又没有必要，这时可以选择将其以static函数的形式放在.h文件。 普通的inline函数只有在本文件中使用会内联，以头文件声明的方式被其他文件引用则不会内联(因为编译器在编译引用这个函数的文件时并不知道其函数体，无法做到内联展开，只能在链接阶段将对函数的引用指向其实际的代码段)，因而当我们需要声明一个全局的inline函数时需要以static inline在.h文件中声明。 extern如果说将函数声明放在.h文件中是这个模块对外的函数接口，那么带有extern前缀的变量就是这个模块对外的变量接口。通常来说，我们会将希望被其他模块访问到的变量在头文件中用extern前缀进行声明。]]></content>
      <categories>
        <category>Academic or Technical</category>
        <category>Languages</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在安装了Windows10系统的基础上安装ArchLinux+KDE桌面环境]]></title>
    <url>%2Fblog%2F2017%2F12%2F04%2F%E5%9C%A8%E5%AE%89%E8%A3%85%E4%BA%86Windows10%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%E5%AE%89%E8%A3%85ArchLinux%2BKDE%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[在安装了Windows10系统的基础上安装ArchLinux+KDE桌面环境安装前在Windows下要做的准备为Arch的安装腾出空间按win+x组合键后选择磁盘管理，可以浏览目前的磁盘使用状况。通过右键某个分卷-压缩卷的方式可以释放一个分区中未被使用的部分，成为“未使用”的磁盘。 如果在试图压缩卷的时候报错“磁盘剩余的空间不足”，就格式化这个空磁盘，再重新尝试。 关闭Windows的快速启动为了能够顺利进入BIOS界面，我们需要关闭windows的快速启动功能。 123456781. 登陆系统，点击左下角开始菜单。2. 点击设置按钮，进入Windows设置界面。3. 点击系统按钮，进入系统设置界面。4. 点击电源和按钮，进入电源和睡眠设置界面。5. 点击其他电源设置，进入电源选项界面。6. 点击选择电源按钮的功能，进入电源选项下的系统设置界面。7. 点击更改当前不可用的设置，使能关机设置的选项。8. 将启用快速启动前面的勾取消，点击保存修改即可。 下载ArchLinux镜像并制作启动盘可以在ArchLinux的官网下载ArchLinux的最新镜像。下载完成之后，格式化一个空的USB，并将镜像文件解压到USB中即可。 注意：这里如果使用UltraISO制作启动盘可能会在装机时出现玄学错误，不推荐。 设置BIOS选项根据自己的电脑机型进入BIOS界面，进入Boot选项，关掉Secure Boot并将USB Device的启动优先级调到最高。 磁盘分区及挂载重启之后选择出现的第一个选项，进入启动盘提供的shell。 检查网络此处需要网络链接，连接网络之后执行dhcpcd，看看能否ping通百度。 磁盘分区先使用lsblk命令查看设备名，一般来说是/dev/sda，因此接下来都将以其作为示范。 执行cgdisk /dev/sda，进入交互式图形界面，在这里可以看到之前腾出来的未使用磁盘。 cgdisk使用方法 NEW 划分一个新分区，会依次询问几个关于分区的选项，除了分区大小一概默认即可。 分区大小格式：xxKiB/MiB/GiB WRITE 写入更改到磁盘 QUIT 退出 在这里我们需要分出一个128MiB的EFI分区和一个大小根据需求决定的根分区。在分好分区之后记住两个分区的设备序号(在分区名左边)，它们对应的device名称就是sda&lt;序号&gt;。为了方便，在这里我们用sda9代指UEFI分区，用sda8代指根分区。 退出cgdisk之后，执行fdisk /dev/sda进入fdisk交互式命令行。 fdisk使用方法 m：打印所有指令 p：显示目前的所有分区 t：更改分区类型 w：写入更改并退出 q：不保存退出 执行 t /dev/sda，输入UEFI分区序号(这里是9)，输入L列出所有分区种类对应的序号，可以发现1对应EFI system。于是输入1,将sda9的分区类型改为EFI分区。可以使用p看一下类型是否成功更改，如果成功就输入w写入更改并退出。 格式化执行mkfs.vfat -F32 /dev/sda9格式化UEFI分区，执行mkfs.ext4 /dev/sda8格式化根分区。 挂载依次输入： 123mount /dev/sda8 /mntmkdir /mnt/bootmount /dev/sda9 /mnt/boot 安装基本软件包更改镜像源编辑/etc/pacman.d/mirrorlist文件，将标有China的源移到前面以加快下载速度。 保存后使用pacman -Syy刷新。 安装软件包执行pacstrap -i /mnt base下载并安装基本软件包。 配置新系统生成fstab执行genfstab -U -p /mnt &gt;&gt; /mnt/etc/fstab生成fstab。 进入新系统执行arch-chroot /mnt /bin/bash进入新系统。 设置Locale修改/etc/locale.gen文件，去掉 123en_US.UTF-8 UTF-8zh_CN.UTF-8 UTF-8zh_TW.UTF-8 UTF-8 三行的注释并保存。 执行locale-gen生成locale文件，然后执行echo LANG=en_US.UTF-8 &gt; /etc/locale.conf将locale配置写入配置文件。 设置时间用tzselect设置时区，并执行ln -s /usr/share/zoneinfo/&lt;时区&gt;/&lt;子时区&gt; /etc/localtime建立软连接，执行hwclock --systohc --utc设置硬件时间。 设置密码执行passwd命令可以更改root密码。 安装bootloader执行bootctl install命令安装bootloader，并执行cp /usr/share/systemd/bootctl/arch.conf /boot/loader/entries/复制配置文件到boot目录下。 执行blkid -s PARTUUID -o value /dev/sda8生成根分区的PARTUUID，并修改/boot/loader/entries/arch.conf如下： 1234title Arch Linuxlinux /vmlinuz-linuxinitrd /initramfs-linux.imgoptions root=PARTUUID= &lt;之前生成的PARTUUID&gt; rw 修改/boot/loader/loader.conf文件的内容如下： 12timeout 3default arch 设置主机名执行echo &lt;hostname&gt; &gt; /etc/hostname将你喜欢的hostname写入配置文件。 在/etc/hosts文件中添加： 12127.0.0.1 localhost.localdomain localhost &lt;hostname&gt;::1 localhost.localdomain localhost &lt;hostname&gt; 配置网络执行wifi-menu可以进入wifi连接图形界面。 用pacman安装iw，执行iw dev可以查看设备的网络Interface，然后执行systemctl enable dhcpcd@&lt;YourInterface&gt;.service启动dhcpcd服务。 结束安装ctrl+D退出chroot，执行pacman -S linux安装linux镜像文件，用umount命令取消挂载，reboot now重启。 重启时注意先进入BIOS将linux boot manager优先级调到最高。(如果想进入windows系统需要将windows boot manager优先级调到最高) 安装KDE桌面环境重启后记得重新使用wifi-menu连接wifi。 执行useradd -m -k /etc/skel/ -G users,wheel &lt;username&gt;建立新用户，并执行passwd &lt;username&gt;设置密码。 依次执行下列所有指令： 1234567891011pacman -S xorg xorg-xinitpacman -S xf86-input-synapticspacman -S xorg-twm # 图形化窗口管理工具Tab Window Managerpacman -S xterm # 标准虚拟终端pacman -S ttf-dejavu wqy-microhei # 字体包pacman -S kf5 kf5-aidspacman -S plasma kdebase # KDE Plasma 桌面环境及基础包pacman -S gwenview # KDE图片浏览工具pacman -S kdegraphics # 图像处理相关工具的软件包pacman -S plasma-mediacenter # 媒体中心pacman -S sddm sddm-kcm # 用于X11和wayland视窗系统的显示管理器（图形登录界面） 执行systemctl enable sddm开启sddm服务并编辑/etc/sddm.conf文件为： 123[Theme] Current=breeze CursorTheme=breeze_cursors 执行下列命令安装gnome支持： 123pacman -S gtk-engines gtk2 gtk3 # 跨平台的图形工具包pacman -S gnome-themes-standard gnome-icon-theme # 显示的主题及图标pacman -S gvfs gamin # GNOME桌面系统的虚拟文件系统+文件和目录监控系统 安装解压缩软件和NTP： 123456pacman -S p7zippacman -S zippacman -S unzippacman -S unrarpacman -S ntpsystemctl enable ntpd 安装网络管理软件： 12345pacman -S networkmanagerpacman -S net-toolssystemctl enable NetworkManagersystemctl enable dhcpcd 安装音频： 12345pacman -S alsa-utils pulseaudio # 声卡测试和音频编辑的工具 + 通过网络工作的声音服务pacman -S pulseaudio-alsapacman -S libcanberra-pulsepacman -S libcanberra-gstreamerpacman -S jack2-dbus 安装NTFS系统识别：pacman -S ntfs-3g 使用pacman安装sudo，并更改/etc/sudoers文件，去掉%wheel ALL=(ALL) ALL前面的注释。如果希望sudo不需要输入密码，可以改为%wheel ALL=(ALL) NOPASSWD: ALL 安装中文支持： 1234567891011pacman -S kde-l10n-zh_cnpacman -S kde-applicationspacman -S fcitx fcitx-rime # 这里使用的是fcitx输入法pacman -S fcitx-impacman -S kcm-fcitxvim /home/air/.xprofileexport LANG=zh_CN.UTF-8 export LC_ALL=zh_CN.UTF-8 export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS="@im=fcitx" 执行reboot now，进入桌面环境。 安装桌面环境之后配置系统设置快捷键设置绝大部分快捷键可以在系统设置-工作空间-快捷键下设置，也有一部分是在其他地方设置。 工作空间-桌面行为-虚拟桌面 配置虚拟桌面数量和切换快捷键 工作空间-桌面行为-锁屏 配置屏保图片和锁屏快捷键 工作空间-快捷键-全局快捷键-系统设置 大部分关于窗口的快捷键 当然，如果有特殊的需要，也可以自定义快捷键： 在工作空间-快捷键-自定义快捷键中，使用编辑-新建-全局快捷键-命令/url可以建立一个新的快捷键，通过设置触发器和动作标签可以进行快捷键的定制。 (例如，对于打开终端的快捷键，需要在动作中填入konsole) 界面风格设置KDE提供了很多强大的特效，这个按照个人爱好设置即可。 安装必要的应用软件像是vim，make，wget这种不可或缺的工具，是一定要事先安装好的。 代码管理工具-gitgit可以直接使用pacman安装。重点在于将git与github上的账户建立联系。 用pacman安装openssh软件，执行ssh-keygen -t rsa -b 4096 -C &quot;&lt;YourComment&gt;&quot;生成一组ssh公私钥，路径选择自己喜欢的路径，密码可以不设置。复制保存位置下的id_rsa.pub文件内容并粘贴到GitHub要求的位置即可。 包管理工具-yay执行git clone https://aur.archlinux.org/yay.git，拉取yay的repo。进入yay的目录后执行makepkg -si命令，开始安装yay。 中间如果出现依赖软件未安装的问题，就用pacman安装对应的软件即可。 安装结束之后，顺便修改一下yay和pacman的下载工具。 美化终端终端自定义打开终端菜单栏上的设置-编辑当前方案，即可设置终端风格。使用外观-编辑可以设置背景透明度。 安装和配置zsh用pacman安装zsh本体之后，下载Oh-My-Zsh配置文件并安装： 123wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.shchmod +x install.sh./install.sh 如果需要自定义zsh，可以编辑~/.zshrc文件。具体的配置可以参考这篇博客 如果需要将zsh设置为默认终端，可以打开终端菜单栏上的设置-编辑当前方案，将命令更改为/bin/zsh即可。 浏览器-ChromiumArch官方有Chrome的软件包，所以直接使用pacman安装Chromium即可。 可以安装ttf-liberation来防止字符输入出现问题。 文本编辑器-sublime可以使用yay sublime列出所有sublime的软件包，可以跟据爱好自行选择安装哪个版本。 我的Sublime配置 Sublime版本：sublime-text-3-imfix 插件安装： Markdown Editor Markdown Preview 快捷键设置(在preferences-key bindings下)：{ &quot;keys&quot;: [&quot;alt+m&quot;], &quot;command&quot;: &quot;markdown_preview&quot;, &quot;args&quot;: {&quot;target&quot;: &quot;browser&quot;, &quot;parser&quot;:&quot;markdown&quot;} } 字体：Fira Code 代理服务使用pacman可以安装shadowsocks。具体的配置此处不详谈。 同样使用pacman安装privoxy。安装完成之后，修改privoxy配置文件/etc/privoxy/config，其中的listen-address代表它监听的地址和端口。将forward-socks5t所在的行取消注释，并将后面的ip地址和端口改为shadowsocks的本地绑定地址和端口。 执行export命令将以下变量加入当前环境： 123# ip地址和端口为privoxy监听的地址和端口export https_proxy=http://127.0.0.1:8118export http_proxy=http://127.0.0.1:8118 执行systemctl start privoxy，curl ip.gs测试当前ip位置，如果在VPS提供商的位置则说明配置成功。 如果要取消代理设置的话，只需要使用unset将这两条全局变量删除即可。 要配置 全局代理 可以打开代理设置，然后将127.0.0.1和1080填入IP地址和端口即可。 按个人喜好安装其他软件我安装的软件： 12341. community/code The Open Source build of Visual Studio Code (vscode) editor2. aur/netease-cloud-music Netease Cloud Music, converted from .deb package 引用 UEFI+GPT安装Win10+Archlinux双系统 UEFI安装Arch’s KDE桌面全过程]]></content>
      <categories>
        <category>Academic or Technical</category>
        <category>ArchLinux and Shell</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[本博客的Hexo配置]]></title>
    <url>%2Fblog%2F2017%2F11%2F23%2F%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84Hexo%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本博客的Hexo配置本篇文章记录了这个用Hexo搭建起来的博客的全部配置，以便留存或供其他人参考。 安装Hexo(注：不以root身份执行的话，某些文件进程无权访问，从而可能带来各种各样的玄学错误) sudo npm install -g hexo-cli - 需要依赖nodejs和npm 12345sudo hexo init &lt;BlogFolderName&gt;cd &lt;BlogFolderName&gt;sudo npm installsudo npm install hexo-deployer-git --saves # 支持发布到github pagessudo npm install hexo-generator-searchdb --save # 支持搜索功能 修改配置这是我的_config.yml内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Gensokyo subtitle: Youkai's Mountaindescription:keywords:author: Drac Zhanglanguage:timezone:# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://dracit7.github.io/blogroot: /blog/permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: truerelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/dracit7/blog.git branch: gh-pages search: path: search.xml field: post format: html limit: 10000 配置分页123hexo new page tagshexo new page abouthexo new page categories 然后修改source/&lt;pagename&gt;/index.md,加一行type: &quot;&lt;pagename&gt;&quot;即可。 配置图片上传hexo默认是不能在md文件中导入图片的。为了实现导入图片的功能，执行： 1sudo npm install https://github.com/CodeFalling/hexo-asset-image --save 安装完毕后，修改node_modules/hexo-asset-image/index.js的内容(原生的js脚本写的有bug，无法正确生成图片路径，我使用的是基于一个同样有bug的代码版本的自己修改过的实现)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1; else var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html". var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function()&#123; if ($(this).attr('src'))&#123; // For windows style path, we replace '\' to '/'. var src = $(this).attr('src').replace('\\', '/'); if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp; !/^\s*\//.test(src)) &#123; // For "about" page, the first part of "src" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem)&#123; return elem != ''; &#125;); var srcArray = src.split('/').filter(function(elem)&#123; return elem != '' &amp;&amp; elem != '.'; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); // 原来的bug就在这一行，本来是root+link+src，会造成路径重复 $(this).attr('src', src); console.info&amp;&amp;console.info("update link as:--&gt;"+ link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info("no src attr, skipped..."); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 保存之后，在_post文件夹下建立一个需要导入图片的文件夹，即可使用相对路径导入图片。 主题配置这是我的NexT主题配置文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813# ===============================================================# ========================= ATTENTION! ==========================# ===============================================================# NexT repository is moving here: https://github.com/theme-next# ===============================================================# It's rebase to v6.0.0 and future maintenance will resume there# ===============================================================# ---------------------------------------------------------------# Theme Core Configuration Settings# ---------------------------------------------------------------# Set to true, if you want to fully override the default configuration.# Useful if you don't want to inherit the theme _config.yml configurations.override: false# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# To get or check favicons visit: https://realfavicongenerator.net# Put your favicons into `hexo-site/source/` (recommend) or `hexo-site/themes/next/source/images/` directory.# Default NexT favicons placed in `hexo-site/themes/next/source/images/` directory.# And if you want to place your icons in `hexo-site/source/` root directory, you must remove `/images` prefix from pathes.# For example, you put your favicons into `hexo-site/source/images` directory.# Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexo.favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml# Set default keywords (Use a comma to separate)keywords: "Hexo, NexT"# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss:footer: # Specify the date when the site was setup. # If not defined, current year will be used. #since: 2015 # Icon between year and copyright info. icon: user # If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- # Hexo link (Powered by Hexo). powered: true theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: true # Version info of NexT after scheme info (vX.X.X). version: true # ------------------------------------------------------------- # Any custom text can be defined here. #custom_text: Hosted by &lt;a target="_blank" href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt;# ---------------------------------------------------------------# SEO Settings# ---------------------------------------------------------------# Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.# See: https://support.google.com/webmasters/answer/139066# Tips: Before you open this tag, remember set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )canonical: true# Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.seo: false# If true, will add site-subtitle to index page, added in main hexo config.# subtitle: Subtitleindex_with_subtitle: false# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives).# Usage: `Key: /link/ || icon`# Key is the name of menu item. If translate for this menu will find in languages - this translate will be loaded; if not - Key name will be used. Key is case-senstive.# Value before `||` delimeter is the target link.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons: enable: true# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes#scheme: Musescheme: Mist#scheme: Pisces#scheme: Gemini# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# Social Links.# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.social: GitHub: https://github.com/dracit7 || github #E-Mail: mailto:yourname@gmail.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skypesocial_icons: enable: true icons_only: false transition: false# Blog rollslinks_icon: linklinks_title: Linkslinks_layout: block#links_layout: inline#links: #Title: http://example.com/# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /images/lyrica.png# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: true # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: # Sidebar Position, available value: left | right (only for Pisces | Gemini). position: left #position: right # Sidebar Display, available value (only for Muse | Mist): # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggle. display: post #display: always #display: hide #display: remove # Sidebar offset from top menubar in pixels (only for Pisces | Gemini). offset: 12 # Back to top in sidebar (only for Pisces | Gemini). b2t: false # Scroll percent label in b2t button. scrollpercent: false # Enable sidebar on narrow view (only for Muse | Mist). onmobile: false# ---------------------------------------------------------------# Post Settings# ---------------------------------------------------------------# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true# Automatically saving scroll position on each post/page in cookies.save_scroll: false# Automatically excerpt description in homepage as preamble text.excerpt_description: true# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150# Post meta display settingspost_meta: item_text: true created_at: true updated_at: false categories: true# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: false min2read: false totalcount: false separated_meta: true# Wechat Subscriber#wechat_subscriber: #enabled: true #qcode: /path/to/your/wechatqcode ex. /uploads/wechat-qcode.jpg #description: ex. subscribe to my blog by scanning my public wechat account# Reward#reward_comment: Donate comment here#wechatpay: /images/wechatpay.jpg#alipay: /images/alipay.jpg#bitcoin: /images/bitcoin.png# Declare license on postspost_copyright: enable: false license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Reduce padding / margin indents on devices with narrow width.mobile_layout_economy: false# Android Chrome header panel color ($black-deep).android_chrome_color: "#222"# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images's urlcustom_logo: enabled: false image:# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night# ---------------------------------------------------------------# Font Settings# - Find fonts on Google Fonts (https://www.google.com/fonts)# - All fonts set here will have the following styles:# light, light italic, normal, normal italic, bold, bold italic# - Be aware that setting too much fonts will cause site running slowly# - Introduce in 5.0.1# ---------------------------------------------------------------# CAUTION! Safari Version 10.1.2 bug: https://github.com/iissnan/hexo-theme-next/issues/1844# To avoid space between header and sidebar in Pisces / Gemini themes recommended to use Web Safe fonts for `global` (and `logo`):# Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS# ---------------------------------------------------------------font: enable: false # Uri of fonts host. E.g. //fonts.googleapis.com (Default). host: # Font options: # `external: true` will load this font family from `host` above. # `family: Times New Roman`. Without any quotes. # `size: xx`. Use `px` as unit. # Global font settings used on &lt;body&gt; element. global: external: true family: Lato size: # Font settings for Headlines (h1, h2, h3, h4, h5, h6). # Fallback to `global` font settings. headings: external: true family: size: # Font settings for posts. # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo. # Fallback to `global` font settings. logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: size:# ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# MathJax Supportmathjax: enable: true per_page: false cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML# Han Support docs: https://hanzi.pro/han: false# Swiftype Search API Key#swiftype_key:# Baidu Analytics ID#baidu_analytics:# Duoshuo ShortName#duoshuo_shortname:# Disqusdisqus: enable: true shortname: Drac_zhang count: true# Hypercomments#hypercomments_id:# changyanchangyan: enable: false appid: appkey:# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: false appid: # your leancloud application appid appkey: # your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size# Support for youyan comments system.# You can get your uid from http://www.uyan.cc#youyan_uid: your uid# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)#livere_uid: your uid# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/# You can get your Github ID from https://api.github.com/users/&lt;Github username&gt;gitment: enable: false mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: # MUST HAVE, Your Github ID github_repo: # MUST HAVE, The repo you use to store Gitment comments client_id: # MUST HAVE, Github client id for the Gitment client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.#baidushare:## type: button# Share# This plugin is more useful in China, make sure you known how to use it.# And you can find the use guide at official webiste: http://www.jiathis.com/.# Warning: JiaThis does not support https.#jiathis: ##uid: Get this uid from http://www.jiathis.com/#add_this_id:# Share#duoshuo_share: true# NeedMoreShare2# This plugin is a pure javascript sharing lib which is useful in China.# See: https://github.com/revir/need-more-share2# Also see: https://github.com/DzmVasileusky/needShareButton# iconStyle: default | box# boxForm: horizontal | vertical# position: top / middle / bottom + Left / Center / Right# networks: Weibo,Wechat,Douban,QQZone,Twitter,Linkedin,Mailto,Reddit,# Delicious,StumbleUpon,Pinterest,Facebook,GooglePlus,Slashdot,# Technorati,Posterous,Tumblr,GoogleBookmarks,Newsvine,# Evernote,Friendfeed,Vkontakte,Odnoklassniki,Mailruneedmoreshare2: enable: false postbottom: enable: false options: iconStyle: box boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook float: enable: false options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/#google_site_verification:# Google Analytics#google_analytics:# Bing Webmaster tools verification setting# See: https://www.bing.com/webmaster/#bing_site_verification:# Yandex Webmaster tools verification setting# See: https://webmaster.yandex.ru/#yandex_site_verification:# CNZZ count#cnzz_siteid:# Application Insights# See https://azure.microsoft.com/en-us/services/application-insights/# application_insights:# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info: ua_enable: true admin_enable: false user_id: 0 #admin_nickname: Author# Post widgets &amp; FB/VK comments settings.# ---------------------------------------------------------------# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Facebook comments plugin# This plugin depends on Facebook SDK.# If facebook_sdk.enable is false, Facebook comments plugin is unavailable.facebook_comments_plugin: enable: false num_of_posts: 10 # min posts num is 1 width: 100% # default width is 550px scheme: light # default scheme is light (light or dark)# VKontakte API Support.# To get your AppID visit https://vk.com/editapp?act=createvkontakte_api: enable: false app_id: #&lt;app_id&gt; like: true comments: true num_of_posts: 10# Star rating support to each article.# To get your ID visit https://widgetpack.comrating: enable: false id: #&lt;app_id&gt; color: fc6423# ---------------------------------------------------------------# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: false app_id: #&lt;app_id&gt; app_key: #&lt;app_key&gt;# Another tool to show number of visitors to each article.# visit https://console.firebase.google.com/u/0/ to get apiKey and projectId# visit https://firebase.google.com/docs/firestore/ to get more information about firestorefirestore: enable: false collection: articles #required, a string collection name to access firestore database apiKey: #required projectId: #required bluebird: false #enable this if you want to include bluebird 3.5.1(core version) Promise polyfill# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: false # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; page_pv_footer:# Tencent analytics ID# tencent_analytics:# Tencent MTA ID# tencent_mta:# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: false# Google Calendar# Share your recent schedule to others via calendar page## API Documentation:# https://developers.google.com/google-apps/calendar/v3/reference/events/listcalendar: enable: false calendar_id: &lt;required&gt; api_key: &lt;required&gt; orderBy: startTime offsetMax: 24 offsetMin: 4 timeZone: showDeleted: false singleEvents: true maxResults: 250# Algolia Searchalgolia_search: enable: false hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: "We didn't find any results for the search: $&#123;query&#125;" hits_stats: "$&#123;hits&#125; results found in $&#123;time&#125; ms"# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1# ---------------------------------------------------------------# Tags Settings# ---------------------------------------------------------------# External URL with BASE64 encrypt &amp; decrypt.# Usage: &#123;% exturl text url "title" %&#125;# Alias: &#123;% extlink text url "title" %&#125;exturl: false# Note tag (bs-callout).note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: simple icons: false border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0# Label tag.label: true# Tabs tag.tabs: enable: true transition: tabs: false labels: true border_radius: 0#! ---------------------------------------------------------------#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---------------------------------------------------------------# Use velocity to animate everything.motion: enable: true async: false transition: # Transition variants: # fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut # swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut # bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut # slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut # slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut # perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut post_block: fadeIn post_header: slideDownIn post_body: slideDownIn coll_header: slideLeftIn # Only for Pisces | Gemini. sidebar: slideUpIn# Fancyboxfancybox: true# Progress bar in the top during page loading.pace: false# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-minimal# Canvas-nestcanvas_nest: false# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false# Only fit scheme Pisces# Canvas-ribbon# size: The width of the ribbon.# alpha: The transparency of the ribbon.# zIndex: The display level of the ribbon.canvas_ribbon: enable: false size: 300 alpha: 0.6 zIndex: -1# Script Vendors.# Set a CDN address for the vendor you want to customize.# For example# jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: fancybox_css: # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: # Internal version: 1 # https://www.algolia.com algolia_instant_js: algolia_instant_css: # Internal version: 1.0.2 # See: https://github.com/HubSpot/pace # Or use direct links below: # pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js # pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css pace: pace_css: # Internal version: 1.0.0 # https://github.com/hustcc/canvas-nest.js canvas_nest: # three three: # three_waves # https://github.com/jjandxa/three_waves three_waves: # three_waves # https://github.com/jjandxa/canvas_lines canvas_lines: # three_waves # https://github.com/jjandxa/canvas_sphere canvas_sphere: # Internal version: 1.0.0 # https://github.com/zproo/canvas-ribbon canvas_ribbon: # Internal version: 3.3.0 # https://github.com/ethantw/Han han: # needMoreShare2 # https://github.com/revir/need-more-share2 needMoreShare2:# Assetscss: cssjs: jsimages: images# Theme versionversion: 5.1.4]]></content>
      <categories>
        <category>Academic or Technical</category>
        <category>Others</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Overview]]></title>
    <url>%2Fblog%2F2017%2F11%2F22%2FOverview%2F</url>
    <content type="text"><![CDATA[After spending several precious hours, finally I built this blog up. It should be easy and quick(thanks to Hexo), but it took me a while to find a proper theme for my site. I’ve tried some cool stuff out, but it turned out that something simple fits me better. So I chose NexT, just like some of my fellows in UniqueStudio. I named here Gensokyo, which origins from Touhou project. Sounds naive, but I’d like to leave some fantasies here to make it not that stiff. I’m not an emotional guy in reality after all. :) The weather is great outside. Just the right time to test if this framework can show Chinese characters well. 接下来的时间里应该会(看心情地)在这里发布一些文章，可能会包括技术或学术上的分享，音乐方面的一些见解和日常随笔(如果有时间写的话)。总的来说应该会是一个记录向的网站，嗯。 So that’s it. Cheers~]]></content>
      <categories>
        <category>Discussion</category>
      </categories>
  </entry>
</search>
