<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="CSAPP Note Taking  这是阅读《深入理解计算机系统》一书时所做的学习笔记。  Chapter 1 计算机系统漫游首先从“hello.c”文件开始讲起。 Unix-like系统下有两个重要概念：  只由ASCII字符构成的文件为文本文件，其余皆为二进制文件 系统中所有信息都是由一串bits构成的。区分它们的不同方式在于它们的上下文。  有关C语言 C语言是贝尔实验室的研究员在196">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP学习笔记">
<meta property="og:url" content="https://dracit7.github.io/blog/2018/04/12/Note of CSAPP/index.html">
<meta property="og:site_name" content="Gensokyo">
<meta property="og:description" content="CSAPP Note Taking  这是阅读《深入理解计算机系统》一书时所做的学习笔记。  Chapter 1 计算机系统漫游首先从“hello.c”文件开始讲起。 Unix-like系统下有两个重要概念：  只由ASCII字符构成的文件为文本文件，其余皆为二进制文件 系统中所有信息都是由一串bits构成的。区分它们的不同方式在于它们的上下文。  有关C语言 C语言是贝尔实验室的研究员在196">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://dracit7.github.io/blog//dracit7.github.io/blog/2018/04/12/Note%20of%20CSAPP/Chapter_4/SEQ+.png">
<meta property="og:image" content="https://dracit7.github.io/blog//dracit7.github.io/blog/2018/04/12/Note%20of%20CSAPP/Chapter_4/PIPE-.png">
<meta property="og:image" content="https://dracit7.github.io/blog//dracit7.github.io/blog/2018/04/12/Note%20of%20CSAPP/Chapter_4/PIPE.png">
<meta property="og:image" content="https://dracit7.github.io/blog//dracit7.github.io/blog/2018/04/12/Note%20of%20CSAPP/Chapter_4/memory.png">
<meta property="og:image" content="https://dracit7.github.io/blog//dracit7.github.io/blog/2018/04/12/Note%20of%20CSAPP/Chapter_4/execute.png">
<meta property="og:image" content="https://dracit7.github.io/blog//dracit7.github.io/blog/2018/04/12/Note%20of%20CSAPP/Chapter_4/decode.png">
<meta property="og:image" content="https://dracit7.github.io/blog//dracit7.github.io/blog/2018/04/12/Note%20of%20CSAPP/Chapter_4/fetch.png">
<meta property="og:image" content="https://dracit7.github.io/blog//dracit7.github.io/blog/2018/04/12/Note%20of%20CSAPP/Chapter_4/control.png">
<meta property="og:image" content="https://dracit7.github.io/blog//dracit7.github.io/blog/2018/04/12/Note%20of%20CSAPP/Chapter_8/stack.png">
<meta property="og:updated_time" content="2019-03-14T13:13:39.720Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CSAPP学习笔记">
<meta name="twitter:description" content="CSAPP Note Taking  这是阅读《深入理解计算机系统》一书时所做的学习笔记。  Chapter 1 计算机系统漫游首先从“hello.c”文件开始讲起。 Unix-like系统下有两个重要概念：  只由ASCII字符构成的文件为文本文件，其余皆为二进制文件 系统中所有信息都是由一串bits构成的。区分它们的不同方式在于它们的上下文。  有关C语言 C语言是贝尔实验室的研究员在196">
<meta name="twitter:image" content="https://dracit7.github.io/blog//dracit7.github.io/blog/2018/04/12/Note%20of%20CSAPP/Chapter_4/SEQ+.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://dracit7.github.io/blog/2018/04/12/Note of CSAPP/">





  <title>CSAPP学习笔记 | Gensokyo</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Gensokyo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Youkai's Mountain</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/blog/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2018/04/12/Note of CSAPP/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">CSAPP学习笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-12T08:22:15+08:00">
                2018-04-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2018/04/12/Note of CSAPP/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/04/12/Note of CSAPP/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p><strong>CSAPP Note Taking</strong></p>
</blockquote>
<p>这是阅读《深入理解计算机系统》一书时所做的学习笔记。</p>
<hr>
<h1 id="Chapter-1-计算机系统漫游"><a href="#Chapter-1-计算机系统漫游" class="headerlink" title="Chapter 1 计算机系统漫游"></a>Chapter 1 计算机系统漫游</h1><p>首先从“hello.c”文件开始讲起。</p>
<p>Unix-like系统下有两个重要概念：</p>
<ul>
<li>只由ASCII字符构成的文件为文本文件，其余皆为二进制文件</li>
<li>系统中所有信息都是由一串bits构成的。<br>区分它们的不同方式在于它们的上下文。</li>
</ul>
<h2 id="有关C语言"><a href="#有关C语言" class="headerlink" title="有关C语言"></a>有关C语言</h2><ol>
<li>C语言是贝尔实验室的研究员在1969-1973年间创建的。</li>
<li>ASCI标准在1989年由美国国家标准学会颁布。</li>
<li>C语言是为了开发UNIX而设计的，由是，它是系统级编程的首选。但它缺乏对一些抽象的显式实现（如异常，类，对象），因此在应用级编程方面弱于C++与JAVA等语言。</li>
</ol>
<h2 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello.c -预处理-&gt; hello.i -编译-&gt; hello.s -汇编-&gt; hello.o -链接-&gt; hello</span><br></pre></td></tr></table></figure>
<ul>
<li>执行这四个阶段的程序（预处理器，编译器，汇编器，连接器）共同构成了 <strong>编译系统</strong> 。<ul>
<li>预处理 ：对源程序中所有 <em>#</em> 打头的语句进行处理</li>
<li>编译 ： 将处理过的源程序翻译为汇编程序</li>
<li>汇编 ： 将汇编程序翻译为机器语言，并打包成为 <em>可重定位目标程序</em></li>
<li>链接 ： 将标准库函数所在的 <em>.o文件</em> 链接到hello.o并生成 <em>可执行目标文件</em></li>
</ul>
</li>
</ul>
<h3 id="有关GNU项目"><a href="#有关GNU项目" class="headerlink" title="有关GNU项目"></a>有关GNU项目</h3><ol>
<li>GNU（GNU‘s not UNIX）是一个免税慈善项目，它的目标是开发一个完整的开源系统。</li>
<li>GNU环境包括 <em>EMACS</em>,<em>GCC</em>,<em>GDB</em>,编器，链接器，处理二进制文件的一些工具以及其他部件<pre><code>（~~然而不包括内核，内核是LINUX独立发展的~~）
</code></pre></li>
<li>它是现代 <strong>开放源码运动</strong> 的思想起源。</li>
</ol>
<h2 id="计算机系统的硬件组成"><a href="#计算机系统的硬件组成" class="headerlink" title="计算机系统的硬件组成"></a>计算机系统的硬件组成</h2><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>总线是在系统的各个部件之间传递信息的渠道，通常被设计为传送定长的字节块。</p>
<ul>
<li>xx位系统的含义:<ul>
<li>xx代表的是这个系统的基本属性：<strong>字长</strong> ,即总线一次传送信息的最小单位。比如，64位系统代表字长是64个位，也就是8个字节。</li>
<li>字长不仅是总线传送信息的最小单位，还是内存中数据单元的一种单位。</li>
</ul>
</li>
</ul>
<h3 id="I-O-设备"><a href="#I-O-设备" class="headerlink" title="I/O 设备"></a>I/O 设备</h3><p>I/O设备通过适配器或控制器与I/O总线相连。</p>
<ul>
<li>控制器与适配器的区别<ul>
<li>控制器是设备本身或者系统主板上的芯片组;</li>
<li>适配器是插在主板插槽上的卡。</li>
</ul>
</li>
</ul>
<h3 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h3><p>主存由一组 <strong><em>动态随机存取存储器</em></strong> 芯片组成。</p>
<h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><p>中央处理单元，简称处理器，是解释执行储存在主存中指令的引擎。</p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>处理器的核心是一个大小为一个字的存储设备 - <strong>程序计数器</strong>，它保存主存中某条指令的地址。处理器读出主存中的指令，执行指令，再更新程序计数器使其指向下一个指令。</p>
<h4 id="算数逻辑单元"><a href="#算数逻辑单元" class="headerlink" title="算数逻辑单元"></a>算数逻辑单元</h4><p>算数逻辑单元（ALU）用于计算数据和地址值。</p>
<h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><p>系统将信息在磁盘，I/O，主存，处理器间来回移动的时间开销过大，一种解决方式是高速缓存。</p>
<p>高速缓存：作为暂时的集结区域，存放处理器近期可能需要的信息。</p>
<p>高速缓存的分级：</p>
<pre><code>* 一级高速缓存：访问速度与大小和寄存器相当
* 二级高速缓存：大小要大很多，但是速度也要慢一些
* ...以此类推
</code></pre><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="操作系统的基本功能："><a href="#操作系统的基本功能：" class="headerlink" title="操作系统的基本功能："></a>操作系统的基本功能：</h3><ol>
<li>防止硬件被失控的应用程序滥用</li>
<li>向应用程序提供简单一致的机制来控制复杂的硬件设备</li>
</ol>
<h4 id="有关Unix"><a href="#有关Unix" class="headerlink" title="有关Unix"></a>有关Unix</h4><p>20世纪60年代末，由于当时开发的Multics操作系统过于复杂，贝尔实验室的研究员用 <strong>机器语言</strong> 写了一个简单易用的操作系统，并在1970年将其命名为“UNIX”。</p>
<ul>
<li>1973年，UNIX内核被用C重新构建</li>
<li>1974年，UNIX正式对外发布</li>
<li>80年代中期，为了防止Unix厂商所加入的新特性导致的不兼容问题，IEEE研发了 <em>POSIX标准</em>。</li>
</ul>
<h3 id="操作系统提供的抽象表示"><a href="#操作系统提供的抽象表示" class="headerlink" title="操作系统提供的抽象表示"></a>操作系统提供的抽象表示</h3><h4 id="1-进程"><a href="#1-进程" class="headerlink" title="1.进程"></a>1.进程</h4><p><strong>进程</strong>是操作系统对一个正在运行的程序的一种抽象。</p>
<p>无论是在单核还是多核系统，操作系统看起来并发地执行多个进程，是通过在进程间切换实现的。<br>这种切换称为 <strong>上下文切换</strong> 。</p>
<ul>
<li>关于 <em>上下文切换</em> ：<ul>
<li>操作系统保持跟踪进程运行所需的所有状态信息。这种信息称为 <strong>上下文</strong> 。</li>
<li>上下文包括程序计数器（PC）和寄存器的当前值，以及主存的内容。</li>
<li>上下文切换就是保存当前进程的上下文并恢复新进程的上下文，然后递交控制权。</li>
</ul>
</li>
</ul>
<p>进程的切换是由操作系统的 <strong>内核</strong>（kernel） 管理的。</p>
<ol>
<li>在应用程序进行系统调用时，控制权移交给内核</li>
<li>内核执行被请求的操作并将控制权返还给应用程序。</li>
</ol>
<h4 id="2-线程"><a href="#2-线程" class="headerlink" title="2.线程"></a>2.线程</h4><p>每个 _进程_ 由许多个更小的执行单元 <strong>线程</strong> 组成，它们共享进程代码和全局数据。</p>
<ul>
<li>多线程的优势所在：<ol>
<li>多线程比多进程更容易共享数据</li>
<li>线程一般比进程更为高效（开销更小）        </li>
</ol>
</li>
</ul>
<h4 id="3-虚拟内存"><a href="#3-虚拟内存" class="headerlink" title="3.虚拟内存"></a>3.虚拟内存</h4><p>虚拟内存提供了一个假象：每个进程都在独立地使用主存。<br>对每个进程来说，它们所看到的主存是一样的，它们所看到的主存称为 <strong>虚拟地址空间</strong> 。</p>
<p>虚拟地址空间的结构：（<strong>地址由高到低</strong>）</p>
<table>
<thead>
<tr>
<th>内核所用的虚拟内存</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户栈（向下增长）</td>
</tr>
<tr>
<td>「预留区域」</td>
</tr>
<tr>
<td>动态链接库映射到内存中的区域（向上增长）</td>
</tr>
<tr>
<td>「预留区域」</td>
</tr>
<tr>
<td>malloc申请的堆内存（向上增长）</td>
</tr>
<tr>
<td>读/写数据</td>
</tr>
<tr>
<td>只读数据和代码</td>
</tr>
</tbody>
</table>
<h4 id="4-文件"><a href="#4-文件" class="headerlink" title="4.文件"></a>4.文件</h4><p><strong>文件</strong> 就是字节序列。在UNIX系统中万物皆文件，包括各种I/O设备。</p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>从一个单独的系统来看，网络可以视为一个I/O设备。</p>
<h1 id="Chapter-2-信息的表示与处理"><a href="#Chapter-2-信息的表示与处理" class="headerlink" title="Chapter 2 信息的表示与处理"></a>Chapter 2 信息的表示与处理</h1><p>数字革命的基础之一就是 <strong>二进制表示法</strong> 。当我们把位组合在一起，我们就可以表示任何一个有限集内的元素。</p>
<p>对于二进制表示数字来讲，三种表示最为重要:</p>
<ol>
<li>Unsigned code ：传统的二进制表示法，表示大于等于零的数字</li>
<li>two’s-complement code ：补码，可以表示有符号的整数</li>
<li>floating-point code ：浮点数编码，可以（近似地）表示所有实数</li>
</ol>
<p>由于编码的位数有限，当结果超出表示范围时就会发生 <strong>溢出</strong> 。</p>
<ul>
<li>对于整数来说，溢出并不影响运算的性质。<ul>
<li>举个例子：以不同的先后顺序计算200×300×400×500,溢出结果是一样的。</li>
</ul>
</li>
<li>但对于浮点数来讲，其数学性质截然不同。<ul>
<li>再举个例子：计算 （0.1+1e20）-1e20 得出的结果是0.0,但先计算1e20-1e20则会得出正确结果</li>
<li>这说明浮点数的表示只是近似的。</li>
</ul>
</li>
</ul>
<p>了解计算机上数字的运算对于提高程序的可移植性和减少漏洞都是有帮助的。</p>
<ul>
<li>C语言标准的发展<ol>
<li>在C语言被开发出来之后，各种标准化组织在为C语言标准化作出努力。1989年，ASCI C标准推出。</li>
<li>1990年，国际标准化组织从美国国家标准协会手中 <del>接锅</del>，开发了ISO C90标准，跟ASCI C的内容基本一致。</li>
<li>1999年，ISO C99标准发布，引入了一些新的数据类型。</li>
<li>在2011年的C11标准中，增加了更多的数据类型和特性。</li>
</ol>
</li>
</ul>
<h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><p>一般来讲，计算机 <strong>可寻址</strong> 的最小单位就是字节。<br>要进行位操作，需要一些其他特殊的手段。</p>
<h3 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h3><p>1 × 十六进制数 == 4 × 二进制数 == 4 × bits == 0.5 × byte</p>
<p>这个换算一定要搞清楚。（不同进制之间是次方关系而非乘法关系）</p>
<ul>
<li>熟练掌握二进制数和十六进制数之间的转换<ul>
<li>对于十六进制对应的四个二进制位来说，一个十六进制数就是1,2,4,8的有机组合。</li>
<li>对于位串来说，每四个二进制数组成一个十六进制数。</li>
</ul>
</li>
</ul>
<h3 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a><strong>字数据大小</strong></h3><p>之前讲到过 <strong>虚拟地址空间</strong> ，每个程序运行时都会从主存分配一个地址从零开始的虚拟地址空间，这个空间（一般来说）就是它们能够使用的最大主存。</p>
<p>之前还讲到过 <strong>字长</strong> ，它的含义是 <strong>ALU</strong>（CPU中的算数逻辑单元） 一次运算能够处理的最大位数，所以也是总线一次能够传递的最大位数。</p>
<p>那么由于操作系统一般是用指针去进行虚拟地址空间中的寻址的， <strong>一个指针的最大大小</strong> 也就决定了 <strong>虚拟地址空间的最大大小</strong> 。而指针身为数据类型的一种，它的大小是受ALU算力的限制的。</p>
<p>也就是说， <strong>计算机字长</strong> 决定 <strong>指针数据的标称大小</strong> ，从而决定 <strong>虚拟地址空间的最大大小</strong> 。由于每一个指针值都对应着虚拟地址空间中的一个字节，一个 <strong>w位</strong> 的机器的虚拟地址空间最大为 <strong>2^w-1</strong> 。</p>
<ul>
<li>为避免程序在不同位系统间切换时数据类型默认大小不同带来的问题，C99标准加入了固定大小的数据类型，比如 <code>int32_t</code> 和 <code>int64_t</code> 。</li>
</ul>
<h3 id="寻址和字节序"><a href="#寻址和字节序" class="headerlink" title="寻址和字节序"></a>寻址和字节序</h3><p><strong>大端序</strong> 和 <strong>小端序</strong> ：最低有效字节（一个数中最右边的）在前为小端序，反之为大端序。</p>
<ul>
<li>大部分Intel兼容机都采用小端序。</li>
<li>这两个名词起源于 <em>格列佛游记</em> 中小人国的大端派和小端派。</li>
</ul>
<p>在一些特定的情景（如网络数据传输，字节级操作）中，大小端序的区别可能会导致错误，需要注意。</p>
<h3 id="表示字符串"><a href="#表示字符串" class="headerlink" title="表示字符串"></a>表示字符串</h3><ul>
<li><p>由于char型变量使用的是单字节，文本型数据在跨平台方面要强于二进制数据 ：它不受字大小和字节序区别的干扰。</p>
</li>
<li><p>字符编码缘起（参考知乎<a href="https://www.zhihu.com/question/23374078" target="_blank" rel="noopener">于洋的回答</a>）：</p>
<ul>
<li>最开始的 <strong>ASCII编码</strong> 标准涵盖了 <strong>控制码</strong>（0x00-0x20） 与用于显示的字符，共128个，每个字节对应一个ASCII码。</li>
<li><p>由于一个字节最多可以表示256种状态，人们添加了 <strong>扩展字符集</strong> ，用来表示一些特殊字符（如某些非英文国家的字母，数学和制表符号等）</p>
</li>
<li><p>由于中文汉字过多，中国采用了两个字节对应一个字符的编码方式-GB2312，一个字节的值不大于127则仍是ASCII码（称为 <strong>半角字符</strong> ），大于127则与后一个字节共同表示一个字符（称为 <strong>全角字符</strong> ）。</p>
</li>
<li><p>后来该协议又有扩展，不再要求后一个字节的值大于127,此次更新的方案称为 <strong>GBK标准</strong>。</p>
</li>
<li><p>再之后ISO出手了，制定了 <strong>UNICODE标准</strong> ，规定用所有字符都用两个字节表示。</p>
</li>
<li>为了网络数据传输的方便，一系列 <strong>UTF编码规则</strong> 被制定出来（UTF-8代表一次传输一个字节）。UTF标准规定可以用1～4个字节来表示一个字符</li>
</ul>
</li>
</ul>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>C标准并没有规定在位右移时是采用 <strong>算术右移</strong> （也就是高位补有效位）还是 <strong>逻辑右移</strong> （也就是高位一律补0），所以导致了一系列可移植性问题（不过一般来说，编译器一律采用算术右移）；但是java用&gt;&gt;和&gt;&gt;&gt;的区别很好地区分了两种移位的判定。</p>
<h2 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h2><p>无非就是两种主要表示形式：signed和unsigned，signed又一般用补码表示。</p>
<h3 id="补码的计算原理"><a href="#补码的计算原理" class="headerlink" title="补码的计算原理"></a>补码的计算原理</h3><p>补码的最左边一位是负权位，如果该整数占w位，那么它的值是-2^(w-1)。补码的计算就是非补码位表示的正值加上补码位负权表示的负值。</p>
<h3 id="补码的符号扩展"><a href="#补码的符号扩展" class="headerlink" title="补码的符号扩展"></a>补码的符号扩展</h3><p>为了保持补码表示的数值不变，补码在扩展时在左边补’1’，原码则是补’0’。因此，一个补码在左边加任意x个1,正如十进制数左边加零一样，其值不变。</p>
<h3 id="补码的截断"><a href="#补码的截断" class="headerlink" title="补码的截断"></a>补码的截断</h3><p>和原码一样，都是去高位留低位，然后根据低位表示的值求出截断后的值。</p>
<h3 id="非补码的数据表示"><a href="#非补码的数据表示" class="headerlink" title="非补码的数据表示"></a>非补码的数据表示</h3><p>在系统级编程和网络编程当中，经常会需要用一个变量代表一串没有数学意义的位。这种时候，补码特殊的负权位会带来一些不必要的麻烦，于是我们可以使用unsigned值来代替。</p>
<p>这里介绍signed和unsigned间隐式类型转换可能带来的漏洞：</p>
<ul>
<li>现在有一个读出缓冲区中信息的函数，这个缓冲区中有些信息是隐私信息，不允许阅读。</li>
<li>为防止这个函数被用来读出不该读的东西，该函数被设置为从可读信息的开始处开始阅读，阅读长度为一个int参数，函数会实现判定其大小是否超出了可读范围。</li>
<li>然而，这个函数调用的用来复制缓冲区中一段信息的系统函数中长度参数的类型为size_t(它被定义为unsigned int)</li>
<li>那么如果有人心怀不轨，将-1作为参数传入，作为int它能通过函数的检验，但在这个函数调用系统函数来复制缓冲区中的信息时，-1就会被隐式类型转换换为unsigned int类型，由于-1的二进制位最左边为1,此时它的值就会变成一个特别大的整数。</li>
<li>这样，这个人就成功读到了本来不应该被他读到的信息。</li>
</ul>
<h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><p>整数运算所产生的大部分漏洞都是溢出所导致的。<br>因此，要格外注意可能引发溢出的情形。</p>
<h3 id="unsigned-int的运算"><a href="#unsigned-int的运算" class="headerlink" title="unsigned int的运算"></a>unsigned int的运算</h3><ul>
<li>无符号数加法的溢出<ul>
<li>溢出的处理规则：舍弃最高位</li>
<li>溢出的判定方法：如果加法得数小于两个加数中的任意一个，则该结果是溢出的。</li>
<li>溢出的应用：阿贝尔群<ul>
<li>概念：任取一个无符号数a，必定存在另一个无符号数b使a+b的结果为0。</li>
<li>原理：a+b的值正好为2^w</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="补码的运算"><a href="#补码的运算" class="headerlink" title="补码的运算"></a>补码的运算</h3><ul>
<li>补码加法的溢出<ul>
<li>如果是正溢出，得数为 <strong><em>原得数 - 2^w</em></strong> 。</li>
<li>如果是负溢出，得数为 <strong><em>原得数 - 2^w</em></strong> 。</li>
<li>溢出的判定方法：如果两个负数相加得到了正数，则发生了负溢出；反之，则为正溢出。</li>
</ul>
</li>
</ul>
<ul>
<li>补码的非<ul>
<li>注意：非和补不是一个东西，非是-，补是～</li>
<li>补码取非就是简单的求反加一</li>
<li>还有一种方法就是找到二进制表示中 <em>从右到左第一个值为‘1’的位</em> ，然后对 <em>这一位左边的所有位</em> 取反。</li>
</ul>
</li>
</ul>
<ul>
<li>补码的乘法<ul>
<li>先直接计算乘积，将其截断后由无符号数转换为补码形式。</li>
<li><strong>这里比较难，之后可以翻回来看一下</strong></li>
</ul>
</li>
</ul>
<h3 id="对于整数乘法的优化"><a href="#对于整数乘法的优化" class="headerlink" title="对于整数乘法的优化"></a>对于整数乘法的优化</h3><p>一般的整数运算（如加减，移位）只需要一个时钟周期，但整数乘法比它们慢的多，需要数个时钟周期来完成。为了提高计算效率，编译器采用了一项重要的优化：用 <strong>移位和加法运算的组合</strong> 来代替。</p>
<ol>
<li>易得， <em>对一个数乘以2的n次方</em> 相当于 <em>将这个数进行n位左移</em> （这两种方式在溢出时得到的结果也是等价的）。</li>
<li>而任意一个整数都可以由 <em>数个2的k次方的和</em> 表示。</li>
<li>于是，由乘法分配律，一个数乘一个常数因子就等价于将若干个它的左移结果相加。</li>
<li>更好的是，有时可以用减法进一步减小计算量。</li>
</ol>
<h3 id="对于整数除法的优化"><a href="#对于整数除法的优化" class="headerlink" title="对于整数除法的优化"></a>对于整数除法的优化</h3><p>在大多数机器上，整数除法比乘法还要慢，大概需要30多个时钟周期。<br>因此，采用与乘法的优化相似的思路来进行优化。</p>
<p>但与乘法不同的是， <strong>移位优化</strong> 只能适用于 $x|(2^k)$ 的情形。(<code>|</code>是离散数学中的符号，意思是能够整除)</p>
<h4 id="整数除法的舍入问题"><a href="#整数除法的舍入问题" class="headerlink" title="整数除法的舍入问题"></a>整数除法的舍入问题</h4><p>我们知道，整数的除法结果应该是 <strong>向零取整</strong> 的（无论正数还是负数），然而直接采用移位法进行除法运算会导致 <strong>向下取整</strong> 的舍入结果。这个问题需要得到解决。</p>
<p>为了解决这个问题，需要引入 <strong>偏置数</strong> 作为修正。</p>
<ul>
<li>对于正数的除法，直接移位即可</li>
<li>对于负数的除法，先进行偏置，再移位。</li>
</ul>
<p>偏置的方式：<strong>将原来的数加上</strong> $(1&lt;&lt;k)-1$ <strong>后再移位，k是将要移动的位数。</strong></p>
<ul>
<li>解析：以除以16来说明。<ul>
<li>当除以16时，应该右移4位，因此k=4</li>
<li>$(1&lt;&lt;k)-1$ = 0b1111</li>
<li>如果将要右移的四位全为0,说明可以整除，则加上0b1111后不进位，移位后结果不变</li>
<li>如果将要右移的四位不全为0,说明有小数部分，则一旦加上0b1111一定会进位，于是结果比向下取整大1,也就实现了向零取整的效果。</li>
</ul>
</li>
</ul>
<p>因此，采用如下表达式来计算 $\frac x {(2^k)}$ :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( x &lt; <span class="number">0</span> ? x + (<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span> : x) &gt;&gt; k</span><br></pre></td></tr></table></figure>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>现在被普遍采用的一种浮点数表示方式为 <strong>IEEE浮点格式</strong> 。<br>它在1985年前后由IEEE（电气和电子工程师协会）推出。</p>
<h3 id="IEEE小数的结构"><a href="#IEEE小数的结构" class="headerlink" title="IEEE小数的结构"></a>IEEE小数的结构</h3><p>IEEE标准表示的小数由以下几部分组成：</p>
<ol>
<li>符号：用一个二进制位来表示小数的正负</li>
<li>尾数：用小数字段frac编码一个范围为 <em>1~2-epsilon</em> 的二进制小数</li>
<li>阶码：用阶码字段exp对这个浮点数加权，权重为2的E次幂</li>
</ol>
<p>对于单精度浮点数而言，exp占8位，frac占23位；对于双精度浮点数而言，exp占11位，frac占52位</p>
<h4 id="三类浮点数"><a href="#三类浮点数" class="headerlink" title="三类浮点数"></a>三类浮点数</h4><p>根据exp的值的情况可以将浮点数分为三类（以float为例）：</p>
<h5 id="当exp不为0且不为255时"><a href="#当exp不为0且不为255时" class="headerlink" title="当exp不为0且不为255时"></a>当exp不为0且不为255时</h5><p>这是最普遍的情况。</p>
<p>在这种情况下，阶码字段是以偏置形式表示的无符号数。其偏置值为 <strong>2^(k-1)-1</strong> ，从而将 <strong><em>1～2^k-2</em></strong> 的无符号正数映射到了 <strong><em>-2^(k-1)+2</em></strong> ~ <strong><em>2^(k-1)-1</em></strong> (对于单精度浮点数而言，这个映射区间就是 -126～127 )。</p>
<p>而小数字段frac表示小数点后的位，也就是说小数点（等价地）位于整个小数字段的左边，小数点的左边则 <strong>默认为1</strong> 。这样，frac表示的就是一个大小为1.xxxxxx……的小数。</p>
<h5 id="当exp为0时"><a href="#当exp为0时" class="headerlink" title="当exp为0时"></a>当exp为0时</h5><p>这种数称为 <strong>非规格化形式</strong> 的数。</p>
<p>此时阶码字段的值为 <strong>1-偏置值</strong> ，而小数字段小数点左边改为 <strong>默认为0</strong> 。</p>
<ul>
<li>非规格化数的用途：<ol>
<li>表示+0.0与-0.0</li>
<li>表示极为接近0.0的值</li>
</ol>
</li>
</ul>
<h5 id="当exp-255-也就是阶码字段全为1时："><a href="#当exp-255-也就是阶码字段全为1时：" class="headerlink" title="当exp=255,也就是阶码字段全为1时："></a>当exp=255,也就是阶码字段全为1时：</h5><p>此时该浮点数表示的是一个特殊值。</p>
<ol>
<li>frac字段全为0时：表示无穷，无穷的符号由符号位决定。</li>
<li>frac字段不为0时：表示 <strong>NaN</strong>(Not a Number)<ul>
<li>当运算结果既不是实数又不是无穷时使用NaN来代替。（如：sqrt(-1)，∞-∞等）</li>
<li>有些时候用以表示未初始化的数据</li>
</ul>
</li>
</ol>
<ul>
<li><p>这种设计的优点</p>
<p>  经过精心设计，这种表示方法使得浮点数在增大时其位级表示的变化规律和整数增大时是一样的。<br>  这对于排序工作的优化起到了相当大的作用，因为比较的时候不需要进行浮点运算。</p>
</li>
</ul>
<h3 id="浮点数的运算"><a href="#浮点数的运算" class="headerlink" title="浮点数的运算"></a>浮点数的运算</h3><h4 id="浮点数的舍入运算"><a href="#浮点数的舍入运算" class="headerlink" title="浮点数的舍入运算"></a>浮点数的舍入运算</h4><p>IEEE标准定义了四种不同的舍入方式。</p>
<ol>
<li>向偶数舍入（也就是向最近的数舍入）<ul>
<li>这是最通用的方法，也就是人们常说的“四舍五入”。</li>
<li>对二进制数来讲，一个数的奇偶由最右边的二进制位决定，我们倾向于在舍入后让最低位为0。</li>
</ul>
</li>
<li>向零舍入</li>
<li>向上舍入</li>
<li>向下舍入</li>
</ol>
<h4 id="浮点数的算术运算"><a href="#浮点数的算术运算" class="headerlink" title="浮点数的算术运算"></a>浮点数的算术运算</h4><p>与整数的运算相似，浮点数算术运算也构成了 <strong>阿贝尔群</strong> 。但要特别注意的是，就像之前所说的， <strong>浮点数运算不满足结合律和分配律</strong> ，这是舍入所造成的。</p>
<p>缺少这两个运算基本属性让浮点运算给编程者们带来了很多麻烦，它使得很多判定变得十分麻烦。</p>
<p>然而，由于浮点数特殊的溢出判定，它具有补码运算和无符号数运算不具有的 <strong>单调性</strong> 。</p>
<h3 id="浮点数与其他数据类型的转换"><a href="#浮点数与其他数据类型的转换" class="headerlink" title="浮点数与其他数据类型的转换"></a>浮点数与其他数据类型的转换</h3><ol>
<li>int -&gt; float：不会溢出，但是可能会被舍入</li>
<li>int/float -&gt; double：可以完整保留精确数值</li>
<li>double -&gt; float：可能溢出也可能会舍入</li>
<li>float/double -&gt; int：不出意外值会向零舍入，但有可能发生 <strong>浮点溢出</strong> ，产生 <strong>整数不确定值</strong> （对于Intel兼容机，它被定义为0b10000……0）</li>
</ol>
<h1 id="Chapter-3-程序的机器级表示"><a href="#Chapter-3-程序的机器级表示" class="headerlink" title="Chapter 3 程序的机器级表示"></a>Chapter 3 程序的机器级表示</h1><p>在高级语言如此发达和完善的今天，为什么还要学习汇编语言?</p>
<ol>
<li>通过阅读汇编代码，我们能够理解编译器优化代码的原理，从而找出代码中隐含的低效率。</li>
<li>有些时候，高级语言的抽象层会隐藏我们想要了解的程序运行时行为。</li>
<li>了解漏洞的产生与防御恶意攻击需要了解机器级代码表示。</li>
</ol>
<p><strong>x86-64</strong>：Intel兼容机使用的机器语言</p>
<h2 id="x86-64缘起"><a href="#x86-64缘起" class="headerlink" title="x86-64缘起"></a>x86-64缘起</h2><p>Intel系列处理器俗称x86，经历了一个漫长的发展过程。<br>其中，后面的处理器可以兼容前面的机器程序。</p>
<ul>
<li><strong>8086</strong>（1978）：它是第一代单芯片16位处理器之一，它的变种8088是第一代IBM兼容机的心脏</li>
<li><strong>8087</strong>（1980）：浮点协处理器，与8086或8088一同工作，进行浮点运算</li>
<li><strong>80286</strong>（1982）：增加了更多寻址模式，是MS Windows最初的使用平台</li>
<li><strong>i386</strong>（1985）：体系结构升级到32位，这是Intel第一台全面支持Unix操作系统的处理器。它所增加的 <strong>平坦寻址模式</strong> 至今仍被大部分Linux和Windows机型使用。</li>
<li><strong>i486</strong>（1989）：将浮点单元集成到了处理器芯片</li>
<li><strong>Pentium系列</strong>（1993-2004）：不断扩展指令集，引入了SSE：增加了新的处理整数和浮点数向量的指令，增加了新的数据类型。在04年的Pentium 4E实现了超线程。增加了EM64T，它是对AMD提出的 <strong>IA32</strong> 的64位扩展的实现，被人们称为x86-64.</li>
<li><strong>Core 2</strong>（2006）：Intel第一个 <strong>多核微处理器</strong> ，但是不支持超线程。</li>
<li><strong>Core i7</strong>（2008）：同时支持多核处理和超线程，引入了SSE的扩展AVX，增加了更多的指令和指令格式。</li>
</ul>
<h2 id="研究汇编程序编码"><a href="#研究汇编程序编码" class="headerlink" title="研究汇编程序编码"></a>研究汇编程序编码</h2><ul>
<li><p>对于机器级编程来讲尤为重要的两种抽象</p>
<ul>
<li><strong>指令集架构</strong>（ISA）<ul>
<li>它定义了处理器状态，指令的格式，以及每条指令对状态的影响</li>
<li>大多数ISA（包括x86-64）将指令的执行抽象为顺序执行，但其硬件实现其实是并发的，只不过有措施保证其执行顺序与ISA规制的相同。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>+ __虚拟地址空间__
    * 存储器系统的实际实现是将多个存储器和操作系统结合起来。
</code></pre><p>汇编代码的表示很接近于机器语言，但是它使用了文本这种更适合人类阅读的表示方法。</p>
<p>x86的代码和原始C代码差别很大，一些在C语言中不显示的硬件状态都会体现出来：</p>
<ul>
<li>程序计数器：用 <strong>%rip</strong> 表示，给出内存中要执行的下一条指令的地址。</li>
<li>整数寄存器：包含16个位置，分别储存64位的值。<ul>
<li>记录重要的程序状态</li>
<li>保存临时数据，如过程参数，局部变量，函数返回值</li>
</ul>
</li>
<li>条件寄存器：用来实现控制或数据流中的条件变化</li>
</ul>
<h3 id="需要用到的调试工具"><a href="#需要用到的调试工具" class="headerlink" title="需要用到的调试工具"></a>需要用到的调试工具</h3><ol>
<li>GCC编译器<ul>
<li>gcc：执行GCC的bash命令</li>
<li><strong>-Og</strong>：指定优化方式，以防过于高级的优化使源代码和汇编代码差距过大不便于研究。</li>
<li><strong>-S</strong>：只进行预处理和编译过程，生成汇编代码 <strong>.s文件</strong> 。</li>
<li><strong>-c</strong>：只进行预处理，编译，汇编过程，生成二进制文件 <strong>.o文件</strong> 。</li>
<li><strong>-masm = &lt; format &gt;</strong>：指定生成汇编代码的格式。</li>
</ul>
</li>
<li>GDB调试器</li>
<li>objdump -d &lt; file name &gt;：反汇编器，根据机器代码生成对应的汇编代码</li>
</ol>
<h3 id="x86-64机器代码的特性"><a href="#x86-64机器代码的特性" class="headerlink" title="x86-64机器代码的特性"></a>x86-64机器代码的特性</h3><ol>
<li>x86-64的指令长度为1-15个字节不等。其中，常用或操作数少的指令占字节数较少，反之较多。</li>
<li>从某个给定位置开始，可以唯一地将字节解码成为机器指令。</li>
</ol>
<h3 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h3><p>以内容如下的 test.c 文件为例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mult2</span><span class="params">(<span class="keyword">long</span>,<span class="keyword">long</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multstore</span><span class="params">(<span class="keyword">long</span> x,<span class="keyword">long</span> y,<span class="keyword">long</span>* dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> t=mult2(x,y);</span><br><span class="line">    *dest=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将其编译之后产生的 test.s 文件内容如下所示：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.file</span>   <span class="string">"test.c"</span></span><br><span class="line"><span class="meta">        .text</span></span><br><span class="line"><span class="meta">        .globl</span>  multstore</span><br><span class="line"><span class="meta">        .type</span>   multstore, @function</span><br><span class="line"><span class="symbol">multstore:</span></span><br><span class="line"><span class="symbol">.LFB0:</span></span><br><span class="line"><span class="meta">        .cfi_startproc</span></span><br><span class="line">        pushq   %rbx</span><br><span class="line"><span class="meta">        .cfi_def_cfa_offset</span> <span class="number">16</span></span><br><span class="line"><span class="meta">        .cfi_offset</span> <span class="number">3</span>, -<span class="number">16</span></span><br><span class="line">        <span class="keyword">movq</span>    %rdx, %rbx</span><br><span class="line">        <span class="keyword">call</span>    mult2@PLT</span><br><span class="line">        <span class="keyword">movq</span>    %rax, (%rbx)</span><br><span class="line">        popq    %rbx</span><br><span class="line"><span class="meta">        .cfi_def_cfa_offset</span> <span class="number">8</span></span><br><span class="line">        <span class="keyword">ret</span></span><br><span class="line"><span class="meta">        .cfi_endproc</span></span><br><span class="line"><span class="symbol">.LFE0:</span></span><br><span class="line"><span class="meta">        .size</span>   multstore, .-multstore</span><br><span class="line"><span class="meta">        .ident</span>  <span class="string">"GCC: (GNU) 8.1.0"</span></span><br><span class="line"><span class="meta">        .section</span>        .note.GNU-stack,<span class="string">""</span>,@progbits</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>所有以 <strong>‘.’</strong> 开头的行都是指导 <strong>汇编器</strong> 和 <strong>链接器</strong> 工作的伪指令</p>
</li>
<li><p>具体语句的作用：</p>
<ul>
<li>pushq %rbx：将rbx寄存器中保存的值压入程序栈</li>
<li>movq %rdx，%rbx：将rdx中的值(dest指针)传递给rbx</li>
<li>call：调用函数，函数的返回值保存在寄存器rax中</li>
<li>movq %rax，（%rbx）：将返回值赋给dest指针</li>
<li>popq %rbx：恢复rbx寄存器中原有的值</li>
<li>ret：该函数返回</li>
</ul>
</li>
</ul>
<h4 id="两种不同的汇编代码格式"><a href="#两种不同的汇编代码格式" class="headerlink" title="两种不同的汇编代码格式"></a>两种不同的汇编代码格式</h4><ul>
<li><strong>ATT格式</strong>：这是根据 <strong>AT&amp;T公司</strong> 命名的汇编格式，是GCC，OBJDUMP等工具的默认格式</li>
<li><strong>Intel格式</strong>：Intel文档和Microsoft的工具使用的都是Intel格式。</li>
</ul>
<p>两种格式的主要区别有：</p>
<ol>
<li>Intel格式省略了操作指令后指定大小的”q”字符与寄存器名前面的”%”。</li>
<li>Intel用不同的方式来描述内存中的位置。</li>
<li>两者列出操作数的顺序相反。</li>
</ol>
<h4 id="在C程序中插入汇编代码"><a href="#在C程序中插入汇编代码" class="headerlink" title="在C程序中插入汇编代码"></a>在C程序中插入汇编代码</h4><p>C语言缺乏一些特定API或操作符来访问一些机器特性。</p>
<p>比如：在x86-64处理器每一次执行算术或逻辑运算时，都会设置一个表示奇偶的称为 <strong>PF</strong> 的1位条件码的值，从而储存这个结果的奇偶性信息。而C语言要想得到这个信息需要至少7次移位、掩码和逻辑运算。</p>
<p>在C程序中插入汇编代码有两种方式:</p>
<ul>
<li>将一个完整的函数单独编写到一个汇编文件中，再用GCC将它和另一个C代码生成的.s文件合并</li>
<li>利用GCC的内联汇编（asm指令）在C代码中插入少量汇编代码。</li>
</ul>
<h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>由于是从16位系统扩展成32位的，Intel将16位数据类型称为“字”。<br>因此，32位数据类型就称为“双字”，64位就是“四字”。</p>
<p>x86-64对于基础数据类型的大小如下定义（括号内为汇编代码中的后缀）：</p>
<ul>
<li><p>普通类型（后缀仅表示操作数大小）：</p>
<ul>
<li>char（b）：1字节</li>
<li>short（w）：2字节</li>
<li>int（l）：4字节</li>
<li>long（q）：8字节</li>
<li>pointer（q）：8字节</li>
</ul>
</li>
<li><p>浮点类型：</p>
<ul>
<li>float（s）：4字节</li>
<li>double（l）：8字节</li>
</ul>
</li>
</ul>
<p>两种类型使用的指令和寄存器完全不同，所以后缀相同也无妨。</p>
<h2 id="访问信息操作"><a href="#访问信息操作" class="headerlink" title="访问信息操作"></a>访问信息操作</h2><p>一个x86-64的CPU包含一组（16个）储存64位值的 <strong>通用目的寄存器</strong> 。<br>每个寄存器都有特殊的用途，它们的名字便反映出这些不同的用途。</p>
<ul>
<li><p>16个寄存器的用途（从左到右分别是8字节，4字节，2字节，1字节对应的寄存器名）</p>
<ul>
<li>%rax %eax %ax %al Accumulator，常用于置放返回值</li>
<li>%rbx %ebx %bx %bl Base，常用于存放地址</li>
<li>%rcx %ecx %cx %cl Count，常用于计数</li>
<li>%rdx %edx %dx %dl Data，常用于存放数据</li>
<li>%rsi %esi %si %sil 源变址寄存器</li>
<li>%rdi %edi %di %dil 目的变址寄存器</li>
<li>%rbp %ebp %bp %bpl 栈帧头指针</li>
<li>%rsp %esp %sp %spl 栈指针</li>
<li>%r8,%r9 %r8d,%r9d %r8w,%r9w %r8b,%r9b 扩展寄存器</li>
<li>%r10，%r11 同理 同理 同理 扩展寄存器</li>
<li>%r12～%r15 同理 同理 同理 扩展寄存器</li>
</ul>
</li>
<li><p>当寄存器中被存入新的变量时的约定：</p>
<ul>
<li>若存入的是1,2字节的值，则不改变寄存器中剩余字节</li>
<li>若存入的是4字节的值，则将剩余字节置为0</li>
</ul>
</li>
</ul>
<h3 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h3><p><strong>操作数</strong>指示出指令需要的原数据值，以及放置结果的位置。</p>
<ul>
<li>操作数可以被分为三种类型：<ul>
<li><strong>立即数</strong>（immediate）：通过 <strong>$Imm</strong> 的格式表示常数，Imm为任意C-style数</li>
<li><strong>寄存器</strong>（register）：直接用寄存器名将寄存器中的部分位作为操作数</li>
<li><strong>内存引用</strong> ：根据计算出的地址访问内存中的某个位置，格式为 <strong>[Imm]（[rb]，[ri]，[s]）</strong><ul>
<li>Imm：立即数表示的偏移量，缺省表示不偏移</li>
<li>rb：基址寄存器，缺省则无基址</li>
<li>ri：变址寄存器，缺省表示无变址寻址</li>
<li>s：比例因子，必须为1,2,4或8，缺省默认为1</li>
<li><strong>计算规则</strong>：最终的内存地址为 <strong>rb + s*ri + Imm</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p><strong><em>MOV S,D</em></strong></p>
<ul>
<li><p>效果：将S中的储存值移动到D</p>
<ul>
<li>S（源操作数）：指定一个寄存器或者内存地址中的立即数</li>
<li>D（目的操作数）：指定一个寄存器或内存地址</li>
<li>注：<strong>x86-64规定两者不能同时为内存地址</strong></li>
</ul>
</li>
<li><p>可能的操作数组合：</p>
<ul>
<li>movl $0x4050,%eax — 立即数-&gt;寄存器 移动4个字节</li>
<li>movw %bp，%sp — 寄存器-&gt;寄存器 移动2个字节</li>
<li>movb （%rdi，%rcx），%al — 内存-&gt;寄存器 移动1个字节</li>
<li>movb %-17,（%rsp） — 立即数-&gt;内存 移动1个字节</li>
<li>movq %rax，-12（%rbp） — 寄存器-&gt;内存 移动8个字节</li>
</ul>
</li>
<li><p>特殊指令：movabsq</p>
<ul>
<li>常规的movq指令只能以 <strong>32位补码</strong> 形式作为源操作数，然后将其扩展成为64位的值放入目的位置</li>
<li>而movabsq指令能以任意的 <strong>64位立即数值</strong> 作为源操作数，但 <strong>只能以寄存器作为目的位置</strong></li>
</ul>
</li>
<li><p>其他的数据传送指令</p>
<ul>
<li><strong>MOVZ</strong>：有两个后缀，分别指定源大小和目的大小。缺少的位用0填充。<ul>
<li>movzlq指令并不存在，因为它完全可以被更简单的movl所取代。（想想4字节的填充特性）</li>
</ul>
</li>
<li><strong>MOVS</strong>：和上面相似，但缺少的位用源操作数的最高位填充。<ul>
<li>cltq指令：将%eax中的值符号扩展到%rax中，没有操作数。</li>
</ul>
</li>
</ul>
</li>
<li><p>一些常见的错误</p>
<ul>
<li>movb %0xF,(%ebx)<ul>
<li>Since address in 64-bits os should be 8-bytes, use %ebx(a 4-bytes register)’s value to index is dangerous and should not be allowed.</li>
</ul>
</li>
<li>movl %rax,(%rsp) <ul>
<li>movl 必须以四字节大小的寄存器号作为其源操作数。</li>
</ul>
</li>
<li>movl %eax,%rdx<ul>
<li>movl 必须以四字节大小的寄存器号作为其目的操作数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="入栈出栈指令"><a href="#入栈出栈指令" class="headerlink" title="入栈出栈指令"></a>入栈出栈指令</h3><p><strong>PUSH &lt; register &gt;</strong>: 将一个寄存器中的值压入程序栈。</p>
<p><strong>POP &lt; register &gt;</strong>: 弹出程序栈顶元素并移入指定寄存器。</p>
<p>出入栈指令的实现（以四字后缀为例）:</p>
<ul>
<li>pushq:<ul>
<li>subq $8,%rsp<ul>
<li>含义：<strong>%rsp</strong>(程序栈指针寄存器)<strong>的值减小8</strong>(因为程序栈从上往下增长)。</li>
</ul>
</li>
<li>movq &lt; register &gt;,(%rsp)</li>
</ul>
</li>
<li>popq:<ul>
<li>movq (%rsp),&lt; register &gt;</li>
<li>addq $8,%rsp<ul>
<li><strong>%rsp的值增大8</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>对于用户程序来说，栈内元素的地址是透明的，也就是说可以直接以 <strong>%rsp</strong> 为基准指针去访问栈内的第n个元素。</p>
<h2 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h2><h3 id="加载有效地址"><a href="#加载有效地址" class="headerlink" title="加载有效地址"></a>加载有效地址</h3><p><strong>LEA</strong>(load effective address)指令：将一个有效地址记录到一个寄存器中。</p>
<ul>
<li>使用方法：<ul>
<li>基本用法(以四字为例)：<strong>leaq &lt; effective address &gt; &lt; target register &gt;</strong></li>
<li>可以用于简单的算术操作：利用内存地址的计算法则来实现简单计算。如：<ul>
<li>寄存器%rdx的值为x</li>
<li>命令 leaq 7(%rdx,%rdx,4), %rax 即是计算5x+7.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="一元算术运算"><a href="#一元算术运算" class="headerlink" title="一元算术运算"></a>一元算术运算</h3><ul>
<li>INC 自增</li>
<li>DEC 自减</li>
<li>NEG 取负</li>
<li>NOT 取补</li>
</ul>
<p>一元算术运算的操作数可以是 <strong>寄存器</strong> 或 <strong>内存位置</strong> 。运算符后缀决定了进行该运算的位数。如：incq就是四字自增，notb就是低字节取补。</p>
<h3 id="二元算术运算"><a href="#二元算术运算" class="headerlink" title="二元算术运算"></a>二元算术运算</h3><ul>
<li>ADD 加</li>
<li>SUB 减</li>
<li>IMUL 乘</li>
<li>XOR 异或</li>
<li>OR 或</li>
<li>AND 与</li>
</ul>
<p>二元算术运算相当于是C语言中的 <strong>～=运算</strong> (～代表一个运算符)。如：SUB S,D 相当于 D-=S</p>
<p>这些运算的第一个操作数可以是 <strong>立即数、寄存器或内存位置</strong>，而第二个操作数只能是 <strong>寄存器或内存位置</strong></p>
<h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><ul>
<li>SAL，SHL 左移</li>
<li>SAR 算术右移</li>
<li><p>SHR 逻辑右移</p>
</li>
<li><p><strong>注意</strong></p>
<ul>
<li>移位运算在运算符后先后给出两个操作数，分别代表移位量和要移位的数</li>
<li>移位量可以是一个 <strong>立即数</strong> ，也可以是 <strong>单字节寄存器%cl</strong> 的值</li>
<li>运算符后缀决定的是取%cl的后几位作为移位量。</li>
</ul>
</li>
</ul>
<h3 id="特殊算术操作"><a href="#特殊算术操作" class="headerlink" title="特殊算术操作"></a>特殊算术操作</h3><ul>
<li><p>imulq指令和mulq指令</p>
<ul>
<li><p>imulq指令有两种含义。</p>
<ul>
<li>作二元操作符：将两个64位操作数相乘得到一个 <strong>64位</strong> 的值，并寄存在后一个操作数的位置。</li>
<li>作一元操作符：将操作数与%rax储存的值相乘得到一个 <strong>128位</strong> 的值，并储存在%rdx(高64位)和%rax(低64位)中。</li>
<li><strong>这两种含义中乘法均为补码乘法</strong>。</li>
</ul>
</li>
<li><p>mulq指令和imulq的第二种含义相似，只不过它做的是无符号乘法。</p>
</li>
</ul>
</li>
<li><p>idivq和divq指令</p>
<ul>
<li>这两种指令与上面的两种用法类似，只不过是除法加取模运算。</li>
<li>idivq指令将%rdx(高64位)和%rax(低64位)表示的128位有符号数作为被除数，而操作数作为除数，得到的 <strong>整数商</strong> 储存在%rax中，<strong>余数</strong>储存在%rdx中。</li>
<li>由于一般来说被除数是64位的，所以可以 <strong>将被除数放在%rax中</strong> ，再使用 <strong>cqto</strong> 指令将符号位扩展。<ul>
<li>cqto指令没有操作数，它自动读出%rax的符号位并将符号位扩展覆盖到%rdx。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="控制操作"><a href="#控制操作" class="headerlink" title="控制操作"></a>控制操作</h2><h3 id="条件操作"><a href="#条件操作" class="headerlink" title="条件操作"></a>条件操作</h3><h4 id="条件码寄存器"><a href="#条件码寄存器" class="headerlink" title="条件码寄存器"></a>条件码寄存器</h4><p>除整数寄存器之外，CPU还维护一组 <strong>条件码寄存器</strong> 。它们描述 <strong>最近一次</strong> 算术或逻辑操作的属性。常用的条件码有：</p>
<ul>
<li>CF 进位标志 显示操作有没有造成操作数最高位发生进位</li>
<li>ZF 零标志   显示操作的结果是不是0</li>
<li>SF 符号标志 显示操作的结果是不是负数</li>
<li>OF 溢出标志 显示补码操作有没有造成正溢出或负溢出</li>
</ul>
<p>只有 <strong>lea指令</strong> 不会改变条件码寄存器。</p>
<p>有两种指令只设置条件码而不改变其他寄存器的值：</p>
<ul>
<li>CMP 求出两个操作数之差(ATT格式是右减左)，并以此为结果设置条件码</li>
<li>TEST 以两个操作数按位与的结果设置条件码</li>
</ul>
<h4 id="对条件码的访问"><a href="#对条件码的访问" class="headerlink" title="对条件码的访问"></a>对条件码的访问</h4><p>x86-64通过 <strong>SET指令</strong> 实现对条件码的直接设置。</p>
<p>set指令是一个单元操作指令集，每条指令的功能取决于set的后缀。所有set指令共同的功能是将某一个 <strong>条件码寄存器</strong> 的值(或某些值的组合)储存到操作数表示的 <strong>单字节寄存器</strong> 中</p>
<ul>
<li>set指令共有(含义解释按上一次操作为a-b):<ul>
<li>sete(setz) - ZF</li>
<li>setne(setnz) - ~ZF</li>
<li>sets,setns - SF,~SF</li>
<li>setl(setnge) - SF^OF</li>
<li>setle(setng) - (SF^OF)|ZF</li>
<li>setg(setnle) - ~(SF^OF)&amp;~ZF</li>
<li>setge(setnl) - ~(SF^OF)</li>
<li>setb(setnae) - CF</li>
<li>setbe(setna) - CF | ZF</li>
<li>seta(setnbe) - ~CF &amp; ~ZF   </li>
<li>setae(setnb) - ~CF</li>
</ul>
</li>
</ul>
<h4 id="用条件控制来实现条件分支"><a href="#用条件控制来实现条件分支" class="headerlink" title="用条件控制来实现条件分支"></a>用条件控制来实现条件分支</h4><p><strong>控制</strong>的条件转移：传统方式，先判断条件是否满足，而后根据判断结果将控制流转移到代码段的某个位置继续执行。</p>
<h5 id="JMP指令"><a href="#JMP指令" class="headerlink" title="JMP指令"></a>JMP指令</h5><ul>
<li>直接使用：操作数是一个label，在代码段中有标记。</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">movq</span> <span class="number">$2333</span> %rax</span><br><span class="line">  <span class="keyword">jmp</span> .L1</span><br><span class="line">  leaq <span class="number">8</span>(%rdx,%rax)     # 这一句被跳过了</span><br><span class="line"><span class="symbol">.L1:</span>                    # L1是label</span><br><span class="line">  <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
<p>还有一种使用方式是间接跳转：jmp *&lt;寄存器或内存地址&gt; 取出小括号内储存的值作为label。</p>
<ul>
<li>条件使用：以j+后缀构成，后缀的使用规则和set指令集类似。<ul>
<li>跳转指令的编码方式<ul>
<li><strong>PC-relative</strong>：将目标指令的地址与jmp指令后一句指令地址的差编码，可以为1,2,4个字节</li>
<li>绝对地址：直接将目标指令的绝对地址编码，用4个字节指定。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="CMOV指令"><a href="#CMOV指令" class="headerlink" title="CMOV指令"></a>CMOV指令</h5><p>先将条件满足和不满足的两种情况下的操作都做完，随后判断条件是否满足，并根据判断结果采用两种情况下操作得出的结果中的一种。</p>
<p>与SET，JMP相似，CMOV指令也是带有指定后缀的指令集。每条CMOV指令都有两个操作数，当后缀所指定的条件满足时，CMOV指令会执行与MOV指令相同的功能。</p>
<p>源和目的值支持单字节以外的任意大小，这个大小可以由寄存器的型号看出，指令本身不给出。</p>
<h5 id="两种条件控制方式的比较"><a href="#两种条件控制方式的比较" class="headerlink" title="两种条件控制方式的比较"></a>两种条件控制方式的比较</h5><p>现代处理器使用的是 <strong>流水线策略</strong> ，即将要执行的指令序列填充进流水线，并同时做一条流水线上的所有工作。当遇到条件分支时，处理器只能预测控制流的走向而去完成那一个分支的工作，而这就意味着一旦预测失误，处理器就必须放弃之前对那一个分支做出的所有工作，并重新填充流水线。这会浪费非常多的时间。而数据条件转移就不存在这个问题。</p>
<p>然而，不是所有条件表达式都可以用条件传送来编译。更重要的是，由于这种处理方式会事先进行两种情况下的操作，如果其中某一种在某种条件下会产生副作用或者错误，那就会导致非法的行为。与此同时，如果两种条件下的计算量都比较大的话，无论怎样编译器都会白白浪费很多资源。</p>
<h3 id="循环操作"><a href="#循环操作" class="headerlink" title="循环操作"></a>循环操作</h3><ul>
<li>对于dowhile循环的实现：</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">func:</span></span><br><span class="line">  ...         # ...</span><br><span class="line"><span class="symbol">.Loop:</span>        # <span class="built_in">do</span> &#123;</span><br><span class="line">  ...         # ...</span><br><span class="line">  &lt;judging&gt;   # &#125;while</span><br><span class="line">  j** .Loop   # (condition)</span><br></pre></td></tr></table></figure>
<ul>
<li>对于while循环的实现：</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">func:</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">jmp</span> .Test   # 一上来先跳到后面的条件判断部分</span><br><span class="line"><span class="symbol">.Loop:</span>        # 循环体</span><br><span class="line">  ...</span><br><span class="line"><span class="meta">.Test</span>         # 条件判断部分</span><br><span class="line">  &lt;judging&gt;</span><br><span class="line">  j** .Loop   # 如果满足条件则回到循环体</span><br></pre></td></tr></table></figure>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">func:</span></span><br><span class="line">  ...</span><br><span class="line">  &lt;judging&gt;   # 先判断是否不符合条件</span><br><span class="line">  j** .Done   # 如果不符合，直接结束循环</span><br><span class="line"><span class="symbol">.Loop:</span></span><br><span class="line">  ...         # 循环体</span><br><span class="line">  &lt;judging&gt;</span><br><span class="line">  j** .Loop   # 如果符合条件则回到循环体</span><br></pre></td></tr></table></figure>
<ul>
<li>对于for循环的实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (init;judge;iteration) &#123;</span><br><span class="line">    body_statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以等效为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">init;</span><br><span class="line"><span class="keyword">while</span>(judge) &#123;</span><br><span class="line">    body_statement;</span><br><span class="line">    iteration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="switch操作"><a href="#switch操作" class="headerlink" title="switch操作"></a>switch操作</h3><p>这边要用到跳转表，等学了表再回来看</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>过程提供了一种封装代码的方式，用一组指定的参数和返回值实现某种功能。常见的过程有函数，方法，子例程，处理函数等等。</p>
<p>在过程调用中，需要牵涉到以下机制：</p>
<ul>
<li>传递控制：调用者要将程序计数器设置为被调用者的起始地址，待调用结束后被调用者又要交还控制权。</li>
<li>传递数据：参数和返回值需要在两块代码间进行交流。</li>
<li>分配内存：局部变量需要临时分配内存，在返回前又要释放这些内存。</li>
</ul>
<h3 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h3><p>C语言调用机制的一个关键特性在于使用了栈提供的 <strong>后进先出</strong> 内存管理原则。</p>
<p>对于局部变量而言，这种机制保证了它可以在作用范围内始终有效，在作用范围外被安全回收：某个过程在入栈时申请了局部变量，则它所调用的所有其他过程都在它之后入栈，在它之前出栈，而它申请的变量在它自身出栈时才销毁。</p>
<ul>
<li>运行时栈的调度机制<ul>
<li>当某一个过程所需要的空间超出了寄存器能提供的范围，就会在栈上分配空间。这一部分空间称为 <strong>过程的栈帧</strong> 。</li>
<li>在这个过程被调用时，它的栈帧会被事先分配好。在这个空间内它可以申请局部变量，设置它所调用的其他过程的参数，保存寄存器的值。有些情况下栈帧的长度会变化，但大部分时候帧的长度是固定的。</li>
<li>一个过程在调用另一个过程时，它会先在寄存器内分配参数；如果六个参数寄存器不够用，多出的参数会被保存在栈帧内。在被调用者分配栈帧之前，调用者会将返回地址压入自己的栈，以指明被调用者返回时调用者的继续执行位置。</li>
<li>如果所有局部变量都可以保存在寄存器中，且这个过程不会调用任何其他过程，这个过程便不会分配栈帧。</li>
</ul>
</li>
</ul>
<h3 id="转移控制"><a href="#转移控制" class="headerlink" title="转移控制"></a>转移控制</h3><ul>
<li>控制的转移使用的指令是 <strong>call</strong> 指令和 <strong>ret</strong> 指令。<ul>
<li>call 的使用方式与 jmp 类似，可以直接接&lt;<strong>Label</strong>&gt;也可以接&lt;<strong>*被调用者的起始地址</strong>&gt;来间接调用。</li>
<li>call指令会将后一条指令的地址压栈，并将PC(%rip)设置为被调用者的起始地址。</li>
<li>ret指令会保存弹出栈的值，并将PC(%rip)设置为这个值。</li>
</ul>
</li>
</ul>
<h3 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h3><ul>
<li>当参数的数目小于等于六个时，全部参数通过寄存器传递。调用者在执行call指令之前需要将实参填充到对应的寄存器中，被调用者需要使用参数时则只需从寄存器中取数据。</li>
<li>若参数的数目大于六个，多余的数据压入运行时栈。<ul>
<li>所有数据的以八字节(四字)为最小单位存储。</li>
<li>参数的顺序是越靠近栈顶的参数越靠后。被调用者可以通过栈顶指针运算来访问这些参数。</li>
<li>参数区域在返回地址区域之前，所以访问时要从 %rsp+8 开始访问。</li>
</ul>
</li>
</ul>
<h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>有些时候，寄存器不足以满足过程的需要，因此需要在运行时栈上位局部变量分配内存：</p>
<ol>
<li>寄存器不够用</li>
<li>对一个局部变量进行取地址操作，此时这个局部变量必须有内存地址</li>
<li>局部变量是数组或结构体</li>
</ol>
<ul>
<li>分配局部内存的方式<ol>
<li>减小栈顶指针%rsp的值</li>
<li>将局部变量的值填充入因为栈顶指针减小而多出来的栈空间内</li>
<li>通过栈顶指针运算访问局部变量</li>
<li>在ret执行之前增大栈顶指针的值，释放内存</li>
</ol>
</li>
</ul>
<h3 id="寄存器使用"><a href="#寄存器使用" class="headerlink" title="寄存器使用"></a>寄存器使用</h3><p>为了避免不同过程中新的寄存器值覆盖旧的寄存器值带来损失，x86-64有一套寄存器使用规范。</p>
<ul>
<li>被调用者保存寄存器：%rbx,%rbp,%r12~%r15<ul>
<li>被调用者有义务在自身返回时保证这些寄存器的值与被调用时相同。</li>
<li>被调用者可以选择不改变这些寄存器中的值。</li>
<li>如果必须改变，可以先将其值压栈，在返回前再将旧值从栈中取回寄存器中。</li>
<li>压栈的寄存器值所处的部分称为“保存的寄存器”部分，位于局部变量区域之前。</li>
</ul>
</li>
<li>调用者保存寄存器：除%rsp以外的其他寄存器<ul>
<li>任何过程都可以修改这些寄存器的值。</li>
</ul>
</li>
</ul>
<h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><p>由于函数栈的性质，递归调用自身和调用其他函数并没有什么区别，递归的实现可谓水到渠成。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>C语言的数组实现与汇编语言相当接近，因此可以使用头指针和内存运算方便地实现数组。</p>
<ul>
<li>数组元素a[i+j]的汇编形式：j(a,i,q)<ul>
<li>a为储存着数组头指针的寄存器或内存位置</li>
<li>i为变量，可以是循环变量</li>
<li>q是数组元素的数据类型大小，可以用sizeof得出</li>
<li>j是常数，用于定址索引</li>
</ul>
</li>
<li>高维数组的储存<ul>
<li>C语言对高维数组采取行优先的线性存储。</li>
<li>对于大小为R行C列的数组a来说，a[i][j]的地址应该是(i<em>C+j)</em>size + a</li>
</ul>
</li>
<li>对变长数组的处理<ul>
<li>由于数组存储的线性性，不事先知道数组的列数就无法表达第二行开始的数组元素。</li>
<li>因此需要将数组的大小n也作为参数传入才能处理</li>
</ul>
</li>
</ul>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构的各个字段通过结构的头指针和字段大小构成的偏移量来访问。机器代码不包含关于字段名字或者字段声明的信息。</p>
<p>联合同理，只不过结构在访问字段时其指针偏移量需要加上该字段前面所有字段的偏移量，而联合每个字段都以联合的头指针为起点。</p>
<p>.align &lt; num &gt; 这个指令可以保证指令后的数据都以num个字节为单位进行数据对齐。</p>
<h2 id="内存越界引用和缓冲区溢出"><a href="#内存越界引用和缓冲区溢出" class="headerlink" title="内存越界引用和缓冲区溢出"></a>内存越界引用和缓冲区溢出</h2><p>为了对抗Buffer attack，内存系统的设计者使用了这样几种机制：</p>
<h3 id="地址空间布局随机化"><a href="#地址空间布局随机化" class="headerlink" title="地址空间布局随机化"></a>地址空间布局随机化</h3><p>采用这种方式，每次运行时程序所使用的运行时栈，堆内存，全局变量区以及代码段都会随机被储存在内存的不同区域，这样就避免了一些简单而重复的攻击</p>
<p>针对这种机制，黑客可以在攻击代码之前插入一段很长的nop操作，这样只要随机化过的栈地址与这段nop操作有重合，程序的执行就会沿着这一系列的nop滑到攻击代码。</p>
<h3 id="栈破坏检测"><a href="#栈破坏检测" class="headerlink" title="栈破坏检测"></a>栈破坏检测</h3><p>程序在每次运行时首先随机产生一个canary值，并储存在栈帧中一个空余的位置(一般在变量区之后)。在返回之前，程序会取出并检查这个canary有没有被改变。如果被改变了，那么程序会异常中止。</p>
<p>GCC会根据一个函数是否容易被进行栈溢出攻击来决定是否要进行这种检测。如果不想使用这种检测，可以在编译时加上-fno-stack-protector选项。</p>
<h3 id="限制可执行代码区域"><a href="#限制可执行代码区域" class="headerlink" title="限制可执行代码区域"></a>限制可执行代码区域</h3><p>将只需要读写的内存区和可执行的内存区分开，可以有效避免注入攻击。</p>
<h2 id="浮点数操作"><a href="#浮点数操作" class="headerlink" title="浮点数操作"></a>浮点数操作</h2><h3 id="浮点数使用的寄存器"><a href="#浮点数使用的寄存器" class="headerlink" title="浮点数使用的寄存器"></a>浮点数使用的寄存器</h3><p>AVX浮点体系结构允许浮点数储存在16个YMM浮点数寄存器中。</p>
<ul>
<li>16个寄存器的名称分别为ymm0-ymm15，长度均为32个字节。但是float只使用最低的四个字节，double只使用最低的八个字节。</li>
<li>汇编代码通常用xmm0-15来引用这些寄存器。xmm是ymm的后16个字节。</li>
</ul>
<h3 id="浮点数的操作命令"><a href="#浮点数的操作命令" class="headerlink" title="浮点数的操作命令"></a>浮点数的操作命令</h3><ul>
<li>移动操作<ul>
<li>vmovss - 移动单精度数</li>
<li>vmovsd - 移动双精度数</li>
<li>vmovaps，vmovapd - 移动封装好的已经对齐的单精度（双精度）数，一般用于寄存器之间的传送</li>
</ul>
</li>
<li>转换操作<ul>
<li>vcvttss2si - 单精度数转整数</li>
<li>vcvttsd2si - 双精度数转整数<ul>
<li>第一个操作数是储存浮点数的寄存器，第二个操作数是储存结果整数的寄存器。</li>
<li>这两个操作会进行自动的 <strong>截断</strong> 而非四舍五入。</li>
<li>转成四字整数只需要在指令后面加后缀q即可</li>
</ul>
</li>
<li>vcvtsi2ss - 整数转单精度数</li>
<li>vcvtsi2sd - 整数转双精度数<ul>
<li>这两个操作是三操作数操作，前一个是整数寄存器，后两个一般写同一个浮点寄存器。</li>
</ul>
</li>
<li>vunpcklps，vmovddup - 交叉存放两个寄存器中的字</li>
<li>vcvtpd2psx，vcvtps2pd - 单双精度之间的转换</li>
</ul>
</li>
<li>算术运算<ul>
<li>算术运算是由运算名和后缀组成的。<ul>
<li>运算名代表运算的种类：<ul>
<li>vadd：加法</li>
<li>vdiv：减法</li>
<li>vmul：乘法</li>
<li>vdiv：除法</li>
<li>vmax：最大</li>
<li>vmin：最小</li>
<li>sqrt：开方</li>
</ul>
</li>
<li>后缀：ss表示单精度操作，sd表示双精度操作</li>
</ul>
</li>
<li>操作数的数量视操作而定。除了开方之外，所有操作都有三个操作数：前两个进行运算，结果存在第三个中。</li>
</ul>
</li>
<li>位运算<ul>
<li>vxorps，vxorpd 位级异或</li>
<li>vandps，vandpd 位级与</li>
<li>位级操作是同时对两个寄存器中的所有128位同时进行进行操作，并将结果储存在第三个操作数中</li>
</ul>
</li>
<li>比较操作<ul>
<li>vucomiss 单精度比较操作，结果是S2-S1</li>
<li>vucomisd 双精度比较操作，结果一样</li>
<li>jp 当比较的对象不可以比较时跳转</li>
</ul>
</li>
</ul>
<h3 id="过程中的浮点数"><a href="#过程中的浮点数" class="headerlink" title="过程中的浮点数"></a>过程中的浮点数</h3><ul>
<li>浮点数使用 <strong>%xmm0</strong> 来储存返回值</li>
<li>浮点数的传参最大数量是 <strong>八</strong> 个，多出的参数要出存在栈中</li>
<li>所有xmm寄存器都是调用者保存的</li>
<li><strong>浮点常数</strong>的定义和使用<ul>
<li>编译器必须为所有的浮点数常量值分配内存空间，然后代码从内存空间读入。</li>
</ul>
</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Doubletest:</span></span><br><span class="line">    <span class="keyword">vmulsd</span> .LC0(%rip),%xmm0,%xmm0 </span><br><span class="line">    # 通过程序计数器和标号的结合去引用内存中的浮点数常量</span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line"><span class="symbol">.LC0:</span></span><br><span class="line"><span class="meta">    .long</span> <span class="number">3435973837</span>                    # double低位<span class="number">4</span>字节的十进制表示</span><br><span class="line"><span class="meta">    .long</span> <span class="number">1073532108</span>                    # double高位<span class="number">4</span>字节的十进制表示</span><br><span class="line"><span class="symbol">Floattest:</span></span><br><span class="line">    <span class="keyword">vmulss</span> .LC1(%rip),%xmm1,%xmm0</span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line"><span class="symbol">.LC1:</span></span><br><span class="line"><span class="meta">    .long</span> <span class="number">1065353216</span>                    # <span class="meta">float</span>编码的十进制表示</span><br></pre></td></tr></table></figure>
<h1 id="Chapter-4-处理器体系结构"><a href="#Chapter-4-处理器体系结构" class="headerlink" title="Chapter 4 处理器体系结构"></a>Chapter 4 处理器体系结构</h1><p>处理器要处理的指令被编码为由一个或者多个字节序列组成的二进制格式。一个处理器支持的 <strong>指令集和指令的编码方式</strong> 称为这个处理器的 <strong>指令集体系结构(ISA)</strong> 。</p>
<p>不同的处理器家族所使用的ISA是不兼容的，但是同一家族内的各型号处理器一般使用同种ISA。</p>
<p>在本教材中，我们使用一种比较简单的指令集，称为Y86-64.</p>
<h2 id="Y86-64-ISA"><a href="#Y86-64-ISA" class="headerlink" title="Y86-64 ISA"></a>Y86-64 ISA</h2><h3 id="程序员可见的状态"><a href="#程序员可见的状态" class="headerlink" title="程序员可见的状态"></a>程序员可见的状态</h3><p>指令集能够修改与读取的那些处理器组成部分称为 <strong>程序员可见状态</strong> 。</p>
<ul>
<li>Y86-64的状态包括以下部分：<ul>
<li><strong>15个64位寄存器</strong>：比x86-64少了一个%r15</li>
<li><strong>程序计数器PC</strong>：存放当前指令的地址</li>
<li><strong>条件码CC</strong>：有三个条件码，比x86-64少了进位符CF</li>
<li><strong>内存</strong>：用 <strong>虚拟地址</strong> 引用内存位置，它是物理地址的一组字节映像。</li>
<li><strong>程序状态码</strong>：用来处理程序异常以防系统崩溃</li>
</ul>
</li>
</ul>
<h3 id="Y86-64指令集"><a href="#Y86-64指令集" class="headerlink" title="Y86-64指令集"></a>Y86-64指令集</h3><p>由于Y86-64是简化版的x86-64指令集，因此有很多限制。</p>
<ul>
<li>只能操作 <strong>八字节大小的整数</strong></li>
<li>寻址方式：基址+偏移量，不支持变址寻址，更不支持变址伸缩</li>
<li>不允许在内存地址之间移动数据，不允许将立即数直接写入内存</li>
<li>x86-64的限制它也一样具有</li>
</ul>
<p>我们需要实现以下指令：</p>
<ul>
<li>移动指令(movq被分成了四个单独的指令)<ul>
<li>irmovq 获取一个立即数(立即数移动到寄存器)</li>
<li>rrmovq 寄存器间的值传递</li>
<li>mrmovq 从内存中读数据</li>
<li>rmmovq 向内存中写数据</li>
</ul>
</li>
<li>条件和运算指令：操作数只能是寄存器，不能是内存寻址<ul>
<li>addq</li>
<li>subq</li>
<li>andq</li>
<li>xorq</li>
</ul>
</li>
<li>跳转指令(由于条件码少了一个CF，无符号数的比较无法实现)<ul>
<li>jmp 直接跳转</li>
<li>jle &lt;=</li>
<li>jl &lt;</li>
<li>je =</li>
<li>jne !=</li>
<li>jge &gt;=</li>
<li>jg &gt;</li>
</ul>
</li>
<li>条件传送指令(同样不支持无符号数)</li>
<li>函数调用指令<ul>
<li>call 返回地址入栈并将PC的值设为目标地址</li>
<li>ret 返回地址出栈并将PC的值设为返回地址</li>
</ul>
</li>
<li>程序栈操作指令<ul>
<li>pushq</li>
<li>popq</li>
</ul>
</li>
<li>停止指令：停止指令的执行<ul>
<li>halt 处理器停止，状态码设置为HLT</li>
</ul>
</li>
</ul>
<h3 id="指令集编码"><a href="#指令集编码" class="headerlink" title="指令集编码"></a>指令集编码</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> 指令名 操作数 操作数<span class="number">2</span>    指令编码</span><br><span class="line">halt                    <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">nop</span>                     <span class="number">1</span> <span class="number">0</span></span><br><span class="line">rrmovq  rA    rB        <span class="number">2</span> <span class="number">0</span>    rA   rB</span><br><span class="line">irmovq  V     rB        <span class="number">3</span> <span class="number">0</span>    <span class="number">0xF</span>  rB      V</span><br><span class="line">rmmovq  rA    D(rB)     <span class="number">4</span> <span class="number">0</span>    rA   rB      D</span><br><span class="line">mrmovq  D(rA) rB        <span class="number">5</span> <span class="number">0</span>    rA   rB      D</span><br><span class="line">OPq     rA    rB        <span class="number">6</span> fn   rA   rB</span><br><span class="line">jXX     Dir             <span class="number">7</span> fn   Dir</span><br><span class="line">cmovXX  rA    rB        <span class="number">2</span> fn   rA   rB</span><br><span class="line"><span class="keyword">call</span>    Dir             <span class="number">8</span> <span class="number">0</span>    Dir</span><br><span class="line"><span class="keyword">ret</span>                     <span class="number">9</span> <span class="number">0</span></span><br><span class="line">pushq   rA              A <span class="number">0</span>    rA   <span class="number">0xF</span></span><br><span class="line">popq    rA              B <span class="number">0</span>    rA   <span class="number">0xF</span></span><br><span class="line"></span><br><span class="line">附注</span><br><span class="line">fn：编码的功能部分(见附表：指令集功能码表)</span><br><span class="line">rA，rB：寄存器(见下面的寄存器码)</span><br><span class="line">Dir：<span class="keyword">jmp</span>类和<span class="keyword">call</span>指令的目标地址</span><br><span class="line">D：偏移量</span><br><span class="line">V：立即数</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">指令集功能码表</span><br><span class="line">OPq类</span><br><span class="line">  addq      60</span><br><span class="line">  subq      61</span><br><span class="line">  andq      62</span><br><span class="line">  xorq      63</span><br><span class="line">jXX类</span><br><span class="line">  jmp       70</span><br><span class="line">  jle       71</span><br><span class="line">  jl        72</span><br><span class="line">  je        73</span><br><span class="line">  jne       74</span><br><span class="line">  jge       75</span><br><span class="line">  jg        76</span><br><span class="line">cmov类</span><br><span class="line">  rrmovq    20</span><br><span class="line">  cmovle    21</span><br><span class="line">  cmovl     22</span><br><span class="line">  cmove     23</span><br><span class="line">  cmovne    24</span><br><span class="line">  cmovge    25</span><br><span class="line">  cmovg     26</span><br></pre></td></tr></table></figure>
<h4 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h4><ul>
<li>每条指令的第一个字节表明指令的具体类型<ul>
<li>前四位是 <strong>代码部分</strong> ，表示指令的种类</li>
<li>后四位是 <strong>功能部分</strong> ，表示指令是大类中的哪一个</li>
</ul>
</li>
<li>rA和rB都是寄存器，用一个范围在0到E之间的 <strong>寄存器标识符</strong> 表示。<ul>
<li>%rax—0</li>
<li>%rcx—1</li>
<li>%rdx—2</li>
<li>%rbx—3</li>
<li>%rsp—4</li>
<li>%rbp—5</li>
<li>%rsi—6</li>
<li>%rdi—7</li>
<li>%r8—-8</li>
<li>%r9—-9</li>
<li>%r10—A</li>
<li>%r11—B</li>
<li>%12—-C</li>
<li>%r13—D</li>
<li>%r14—E</li>
<li>不需要–F</li>
</ul>
</li>
<li>由于小端序的问题，八字节长的立即数，偏移量和地址都要反序书写。也就是说一个指令(以rmmovq $0x12345678,%rax为例)的完整编码是 40 F0 78 56 34 12 00 00 00 00.</li>
</ul>
<h4 id="RISC与CISC"><a href="#RISC与CISC" class="headerlink" title="RISC与CISC"></a>RISC与CISC</h4><p>CISC，也就是复杂指令集计算机，是比较早发展起来的一种计算机。它们的指令集比较庞大，指令类型多样，功能强大，对硬件的要求和复杂度都很高。为了开发一种能用较少硬件实现的指令集，RISC(精简指令集计算机)成为了人们的研究对象。</p>
<p>RISC的主要特点是指令少而简单，编码方式固定(所有指令都用4字节编码)，寻址方式简单，因而执行速度很快，对硬件要求很小。但因为本来应该由条件码和内存引用承担的一部分工作现在要全部让寄存器来承担，所以这种指令集需要很多性能优良的寄存器，最多有32个。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul>
<li>状态码可能的值<ul>
<li>AOK—1：表示程序运行正常</li>
<li>HLT—2：执行了halt指令</li>
<li>ADR—3：遇到了非法地址</li>
<li>INS—4：执行了非法指令</li>
</ul>
</li>
</ul>
<p>在遇到异常的时候，完善的架构会调用一个异常处理函数来处理特定的异常。但在Y86-64这里，我们只简单地让程序停止运行。</p>
<h3 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h3><p>以“.”开头的词是汇编器伪指令。它们用来告知汇编器调整地址。</p>
<ul>
<li>标号的作用<ul>
<li>在汇编语言程序中，不缩进而后跟冒号的 <strong>标号</strong> 用以指定一个内存地址。通过引用这个标号，指令可以获得这个标号所在代码段位置的内存地址。</li>
</ul>
</li>
<li>汇编器伪指令<ul>
<li>.pos &lt; addr &gt; 指定一个地址，这条指令之后的代码从这个地址开始存放。</li>
<li>.align &lt; num &gt; 指定对齐方式</li>
</ul>
</li>
</ul>
<h2 id="硬件控制语言HCL"><a href="#硬件控制语言HCL" class="headerlink" title="硬件控制语言HCL"></a>硬件控制语言HCL</h2><p>要实现一个数字系统，需要三个主要的组成部分：<strong>位运算函数的组合逻辑</strong>，<strong>存储位的存储器单元</strong>，<strong>以及更新存储位信息的时钟信号</strong>。</p>
<p><strong>HDL</strong> 是描述硬件的一种文本表示，典型的例子是Verilog语言，其语法类似于C。而 <strong>HCL</strong> 只表达硬件的控制部分，需要翻译成Verilog之后结合一些其他Verilog代码来产生HDL描述，从而生成对应的硬件。</p>
<h3 id="逻辑门和组合电路"><a href="#逻辑门和组合电路" class="headerlink" title="逻辑门和组合电路"></a>逻辑门和组合电路</h3><p>将很多逻辑门组合在一起，就可以构成 <strong>计算块</strong> ，称为 <strong>组合电路</strong> 。</p>
<ul>
<li>构建这样的电路有几个限制：<ul>
<li>每个逻辑门的输入必须连接到以下选项之一：<ul>
<li>系统输入</li>
<li>某个存储单元的输出</li>
<li>某个逻辑门的输出</li>
</ul>
</li>
<li>逻辑门的输出不能连接在一起，否则可能造成信号紊乱。</li>
<li>这个网必须是无环的。</li>
</ul>
</li>
</ul>
<p>我们可以通过构造HCL表达式的方式来设计这样的组合电路。例如：</p>
<ul>
<li>位相等判断器：(a&amp;&amp;b)||(!a&amp;&amp;!b)</li>
<li>多路复用器(选择器):(s&amp;&amp;a)||(!s&amp;&amp;b)</li>
</ul>
<p>HCL表达式与C表达式的区别：</p>
<ul>
<li>HCL表达式只对单个位进行操作，可能的值只有0和1,可能的操作只有与或非，因此情况简单，需要进行的操作比较少；而C中的True可以是任一个非0的数，且同时操作一整个字，这样要达到相同的功能就会更加复杂(见datalab中的多路复用器位实现)</li>
<li>HCL表达式的变量和值都是动态更新的</li>
<li>C表达式有部分求值的特性，而HCL没有。</li>
</ul>
<h3 id="字级别的组合电路"><a href="#字级别的组合电路" class="headerlink" title="字级别的组合电路"></a>字级别的组合电路</h3><p>在HCL语言中，我们把表达式定义为 <strong><em>bool</em></strong> 型，而字级的 <strong>信号</strong> 不论大小都为 <strong><em>int</em></strong> 型。</p>
<p>在画字级电路时，用虚线表示布尔信号结果，而用中等粗度的线表示携带字的每个位的线路。</p>
<p><strong>多路复用函数</strong>是用 <strong>情况表达式</strong> 来描述的。其通用格式如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">word Out = [</span><br><span class="line">    select_1 : expr_1;</span><br><span class="line">    select_2 : expr_2;</span><br><span class="line">    ...</span><br><span class="line">    select_k : expr_k;</span><br><span class="line">    <span class="number">1</span>        : expr_default     <span class="comment"># 如果前面的都没选中则执行这个</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>与C中的多路复用不同的是，这里只要有一个条件满足就会跳过剩下的。</p>
<p><strong>算术逻辑单元</strong>(ALU)是一种很重要的组合电路。它有一组控制输入和一组参数输入，根据控制输入的不同，ALU会对参数做不同的操作，然后输出结果。</p>
<h3 id="集合关系"><a href="#集合关系" class="headerlink" title="集合关系"></a>集合关系</h3><p>判断集合关系的通用格式是: <strong>iexpr in {expr1,…exprn}</strong></p>
<p>如果iexpr在集合内有出现，则表达式的值为真，否则为假。</p>
<h3 id="存储器与时钟"><a href="#存储器与时钟" class="headerlink" title="存储器与时钟"></a>存储器与时钟</h3><p>组合电路只会接受输入，传送输出而不会存储任何信息。因此，为了产生 <strong>时序电路</strong> ，必须引入按位存储信息的设备。</p>
<ul>
<li>存储器设备<ul>
<li>寄存器(这里指硬件上的物理寄存器) ：是CPU的一部分，存储单个位或者单个字。<ul>
<li>寄存器的值随着时钟周期更新。</li>
</ul>
</li>
<li>随机访问存储器 ：存储多个字，用地址来决定读写哪个字。具体的例子包括：<ul>
<li>处理器的 <strong>虚拟内存系统</strong> (也就是我们通常讲的内存):操作系统辅助硬件使CPU能够访问一个很大地址空间中的任意一个字。<ul>
<li>在需要读得时候，将write位输入设为0，将address字设置好，等一个时钟周期，在时钟发信号之后就可以在data字接收到输出。如果出现错误，error位会设为1,否则为0.</li>
<li>在需要写的时候，将write位输入设为1，同样地设置address值，并设置输入值到data，等一个时钟周期，再查看error位有没有出现错误。</li>
</ul>
</li>
<li><strong>寄存器文件</strong>(就是我们通常说的寄存器的总和)：由所有物理寄存器组成的寄存器阵列构成。<ul>
<li>寄存器文件被划分为数个 <strong>程序寄存器</strong> 。这些程序寄存器的 <strong>标识符</strong> 就代表着它们在寄存器文件中的地址。</li>
<li>寄存器文件有两个 <strong>读端口</strong> 和一个 <strong>写端口</strong> 。每个端口都有一个地址输入(用来指定程序寄存器)，另外读端口还有一个读数据输出，写端口还有一个写数据输入。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Y86-64的顺序实现"><a href="#Y86-64的顺序实现" class="headerlink" title="Y86-64的顺序实现"></a>Y86-64的顺序实现</h2><p><strong>顺序实现处理器</strong>(<strong>SEQ</strong>)是非常低效的，因为它要在一个时钟周期内完成一条指令的全部步骤。但是，SEQ是开发流水线化处理器必不可少的一个中间过程。</p>
<h3 id="将指令划分阶段"><a href="#将指令划分阶段" class="headerlink" title="将指令划分阶段"></a>将指令划分阶段</h3><p>绝大部分指令都遵循以下的操作序列：</p>
<ul>
<li><strong>取指令</strong>(fetch)：根据程序计数器的值从内存中读取指令内容。<ul>
<li>首先读取代表指令种类的两个四位部分，辨别指令类型</li>
<li>根据指令类型决定的数据长度读取剩下的数据。</li>
</ul>
</li>
<li><strong>译码</strong>(decode)：这个阶段从寄存器文件读入至多两个操作数。</li>
<li><strong>执行</strong>(execute)：<strong>算术逻辑单元</strong>执行指令，进行数学和逻辑运算，改变栈指针，设置或检验条件码。</li>
<li><strong>访存</strong>(memory)：将运算结果写入内存或从内存读出数据。</li>
<li><strong>回写</strong>(writeback)：写入最多两个数据到寄存器文件</li>
<li><strong>更新PC</strong>(update)：更新程序寄存器的值</li>
</ul>
<h3 id="SEQ硬件结构"><a href="#SEQ硬件结构" class="headerlink" title="SEQ硬件结构"></a>SEQ硬件结构</h3><p>采用SEQ顺序式设计，时基发生器需要将一条指令整个完成的时间作为时钟周期。</p>
<h4 id="硬件对指令六个步骤的配合"><a href="#硬件对指令六个步骤的配合" class="headerlink" title="硬件对指令六个步骤的配合"></a>硬件对指令六个步骤的配合</h4><ul>
<li>取指令：<ul>
<li>读程序计数器的值，以其为地址取内存中保存的指令。</li>
<li>PC增加器同时计算下一条指令的地址valP并保存。</li>
</ul>
</li>
<li>译码：寄存器文件有两个读端口，从这两个端口分别读入两个寄存器的值<ul>
<li>两个端口的设计保证了这一步骤能够在一个时钟周期内完成</li>
</ul>
</li>
<li>执行：ALU接受输入，进行操作，传递输出<ul>
<li>由于Y86-64的计算命令过于简单，所有操作能在一个时钟周期内完成。</li>
</ul>
</li>
<li>访存：从数据内存读入或者写出一个内存字</li>
<li>写回：寄存器文件有两个写端口<ul>
<li>一个用来写入ALU的计算结果</li>
<li>一个用来写入从内存中读出的值</li>
</ul>
</li>
<li>PC更新：程序计数器的新值可能是：<ul>
<li>下一条指令的地址valP(一般情况)</li>
<li>jXX或call指令指定的指令地址(指令是call或jXX时)</li>
<li>从内存读入的返回地址(指令是ret时)</li>
</ul>
</li>
</ul>
<h4 id="SEQ时序控制"><a href="#SEQ时序控制" class="headerlink" title="SEQ时序控制"></a>SEQ时序控制</h4><p>SEQ的实现包括 <strong>组合逻辑</strong> 和 <strong>两种存储器</strong>(时钟寄存器和随机访问存储器)。</p>
<p>组合逻辑不需要时序控制，只要输入产生变化，变化会以光速通过逻辑网进行传播。在小型电路中，对指令内存的访问可以看成和组合逻辑一样的操作；而大型电路可以使用特殊的时基发生器来达到类似的效果。</p>
<p>而对于程序计数器，条件码寄存器，数据内存和寄存器文件，它们通过一个时钟信号来控制，这个信号会触发向寄存器和数据内存的写操作。</p>
<p>组织计算有一个原则：<strong>从不回读</strong>，也就是处理器不需要为了完成一条指令而去读因为这条指令更新过的状态。</p>
<p>如pushq指令，它既要使用%rsp的值又要更新%rsp的值，这种情况下为了这个原则要把使用这个步骤放在更新前面。分步来看，首先在执行阶段指令计算%rsp+8并保存，然后访存阶段用%rsp的值去写内存，写回阶段再将%rsp+8的值写回%rsp中。</p>
<p>另外的一个例子是CC的更新。没有指令会同时改变CC的值和使用CC的值，因此任何指令试图读CC的之后它的值都是已经更新的。</p>
<h4 id="SEQ的HCL实现"><a href="#SEQ的HCL实现" class="headerlink" title="SEQ的HCL实现"></a>SEQ的HCL实现</h4><ul>
<li>用作HCL参数的常数预定义<ul>
<li>指令代码<ul>
<li>IHALT</li>
<li>INOP</li>
<li>IRRMOVQ</li>
<li>IIRMOVQ</li>
<li>IRMMOVQ</li>
<li>IMRMOVQ</li>
<li>IOPL</li>
<li>IJXX</li>
<li>ICALL</li>
<li>IRET</li>
<li>IPUSHQ</li>
<li>IPOPQ</li>
</ul>
</li>
<li>FNONE 默认功能码</li>
<li>寄存器<ul>
<li>RRSP %rsp的寄存器ID</li>
<li>RNONE 表示无寄存器参与</li>
</ul>
</li>
<li>ALUADD 加法运算的功能</li>
<li>状态码<ul>
<li>SAOK 正常</li>
<li>SADR 地址异常</li>
<li>SINS 操作异常</li>
<li>SHLT Halt</li>
</ul>
</li>
</ul>
</li>
<li>取指令<ul>
<li>以PC为起始地址，从内存中读出10个字节<ul>
<li>如果地址不合法，就舍弃后9个字节，并将第一个字节设置为nop指令，同时产生一个 <strong>imem_error信号</strong> ，传递到下一步骤</li>
</ul>
</li>
<li>从第一个字节中取得icode与ifun值，并进行一系列逻辑判断，判断结果传递至下一步骤<ul>
<li><strong>instr_valid</strong>：该指令是否为合法的Y86-64指令</li>
<li><strong>need_regids</strong>：该指令是否包含寄存器字节</li>
<li><strong>need_valC</strong>：该指令是否包含常数字</li>
<li>这三个判断使用一个HCL中的 <strong>集合关系判断</strong> 就可以实现。</li>
</ul>
</li>
<li>根据icode与ifun值产生 <strong>alufun</strong> 信号并传递到执行阶段</li>
<li>标号为“<strong>Align</strong>”的硬件单元处理后面的九个字节<ul>
<li>if need_regids : 将第二个字节分开分别放入 <strong>rA</strong> 和 <strong>rB</strong> 指示符，后八个字节作为常数字</li>
<li>else : 将第二个到第九个字节作为常数字</li>
</ul>
</li>
<li><strong>PC增加器</strong>计算生成valP<ul>
<li>PC值为p，need_rigids值为r，need_valC值为c</li>
<li>则valP = p + r + 8c + 1</li>
</ul>
</li>
</ul>
</li>
<li>译码和写回阶段<ul>
<li>寄存器文件的两个读端口和两个写端口都各有两个输入(或一个输入一个输出)：一个地址输入表示寄存器的编号，一个数据输入输出表示读写的数据。两个读端口的地址输入是 <strong>srcA</strong> 和 <strong>srcB</strong> ，两个写端口则是 <strong>dstE</strong> 和 <strong>dstM</strong> (分别存放计算结果和内存中取出的值)。</li>
<li>根据icode值，通过逻辑控制填入两个读端口(或者写端口)的地址输入</li>
<li>当遇到popq %rsp指令时，两个写端口的目标将会是同一个寄存器。这时需要在两个写端口之间确定一个优先级。为了让从内存中读出的值能存到%rsp，让 <strong>dstM优先级更高</strong> ，也就是冲突的时候不写入dstE。</li>
</ul>
</li>
<li>执行阶段<ul>
<li>将两个操作数填入ALU<ul>
<li>前一个操作数填valB</li>
<li>后一个操作数根据情况填valA或常数C或8，-8</li>
</ul>
</li>
<li>产生一个信号 <strong>set_cc</strong> 判断操作是否为OPq，不是则没必要更新条件码寄存器。</li>
<li>标号为“<strong>cond</strong>”的硬件单元根据条件码CC和icode，ifun值判断是否需要跳转或条件传送。判断结果作为一个 <strong>Cnd信号</strong> 传递给下一个步骤</li>
<li>ALU进行计算，计算结果是 <strong>valE</strong></li>
</ul>
</li>
<li>访存阶段<ul>
<li>读写控制模块根据icode的值判断是应该读还是应该写。</li>
<li>地址控制模块根据icode的值判断内存地址是valA还是valE</li>
<li>数据控制模块根据icode的值判断数据是valA还是valP(返回地址)</li>
<li>进行读写操作，读出的值为 <strong>valM</strong></li>
<li>根据数据内存产生的 <strong>dmem_error</strong> 信号及之前产生的三种信号设置程序的stat状态码</li>
</ul>
</li>
<li>更新PC阶段<ul>
<li>控制模块根据Cnd信号和icode值判断采用valC，valM，valP中的哪一个作为新的PC值</li>
</ul>
</li>
</ul>
<p>SEQ的HCL实现：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于HCL语言不像HDL那样有着对硬件本身的封装，这里使用一些类似于类的语法来表示硬件</span></span><br><span class="line"><span class="comment"># 程序开始运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取指令</span></span><br><span class="line"></span><br><span class="line">word p = PC.read(); <span class="comment"># 读出PC中的值</span></span><br><span class="line"><span class="keyword">if</span> p == SADR：</span><br><span class="line">    word ins = INOP;</span><br><span class="line">    bool imem_error = <span class="number">1</span>;</span><br><span class="line">    <span class="comment"># 如果PC中储存的地址不合法，产生imem_error信号并将指令设置为nop</span></span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">    word ins = MEM.read(baseptr=p,size=<span class="number">10</span>); <span class="comment"># 以p为基址在内存中读出10个字节</span></span><br><span class="line">    int icode,int ifun = SPLIT.split(ins[<span class="number">0</span>]); <span class="comment"># 指令的第一个字节被split硬件单元解析</span></span><br><span class="line">    bool instr_valid = ***;</span><br><span class="line">    <span class="comment"># 这个判断就是依次判断每个可能的icode对应的ifun是否符合，过于长这里不写了</span></span><br><span class="line">    bool need_regids = </span><br><span class="line">        icode <span class="keyword">in</span> &#123;IRRMOVQ,IIRMOVQ,IMRMOVQ,IRMMOVQ,IOPQ,IPUSHQ,IPOPQ&#125;;</span><br><span class="line">    bool need_valC = </span><br><span class="line">        icode <span class="keyword">in</span> &#123;IIRMOVQ,IMRMOVQ,IRMMOVQ,IJXX,ICALL&#125;;</span><br><span class="line">    <span class="comment"># 这两个判断看一下哪些指令需要常数字段和寄存器字段就好了</span></span><br><span class="line">    <span class="keyword">if</span> need_regids：</span><br><span class="line">        int rA,int rB = ALIGN.align(ins[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> need_valC：</span><br><span class="line">            word valC = ALIGN.align(ins[<span class="number">2</span>:<span class="number">10</span>]);</span><br><span class="line">        <span class="comment"># 如果指令需要寄存器就从第二个字节中读出</span></span><br><span class="line">        <span class="comment"># valC同理，都由align硬件单元读出</span></span><br><span class="line">    <span class="keyword">else</span>：</span><br><span class="line">        int rA = <span class="number">0xF</span>;</span><br><span class="line">        int rB = <span class="number">0xF</span>;</span><br><span class="line">        <span class="keyword">if</span> need_valC：</span><br><span class="line">            word valC = ALIGN.align(ins[<span class="number">1</span>:<span class="number">9</span>]);</span><br><span class="line">        <span class="comment"># 反之，如果不需要寄存器就将两个寄存器值都设为0xF，即无寄存器</span></span><br><span class="line">        <span class="comment"># 这样valC就会存放在指令的2到9字节。</span></span><br><span class="line">    word valP = p + need_regids + <span class="number">8</span>*need_valC;</span><br><span class="line">    <span class="comment"># valP代表下一条指令的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 译码</span></span><br><span class="line"></span><br><span class="line">word srcA = [</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IRRMOVQ,IMRMOVQ,IOPQ,IPUSHQ&#125; : rA;</span><br><span class="line">    <span class="comment"># 需要读rA寄存器的值时</span></span><br><span class="line">    icode <span class="keyword">in</span> &#123;IPOPQ,IRET&#125; : RRSP;</span><br><span class="line">    <span class="comment"># 这里与后面访存阶段的访问联系</span></span><br><span class="line">    <span class="number">1</span> : RNONE;</span><br><span class="line">    <span class="comment"># 默认情况是没有寄存器需求</span></span><br><span class="line">]; <span class="comment"># srcA一般用来提供运算的第二个参数</span></span><br><span class="line"></span><br><span class="line">word srcB = [</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IRMMOVQ,IOPQ&#125; : rB;</span><br><span class="line">    <span class="comment"># 需要读rB寄存器的值时</span></span><br><span class="line">    icode <span class="keyword">in</span> &#123;IPUSHQ,IPOPQ,ICALL,IRET&#125; : RRSP;</span><br><span class="line">    <span class="number">1</span> : RNONE;</span><br><span class="line">]; <span class="comment"># srcB提供运算的主参数与rsp地址信息</span></span><br><span class="line"></span><br><span class="line">word valA = REG.read(srcA);</span><br><span class="line">word valB = REG.read(srcB);</span><br><span class="line"><span class="comment"># 从寄存器文件中读出对应的值并保存为valA和valB</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line"></span><br><span class="line">word aluA = [</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IRRMOVQ,IOPQ&#125; : valA;</span><br><span class="line">    <span class="comment"># 寄存器rA的值直接作操作数</span></span><br><span class="line">    icode <span class="keyword">in</span> &#123;IIRMOVQ,IMRMOVQ,IRMMOVQ&#125; : valC;</span><br><span class="line">    <span class="comment"># 内存与寄存器之间的移动需要计算地址加偏移量，所以将valC作操作数</span></span><br><span class="line">    icode <span class="keyword">in</span> &#123;ICALL,IPUSHQ&#125; : <span class="number">-8</span>;</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IRET,IPOPQ&#125; : <span class="number">8</span>;</span><br><span class="line">    <span class="comment"># 这几个指令涉及对栈地址的计算，以8为单位进行增减，需要用到ALU计算</span></span><br><span class="line">]; <span class="comment"># 辅助操作数</span></span><br><span class="line"></span><br><span class="line">word aluB = [</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IRMMOVQ,IOPQ&#125; : valB;</span><br><span class="line">    <span class="comment"># 寄存器rB的值直接做操作数或需要做地址运算</span></span><br><span class="line">    icode <span class="keyword">in</span> &#123;IMRMOVQ&#125; : valA;</span><br><span class="line">    <span class="comment"># 寄存器rA的值需要做地址运算</span></span><br><span class="line">    icode <span class="keyword">in</span> &#123;ICALL,IRET,IPUSHQ,IPOPQ&#125; : valB;</span><br><span class="line">    <span class="comment"># 这些时候valB的值是%rsp寄存器的值，作为栈基址操作数</span></span><br><span class="line">    icode <span class="keyword">in</span> &#123;IIRMOVQ,IRRMOVQ&#125; : <span class="number">0</span>;</span><br><span class="line">    <span class="comment"># 保留aluA的值不受操作影响</span></span><br><span class="line">]; <span class="comment"># 主操作数</span></span><br><span class="line"></span><br><span class="line">word alufun = [</span><br><span class="line">    icode == IOPQ : ifun;</span><br><span class="line">    <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="comment"># 除了在使用IPOQ指令时，所有时候ALU都是当加法器用的，其对应的alufun值为1</span></span><br><span class="line">]; <span class="comment"># 操作类型</span></span><br><span class="line"></span><br><span class="line">bool set_cc = icode <span class="keyword">in</span> &#123;IOPQ&#125;;</span><br><span class="line"><span class="comment"># 如果指令是IOPQ，还要设置条件码</span></span><br><span class="line"></span><br><span class="line">int cc = ALU.calculate(aluA,aluB,func=alufun);</span><br><span class="line"><span class="comment"># ALU进行运算并返回条件码</span></span><br><span class="line"><span class="keyword">if</span> set_cc:</span><br><span class="line">    CC.set(cc);</span><br><span class="line">    <span class="comment"># 设置条件码</span></span><br><span class="line">bool Cnd = COND.gencnd(CC.get())</span><br><span class="line"><span class="comment"># 生成Cnd信号，传输给写回阶段</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访存</span></span><br><span class="line"></span><br><span class="line">word mem_addr = [</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IRMMOVQ,IMRMOVQ,ICALL,IMRMOVQ&#125; : valE;</span><br><span class="line">    <span class="comment"># 正常状态的地址都要经过ALU的计算成为valE</span></span><br><span class="line">    icode <span class="keyword">in</span> &#123;IRET,IPOPQ&#125; : valA;</span><br><span class="line">    <span class="comment"># 这边是与译码部分联系</span></span><br><span class="line">]; <span class="comment"># 确定内存访问的地址</span></span><br><span class="line"></span><br><span class="line">bool mem_read = icode <span class="keyword">in</span> &#123;IMRMOVQ,IPOPQ,IRET&#125;;</span><br><span class="line">bool mem_write = icode <span class="keyword">in</span> &#123;IRMMOVQ,IPUSHQ,ICALL&#125;;</span><br><span class="line"><span class="comment"># 确定指令要求的访存方式是读还是写</span></span><br><span class="line"></span><br><span class="line">word mem_data = [</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IRMMOVQ,IPUSHQ&#125; : valA;</span><br><span class="line">    <span class="comment"># 从寄存器中获取写入值</span></span><br><span class="line">    icode == ICALL : valP;</span><br><span class="line">    <span class="comment"># CALL指令要写入的是返回地址，也就是下一条指令的地址valP。</span></span><br><span class="line">]; <span class="comment"># 确定读写的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> mem_read:</span><br><span class="line">        valM = MEM.read(baseptr=mem_addr,size=<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> mem_write:</span><br><span class="line">        MEM.write(baseptr=mem_addr,data=mem_data);</span><br><span class="line">    <span class="comment"># 读写数据</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    bool dmem_error = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">word stat = [</span><br><span class="line">    imem_error || dmem_error : SADR;</span><br><span class="line">    !instr_valid : SINS;</span><br><span class="line">    icode == IHALT : SHLT;</span><br><span class="line">    <span class="number">1</span> : SAOK;</span><br><span class="line">];</span><br><span class="line">STAT.set(stat);</span><br><span class="line"><span class="comment"># 判断程序运行状态并更新状态码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写回</span></span><br><span class="line"></span><br><span class="line">word dstE = [</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IIRMOVQ,IOPQ&#125; : rB</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IRRMOVQ&#125; &amp;&amp; Cnd : rB</span><br><span class="line">    <span class="comment"># 这里要包含一下条件传送的情况</span></span><br><span class="line">    icode <span class="keyword">in</span> &#123;IPUSHQ,IPOPQ,ICALL,IRET&#125; : RRSP</span><br><span class="line">    <span class="number">1</span> : RNONE</span><br><span class="line">] <span class="comment"># 需要写入计算结果时</span></span><br><span class="line"></span><br><span class="line">word dstM = [</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IMRMOVQ&#125; : rB</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IPOPQ&#125; : rA</span><br><span class="line">    <span class="number">1</span> : RNONE</span><br><span class="line">] <span class="comment"># 需要写入访存结果时</span></span><br><span class="line"></span><br><span class="line">REG.write(dstE,data=valE);</span><br><span class="line">REG.write(dstM,data=valM);</span><br><span class="line"><span class="comment"># 进行写回</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新PC</span></span><br><span class="line"></span><br><span class="line">word new_pc = [</span><br><span class="line">    icode == ICALL : valC;</span><br><span class="line">    <span class="comment"># 调用函数则直接跳到函数起始地址</span></span><br><span class="line">    icode == IJXX &amp;&amp; Cnd : valC;</span><br><span class="line">    <span class="comment"># 条件跳转需要判断条件</span></span><br><span class="line">    icode == IRET : valM;</span><br><span class="line">    <span class="comment"># 读取返回地址</span></span><br><span class="line">    <span class="number">1</span> : valP;</span><br><span class="line">    <span class="comment"># 正常情况下就到下一句指令</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">PC.set(new_pc);</span><br><span class="line"><span class="comment"># 更新PC</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指令执行完毕，回到开头，开始执行下一条指令...</span></span><br></pre></td></tr></table></figure></p>
<h2 id="流水线化原理"><a href="#流水线化原理" class="headerlink" title="流水线化原理"></a>流水线化原理</h2><p>流水线化的重要优点就是增加了系统的 <strong>吞吐量</strong> ，也就是单位时间内能够服务顾客的数量；但缺点是会稍稍增加对单独顾客的 <strong>延迟(处理某一阶段需要的时间)</strong> ，因为每个顾客都要经历每个步骤，不管它需不需要某些步骤。</p>
<p>在硬件设计中，只需要将整个过程划分为数个步骤，在每两个步骤之间插入储存中间结果的寄存器，就可以实现SEQ的流水线化。</p>
<h3 id="流水线化的局限性"><a href="#流水线化的局限性" class="headerlink" title="流水线化的局限性"></a>流水线化的局限性</h3><ul>
<li>不一致的划分<ul>
<li>如果流水线上的几个步骤所需要的延迟差距较大，由于流水线的时钟周期必须适应延迟最长的那个步骤，整个流水线的效率都会被拖慢，造成很大的资源浪费。</li>
<li>对硬件设计来说，划分延迟相差不大的阶段是一件比较难的事。</li>
</ul>
</li>
<li>流水线过深的惩罚<ul>
<li>比起顺序执行，流水线化执行需要在它划分的每两个阶段之间插入一组流水线寄存器，以储存中间结果。在这组寄存器上的读写也会产生延迟，而当流水线过深(也就是划分阶段过多)时，这些延迟会拖慢整体的吞吐量。</li>
<li>为了减轻这个惩罚，现在的流水线寄存器延迟已经很小。</li>
</ul>
</li>
</ul>
<h3 id="带反馈的流水线化系统"><a href="#带反馈的流水线化系统" class="headerlink" title="带反馈的流水线化系统"></a>带反馈的流水线化系统</h3><p>对于条件控制的条件码处理，以及PC的更新和寄存器的更新，这些都属于 <strong>反馈路径</strong> ，每一条指令产生的变化都会反馈给下一条指令。</p>
<p>然而在流水线系统中，这个处理会带来危险。我们知道由于流水线化的进行，每个阶段执行的时候与它同时执行的前一个阶段就不是它所在指令的阶段，而是后一个指令的阶段了。这样如果仍然使用原来的反馈机制，就会导致一个指令的反馈信息反馈到了之后的指令那里。</p>
<h3 id="设计流水线化的Y86-64处理器"><a href="#设计流水线化的Y86-64处理器" class="headerlink" title="设计流水线化的Y86-64处理器"></a>设计流水线化的Y86-64处理器</h3><ul>
<li>重新安排计算阶段<ul>
<li>为了避免反馈机制被流水线化干扰，有必要调整一下各个阶段的内容与顺序。</li>
<li>一个可能的改进是移动计算PC阶段，使其在一个时钟周期的开始时作用而不是在时钟周期结束。在每个时钟周期开始时，根据状态寄存器中的值动态地计算PC值。<br><img src="/blog//dracit7.github.io/blog/2018/04/12/Note of CSAPP/Chapter_4/SEQ+.png" alt="SEQ+示意图"></li>
<li>这种策略称为 <strong>电路重定时</strong> ，它是指在不改变电路逻辑的情况下调整一个系统的状态表示。电路重定时通常用来平衡流水线各阶段之间的延迟。</li>
</ul>
</li>
<li>插入流水线寄存器<ul>
<li>在各个阶段之间插入流水线寄存器并对信号重新排列，得到PIPE-处理器结构。<br><img src="/blog//dracit7.github.io/blog/2018/04/12/Note of CSAPP/Chapter_4/PIPE-.png" alt="PIPE-示意图"></li>
<li>五个流水线寄存器的职能<ul>
<li>F 保存程序计数器的预测值</li>
<li>D 保存icode,ifun,rA,rB,valC,valP等指令信息</li>
<li>E 保存从寄存器文件中读出的值及计算得出的srcA、srcB、dstE、dstM信息，传递icode,ifun,valC信息</li>
<li>M 保存计算结果valE与状态码Cnd，传递icode，dstE，dstM信息</li>
<li>W 保存将要写回寄存器的valE和valM以及写回地址dstE和dstM<ul>
<li>将dstE和dstM一直传递到这一步的目的是保证写回地址和写回数据匹配。</li>
</ul>
</li>
</ul>
</li>
<li>在流水线化系统的一个时钟周期中，状态码的值stat是随时会变化的。这要求我们仔细地处理stat的值。对于寄存器中储存的stat值，我们使用D_stat,E_stat,M_stat,W_stat来表示；对于阶段中的stat值，我们改用小写字母前缀表示。</li>
</ul>
</li>
<li>PC值的预测<ul>
<li>除了条件转移类指令和ret指令，我们都可以在解析一条指令的同时准确地得知PC的下一个值，从而在下一个阶段PC读入新一条指令之前更新PC的值。因此，通过预测PC值，大部分指令都可以做到每个时钟周期发射一条指令。<ul>
<li>对于条件转移类指令，根据条件码PC既有可能是valC(跳转),又有可能是valP(不跳转)。因此，如果预测发生错误，我们需要设计完善的修正错误的机制。</li>
<li>猜测分支的方向并根据猜测取指的技术称为 <strong>分支预测</strong> 。PIPE-简化了预测过程，即我们总是预测将要将valC作为PC的新值。<ul>
<li>由于分支预测发生错误会极大影响程序性能，<strong>条件传送</strong> 一般比 <strong>条件跳转</strong> 要更好一些。</li>
</ul>
</li>
<li>对于ret指令，由于PC的新值有近乎无限种可能性，我们放弃预测，转而暂停流水线的运行直到PC的值有确定的结果。<ul>
<li>在一些硬件设计中，会有一个程序员不可见的硬件栈，它在每次函数call的时候将返回地址压栈，而在每次ret指令时从栈顶弹出一个地址作为新的PC值。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Streamline Hazard<ul>
<li>根据相邻指令之间的反馈方式，Hazard可以分为Data Hazard和Control Hazard两类。</li>
<li>Data Hazard<ul>
<li>Data Hazard的类型<ul>
<li>寄存器：一条指令要改变某个寄存器，但在写回阶段之前另一条指令读取了该寄存器的值。</li>
<li>程序计数器：错误的预测和ret的影响</li>
<li>内存：如果程序在访存阶段修改代码部分内存，会引起之后的指令取指出错。我们简单地禁止程序修改自身代码段来避免这种情况。除此之外，由于内存读写发生在同一阶段，不同指令之间不会发生冲突。</li>
<li>条件码寄存器：不会发生Hazard。</li>
<li>状态寄存器stat：采用多状态码机制。</li>
</ul>
</li>
<li>如何避免Data Hazard的发生<ul>
<li>Stalling(暂停)：暂停一条或多条指令(通过插入bubble)，直到Hazard的条件不再满足。</li>
<li>Forwarding(转发)：对于某些情况，可以直接将将要写回寄存器的结果转发至另一条指令的读寄存器端口。这样可以大幅减少需要的暂停时间。</li>
<li>load interlock：将暂停和转发技术合理地结合起来，基本可以实现高吞吐量。<br><img src="/blog//dracit7.github.io/blog/2018/04/12/Note of CSAPP/Chapter_4/PIPE.png" alt="PIPE示意图"></li>
</ul>
</li>
</ul>
</li>
<li>Control Hazard<ul>
<li>当处理器无法通过取指阶段的指令去预测下一个指令的地址时会发生控制冒险。</li>
<li>Control Hazard的处理措施<ul>
<li>ret：使用Stalling策略</li>
<li>jxx：使用Cancel策略。设当前指令为指令1,则它在执行阶段就可以通过状态码CC的设置判断之前的预测是否发生了失误。如果发生失误，由于指令2和指令3还分别在译码和取指阶段而没有进行任何数据写操作，它们对程序状态其实是没有影响的。于是，我们重新设定PC值，并用bubble取代指令2和指令3剩余的阶段，以消除错误带来的影响。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h3><ul>
<li>在Y86-64处理器模型中，我们主要处理三种内部异常：<ul>
<li>halt指令</li>
<li>由非法指令和有非法功能码组合的指令引起的异常</li>
<li>取指和数据读写使用了非法地址</li>
</ul>
</li>
</ul>
<p>引起异常的指令称为 <strong>异常指令</strong> 。在异常触发之后，一个完整设计过的操作系统会调用异常处理程序，但在简化模型中处理器会直接停止并设置状态码。</p>
<p>对于优先级问题，在流水线中位置最深的指令引发的异常优先级最高。</p>
<p>当处于访存或者写回阶段的指令引发异常时，流水线控制逻辑应当立即禁止处理器或内存的更新。</p>
<h3 id="控制逻辑"><a href="#控制逻辑" class="headerlink" title="控制逻辑"></a>控制逻辑</h3><p>处理器的控制逻辑处理其他机制无法处理的四种情况：</p>
<ul>
<li>Data Hazard</li>
<li>ret语句</li>
<li>预测失误</li>
<li>异常</li>
</ul>
<p>处理它们的主要方式是插入气泡(bubble)，也就是将某些步骤的icode设置为INOP，并用RNONE填充流水线寄存器；以及暂停(stalling)，就是禁止流水线寄存器更新状态以将指令阻塞在某个阶段。</p>
<p>控制逻辑机制</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>条件</th>
<th>F</th>
<th>D</th>
<th>E</th>
<th>M</th>
<th>W</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>处理ret语句</td>
<td>Stall</td>
<td>Bubble</td>
<td>-&gt;</td>
<td>-&gt;</td>
<td>-&gt;</td>
</tr>
<tr>
<td>2</td>
<td>Regid/Memory Hazard</td>
<td>Stall</td>
<td>Stall</td>
<td>Bubble</td>
<td>-&gt;</td>
<td>-&gt;</td>
</tr>
<tr>
<td>3</td>
<td>预测错误的分支(E中发现)</td>
<td>-&gt;</td>
<td>Bubble</td>
<td>Bubble</td>
<td>-&gt;</td>
<td>-&gt;</td>
</tr>
<tr>
<td>4</td>
<td>1,3的组合情况(同时)</td>
<td>Stall</td>
<td>Bubble</td>
<td>Bubble</td>
<td>-&gt;</td>
<td>-&gt;</td>
</tr>
</tbody>
</table>
<h2 id="完整的Y86-64流水线化处理器"><a href="#完整的Y86-64流水线化处理器" class="headerlink" title="完整的Y86-64流水线化处理器"></a>完整的Y86-64流水线化处理器</h2><h3 id="PIPE的HCL实现"><a href="#PIPE的HCL实现" class="headerlink" title="PIPE的HCL实现"></a>PIPE的HCL实现</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以发现PIPE的实现与SEQ是大部分一致的，只是在信号前加入了前缀</span></span><br><span class="line"><span class="comment"># 大写的前缀代表寄存器中的值，小写的前缀代表产生的信号</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>取指和PC Selection</span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制逻辑，对于F阶段只有Stall的可能</span></span><br><span class="line"></span><br><span class="line">bool F_stall = </span><br><span class="line">    <span class="comment"># 寄存器/内存 Hazard</span></span><br><span class="line">    E_icode <span class="keyword">in</span> &#123;IMRMOVQ,IPOPQ&#125; &amp;&amp; E_dstM <span class="keyword">in</span> &#123;d_srcA,d_srcB&#125; || </span><br><span class="line">    IRET    <span class="keyword">in</span> &#123;D_icode,E_icode,M_icode&#125;; <span class="comment"># RET指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析阶段，与SEQ基本没有区别</span></span><br><span class="line"></span><br><span class="line">word p = PC.read(); <span class="comment"># 读出PC中的值</span></span><br><span class="line"><span class="keyword">if</span> p == SADR：</span><br><span class="line">    word f_ins = INOP;</span><br><span class="line">    bool imem_error = <span class="number">1</span>;</span><br><span class="line">    <span class="comment"># 如果PC中储存的地址不合法，产生imem_error信号并将指令设置为nop</span></span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">    word f_ins = MEM.read(baseptr=p,size=<span class="number">10</span>); <span class="comment"># 以p为基址在内存中读出10个字节</span></span><br><span class="line">    int f_icode,f_ifun = SPLIT.split(ins[<span class="number">0</span>]); <span class="comment"># 指令的第一个字节被split硬件单元解析</span></span><br><span class="line">    bool instr_valid = ***;</span><br><span class="line">    <span class="comment"># 这个判断就是依次判断每个可能的icode对应的ifun是否符合，过于长这里不写了</span></span><br><span class="line">    bool need_regids = </span><br><span class="line">        icode <span class="keyword">in</span> &#123;IRRMOVQ,IIRMOVQ,IMRMOVQ,IRMMOVQ,IOPQ,IPUSHQ,IPOPQ&#125;;</span><br><span class="line">    bool need_valC = </span><br><span class="line">        icode <span class="keyword">in</span> &#123;IIRMOVQ,IMRMOVQ,IRMMOVQ,IJXX,ICALL&#125;;</span><br><span class="line">    <span class="comment"># 这两个判断看一下哪些指令需要常数字段和寄存器字段就好了</span></span><br><span class="line">    <span class="keyword">if</span> need_regids：</span><br><span class="line">        int f_rA,f_rB = ALIGN.align(ins[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> need_valC：</span><br><span class="line">            word f_valC = ALIGN.align(ins[<span class="number">2</span>:<span class="number">10</span>]);</span><br><span class="line">        <span class="comment"># 如果指令需要寄存器就从第二个字节中读出</span></span><br><span class="line">        <span class="comment"># valC同理，都由align硬件单元读出</span></span><br><span class="line">    <span class="keyword">else</span>：</span><br><span class="line">        int f_rA = <span class="number">0xF</span>;</span><br><span class="line">        int f_rB = <span class="number">0xF</span>;</span><br><span class="line">        <span class="keyword">if</span> need_valC：</span><br><span class="line">            word f_valC = ALIGN.align(ins[<span class="number">1</span>:<span class="number">9</span>]);</span><br><span class="line">        <span class="comment"># 反之，如果不需要寄存器就将两个寄存器值都设为0xF，即无寄存器</span></span><br><span class="line">        <span class="comment"># 这样valC就会存放在指令的2到9字节。</span></span><br><span class="line">    word f_valP = p + need_regids + <span class="number">8</span>*need_valC;</span><br><span class="line">    <span class="comment"># valP代表下一条指令的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于PC值的运算</span></span><br><span class="line"></span><br><span class="line">word f_predPC = [</span><br><span class="line">    f_icode <span class="keyword">in</span> &#123;ICALL,IJXX&#125; : f_valC</span><br><span class="line">    <span class="number">1</span> : f_valP</span><br><span class="line">]; <span class="comment"># 预测PC的值</span></span><br><span class="line"></span><br><span class="line">f_predPC =&gt; F_predPC # 将预测结果存入流水线寄存器F</span><br><span class="line"></span><br><span class="line">word f_pc = [</span><br><span class="line">    M_icode == IJXX &amp;&amp; !M_Cnd : M_valA; <span class="comment"># 预测发生错误的情况，根据M寄存器储存的值判断</span></span><br><span class="line">    W_icode == IRET : W_valM; <span class="comment"># ret指令</span></span><br><span class="line">    <span class="number">1</span> : F_predPC <span class="comment"># 大多数情况，预测模块给出的值都是正确的</span></span><br><span class="line">]; <span class="comment"># 确定PC的值，为取出下一条指令作准备</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 信号的传递</span></span><br><span class="line"></span><br><span class="line">f_icode =&gt; D_icode</span><br><span class="line">f_ifun =&gt; D_ifun</span><br><span class="line">F_stat += (imem_error,instr_valid) =&gt; D_stat</span><br><span class="line">f_rA =&gt; D_rA</span><br><span class="line">f_rB =&gt; D_rB</span><br><span class="line">f_valC =&gt; D_valC</span><br><span class="line">f_valP =&gt; D_valP</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>译码和写回</span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制逻辑，这里可能会发生Stall或Bubble</span></span><br><span class="line"></span><br><span class="line">bool D_stall = E_icode <span class="keyword">in</span> &#123;IMRMOVQ,IPOPQ&#125; &amp;&amp; E_dstM <span class="keyword">in</span> &#123;d_srcA,d_srcB&#125;;</span><br><span class="line"></span><br><span class="line">bool D_bubble = (E_icode == IJXX &amp;&amp; !e_Cnd) || <span class="comment"># 预测出现失误的情况</span></span><br><span class="line">               !(E_icode <span class="keyword">in</span> &#123;IMRMOVQ,IPOPQ&#125; &amp;&amp; E_dstM <span class="keyword">in</span> &#123;d_srcA,d_srcB&#125;) &amp;&amp; IRET <span class="keyword">in</span> &#123;D_icode,E_icode,M_icode&#125;; <span class="comment"># 处理RET指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 译码部分与SEQ大部分一致</span></span><br><span class="line"></span><br><span class="line">word d_srcA = [</span><br><span class="line">    D_icode <span class="keyword">in</span> &#123;IRRMOVQ,IRMMOVQ,IOPQ,IPUSHQ&#125; : D_rA;</span><br><span class="line">    D_icode <span class="keyword">in</span> &#123;IPOPQ,IRET&#125; : RRSP;</span><br><span class="line">    <span class="number">1</span> : RNONE;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">word d_srcB = [</span><br><span class="line">    D_icode <span class="keyword">in</span> &#123;IRMMOVQ,IOPQ&#125; : D_rB;</span><br><span class="line">    D_icode <span class="keyword">in</span> &#123;IPUSHQ,IPOPQ,ICALL,IRET&#125; : RRSP;</span><br><span class="line">    <span class="number">1</span> : RNONE;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">word d_dstE = [</span><br><span class="line">    D_icode <span class="keyword">in</span> &#123;IIRMOVQ,IOPQ,IRRMOVQ&#125; : D_rB;</span><br><span class="line">    D_icode <span class="keyword">in</span> &#123;IPUSHQ,IPOPQ,ICALL,IRET&#125; : RRSP</span><br><span class="line">    <span class="number">1</span> : RNONE</span><br><span class="line">]; <span class="comment"># 写回阶段的地址计算放在了译码阶段</span></span><br><span class="line"></span><br><span class="line">word d_dstM = [</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IMRMOVQ&#125; : D_rB</span><br><span class="line">    icode <span class="keyword">in</span> &#123;IPOPQ&#125; : D_rA</span><br><span class="line">    <span class="number">1</span> : RNONE</span><br><span class="line">]; <span class="comment"># 初步的地址计算</span></span><br><span class="line"></span><br><span class="line">word d_rvalA = REG.read(d_srcA);</span><br><span class="line">word d_rvalB = REG.read(d_srcB);</span><br><span class="line"><span class="comment"># 由于PIPE对valA和valP有个合并机制，这里读出的并不是最终的valA</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并信号valA和valP的依据是，只有call和跳转指令需要valP的值，而它们都不会需要valA</span></span><br><span class="line"><span class="comment"># 在这个阶段要处理数据转发，转发源有五个，需要分情况讨论</span></span><br><span class="line"></span><br><span class="line">word d_valA = [</span><br><span class="line">    D_icode <span class="keyword">in</span> &#123;IJXX,ICALL&#125; : D_valP;</span><br><span class="line">    d_srcA == e_dstE : e_valE;</span><br><span class="line">    <span class="comment"># Forwarding，直接接受上一条指令execute阶段的计算结果</span></span><br><span class="line">    d_srcA == M_dstM : m_valM;</span><br><span class="line">    <span class="comment"># Forwarding，接受上上条指令memory阶段的读内存结果</span></span><br><span class="line">    d_srcA == M_dstE : M_valE;</span><br><span class="line">    <span class="comment"># Forwarding，接受上上条指令memory阶段进行前还未写回的计算结果</span></span><br><span class="line">    d_srcA == W_dstM : W_valM;</span><br><span class="line">    d_srcA == W_dstE : W_valE;</span><br><span class="line">    <span class="comment"># Forwarding，接受上上上条指令在写回之前W寄存器中储存的访存和计算结果</span></span><br><span class="line">    <span class="number">1</span> : d_rvalA;</span><br><span class="line">    <span class="comment"># 没有Forwarding，直接采取寄存器中读出的valA</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">word d_valB = [</span><br><span class="line">    d_srcB == e_dstE : e_valE;</span><br><span class="line">    <span class="comment"># Forwarding，直接接受上一条指令execute阶段的计算结果</span></span><br><span class="line">    d_srcB == M_dstM : m_valM;</span><br><span class="line">    <span class="comment"># Forwarding，接受上上条指令memory阶段的读内存结果</span></span><br><span class="line">    d_srcB == M_dstE : M_valE;</span><br><span class="line">    <span class="comment"># Forwarding，接受上上条指令memory阶段进行前还未写回的计算结果</span></span><br><span class="line">    d_srcB == W_dstM : W_valM;</span><br><span class="line">    d_srcB == W_dstE : W_valE;</span><br><span class="line">    <span class="comment"># Forwarding，接受上上上条指令在写回之前W寄存器中储存的访存和计算结果</span></span><br><span class="line">    <span class="number">1</span> : d_rvalB;</span><br><span class="line">    <span class="comment"># 没有Forwarding，直接采取寄存器中读出的valA</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment"># 信号传递</span></span><br><span class="line"></span><br><span class="line">D_stat =&gt; E_stat</span><br><span class="line">d_icode =&gt; E_icode</span><br><span class="line">d_ifun =&gt; E_ifun</span><br><span class="line">d_valC =&gt; E_valC</span><br><span class="line">d_valA =&gt; E_valA</span><br><span class="line">d_valB =&gt; E_valB</span><br><span class="line">d_srcA,d_srcB,d_dstE,d_dstM =&gt; E_srcA,E_srcB,E_dstE,E_dstM</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>执行</span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制逻辑，只会出现Bubble</span></span><br><span class="line"></span><br><span class="line">bool E_bubble = E_icode <span class="keyword">in</span> &#123;IMRMOVQ,IPOPQ&#125; &amp;&amp; E_dstM <span class="keyword">in</span> &#123;d_srcA,d_srcB&#125; ||</span><br><span class="line">                (E_icode == IJXX &amp;&amp; !e_Cnd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这部分实现基本与SEQ无异</span></span><br><span class="line"></span><br><span class="line">word e_aluA = [</span><br><span class="line">    E_icode <span class="keyword">in</span> &#123;IRRMOVQ,IOPQ&#125; : E_valA;</span><br><span class="line">    <span class="comment"># 寄存器rA的值直接作操作数</span></span><br><span class="line">    E_icode <span class="keyword">in</span> &#123;IIRMOVQ,IMRMOVQ,IRMMOVQ&#125; : E_valC;</span><br><span class="line">    <span class="comment"># 内存与寄存器之间的移动需要计算地址加偏移量，所以将valC作操作数</span></span><br><span class="line">    E_icode <span class="keyword">in</span> &#123;ICALL,IPUSHQ&#125; : <span class="number">-8</span>;</span><br><span class="line">    E_icode <span class="keyword">in</span> &#123;IRET,IPOPQ&#125; : <span class="number">8</span>;</span><br><span class="line">    <span class="comment"># 这几个指令涉及对栈地址的计算，以8为单位进行增减，需要用到ALU计算</span></span><br><span class="line">]; <span class="comment"># 辅助操作数</span></span><br><span class="line"></span><br><span class="line">word e_aluB = [</span><br><span class="line">    E_icode <span class="keyword">in</span> &#123;IRMMOVQ,IOPQ&#125; : E_valB;</span><br><span class="line">    <span class="comment"># 寄存器rB的值直接做操作数或需要做地址运算</span></span><br><span class="line">    E_icode <span class="keyword">in</span> &#123;IMRMOVQ&#125; : E_valA;</span><br><span class="line">    <span class="comment"># 寄存器rA的值需要做地址运算</span></span><br><span class="line">    E_icode <span class="keyword">in</span> &#123;ICALL,IRET,IPUSHQ,IPOPQ&#125; : E_valB;</span><br><span class="line">    <span class="comment"># 这些时候valB的值是%rsp寄存器的值，作为栈基址操作数</span></span><br><span class="line">    E_icode <span class="keyword">in</span> &#123;IIRMOVQ,IRRMOVQ&#125; : <span class="number">0</span>;</span><br><span class="line">    <span class="comment"># 保留aluA的值不受操作影响</span></span><br><span class="line">]; <span class="comment"># 主操作数</span></span><br><span class="line"></span><br><span class="line">word e_alufun = [</span><br><span class="line">    E_icode == IOPQ : E_ifun;</span><br><span class="line">    <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="comment"># 除了在使用IPOQ指令时，所有时候ALU都是当加法器用的，其对应的alufun值为1</span></span><br><span class="line">]; <span class="comment"># 操作类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置条件码，这里要小心异常触发的情况</span></span><br><span class="line"></span><br><span class="line">bool set_CC = </span><br><span class="line">    !(m_stat <span class="keyword">in</span> &#123;SADR,SINS,SHLT&#125;) &amp;&amp;</span><br><span class="line">    !(W_stat <span class="keyword">in</span> &#123;SADR,SINS,SHLT&#125;) &amp;&amp;</span><br><span class="line">    E_icode == IOPQ ;</span><br><span class="line"><span class="comment"># 如果memory和writeback阶段的指令触发了异常，任何对条件码的修改都应该中止。</span></span><br><span class="line"></span><br><span class="line">word e_valE, int cc = ALU.calculate(e_aluA,e_aluB,func=e_alufun);</span><br><span class="line"><span class="keyword">if</span> set_cc:</span><br><span class="line">    CC.set(cc);</span><br><span class="line">bool e_Cnd = COND.gencnd(CC.get());</span><br><span class="line"><span class="comment"># 进行计算，设置条件码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 信号传输</span></span><br><span class="line"></span><br><span class="line">E_stat =&gt; M_stat</span><br><span class="line">e_icode =&gt; M_icode</span><br><span class="line">e_Cnd =&gt; M_Cnd</span><br><span class="line">e_valE =&gt; M_valE</span><br><span class="line">E_valA =&gt; M_valA</span><br><span class="line">e_dstE =&gt; M_dstE</span><br><span class="line">E_dstM =&gt; M_dstM</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>访存</span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制逻辑，这部分需要处理异常</span></span><br><span class="line"></span><br><span class="line">bool M_bubble = m_stat <span class="keyword">in</span> &#123;SADR,SINS,SHLT&#125; || W_stat <span class="keyword">in</span> &#123;SADR,SINS,SHLT&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这一部分与SEQ相同</span></span><br><span class="line"></span><br><span class="line">word mem_addr = [</span><br><span class="line">    M_icode <span class="keyword">in</span> &#123;IRMMOVQ,IMRMOVQ,ICALL,IMRMOVQ&#125; : M_valE;</span><br><span class="line">    M_icode <span class="keyword">in</span> &#123;IRET,IPOPQ&#125; : M_valA;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bool mem_read = M_icode <span class="keyword">in</span> &#123;IMRMOVQ,IPOPQ,IRET&#125;;</span><br><span class="line">bool mem_write = M_icode <span class="keyword">in</span> &#123;IRMMOVQ,IPUSHQ,ICALL&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确定读写数据的步骤被省略了，因为之前已经将valA和valP进行了merge操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> mem_read:</span><br><span class="line">        m_valM = MEM.read(baseptr=mem_addr,size=<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> mem_write:</span><br><span class="line">        MEM.write(baseptr=mem_addr,data=M_valA);</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    bool dmem_error = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 信号传输</span></span><br><span class="line"></span><br><span class="line">m_stat += dmem_eroor =&gt; W_stat</span><br><span class="line">M_icode =&gt; W_icode</span><br><span class="line">M_valE =&gt; W_valE</span><br><span class="line">m_valM =&gt; W_valM</span><br><span class="line">M_dstE =&gt; W_dstE</span><br><span class="line">M_dstM =&gt; W_dstM</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>写回</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在下一个时钟周期开始之前，handle一下异常</span></span><br><span class="line"></span><br><span class="line">bool W_stall = W_stat <span class="keyword">in</span> &#123;SADR,SINS,SHLT&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h3><p><img src="/blog//dracit7.github.io/blog/2018/04/12/Note of CSAPP/Chapter_4/memory.png" alt="memory"><br><img src="/blog//dracit7.github.io/blog/2018/04/12/Note of CSAPP/Chapter_4/execute.png" alt="execute"><br><img src="/blog//dracit7.github.io/blog/2018/04/12/Note of CSAPP/Chapter_4/decode.png" alt="decode"><br><img src="/blog//dracit7.github.io/blog/2018/04/12/Note of CSAPP/Chapter_4/fetch.png" alt="fetch"><br><img src="/blog//dracit7.github.io/blog/2018/04/12/Note of CSAPP/Chapter_4/control.png" alt="control"></p>
<h2 id="改进的空间"><a href="#改进的空间" class="headerlink" title="改进的空间"></a>改进的空间</h2><ul>
<li>多周期指令<ul>
<li>整数乘法需要3-4个时钟周期完成，而整数除法更是需要64个周期。对于这样的多周期操作，必须调整流水线的设计以适应其运行时间。</li>
</ul>
</li>
<li>与存储系统的接口<ul>
<li>在PIPE设计中，我们假设取指单元和数据内存的读写都可以在一个时钟周期内完成(但这显然是不可能的)。</li>
<li>通过高速缓存和翻译后备缓冲器(将物理地址翻译为虚拟地址)，可以将数据内存读写的速度尽可能降低到一个时钟周期以内。</li>
<li>对于高速缓存不命中和pagefault异常触发等问题，可以使用stall来等待数据就位。</li>
</ul>
</li>
</ul>
<h1 id="Chapter-5-优化程序性能"><a href="#Chapter-5-优化程序性能" class="headerlink" title="Chapter 5 优化程序性能"></a>Chapter 5 优化程序性能</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><ul>
<li>编写高效程序的要素<ul>
<li>合适的算法和数据结构</li>
<li>写出适于编译器优化的代码<ul>
<li>不同的语言优化的难度是不同的，越灵活的语言越是难以优化。</li>
<li>程序员应当在代码性能和代码可读性之间作出权衡。</li>
</ul>
</li>
<li>使用并行计算的策略</li>
</ul>
</li>
</ul>
<h2 id="编译器优化的局限性"><a href="#编译器优化的局限性" class="headerlink" title="编译器优化的局限性"></a>编译器优化的局限性</h2><h3 id="编译器的优化级别"><a href="#编译器的优化级别" class="headerlink" title="编译器的优化级别"></a>编译器的优化级别</h3><p>编译器会对其在编译过程中做的优化工作量做一个分级。以GCC为例，参数-Og表示使用基本的优化，-O1到-O3则代表着越来越大的优化量。</p>
<p>优化量越大，程序的效率一般会越高，但程序和源程序的差距也越大，越难以调试。企业采用的优化标准一般是-O2级，本书采用的级别是-O1.</p>
<h3 id="保证优化的安全性"><a href="#保证优化的安全性" class="headerlink" title="保证优化的安全性"></a>保证优化的安全性</h3><p>为了避免优化前后程序的行为出现差异，编译器被限制为只能做出“安全”的优化。这就意味着编译器能做的改动更小，程序员的优化显得更为重要。</p>
<p>不安全的优化大致有以下几种：</p>
<h4 id="Memory-aliasing"><a href="#Memory-aliasing" class="headerlink" title="Memory aliasing"></a>Memory aliasing</h4><p>在对指针的目标值进行操作的过程中，可能出现两个指针指向同一个内存地址的情况，这种状况称为 <strong>内存别名使用(Memory aliasing)</strong> 。编译器必须假设两个不同的指针可能指向同一位置，这就大大限制了可以作出的优化。</p>
<p>例如，执行下面代码段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*ptr1 = <span class="number">3000</span>;</span><br><span class="line">*ptr2 = <span class="number">1000</span>;</span><br><span class="line">x = *ptr1;</span><br></pre></td></tr></table></figure>
<p>如果两个指针指向不同的位置，那么x无疑等于3000,但如果反之，由于逻辑顺序，x等于1000。考虑到可能出现二义性的后果，编译器不能产生类似这样的代码段(除非源程序有意为之)。</p>
<h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>同一个函数，以同样的参数调用，其返回的值可能不同，这是过程式语言的一大弱点，即所谓的side effect。这就导致了，编译器无法把以几次函数调用的返回值为操作数的多次操作化简为一次操作，比如不能把<code>f()+f()</code>化简为<code>2*f()</code>。</p>
<h2 id="度量程序的性能"><a href="#度量程序的性能" class="headerlink" title="度量程序的性能"></a>度量程序的性能</h2><p>对于线性类复杂度的程序，我们引入 <strong>每元素周期数(CPE)</strong> 作为度量标准。每元素周期数指的是输入每增加一个元素，程序所多消耗的时钟周期数。本质上讲，也就是复杂度公式中n项的参数。</p>
<h2 id="对循环过程进行的优化"><a href="#对循环过程进行的优化" class="headerlink" title="对循环过程进行的优化"></a>对循环过程进行的优化</h2><h3 id="代码移动"><a href="#代码移动" class="headerlink" title="代码移动"></a>代码移动</h3><p>将在循环过程中结果不会改变的操作移到循环外进行，这个过程称为 <strong>代码移动(code motion)</strong> 。编译器在遇到函数调用或内存访问的情况下不敢进行代码移动，因为它们可能产生side effect。这种时候就需要程序员宏观地修改代码进行代码移动。</p>
<p>代码移动是一项简朴易懂但十分有效的优化。虽然看似有经验的程序员都能够自动完成这项工作，但大型项目中也不乏由于没有进行代码移动而导致的效率危机。</p>
<h3 id="减少过程调用"><a href="#减少过程调用" class="headerlink" title="减少过程调用"></a>减少过程调用</h3><p>是应该进行更多的封装，使程序更加模块化和易于复用还是减少过程的调用，直接操作底层数据结构一直是一个保受争议的问题。对于C程序员来说，灵活地操作底层数据结构虽然会增大程序崩溃的几率，但可以大大提高程序的运行效率(因为减少了不必要的条件检查)。</p>
<h3 id="消除不必要的内存引用"><a href="#消除不必要的内存引用" class="headerlink" title="消除不必要的内存引用"></a>消除不必要的内存引用</h3><p>众所周知，内存读写比寄存器的读写要慢的多。因此，在循环过程中用临时变量存储计算中间结果要大大优于每次都进行内存读写。尽量消除不必要的内存读写可以大大提高程序性能，尤其是在循环结构中。</p>
<h2 id="利用硬件特性进行的优化"><a href="#利用硬件特性进行的优化" class="headerlink" title="利用硬件特性进行的优化"></a>利用硬件特性进行的优化</h2><p>现代处理器的微体系结构已经相当发达，这使得汇编语言指定的行为与机器实际的行为大相径庭。由于 <strong>指令级并行</strong> 的存在，现代处理器同时对多条指令进行求值，通过hazard消除技术避免副作用，并通过巧妙的安排让执行结果看上去像是顺序执行的。</p>
<p>在上一章对处理器流水线结构设计的了解中，我们知道要避免Hazard必须满足前后两条指令之间没有依赖关系，否则无论如何后一条指令都必须在前一条指令执行完后才能执行。一系列操作之间的依赖性导致的性能瓶颈称为 <strong>延迟界限(latency bound)</strong>，而处理器本身算力所导致的性能瓶颈称为 <strong>吞吐量界限(throughput bound)</strong> 。</p>
<h3 id="现代微处理器设计"><a href="#现代微处理器设计" class="headerlink" title="现代微处理器设计"></a>现代微处理器设计</h3><p>与之前的流水线顺序处理器不同，现代处理器是乱序处理的，也就是说指令执行顺序甚至不一定与机器语言中规定的相同。为了达成这个目的，处理器分为两部分：<strong>指令控制单元(ICU)</strong> 和 <strong>执行单元(EU)</strong> 。前者负责读出指令序列并生成操作，后者执行这些操作。</p>
<p>ICU会从指令高速缓存中取指令，并利用分支预测技术来决定下一个指令从哪里取出。每取出一个指令，ICU都将其拆分成一个个单元操作，并将单元操作们输送给EU，再由EU中的多个操作单元并行执行各种单元操作。</p>
<h3 id="功能单元的性能"><a href="#功能单元的性能" class="headerlink" title="功能单元的性能"></a>功能单元的性能</h3><p>功能单元的性能从三个方面衡量：<strong>延迟(latency)</strong>，<strong>发射时间(issuetime)</strong>，<strong>容量(capacity)</strong>。</p>
<p>延迟表示运算需要的总时间，而发射时间表示开始执行一次运算后到开始执行下一次运算所需要的时间。在完全顺序执行的情况下两者应该相等，但由于流水线化的设计，一条指令可以在上一条结束前就开始执行，这使得发射时间大大减小了。发射时间为1的操作称为完全流水线化操作，这种操作的两次之间必须是完全无依赖的。</p>
<p>容量则表示了能执行一个操作的功能单元数。一个处理器的 <strong>吞吐量</strong> 由功能单元的发射时间和容量决定，其具体值为 capacity/issuetime。</p>
<h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><p>将操作全部分解为基本操作，理清寄存器的占用与操作之间的依赖关系之后，便可以找出所有依赖链中最长最粗的一条，这条操作链就是关键路径。关键路径的长度和单位长度耗时直接决定着延迟界限，也就是程序性能。</p>
<h2 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h2><p>将原循环过程中的每两次循环合并为一次来书写循环体，这种修改称为 <strong>循环展开</strong> 。</p>
<p>循环展开有如下好处：</p>
<ul>
<li>减少了条件判断和迭代量计算的次数</li>
<li>提供了变化代码，减少关键路径上操作的机会</li>
</ul>
<p>在不改变关键路径操作的情况下，循环展开能将性能改善到逼近延迟界限的程度。</p>
<p>优化等级-O3会使GCC自动使用循环展开优化。</p>
<h2 id="提高并行性"><a href="#提高并行性" class="headerlink" title="提高并行性"></a>提高并行性</h2><p>这一部分，《串并行算法与数据结构》已经讲的足够清楚了。</p>
<h2 id="其他的制约因素"><a href="#其他的制约因素" class="headerlink" title="其他的制约因素"></a>其他的制约因素</h2><h3 id="寄存器溢出"><a href="#寄存器溢出" class="headerlink" title="寄存器溢出"></a>寄存器溢出</h3><p>虽然程序的并行度可以提高，但是处理器的寄存器数量是有限的。如果我们只顾着提高并行度，建立更多的临时循环变量，寄存器就可能发生不够用的情况。这时，处理器会在程序栈甚至内存中存放临时变量，这样甚至会使程序性能变得更低。</p>
<h3 id="预测错误处罚"><a href="#预测错误处罚" class="headerlink" title="预测错误处罚"></a>预测错误处罚</h3><p>分支预测技术的错误处罚代价是很大的，因为要抛弃所有正在运行的指令和结果并跳回到新位置重新开始。很难帮助处理器避免预测错误，因为其预测逻辑不为程序员所见。但是，如果能够尽量用 <strong>条件数据传送</strong> 来取代 <strong>条件控制转移</strong> 命令，就可以大大减少分支预测错误的处罚，因为数据传送一般不涉及控制流跳转问题，发生错误只需要更改结果即可。</p>
<p>对于GCC来说，用条件操作计算值并用值更新程序状态会编译出条件数据传送，而直接用条件操作改变程序状态则会编译出条件控制转移。因此，在一些关键位置改变代码风格可以大大降低错误预测的开销。</p>
<h2 id="程序分析工具gprof"><a href="#程序分析工具gprof" class="headerlink" title="程序分析工具gprof"></a>程序分析工具gprof</h2><p>gprof以二进制可执行文件为参数，它记录输入的程序执行过程中每个函数所花的时间。</p>
<h1 id="Chapter-6-存储器层次结构"><a href="#Chapter-6-存储器层次结构" class="headerlink" title="Chapter 6 存储器层次结构"></a>Chapter 6 存储器层次结构</h1><h2 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h2><h3 id="随机访问存储器-RAM"><a href="#随机访问存储器-RAM" class="headerlink" title="随机访问存储器(RAM)"></a>随机访问存储器(RAM)</h3><p>随机访问存储器分为两类：静态的(SRAM)和动态的(DRAM)。SRAM比DRAM更快(1000倍)，常常用作高速缓存。</p>
<p>SRAM由双稳态存储单元组成。每个单元都是一个六晶体管电路，它只有两种稳态值，只要有电，就算受到扰动也会迅速回归到稳态值上去。</p>
<p>DRAM由C很小的电容组成，用对电容的充电或无电表示1和0。DRAM存储器单元对扰动非常敏感，一旦电压被扰乱便无法恢复。</p>
<h4 id="内存条的存储结构"><a href="#内存条的存储结构" class="headerlink" title="内存条的存储结构"></a>内存条的存储结构</h4><p>每一块DRAM芯片的存储位被组织成同样大小的 <strong>单元</strong> ，每个单元一般含有若干个字节的信息。单元在DRAM芯片中以矩阵形式排列，每个单元都有其唯一的可以被索引的地址。</p>
<p>DRAM芯片通过 <strong>引脚</strong> 和外界沟通，一块芯片有8个data引脚，用以传递一个字节的信息；还有若干个addr引脚，用以索引具体的单元。每个芯片还有一个行缓冲区。</p>
<p>所有的DRAM芯片都连接到一个内存控制器上，内存控制器可以同时向每个DRAM芯片发送一位。在需要读取的时候，控制器首先将需要读取的地址转换成DRAM中的行和列索引，随即向每个DRAM芯片的addr发送一个相同的行索引，让其将对应的行复制到行缓冲区中；然后发送一个列索引，从每个芯片中取到目标单元值，最后内存控制器整合所有的单元值并输出。</p>
<h3 id="非易失性存储器"><a href="#非易失性存储器" class="headerlink" title="非易失性存储器"></a>非易失性存储器</h3><h4 id="只读存储器-ROM"><a href="#只读存储器-ROM" class="headerlink" title="只读存储器(ROM)"></a>只读存储器(ROM)</h4><p>PROM存储器(programmable read-only memory)只能被编程一次，它由能用高电流熔断的熔丝组成。EPROM(erasable PROM)和EEPROM(electrical EPROM)则可以多次编程。</p>
<p>存储在ROM中的程序称为 <strong>固件(firmware)</strong> 。它包括一些基本的输入输出函数和计算机系统启动所必需的程序。</p>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><h1 id="Chapter-7-链接"><a href="#Chapter-7-链接" class="headerlink" title="Chapter 7 链接"></a>Chapter 7 链接</h1><h2 id="Compiler-driver"><a href="#Compiler-driver" class="headerlink" title="Compiler driver"></a>Compiler driver</h2><p>大多数需要编译的语言都会提供一个 <strong>编译器驱动程序(Compiler driver)</strong> ，以C语言为例，这个程序会依次调用预处理器，编译器，汇编器和链接器，将源代码转换为二进制文件。</p>
<p>当我们使用gcc去将多个互相关联的文件编译为一个二进制文件时，这些源文件的预处理、编译和汇编过程都是分别进行的，而在最后的链接过程中被合为一体。</p>
<p>当我们运行可执行文件时，shell调用加载器，将文件内容拷贝到内存中并将控制流转移到二进制文件开头。</p>
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>静态链接器所接受的 <strong>可重定位目标文件</strong> 由各种不同的代码和数据节组成，其中每一节都是一个连续的字节序列。指令、未初始化的全局变量和初始化过的全局变量分居不同的section。</p>
<p>链接器要完成的主要任务是：</p>
<ul>
<li><strong>符号解析</strong>：将目标文件中的每个每个符号引用和其符号定义关联起来。</li>
<li><strong>重定位</strong>：将每个符号引用指向其对应的符号定义的内存位置。</li>
</ul>
<p>注意：链接器进行重定位的依据是汇编器所产生并记录在目标文件中的重定位条目。其自身并不做过多工作。</p>
<h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><p>目标文件有三种：</p>
<ul>
<li>可重定位目标文件：无法直接执行，但包括所有数据和代码的文件</li>
<li>可执行目标文件：经过链接，可以直接复制到内存中执行的文件</li>
<li>共享目标文件：可以动态地加载到内存中进行运行或链接的可重定位目标文件</li>
</ul>
<h3 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h3><p>现代Linux系统下的目标文件格式一般为 <strong>ELF(Executable and Linkable format)</strong> 格式。下表大致地描述了一个ELF可重定位目标文件的组成格式。</p>
<table>
<thead>
<tr>
<th>ELF头</th>
</tr>
</thead>
<tbody>
<tr>
<td>.text</td>
</tr>
<tr>
<td>.rodata</td>
</tr>
<tr>
<td>.data</td>
</tr>
<tr>
<td>.bss</td>
</tr>
<tr>
<td>.symtab</td>
</tr>
<tr>
<td>.rel.text</td>
</tr>
<tr>
<td>.rel.data</td>
</tr>
<tr>
<td>.debug</td>
</tr>
<tr>
<td>.line</td>
</tr>
<tr>
<td>.strtab</td>
</tr>
<tr>
<td>节头部表</td>
</tr>
</tbody>
</table>
<p>灵活地使用linux下的<code>readelf</code>工具可以有很大帮助。</p>
<h4 id="ELF头"><a href="#ELF头" class="headerlink" title="ELF头"></a>ELF头</h4><p>ELF头记录着一个目标文件的基本信息。其内容如下：</p>
<ul>
<li>描述系统 <strong>字长</strong> 和 <strong>字节序</strong> 的一个16字节序列</li>
<li>ELF头的大小</li>
<li>目标文件类型</li>
<li>机器类型</li>
<li>节头部表的位置</li>
<li>节头部表中条目的大小和数量</li>
</ul>
<h4 id="节头部表"><a href="#节头部表" class="headerlink" title="节头部表"></a>节头部表</h4><p>节头部表位于目标文件的末端，它记录了ELF文件中每个节的大小和位置。</p>
<h4 id="节"><a href="#节" class="headerlink" title="节"></a>节</h4><p>在ELF头和节头部表之间的部分都是节。一个典型的ELF文件包括如下节：</p>
<ul>
<li><code>.text</code> 已编译程序的机器代码</li>
<li><code>.rodata</code> 只读数据，包括声明中用到的常量和switch跳转表等</li>
<li><code>.data</code> 已经初始化的全局变量和静态变量(局部变量在程序栈中)</li>
<li><code>.bss</code> 未初始化或初始化为0的全局和静态变量，它们不占据任何实际空间。</li>
<li><code>.symtab</code> 存放着在程序中定义和引用的函数和全局变量信息的符号表<ul>
<li><strong>这个符号表只在链接或调试过程中有用</strong></li>
<li>可以使用<code>strip</code>命令去掉目标文件中的符号表</li>
</ul>
</li>
<li><code>.rel.text</code>和<code>.rel.data</code> 分别是函数和全局变量的重定位表，链接器根据其中储存的信息去制作symtab</li>
<li><code>.debug</code> 一个调试符号表，以-g选项调用编译器才会产生这张表，是调试所需要的</li>
<li><code>.line</code> 同样以-g选项调用才会产生，用于将行数映射到机器指令</li>
<li><code>.strtab</code> 一个字符串表，包括.symtab和.debug节中的符号名和各种节头的名字</li>
</ul>
<p>除了这些节以外，还有没有列入节头部表的几个 <strong>伪节</strong> ：</p>
<ul>
<li><code>ABS</code> 不该被重定位的符号</li>
<li><code>UNDEF</code> 外部符号</li>
<li><code>COMMON</code> 和.bss类似，COMMON包括未初始化的全局变量，其余归.bss。</li>
</ul>
<h4 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h4><p>在链接器的上下文中有三种不同的符号：</p>
<ul>
<li>全局符号：由一个模块定义，被其他模块引用的符号，如非静态函数和全局变量。</li>
<li>外部符号：由其他模块定义，被本模块引用的符号。</li>
<li>局部符号：被一个模块定义且只被其本身引用的符号，包括静态的函数和全局变量。</li>
</ul>
<p><strong>在C中，源文件扮演模块的角色</strong>。用static声明的函数和变量可以视为private的，而不加static的则可以视为pubilc的。</p>
<p><code>.symtab</code>节中的符号表表项是下面的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> name;        <span class="comment">// 指示表项的名称字符串在.strtab中的位置</span></span><br><span class="line">    <span class="keyword">char</span> type:<span class="number">4</span>;     <span class="comment">// 4bits数据，表示该表项是函数还是变量(或者其它类别)</span></span><br><span class="line">    <span class="keyword">char</span> binding:<span class="number">4</span>;  <span class="comment">// 4bits数据，表示该表项是本地还是全局的(或者其它类别)</span></span><br><span class="line">    <span class="keyword">long</span> value;      <span class="comment">// 指示表项的初始化位置距离初始化节起始位置的偏移量</span></span><br><span class="line">    <span class="keyword">long</span> size;       <span class="comment">// 每个表项指向的量所占的字节数</span></span><br><span class="line">    <span class="keyword">short</span> section;   <span class="comment">// 表项所属的节在节头部表中的位置(或伪节的名称)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="可执行目标文件"><a href="#可执行目标文件" class="headerlink" title="可执行目标文件"></a>可执行目标文件</h3><p>可执行目标文件的结构与可重定位目标文件大致相同：</p>
<table>
<thead>
<tr>
<th>ELF头</th>
</tr>
</thead>
<tbody>
<tr>
<td>段头部表</td>
</tr>
<tr>
<td>.init</td>
</tr>
<tr>
<td>.text</td>
</tr>
<tr>
<td>.rodata</td>
</tr>
<tr>
<td>.data</td>
</tr>
<tr>
<td>.bss</td>
</tr>
<tr>
<td>.symtab</td>
</tr>
<tr>
<td>.debug</td>
</tr>
<tr>
<td>.line</td>
</tr>
<tr>
<td>.strtab</td>
</tr>
<tr>
<td>节头部表</td>
</tr>
</tbody>
</table>
<p>ELF头中多出了程序的入口点，即第一条指令地址这一信息。.init节定义了一个初始化函数。由于可执行文件已经完成重定位，它不再需要.rel节。</p>
<p>从.init到.rodata段是只读段，存放代码段；.data和.bss是读写段，存放数据；剩下的位置不加载到内存，多数情况下用于调试。</p>
<p>段头部表指示各个代码/数据段的位置。</p>
<h4 id="可执行目标文件的加载"><a href="#可执行目标文件的加载" class="headerlink" title="可执行目标文件的加载"></a>可执行目标文件的加载</h4><p>加载的过程是由加载器来完成的。加载器首先根据段头部表将各个字节段拷贝到内存的相应位置，然后跳转到程序的入口点，也就是<code>_start</code>函数的地址。这个函数是所有C程序的入口点，<code>_start</code>函数会调用系统启动函数来初始化执行环境并调用main函数。main函数返回后，它接受并处理返回值。</p>
<h2 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h2><h3 id="多重定义的全局符号"><a href="#多重定义的全局符号" class="headerlink" title="多重定义的全局符号"></a>多重定义的全局符号</h3><p>Linux将未初始化的全局变量规定为弱符号，而函数和初始化的全局变量是强符号。</p>
<ul>
<li>当出现同名的强符号时，报错</li>
<li>当出现同名的强符号和弱符号时，选择强符号</li>
<li>当出现同名的弱符号时，随机选择一个</li>
</ul>
<p>后两条规则会导致一些不易察觉的错误。比如，一个文件中定义了一个未初始化的x和一个操作x的函数，而另一个文件中定义了一个初始化过的x，那么函数的执行就可能在另一个文件编写者不知道的情况下改变x的值。</p>
<h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><p>编译系统提供一种机制，将所有相关的目标文件打包成为一个单独的文件，称为静态库。当链接器构造出一个目标文件时，它只会拷贝静态库中被引用的部分。</p>
<p>在编译指令中加上静态库文件的名字可以将这个库作为链接器的输入之一。使用静态库可以减少程序员在源文件中进行include的头文件数。</p>
<p>静态库以一种称为 <strong>存档(archive)</strong> 的特殊文件格式存放在磁盘中。存档文件由后缀<code>.a</code>标识。</p>
<p><code>ar</code>工具可以将几个.o文件打包成为一个静态库。</p>
<p>当将静态库作为gcc的参数时，要注意目标文件和库文件的顺序。一般来说，依赖源放在后面。</p>
<h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>重定位过程合并输入模块，并为每个符号分配运行时地址。</p>
<p>重定位分为两步：</p>
<ul>
<li><strong>重定位节和符号定义</strong>：在这个过程中，链接器将所有相同类型的节进行合并，为它们中的每个条目重新分配运行时内存地址，并更新ELF头和节头部表的信息。完成这一步后，程序中每条 <strong>指令</strong> 和每个 <strong>全局变量</strong> 都具有唯一的运行时内存地址。</li>
<li><strong>重定位符号引用</strong>：修改代码节和数据节中对每个变量或函数的引用，将它们指向正确的运行时地址。完成这一步需要借助可重定位目标文件中的 <strong>重定位条目</strong> 。</li>
</ul>
<h3 id="重定位条目"><a href="#重定位条目" class="headerlink" title="重定位条目"></a>重定位条目</h3><p>汇编器会将每个遇到的引用分别放在等量的重定位条目中，以此告诉链接器如何在目标文件合并时修改这个引用。代码和已初始化数据的重定位条目分别存放在.rel.text和.rel.data中。</p>
<p>重定位条目的格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> offset;    <span class="comment">// 需要被修改的引用在节中的位置</span></span><br><span class="line">    <span class="keyword">long</span> type:<span class="number">32</span>;   <span class="comment">// 重定位类型</span></span><br><span class="line">    <span class="keyword">long</span> symbol:<span class="number">32</span>; <span class="comment">// 被修改的引用应该指向的符号在符号表中的位置,用于标识引用对象</span></span><br><span class="line">    <span class="keyword">long</span> addend;    <span class="comment">// 对最终重定位位置所做的调整</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>重定义类型</strong>有32种，其中最常见的有两种：</p>
<ul>
<li>R_X86_64_PC32 重定义一个使用相对寻址的引用</li>
<li>R_X86_64_32 重定义一个使用绝对寻址的引用</li>
</ul>
<p>对于相对寻址来说，由于在重定位过程中所有模块中的节都已经合并，可以知道引用源和引用对象处于同一个<code>.text</code>节中。这样一来，只需要知道引用对象的地址，就可以通过offset和addend计算出所需要的相对变址，也就是源和对象代码之间的距离。</p>
<p>而绝对寻址更加简单，只需要将引用对象的地址和addend的加值作为绝对地址来重定位即可。</p>
<p>addend项的作用是抵消掉处理器流水线的影响。在相对寻址中，处理器根据当前PC的值和变址来计算应当跳转到的位置。然而当处理器在执行调用指令(比如call)时，此时的PC值其实是下一条指令的地址。因而，此时需要在变址中加入addend值来进行修正，addend值应设置为两条指令之间地址差的相反数。对于绝对寻址，addend一般设置为0.</p>
<h2 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h2><p>动态链接库是一个目标模块，可以加载到任意的内存地址并与内存中的程序链接。这个过程是由 <strong>动态链接器</strong> 来完成的，称为动态链接。动态链接库在LINUX下以<code>.so</code>为后缀，而在windows下则以DLL文件为格式。</p>
<p>对于使用了动态链接库的目标文件，链接器会额外创建一个<code>.interp</code>节来包含动态链接器的路径。在加载器加载和运行可执行目标文件时，它会识别这个节，并加载和运行这个动态链接器。</p>
<p>动态链接器被加载后，将需要的共享库加载到指定内存段，并建立目标程序与共享库之间的链接，最后将控制传递给目标程序。</p>
<p>如果要在编写程序时指定共享库，可以使用<code>&lt;dlfcn.h&gt;</code>。如果要创建共享库，可以使用gcc参数<code>gcc -shared -fpic</code></p>
<p><code>-fpic</code>参数会指定生成 <strong>位置无关代码</strong>(Position-Independent Code) 这种代码可以加载而无需重定位，是为了解决动态链接加载问题而设计的。</p>
<h3 id="位置无关代码-PIC"><a href="#位置无关代码-PIC" class="headerlink" title="位置无关代码(PIC)"></a>位置无关代码(PIC)</h3><p>动态链接的一个问题在于，进程该如何定位加载到内存中的动态链接库代码。如果为每一个动态链接库分配一块指定的内存，既不方便动态链接库的修改与更新，又会使系统的可用资源减少。</p>
<p>PIC利用了加载的一个特性，即加载到内存中的数据段和代码段之间的距离是 <strong>运行时常量</strong> 。它在每个数据段开始的位置创建一个 <strong>全局偏移量表(GOT)</strong> ，这个表的每一项都与数据段中对全局变量或函数的引用关联。在加载时，动态链接器会重定位GOT的每一项，使其指向本模块或其他模块中的引用对象定义/初始化位置。</p>
<p>然而，动态链接库中的函数有可能数量巨大，如果所有函数都交由GOT和动态链接器处理，程序的加载过程将会变得极其耗时。为了解决这个问题，GNU采用一种叫做 <strong>延迟绑定</strong> 的机制，将过程地址的重定位推迟到第一次调用该过程的时间点。</p>
<p>延迟绑定需要GOT和另一种数据结构 —— <strong>过程链接表(PLT)</strong> 的辅助。GOT是数据段的一部分，而PLT是代码段的一部分，它的每个表项都是一个16字节代码段，对应一个函数调用。在初始化GOT的时候，所有对函数引用的GOT都指向其函数对应的PLT的第二个指令。</p>
<p><code>PLT[0]</code>对应动态链接器的入口，用于跳转到动态链接器；<code>PLT[1]</code>对应<code>_start</code>函数，之后的条目则对应用户所声明的函数。而GOT的前两个条目包含动态链接器的参数信息，其后的条目则依次对应PLT中相应函数的入口。由于数据段与代码段之间的距离是运行时不变量，GOT的每个表项<code>GOT[i]</code>与PLT中的<code>PLT[i-2]</code>之间的距离是固定的。</p>
<p>在一个函数第一次被调用时，它的运行时地址被解析：</p>
<ul>
<li>程序进入这个函数对应的PLT条目</li>
<li>PLT条目第一指令是跳转指令，跳转目标是该函数对应GOT所指向的地址</li>
<li>由于GOT的初始值为PLT第二个指令，此时控制来到PLT第二个指令</li>
<li>第二个指令将函数ID压栈，第三个指令跳转到<code>PLT[0]</code></li>
<li><code>PLT[0]</code>通过<code>GOT[1]</code>将动态链接器参数压栈，并通过<code>GOT[2]</code>跳转到动态链接器入口</li>
<li>动态链接器通过两个参数确定函数所在的动态库模块并找到其加载到的内存位置</li>
<li>动态链接器用这个位置重写GOT中该函数表项的值</li>
<li>动态链接器将控制转交给这个函数</li>
</ul>
<p>而之后的调用就会简单很多，因为GOT中关于这个函数的表项已经被重写为正确的地址了，PLT可以直接通过这个地址跳转到函数入口。</p>
<h2 id="库打桩机制"><a href="#库打桩机制" class="headerlink" title="库打桩机制"></a>库打桩机制</h2><p>Linux链接器支持打桩机制，它允许用户截取对系统函数的调用，取而代之地调用一个与这个函数原型完全相同，但内容自由定义的函数。</p>
<h3 id="编译时打桩"><a href="#编译时打桩" class="headerlink" title="编译时打桩"></a>编译时打桩</h3><p>以对malloc.h文件进行打桩为例：</p>
<ul>
<li>首先，在调用了malloc函数的源文件所在文件夹下创建一个malloc.h文件，并在其中将对malloc的调用重新定向：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) fake_malloc(size)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">fake_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>自行编写一个.c文件，将你想要让malloc函数做的事情写进去，并用gcc将其编译为.o文件：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c &lt;xxx&gt;.c</span><br></pre></td></tr></table></figure>
<ul>
<li>用gcc进行编译时打桩</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -I. &lt;源文件&gt;.c &lt;xxx&gt;.o</span><br></pre></td></tr></table></figure>
<p>由于指定了<code>-I.</code>参数，C预处理器会优先在当前文件夹中搜索malloc.h文件，于是打桩成功，计划通！</p>
<h3 id="链接时打桩"><a href="#链接时打桩" class="headerlink" title="链接时打桩"></a>链接时打桩</h3><p>gcc的一组参数可以用于打桩：</p>
<ul>
<li><code>-Wl,&lt;option&gt;</code>参数：将option作为参数传给链接器。option中的空格要替换为逗号来写。</li>
<li><code>--wrap &lt;token&gt;</code>参数：链接器参数，将token解析为<code>__wrap_&lt;token&gt;</code>，并将<code>__real_&lt;token&gt;</code>解析为token。</li>
</ul>
<p>利用这两个参数，可以自定义<code>__wrap_&lt;token&gt;</code>函数，在其中定义自己的函数，再使用<code>__real_&lt;token&gt;</code>来调用原本的token函数。最后，使用<code>gcc -Wl,--wrap,&lt;token&gt;</code>参数来编译。</p>
<h3 id="运行时打桩"><a href="#运行时打桩" class="headerlink" title="运行时打桩"></a>运行时打桩</h3><p>通过设置<code>LD_PRELOAD</code>环境变量的值为一个目录，可以使动态链接器在搜索默认目录的动态库之前先搜索指定目录下的动态库。通过这个特性可以轻松地实现运行时打桩。</p>
<h2 id="工具总结"><a href="#工具总结" class="headerlink" title="工具总结"></a>工具总结</h2><ul>
<li>AR 用于创建和修改静态库 </li>
<li>STRINGS 列出一个 <strong>可执行文件</strong> 中所有可以打印的字符串</li>
<li>STRIP 用于删除符号表</li>
<li>NM 列出一个 <strong>可执行文件</strong> 的符号表信息</li>
<li>SIZE 列出可执行文件中节的信息</li>
<li>READELF</li>
<li>OBJDUMP</li>
<li>LDD 列出一个可执行文件需要的共享库</li>
</ul>
<h1 id="Chapter-8-异常控制流"><a href="#Chapter-8-异常控制流" class="headerlink" title="Chapter 8 异常控制流"></a>Chapter 8 异常控制流</h1><p>控制流会在很多种情况下发生变化：跳转，函数调用，返回都属于正常的控制流变化，在源程序的控制之内；但系统状态的变化也会引起一些控制流突变，我们将这些控制流变化统称为 <strong>异常控制流(Exceptional Control Flow)</strong> 。</p>
<p>在硬件层，硬件可能会因为预料外或不合规定的状态变化而抛出异常；在操作系统层，内核经常将控制权在不同进程之间转移；在应用层，进程之间的信号通信可以让程序回避栈规则进行跳转。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><strong>异常(Exception)</strong> 是异常控制流的一种形式。在任何情况下，如果 <strong>处理器</strong> 检测到有反常事件发生，它就会通过一张叫做 <strong>异常表(exception table)</strong> 的跳转表进行一个间接过程调用(也就是异常)，将控制权转交到这个异常所对应的异常处理程序。</p>
<p>异常处理程序完成处理后，有三种情况:</p>
<ul>
<li>控制权回到异常抛出时正在执行的指令</li>
<li>控制权转交给引发异常的下一条指令</li>
<li>终止被中断的程序</li>
</ul>
<p>系统中可能的每种类型的异常都分配了惟一的一个 <strong>异常号</strong> 。硬件层面的异常号由处理器设计者来规定，软件层面的异常号由操作系统内核设计者来规定。异常号是异常表的索引，在触发一个异常时，处理器取出 <strong>异常表基址寄存器</strong> 的值，与(异常号×异常表表项的大小)做加法，得到异常表对应表项的地址。</p>
<p>异常的函数调用和普通函数调用有一些区别：</p>
<ul>
<li>异常调用的返回地址不一定是正在执行指令的下一条指令</li>
<li>处理器会把一些额外的状态量压入栈中</li>
<li>如果控制从用户转到内核，所有项目被压入内核栈而不是程序栈</li>
<li>异常处理程序运行在系统态</li>
</ul>
<h3 id="异常的类别"><a href="#异常的类别" class="headerlink" title="异常的类别"></a>异常的类别</h3><p>异常可以分为如下四类：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>原因</th>
<th>行为</th>
<th>返回</th>
</tr>
</thead>
<tbody>
<tr>
<td>中断(<strong>Interrupt</strong>)</td>
<td>IO设备的信号</td>
<td>异步</td>
<td>返回到下一条指令</td>
</tr>
<tr>
<td>陷阱(<strong>trap</strong>)</td>
<td>有目的地引发</td>
<td>同步</td>
<td>返回到下一条指令</td>
</tr>
<tr>
<td>故障(<strong>fault</strong>)</td>
<td>潜在的可恢复的错误</td>
<td>同步</td>
<td>返回到下一条或当前指令</td>
</tr>
<tr>
<td>终止(<strong>abort</strong>)</td>
<td>不可恢复的错误</td>
<td>同步</td>
<td>不返回</td>
</tr>
</tbody>
</table>
<h4 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h4><p>IO设备在完成某个读取或写入过程后，就会向处理器的一个引脚发出信号，并将异常号放到系统总线。处理器会在执行完一条指令之后发觉引脚电位的变化，读取异常号并调用对应的异常处理程序来进行下一个IO操作。处理程序返回时，控制权交给下一条指令，使源程序的行为不受影响。</p>
<h4 id="Trap"><a href="#Trap" class="headerlink" title="Trap"></a>Trap</h4><p>陷阱通常用来进行 <strong>系统调用</strong> 。在操作系统学习中已经对系统调用过程有了够多的了解，此处不予详述。</p>
<h4 id="Fault"><a href="#Fault" class="headerlink" title="Fault"></a>Fault</h4><p>当一个故障发生时，异常处理程序会首先试图去修复这个故障。如果修复成功，控制权会回到引起故障的指令并重新执行它；否则，异常处理程序会调用内核中的abort例程并终止引起异常的程序。</p>
<h4 id="Abort"><a href="#Abort" class="headerlink" title="Abort"></a>Abort</h4><p>终止是确定无法恢复的错误，因而会直接终止引发异常的程序。</p>
<h3 id="常见的异常"><a href="#常见的异常" class="headerlink" title="常见的异常"></a>常见的异常</h3><ul>
<li><code>0</code>-除法错误：除法发生的错误属于硬件层面故障，但Linux系统不会试图恢复，而是直接abort。</li>
<li><code>13</code>-<strong>段错误</strong>：对未定义内存区域的引用或对只读文本段的写操作引发的故障，是相当常见的故障。Linux系统同样会直接将段错误进行abort处理，产生大家常常看到的<code>Segmentation fault</code>错误。</li>
<li><code>14</code>-<strong>缺页错误</strong>：指令所引用的虚拟地址所对应的物理页面不在内存中。这种情况是惰性加载的产物，在存储技术中相当常见。异常处理程序会将物理页面加载进内存，并返还控制权。</li>
<li><code>18</code>-机器检查：致命的硬件错误，属于abort类型。</li>
</ul>
<h3 id="Linux的系统调用"><a href="#Linux的系统调用" class="headerlink" title="Linux的系统调用"></a>Linux的系统调用</h3><p>在汇编语言中，<code>%rax</code>寄存器包含系统调用号，<code>%rdi</code>，<code>%rsi</code>，<code>%rdx</code>等寄存器包含最多6个参数的情况下，<code>syscall</code>指令会发起一次系统调用。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程提供给应用程序的关键抽象有二：</p>
<ol>
<li>一个独立的逻辑控制流</li>
<li>一个独立的虚拟地址空间</li>
</ol>
<h3 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h3><p>抢占式的任务调度中，所有的进程会轮流获取CPU的使用权。在这种抽象中，若干个进程可以看做是同时在运行，这种现象称为 <strong>并发</strong> 。而如果两个进程真正在不同的处理器核上运行，那么它们则被称为是 <strong>并行</strong> 的。</p>
<h3 id="私有地址空间"><a href="#私有地址空间" class="headerlink" title="私有地址空间"></a>私有地址空间</h3><p>对于每个进程来说，它的地址空间结构是相同的：</p>
<p><img src="/blog//dracit7.github.io/blog/2018/04/12/Note of CSAPP/Chapter_8/stack.png" alt="stack"></p>
<h3 id="系统态和用户态"><a href="#系统态和用户态" class="headerlink" title="系统态和用户态"></a>系统态和用户态</h3><p>这一部分详见操作系统课程的相关内容</p>
<h2 id="系统调用的错误处理"><a href="#系统调用的错误处理" class="headerlink" title="系统调用的错误处理"></a>系统调用的错误处理</h2><p>这一部分详见《UNIX系统编程》</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>同样详见《UNIX系统编程》</p>
<h3 id="fork指令"><a href="#fork指令" class="headerlink" title="fork指令"></a>fork指令</h3><p><code>fork()</code>系统调用创建当前程序的一个子进程，宏观上来看在这个调用之后子进程会从下一条指令开始与主进程并发运行相同的代码。区分主进程和子进程的方式是fork的返回值——<strong>在父进程中返回值是子进程的pid，在子进程中返回值为0</strong>。</p>
<p>这个指令的特点有：</p>
<ul>
<li>调用一次，返回两次。为了理清多次fork所创建的进程关系，通常需要画进程图。</li>
<li>父进程与子进程并发执行</li>
<li>子进程的地址空间是父进程的副本，但又与父进程相互独立。</li>
</ul>
<h3 id="子进程的回收"><a href="#子进程的回收" class="headerlink" title="子进程的回收"></a>子进程的回收</h3><p>子进程在返回或终止后并不会马上被内核清除，它会一直保持一个已终止的状态直到被它的父进程回收。这种未被回收但已经中止的进程被称为 <strong>僵尸进程</strong> 。父进程回收子进程后，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程。</p>
<p>如果父进程在它的子进程被回收之前终止,init进程会接管子进程,成为它的养父，并最终回收这些僵尸进程。但是，由于僵尸进程也会占用系统内存等资源，每个进程都应当回收它们的子进程，这就要用到<code>waitpid</code>函数了。它会使进程等待目标子进程终止，并马上回收这个子进程。如果当前没有子进程，这个函数返回-1并设置错误码。</p>
<p><code>pid_t waitpid(pid_t pid, int *statusp, int options)</code></p>
<ul>
<li><code>pid</code>:指定要等待的子进程pid。如果这个值为-1,就等待所有子进程。</li>
<li><code>options</code>: 改变函数默认的执行模式，如果为0则不改变。waitpid默认会挂起进程来等待子进程终止，并返回已终止子进程的pid。<ul>
<li><code>WNOHANG</code>: 立即返回而不等待子进程终止，若没有子进程终止则返回值为0</li>
<li><code>WUNTRACED</code>: 不仅返回已终止子进程的PID，还返回被停止子进程的pid。</li>
<li><code>WCONTINUED</code>: 挂起直到子进程终止或一个被停止的子进程收到信号继续执行</li>
</ul>
</li>
<li><code>statusp</code>: 用于存放返回的子进程的状态信息，<code>wait.h</code>中的宏可以解析这些信息。</li>
</ul>
<p><code>waitpid(-1,NULL,0)</code>会回收所有子进程中最先结束的子进程，然后返回。</p>
<h3 id="加载和运行程序"><a href="#加载和运行程序" class="headerlink" title="加载和运行程序"></a>加载和运行程序</h3><p><code>execve</code>函数可以在当前进程的上下文中加载并运行一个程序。</p>
<p><code>int execve(char* filename, char* argv[], char* envp[])</code></p>
<p>其中filename和argv不必解释，envp指向一个环境变量字符串数组，每个字符串都是<code>“name=value”</code>格式的键值对。</p>
<p><code>getenv</code>函数可以根据环境变量中的<code>name</code>在环境变量数组中搜索并返回对应的<code>value</code>字符串指针。如果找不到则返回NULL。<code>setenv</code>和<code>unsetenv</code>则可以修改环境变量。</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号是一种消息，内核使用信号来通知进程系统中发生的事情。可以执行<code>man 7 signal</code>来查看linux系统支持的信号种类。</p>
<p>传递信号由两个步骤组成：</p>
<ol>
<li>内核通过更新目标进程上下文中的某个状态，向一个进程 <strong>发送信号</strong></li>
<li>目标进程对信号做出的反应被称为 <strong>接受信号</strong></li>
</ol>
<p>一个发出但没有接受的信号被称为 <strong>待处理信号</strong> ，每种类型的信号在 <strong>同一时间只能存在一个待处理信号</strong> ，在这个信号被接受之前的同类型新信号会被丢弃。<strong>每个信号只能被接受一次</strong>。</p>
<h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>每个进程都只属于一个进程组，进程组由一个pgid来标识。用户进程可以通过<code>getpgrp</code>函数获取自己所在的进程组ID，通过<code>setpgid</code>改变自己或者其他进程的进程组。在<code>setpgid(pid,pgid)</code>函数中，如果pid为0则指定自身，如果pgid为0则用pid指定的PID作为进程组ID。</p>
<h3 id="信号的发送"><a href="#信号的发送" class="headerlink" title="信号的发送"></a>信号的发送</h3><p>linux系统下的<code>/bin/kill</code>文件可以向其他的进程发送信号。</p>
<p>使用方式：<code>kill -&lt;sig&gt; &lt;pid&gt;</code></p>
<p>其中<code>sig</code>指定发送的信号种类，而<code>pid</code>指定发送目标。负的pid会将信号发送给进程组中的每个进程。</p>
<p>类似地可以发送信号的函数有<code>signal.h</code>库中的<code>kill</code>函数,它的使用规范与<code>/bin/kill</code>相近；<code>unistd</code>中的<code>alarm</code>函数也可以在sec秒后向调用进程发送一个<code>SIGALRM</code>信号。</p>
<p>键盘输入如<code>ctrl-C</code>也会向当前作业的进程组发送信号。</p>
<h3 id="信号的接受"><a href="#信号的接受" class="headerlink" title="信号的接受"></a>信号的接受</h3><p>当一个进程 <strong>从内核模式切换回用户模式</strong> 时，它会检测进程的待处理信号集合，如果集合为空则将控制流转移给下一条指令，否则 <strong>强制</strong> 这个进程接受这个信号。</p>
<p>进程对于每个信号都有一种默认反应，大多是终止，转储内存，挂起或忽略。我们可以通过使用<code>signal.h</code>中的<code>signal</code>函数来修改默认行为。(<strong>SIGKILL和STGSTOP信号是无法更改的</strong>)</p>
<p><code>sighandler_t signal(int signum, sighandler_t handler)</code></p>
<ul>
<li>返回值：如果失败返回<code>SIG_ERR</code>，可以用于检验是否成功</li>
<li><code>signum</code>：指定要监测并处理的信号</li>
<li><code>handler</code>：指定处理信号的函数<ul>
<li><code>SIG_IGN</code>：忽略这个信号</li>
<li><code>SIG_DEL</code>：取消对信号默认行为的更改</li>
<li>自定义的函数</li>
</ul>
</li>
</ul>
<p>调用这个函数会改变当前进程在其剩余生命周期内对某个信号的行为。</p>
<h3 id="信号的阻塞"><a href="#信号的阻塞" class="headerlink" title="信号的阻塞"></a>信号的阻塞</h3><p><code>sigprocmask</code>函数可以显式地阻塞一些信号。</p>
<p><code>int sigprocmask(int how, sigset_t* set, sigset_t* oldset)</code></p>
<ul>
<li><code>how</code>：指定对两个set的操作<ul>
<li><code>SIG_BLOCK</code>：阻塞所有<code>set</code>中的信号</li>
<li><code>SIG_UNBLOCK</code>：解除对所有<code>set</code>中信号的阻塞</li>
<li><code>SIG_SETMASK</code>：将阻塞集合变成<code>set</code></li>
</ul>
</li>
<li><code>oldset</code>：之前的阻塞信号集合会保存在这里</li>
</ul>
<p>sigset的使用方法是，首先声明一个sigset，再使用辅助函数(<code>sigemptyset</code>,<code>sigaddset</code>,<code>sigdelset</code>)进行构造。</p>
<h3 id="信号处理程序的编写"><a href="#信号处理程序的编写" class="headerlink" title="信号处理程序的编写"></a>信号处理程序的编写</h3><p>信号处理程序与主程序并发运行，因而它很容易引起race condition。因此，我们只能在信号处理函数中使用 <strong>异步安全</strong> 的函数，而printf，scanf，malloc和exit等函数都不在此列，因而输出基本靠<code>write</code>。</p>
<p>还有一种精简信号处理程序的方式是只在程序中改变全局变量的值，然后立即返回，将所有的处理过程留给主程序。</p>
<p>除此之外，任何可能被信号处理程序修改的全局变量都应该使用<code>volatile</code>前缀和<code>sig_atomic_t</code>类型，前者保证这个变量不会被缓存，后者保证对这个变量的所有读写都是原子操作。</p>
<p>最后，处理程序有义务保存调用时errno的值，并在返回时将其重置。</p>
<p>另一个需要注意的问题是，由于未被处理的信号同时每种只能存在一个，当我们发现有一个未被处理的信号时很可能有 <strong>不止一个</strong> 信号已经到达。比如，我们在一个模拟shell行为的程序中监听SIGCHLD信号，每接受到一个SIGCHLD就回收相应的子进程。如果在handler处理第一个SIGCHLD的过程中又有两个新的SIGCHLD到达，那么其中的一个就会被丢弃。</p>
<p>为了解决这个问题，我们需要用一个不断执行<code>waitpid</code>直到返回-1的循环来取代对<code>waitpid</code>操作次数的计数。</p>
<h3 id="信号处理的兼容性"><a href="#信号处理的兼容性" class="headerlink" title="信号处理的兼容性"></a>信号处理的兼容性</h3><p>在不同的Unix系统上，<code>signal</code>函数的行为可能不一致。为此，我们可以显式地调用<code>sigaction</code>函数来设定默认行为。</p>
<h3 id="信号处理的常见问题及解决方案"><a href="#信号处理的常见问题及解决方案" class="headerlink" title="信号处理的常见问题及解决方案"></a>信号处理的常见问题及解决方案</h3><h4 id="任务列表管理中的race-condition问题"><a href="#任务列表管理中的race-condition问题" class="headerlink" title="任务列表管理中的race condition问题"></a>任务列表管理中的race condition问题</h4><p>有一个经典的案例：父进程通过fork创建一个子进程并将其添加到任务列表中，并在接受到SIG_CHLD信号之后将其从任务列表中移除。然而由于某些状况，子进程在被创建之后立即退出。在这个案例中，系统的控制流是这样变化的：</p>
<ul>
<li>父进程发出请求创建子进程，控制流陷入内核</li>
<li>内核创建子进程并移交控制权</li>
<li>子进程退出，控制权回到内核，内核向父进程发送一个SIG_CHLD信号</li>
</ul>
<p>需要注意的是这个时候父进程还并没有拿回控制权，因而它并不知道子进程已经终止。但它在接收到SIG_CHLD信号的时候会马上调用对应的handler去从任务列表中移除子进程，而当时任务列表中甚至还没有这个子进程！</p>
<p>为了解决这个问题，处理程序应当在创建子进程之前阻塞SIG_CHLD信号，并在添加完任务之后再取消这个阻塞。这样就实现了并发进程之间的同步。</p>
<h3 id="显式地等待信号"><a href="#显式地等待信号" class="headerlink" title="显式地等待信号"></a>显式地等待信号</h3><p>另一个例子是，父进程在创建一个子进程之后需要等待其返回再进行下一步操作。判断等待何时结束显然要依靠SIG_CHLD信号的接受和处理，但在等待的过程中应该做什么呢？</p>
<p><code>sigsuspend(const sigset_t *mask)</code>函数可以解决这个问题。它包括了用mask取代原有的阻塞集合、等待某个信号到达和恢复原有的阻塞集合三个操作，但不同于分别进行这三个操作的是，这个函数是 <strong>原子的</strong> 。</p>
<p>常见的处理机制是，父进程阻塞SIG_CHLD信号并创建子进程，然后调用<code>sigsuspend</code>函数来取消阻塞并等待SIG_CHLD信号，在接受信号之后恢复阻塞并继续执行之后的指令。</p>
<h2 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h2><p>有一种方式可以让用户程序摆脱一般函数的调用-返回逻辑，直接将控制流跳转到一个指定位置，并设定当时的 <strong>系统环境</strong> (系统环境是指程序计数器，栈指针，通用寄存器的值等信息)。</p>
<p><code>int setjmp(jmp_buf env)</code>函数可以在当前的位置设定一个跳转坐标，并将当前的系统环境保存在env变量中，之后挂起等待跳转。如果用户程序在其他位置调用了<code>longjmp(jmp_buf env, int retval)</code>函数，控制流就会跳转到setjmp的调用位置，恢复env所保存的环境，然后<code>setjmp</code>函数返回，返回值为retval。</p>
<p>需要注意的是，<code>setjmp</code>函数的返回值不能被用来赋值，只能用于判断。</p>
<h2 id="操作进程的工具"><a href="#操作进程的工具" class="headerlink" title="操作进程的工具"></a>操作进程的工具</h2><ul>
<li><code>strace</code>：打印一个正在运行的程序以及它的子进程所做的系统调用轨迹</li>
<li><code>ps</code>：列出所有进程</li>
<li><code>pmap</code>：显示进程的内存映射</li>
<li><code>top/htop</code>：类似于任务管理器</li>
</ul>
<h1 id="Chapter-9-虚拟内存"><a href="#Chapter-9-虚拟内存" class="headerlink" title="Chapter 9 虚拟内存"></a>Chapter 9 虚拟内存</h1><p>虚拟内存提供了三个重要的能力：</p>
<ul>
<li>在主存中只保留活动区域，高效地利用了主存</li>
<li>它为每个进程分配了一致的地址空间，简化了内存管理</li>
<li>每个进程拥有了自己独特的地址空间，内存空间因而不会受到破坏</li>
</ul>
<h2 id="物理寻址和虚拟寻址"><a href="#物理寻址和虚拟寻址" class="headerlink" title="物理寻址和虚拟寻址"></a>物理寻址和虚拟寻址</h2>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/2018/03/01/借助WSL在Windows下使用gcc/" rel="next" title="借助WSL在Windows下使用GCC等GNU工具">
                <i class="fa fa-chevron-left"></i> 借助WSL在Windows下使用GCC等GNU工具
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/2018/07/11/ArchLinux下的软件安装/" rel="prev" title="ArchLinux下的软件安装">
                ArchLinux下的软件安装 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/blog/images/lyrica.png" alt="Drac Zhang">
            
              <p class="site-author-name" itemprop="name">Drac Zhang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/blog/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/blog/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/dracit7" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-1-计算机系统漫游"><span class="nav-number">1.</span> <span class="nav-text">Chapter 1 计算机系统漫游</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#有关C语言"><span class="nav-number">1.1.</span> <span class="nav-text">有关C语言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编译系统"><span class="nav-number">1.2.</span> <span class="nav-text">编译系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#有关GNU项目"><span class="nav-number">1.2.1.</span> <span class="nav-text">有关GNU项目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算机系统的硬件组成"><span class="nav-number">1.3.</span> <span class="nav-text">计算机系统的硬件组成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#总线"><span class="nav-number">1.3.1.</span> <span class="nav-text">总线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O-设备"><span class="nav-number">1.3.2.</span> <span class="nav-text">I/O 设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主存"><span class="nav-number">1.3.3.</span> <span class="nav-text">主存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理器"><span class="nav-number">1.3.4.</span> <span class="nav-text">处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#程序计数器"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算数逻辑单元"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">算数逻辑单元</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高速缓存"><span class="nav-number">1.3.5.</span> <span class="nav-text">高速缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统"><span class="nav-number">1.4.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统的基本功能："><span class="nav-number">1.4.1.</span> <span class="nav-text">操作系统的基本功能：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#有关Unix"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">有关Unix</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统提供的抽象表示"><span class="nav-number">1.4.2.</span> <span class="nav-text">操作系统提供的抽象表示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-进程"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">1.进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-线程"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">2.线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-虚拟内存"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">3.虚拟内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-文件"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">4.文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算机网络"><span class="nav-number">1.5.</span> <span class="nav-text">计算机网络</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-2-信息的表示与处理"><span class="nav-number">2.</span> <span class="nav-text">Chapter 2 信息的表示与处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#信息存储"><span class="nav-number">2.1.</span> <span class="nav-text">信息存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#十六进制表示法"><span class="nav-number">2.1.1.</span> <span class="nav-text">十六进制表示法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字数据大小"><span class="nav-number">2.1.2.</span> <span class="nav-text">字数据大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寻址和字节序"><span class="nav-number">2.1.3.</span> <span class="nav-text">寻址和字节序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#表示字符串"><span class="nav-number">2.1.4.</span> <span class="nav-text">表示字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#位运算"><span class="nav-number">2.1.5.</span> <span class="nav-text">位运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#整数表示"><span class="nav-number">2.2.</span> <span class="nav-text">整数表示</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#补码的计算原理"><span class="nav-number">2.2.1.</span> <span class="nav-text">补码的计算原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#补码的符号扩展"><span class="nav-number">2.2.2.</span> <span class="nav-text">补码的符号扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#补码的截断"><span class="nav-number">2.2.3.</span> <span class="nav-text">补码的截断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非补码的数据表示"><span class="nav-number">2.2.4.</span> <span class="nav-text">非补码的数据表示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#整数运算"><span class="nav-number">2.3.</span> <span class="nav-text">整数运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#unsigned-int的运算"><span class="nav-number">2.3.1.</span> <span class="nav-text">unsigned int的运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#补码的运算"><span class="nav-number">2.3.2.</span> <span class="nav-text">补码的运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对于整数乘法的优化"><span class="nav-number">2.3.3.</span> <span class="nav-text">对于整数乘法的优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对于整数除法的优化"><span class="nav-number">2.3.4.</span> <span class="nav-text">对于整数除法的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#整数除法的舍入问题"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">整数除法的舍入问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浮点数"><span class="nav-number">2.4.</span> <span class="nav-text">浮点数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IEEE小数的结构"><span class="nav-number">2.4.1.</span> <span class="nav-text">IEEE小数的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#三类浮点数"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">三类浮点数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#当exp不为0且不为255时"><span class="nav-number">2.4.1.1.1.</span> <span class="nav-text">当exp不为0且不为255时</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#当exp为0时"><span class="nav-number">2.4.1.1.2.</span> <span class="nav-text">当exp为0时</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#当exp-255-也就是阶码字段全为1时："><span class="nav-number">2.4.1.1.3.</span> <span class="nav-text">当exp=255,也就是阶码字段全为1时：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浮点数的运算"><span class="nav-number">2.4.2.</span> <span class="nav-text">浮点数的运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#浮点数的舍入运算"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">浮点数的舍入运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#浮点数的算术运算"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">浮点数的算术运算</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浮点数与其他数据类型的转换"><span class="nav-number">2.4.3.</span> <span class="nav-text">浮点数与其他数据类型的转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-3-程序的机器级表示"><span class="nav-number">3.</span> <span class="nav-text">Chapter 3 程序的机器级表示</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#x86-64缘起"><span class="nav-number">3.1.</span> <span class="nav-text">x86-64缘起</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#研究汇编程序编码"><span class="nav-number">3.2.</span> <span class="nav-text">研究汇编程序编码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#需要用到的调试工具"><span class="nav-number">3.2.1.</span> <span class="nav-text">需要用到的调试工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x86-64机器代码的特性"><span class="nav-number">3.2.2.</span> <span class="nav-text">x86-64机器代码的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码格式"><span class="nav-number">3.2.3.</span> <span class="nav-text">代码格式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#两种不同的汇编代码格式"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">两种不同的汇编代码格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在C程序中插入汇编代码"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">在C程序中插入汇编代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据格式"><span class="nav-number">3.2.4.</span> <span class="nav-text">数据格式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问信息操作"><span class="nav-number">3.3.</span> <span class="nav-text">访问信息操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#操作数指示符"><span class="nav-number">3.3.1.</span> <span class="nav-text">操作数指示符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据传送指令"><span class="nav-number">3.3.2.</span> <span class="nav-text">数据传送指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#入栈出栈指令"><span class="nav-number">3.3.3.</span> <span class="nav-text">入栈出栈指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算术和逻辑操作"><span class="nav-number">3.4.</span> <span class="nav-text">算术和逻辑操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#加载有效地址"><span class="nav-number">3.4.1.</span> <span class="nav-text">加载有效地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一元算术运算"><span class="nav-number">3.4.2.</span> <span class="nav-text">一元算术运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二元算术运算"><span class="nav-number">3.4.3.</span> <span class="nav-text">二元算术运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#移位运算"><span class="nav-number">3.4.4.</span> <span class="nav-text">移位运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特殊算术操作"><span class="nav-number">3.4.5.</span> <span class="nav-text">特殊算术操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制操作"><span class="nav-number">3.5.</span> <span class="nav-text">控制操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#条件操作"><span class="nav-number">3.5.1.</span> <span class="nav-text">条件操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#条件码寄存器"><span class="nav-number">3.5.1.1.</span> <span class="nav-text">条件码寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对条件码的访问"><span class="nav-number">3.5.1.2.</span> <span class="nav-text">对条件码的访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用条件控制来实现条件分支"><span class="nav-number">3.5.1.3.</span> <span class="nav-text">用条件控制来实现条件分支</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#JMP指令"><span class="nav-number">3.5.1.3.1.</span> <span class="nav-text">JMP指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CMOV指令"><span class="nav-number">3.5.1.3.2.</span> <span class="nav-text">CMOV指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#两种条件控制方式的比较"><span class="nav-number">3.5.1.3.3.</span> <span class="nav-text">两种条件控制方式的比较</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环操作"><span class="nav-number">3.5.2.</span> <span class="nav-text">循环操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch操作"><span class="nav-number">3.5.3.</span> <span class="nav-text">switch操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过程"><span class="nav-number">3.6.</span> <span class="nav-text">过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时栈"><span class="nav-number">3.6.1.</span> <span class="nav-text">运行时栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转移控制"><span class="nav-number">3.6.2.</span> <span class="nav-text">转移控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据传送"><span class="nav-number">3.6.3.</span> <span class="nav-text">数据传送</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分配内存"><span class="nav-number">3.6.4.</span> <span class="nav-text">分配内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寄存器使用"><span class="nav-number">3.6.5.</span> <span class="nav-text">寄存器使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归实现"><span class="nav-number">3.6.6.</span> <span class="nav-text">递归实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">3.7.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体"><span class="nav-number">3.8.</span> <span class="nav-text">结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存越界引用和缓冲区溢出"><span class="nav-number">3.9.</span> <span class="nav-text">内存越界引用和缓冲区溢出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#地址空间布局随机化"><span class="nav-number">3.9.1.</span> <span class="nav-text">地址空间布局随机化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈破坏检测"><span class="nav-number">3.9.2.</span> <span class="nav-text">栈破坏检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#限制可执行代码区域"><span class="nav-number">3.9.3.</span> <span class="nav-text">限制可执行代码区域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浮点数操作"><span class="nav-number">3.10.</span> <span class="nav-text">浮点数操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#浮点数使用的寄存器"><span class="nav-number">3.10.1.</span> <span class="nav-text">浮点数使用的寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浮点数的操作命令"><span class="nav-number">3.10.2.</span> <span class="nav-text">浮点数的操作命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过程中的浮点数"><span class="nav-number">3.10.3.</span> <span class="nav-text">过程中的浮点数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-4-处理器体系结构"><span class="nav-number">4.</span> <span class="nav-text">Chapter 4 处理器体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Y86-64-ISA"><span class="nav-number">4.1.</span> <span class="nav-text">Y86-64 ISA</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#程序员可见的状态"><span class="nav-number">4.1.1.</span> <span class="nav-text">程序员可见的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Y86-64指令集"><span class="nav-number">4.1.2.</span> <span class="nav-text">Y86-64指令集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指令集编码"><span class="nav-number">4.1.3.</span> <span class="nav-text">指令集编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#编码规范"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">编码规范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RISC与CISC"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">RISC与CISC</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常处理"><span class="nav-number">4.1.4.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伪指令"><span class="nav-number">4.1.5.</span> <span class="nav-text">伪指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#硬件控制语言HCL"><span class="nav-number">4.2.</span> <span class="nav-text">硬件控制语言HCL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#逻辑门和组合电路"><span class="nav-number">4.2.1.</span> <span class="nav-text">逻辑门和组合电路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字级别的组合电路"><span class="nav-number">4.2.2.</span> <span class="nav-text">字级别的组合电路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合关系"><span class="nav-number">4.2.3.</span> <span class="nav-text">集合关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储器与时钟"><span class="nav-number">4.2.4.</span> <span class="nav-text">存储器与时钟</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Y86-64的顺序实现"><span class="nav-number">4.3.</span> <span class="nav-text">Y86-64的顺序实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#将指令划分阶段"><span class="nav-number">4.3.1.</span> <span class="nav-text">将指令划分阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SEQ硬件结构"><span class="nav-number">4.3.2.</span> <span class="nav-text">SEQ硬件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#硬件对指令六个步骤的配合"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">硬件对指令六个步骤的配合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SEQ时序控制"><span class="nav-number">4.3.2.2.</span> <span class="nav-text">SEQ时序控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SEQ的HCL实现"><span class="nav-number">4.3.2.3.</span> <span class="nav-text">SEQ的HCL实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流水线化原理"><span class="nav-number">4.4.</span> <span class="nav-text">流水线化原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#流水线化的局限性"><span class="nav-number">4.4.1.</span> <span class="nav-text">流水线化的局限性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#带反馈的流水线化系统"><span class="nav-number">4.4.2.</span> <span class="nav-text">带反馈的流水线化系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设计流水线化的Y86-64处理器"><span class="nav-number">4.4.3.</span> <span class="nav-text">设计流水线化的Y86-64处理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常处理-1"><span class="nav-number">4.4.4.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制逻辑"><span class="nav-number">4.4.5.</span> <span class="nav-text">控制逻辑</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#完整的Y86-64流水线化处理器"><span class="nav-number">4.5.</span> <span class="nav-text">完整的Y86-64流水线化处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PIPE的HCL实现"><span class="nav-number">4.5.1.</span> <span class="nav-text">PIPE的HCL实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示意图"><span class="nav-number">4.5.2.</span> <span class="nav-text">示意图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#改进的空间"><span class="nav-number">4.6.</span> <span class="nav-text">改进的空间</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-5-优化程序性能"><span class="nav-number">5.</span> <span class="nav-text">Chapter 5 优化程序性能</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#绪论"><span class="nav-number">5.1.</span> <span class="nav-text">绪论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编译器优化的局限性"><span class="nav-number">5.2.</span> <span class="nav-text">编译器优化的局限性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编译器的优化级别"><span class="nav-number">5.2.1.</span> <span class="nav-text">编译器的优化级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#保证优化的安全性"><span class="nav-number">5.2.2.</span> <span class="nav-text">保证优化的安全性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Memory-aliasing"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">Memory aliasing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数调用"><span class="nav-number">5.2.2.2.</span> <span class="nav-text">函数调用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#度量程序的性能"><span class="nav-number">5.3.</span> <span class="nav-text">度量程序的性能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对循环过程进行的优化"><span class="nav-number">5.4.</span> <span class="nav-text">对循环过程进行的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#代码移动"><span class="nav-number">5.4.1.</span> <span class="nav-text">代码移动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#减少过程调用"><span class="nav-number">5.4.2.</span> <span class="nav-text">减少过程调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消除不必要的内存引用"><span class="nav-number">5.4.3.</span> <span class="nav-text">消除不必要的内存引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用硬件特性进行的优化"><span class="nav-number">5.5.</span> <span class="nav-text">利用硬件特性进行的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#现代微处理器设计"><span class="nav-number">5.5.1.</span> <span class="nav-text">现代微处理器设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#功能单元的性能"><span class="nav-number">5.5.2.</span> <span class="nav-text">功能单元的性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关键路径"><span class="nav-number">5.5.3.</span> <span class="nav-text">关键路径</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环展开"><span class="nav-number">5.6.</span> <span class="nav-text">循环展开</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#提高并行性"><span class="nav-number">5.7.</span> <span class="nav-text">提高并行性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他的制约因素"><span class="nav-number">5.8.</span> <span class="nav-text">其他的制约因素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#寄存器溢出"><span class="nav-number">5.8.1.</span> <span class="nav-text">寄存器溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#预测错误处罚"><span class="nav-number">5.8.2.</span> <span class="nav-text">预测错误处罚</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#程序分析工具gprof"><span class="nav-number">5.9.</span> <span class="nav-text">程序分析工具gprof</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-6-存储器层次结构"><span class="nav-number">6.</span> <span class="nav-text">Chapter 6 存储器层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#存储技术"><span class="nav-number">6.1.</span> <span class="nav-text">存储技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#随机访问存储器-RAM"><span class="nav-number">6.1.1.</span> <span class="nav-text">随机访问存储器(RAM)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内存条的存储结构"><span class="nav-number">6.1.1.1.</span> <span class="nav-text">内存条的存储结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非易失性存储器"><span class="nav-number">6.1.2.</span> <span class="nav-text">非易失性存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#只读存储器-ROM"><span class="nav-number">6.1.2.1.</span> <span class="nav-text">只读存储器(ROM)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#磁盘"><span class="nav-number">6.1.3.</span> <span class="nav-text">磁盘</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-7-链接"><span class="nav-number">7.</span> <span class="nav-text">Chapter 7 链接</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Compiler-driver"><span class="nav-number">7.1.</span> <span class="nav-text">Compiler driver</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态链接"><span class="nav-number">7.2.</span> <span class="nav-text">静态链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#目标文件"><span class="nav-number">7.3.</span> <span class="nav-text">目标文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#可重定位目标文件"><span class="nav-number">7.3.1.</span> <span class="nav-text">可重定位目标文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ELF头"><span class="nav-number">7.3.1.1.</span> <span class="nav-text">ELF头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#节头部表"><span class="nav-number">7.3.1.2.</span> <span class="nav-text">节头部表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#节"><span class="nav-number">7.3.1.3.</span> <span class="nav-text">节</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#符号表"><span class="nav-number">7.3.1.4.</span> <span class="nav-text">符号表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可执行目标文件"><span class="nav-number">7.3.2.</span> <span class="nav-text">可执行目标文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#可执行目标文件的加载"><span class="nav-number">7.3.2.1.</span> <span class="nav-text">可执行目标文件的加载</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#符号解析"><span class="nav-number">7.4.</span> <span class="nav-text">符号解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多重定义的全局符号"><span class="nav-number">7.4.1.</span> <span class="nav-text">多重定义的全局符号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态库"><span class="nav-number">7.4.2.</span> <span class="nav-text">静态库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重定位"><span class="nav-number">7.5.</span> <span class="nav-text">重定位</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#重定位条目"><span class="nav-number">7.5.1.</span> <span class="nav-text">重定位条目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态链接库"><span class="nav-number">7.6.</span> <span class="nav-text">动态链接库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#位置无关代码-PIC"><span class="nav-number">7.6.1.</span> <span class="nav-text">位置无关代码(PIC)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#库打桩机制"><span class="nav-number">7.7.</span> <span class="nav-text">库打桩机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编译时打桩"><span class="nav-number">7.7.1.</span> <span class="nav-text">编译时打桩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链接时打桩"><span class="nav-number">7.7.2.</span> <span class="nav-text">链接时打桩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时打桩"><span class="nav-number">7.7.3.</span> <span class="nav-text">运行时打桩</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工具总结"><span class="nav-number">7.8.</span> <span class="nav-text">工具总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-8-异常控制流"><span class="nav-number">8.</span> <span class="nav-text">Chapter 8 异常控制流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#异常"><span class="nav-number">8.1.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#异常的类别"><span class="nav-number">8.1.1.</span> <span class="nav-text">异常的类别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Interrupt"><span class="nav-number">8.1.1.1.</span> <span class="nav-text">Interrupt</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Trap"><span class="nav-number">8.1.1.2.</span> <span class="nav-text">Trap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Fault"><span class="nav-number">8.1.1.3.</span> <span class="nav-text">Fault</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Abort"><span class="nav-number">8.1.1.4.</span> <span class="nav-text">Abort</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见的异常"><span class="nav-number">8.1.2.</span> <span class="nav-text">常见的异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux的系统调用"><span class="nav-number">8.1.3.</span> <span class="nav-text">Linux的系统调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程"><span class="nav-number">8.2.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#逻辑控制流"><span class="nav-number">8.2.1.</span> <span class="nav-text">逻辑控制流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#私有地址空间"><span class="nav-number">8.2.2.</span> <span class="nav-text">私有地址空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#系统态和用户态"><span class="nav-number">8.2.3.</span> <span class="nav-text">系统态和用户态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#系统调用的错误处理"><span class="nav-number">8.3.</span> <span class="nav-text">系统调用的错误处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程控制"><span class="nav-number">8.4.</span> <span class="nav-text">进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fork指令"><span class="nav-number">8.4.1.</span> <span class="nav-text">fork指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子进程的回收"><span class="nav-number">8.4.2.</span> <span class="nav-text">子进程的回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加载和运行程序"><span class="nav-number">8.4.3.</span> <span class="nav-text">加载和运行程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号"><span class="nav-number">8.5.</span> <span class="nav-text">信号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程组"><span class="nav-number">8.5.1.</span> <span class="nav-text">进程组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号的发送"><span class="nav-number">8.5.2.</span> <span class="nav-text">信号的发送</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号的接受"><span class="nav-number">8.5.3.</span> <span class="nav-text">信号的接受</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号的阻塞"><span class="nav-number">8.5.4.</span> <span class="nav-text">信号的阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号处理程序的编写"><span class="nav-number">8.5.5.</span> <span class="nav-text">信号处理程序的编写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号处理的兼容性"><span class="nav-number">8.5.6.</span> <span class="nav-text">信号处理的兼容性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号处理的常见问题及解决方案"><span class="nav-number">8.5.7.</span> <span class="nav-text">信号处理的常见问题及解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#任务列表管理中的race-condition问题"><span class="nav-number">8.5.7.1.</span> <span class="nav-text">任务列表管理中的race condition问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#显式地等待信号"><span class="nav-number">8.5.8.</span> <span class="nav-text">显式地等待信号</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非本地跳转"><span class="nav-number">8.6.</span> <span class="nav-text">非本地跳转</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作进程的工具"><span class="nav-number">8.7.</span> <span class="nav-text">操作进程的工具</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-9-虚拟内存"><span class="nav-number">9.</span> <span class="nav-text">Chapter 9 虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#物理寻址和虚拟寻址"><span class="nav-number">9.1.</span> <span class="nav-text">物理寻址和虚拟寻址</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Drac Zhang</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/blog/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/blog/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://Drac_zhang.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://dracit7.github.io/blog/2018/04/12/Note of CSAPP/';
          this.page.identifier = '2018/04/12/Note of CSAPP/';
          this.page.title = 'CSAPP学习笔记';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://Drac_zhang.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
