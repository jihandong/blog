<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="MIT 6.828 Labs 实验记录本博客中所有代码所对应的github repo地址：6.828 Overall 6.828自带了一个打分系统，在Lab文件夹下执行make grade即可运行这个系统来检验自己的解答。 make grade执行过程中JOS console的输出会保存在当前文件夹下的jos.out.xxx文件中  Build up the environmentCompiler">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT 6.828 Labs 实验记录">
<meta property="og:url" content="https://dracit7.github.io/blog/2019/02/24/MIT_6.828/index.html">
<meta property="og:site_name" content="Gensokyo">
<meta property="og:description" content="MIT 6.828 Labs 实验记录本博客中所有代码所对应的github repo地址：6.828 Overall 6.828自带了一个打分系统，在Lab文件夹下执行make grade即可运行这个系统来检验自己的解答。 make grade执行过程中JOS console的输出会保存在当前文件夹下的jos.out.xxx文件中  Build up the environmentCompiler">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://dracit7.github.io/blog/2019/02/24/MIT_6.828/memlayout.png">
<meta property="og:image" content="https://dracit7.github.io/blog/2019/02/24/MIT_6.828/descriptor.png">
<meta property="og:image" content="https://dracit7.github.io/home/drac_zhang/Workplace/PersonalWebsite/Blog/source/_posts/MIT_6.828/trapframe.png">
<meta property="og:updated_time" content="2019-04-20T09:11:44.913Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MIT 6.828 Labs 实验记录">
<meta name="twitter:description" content="MIT 6.828 Labs 实验记录本博客中所有代码所对应的github repo地址：6.828 Overall 6.828自带了一个打分系统，在Lab文件夹下执行make grade即可运行这个系统来检验自己的解答。 make grade执行过程中JOS console的输出会保存在当前文件夹下的jos.out.xxx文件中  Build up the environmentCompiler">
<meta name="twitter:image" content="https://dracit7.github.io/blog/2019/02/24/MIT_6.828/memlayout.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://dracit7.github.io/blog/2019/02/24/MIT_6.828/">





  <title>MIT 6.828 Labs 实验记录 | Gensokyo</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Gensokyo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Youkai's Mountain</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/blog/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2019/02/24/MIT_6.828/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">MIT 6.828 Labs 实验记录</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-24T20:10:08+08:00">
                2019-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Academic or Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/Operating-System/" itemprop="url" rel="index">
                    <span itemprop="name">Operating System</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2019/02/24/MIT_6.828/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/02/24/MIT_6.828/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="MIT-6-828-Labs-实验记录"><a href="#MIT-6-828-Labs-实验记录" class="headerlink" title="MIT 6.828 Labs 实验记录"></a>MIT 6.828 Labs 实验记录</h2><p>本博客中所有代码所对应的github repo地址：<a href="https://github.com/dracit7/6.828" target="_blank" rel="noopener">6.828</a></p>
<h3 id="Overall"><a href="#Overall" class="headerlink" title="Overall"></a>Overall</h3><ul>
<li>6.828自带了一个打分系统，在Lab文件夹下执行<code>make grade</code>即可运行这个系统来检验自己的解答。</li>
<li><code>make grade</code>执行过程中JOS console的输出会保存在当前文件夹下的<code>jos.out.xxx</code>文件中</li>
</ul>
<h3 id="Build-up-the-environment"><a href="#Build-up-the-environment" class="headerlink" title="Build up the environment"></a>Build up the environment</h3><h4 id="Compiler-Toolchain"><a href="#Compiler-Toolchain" class="headerlink" title="Compiler Toolchain"></a>Compiler Toolchain</h4><p>由于Archlinux中的objdump和gcc均满足Lab的要求，不需要手动搭建编译环境。</p>
<h4 id="QEMU-emulator"><a href="#QEMU-emulator" class="headerlink" title="QEMU emulator"></a>QEMU emulator</h4><p>建议follow一下MIT官网上最新版的6.828课程页面。老的课程页面上的链接可能不可用。此处根据<a href="https://pdos.csail.mit.edu/6.828/2018/tools.html" target="_blank" rel="noopener">Fall 2018的课程页面</a>进行配置。</p>
<p>由于QEMU的调试系统不完善，课程组准备了改进过的QEMU，使它可以与系统中的GDB调试器绑定，并使用GDB来调试。执行以下步骤安装打好补丁的QEMU:</p>
<ol>
<li>执行<code>git clone https://github.com/mit-pdos/6.828-qemu.git qemu</code>拉取源代码</li>
<li>安装各种依赖。在Archlinux下的安装方式如下：<ul>
<li>libdtc：<code>yay DTC</code>，任选一项安装。</li>
<li>python：坑爹的是都8102年了这门课还不支持python3.不过Arch一般自带python2,问题不大</li>
</ul>
</li>
<li>进入源代码文件夹，Configure the source code<ul>
<li>执行<code>./configure --disable-kvm --disable-werror --python= &lt;pathToPython2&gt;</code></li>
</ul>
</li>
<li>执行<code>make &amp;&amp; make install</code>进行安装</li>
</ol>
<p>安装到一半，报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">qga/commands-posix.c: 在函数‘dev_major_minor’中:</span><br><span class="line">qga/commands-posix.c:634:21: 警告：implicit declaration of <span class="keyword">function</span> ‘major’; did you mean ‘_m_por’? [-Wimplicit-function-declaration]</span><br><span class="line">         *devmajor = major(st.st_rdev);</span><br><span class="line">                     ^~~~~</span><br><span class="line">                     _m_por</span><br><span class="line">qga/commands-posix.c:634:21: 警告：对‘major’的嵌套的外部声明 [-Wnested-externs]</span><br><span class="line">qga/commands-posix.c:635:21: 警告：implicit declaration of <span class="keyword">function</span> ‘minor’; did you mean ‘mknod’? [-Wimplicit-function-declaration]</span><br><span class="line">         *devminor = minor(st.st_rdev);</span><br><span class="line">                     ^~~~~</span><br><span class="line">                     mknod</span><br><span class="line">qga/commands-posix.c:635:21: 警告：对‘minor’的嵌套的外部声明 [-Wnested-externs]</span><br></pre></td></tr></table></figure>
<p>很显然是有两个函数major和minor在使用之前并未声明。这是两个库函数，在linux下的<code>&lt;sys/sysmacros.h&gt;</code>头文件中有定义，然而MIT给的代码里并没有包含这个头文件。根据报错信息打开<code>qga/commands-posix.c</code>，添加<code>#include &lt;sys/sysmacros.h&gt;</code>，保存。</p>
<p>再次安装，装到一半又报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: ../hw/9pfs/virtio-9p.o: <span class="keyword">in</span> <span class="keyword">function</span> `stat_to_v9stat<span class="string">':</span></span><br><span class="line"><span class="string">/home/drac_zhang/Downloads/qemu/hw/9pfs/virtio-9p.c:796: undefined reference to `minor'</span></span><br><span class="line">/usr/bin/ld: /home/drac_zhang/Downloads/qemu/hw/9pfs/virtio-9p.c:796: undefined reference to `major<span class="string">'</span></span><br><span class="line"><span class="string">/usr/bin/ld: ../hw/9pfs/virtio-9p.o: in function `v9fs_mknod'</span>:</span><br><span class="line">/home/drac_zhang/Downloads/qemu/hw/9pfs/virtio-9p.c:2803: undefined reference to `makedev<span class="string">'</span></span><br><span class="line"><span class="string">/usr/bin/ld: ../hw/9pfs/virtio-9p.o: in function `v9fs_create'</span>:</span><br><span class="line">/home/drac_zhang/Downloads/qemu/hw/9pfs/virtio-9p.c:2124: undefined reference to `makedev<span class="string">'</span></span><br><span class="line"><span class="string">collect2: 错误：ld 返回 1</span></span><br></pre></td></tr></table></figure>
<p>差不多的理由，还是缺少库函数。也不管重复包含dirty不dirty了，向<code>hw/9pfs/virtio-9p.c</code>中添加<code>#include &lt;sys/sysmacros.h&gt;</code>，保存后再次编译。</p>
<p>因为类似的理由，还需要添加这个头文件的源文件有<code>linux-user/strace.c</code>。</p>
<h4 id="Other-problems"><a href="#Other-problems" class="headerlink" title="Other problems"></a>Other problems</h4><p>这里是其他各种各样可能会出现的玄学错误。</p>
<h5 id="Dependencies-upgraded"><a href="#Dependencies-upgraded" class="headerlink" title="Dependencies upgraded"></a>Dependencies upgraded</h5><p>在我完成这个lab的过程中，<code>libnfs</code>库在我滚arch的时候升级了，结果一运行<code>make</code>就会报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error <span class="keyword">while</span> loading shared libraries: libnfs.so.12: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
<p>执行<code>whereis libnfs.so.12</code>，发现系统的库中只有<code>libnfs.so.13</code>，原来是这个库在升级的时候名字变掉了……</p>
<p>没办法，只好用<code>downgrade</code>命令手动降级到<code>4.0.0-2</code>版本，再执行<code>make</code>的时候就没事了。</p>
<h3 id="Lab-1-Booting-a-PC"><a href="#Lab-1-Booting-a-PC" class="headerlink" title="Lab 1 Booting a PC"></a>Lab 1 Booting a PC</h3><p>Lab1的源码可以从<code>https://pdos.csail.mit.edu/6.828/2018/jos.git</code>处clone到。</p>
<h4 id="Part-1-PC-bootstrap"><a href="#Part-1-PC-bootstrap" class="headerlink" title="Part 1 PC bootstrap"></a>Part 1 PC bootstrap</h4><p>这一部分的目的是让我们熟悉x86汇编语言和PC bootstrap过程，并熟悉QEMU和gdb的操作。</p>
<p>首先在lab目录下执行<code>make</code>命令来编译内核和启动器。编译完成的内核与启动器位于<code>obj/kern/kernel.img</code>镜像文件中，这个镜像文件是一个用于模拟真实硬盘的虚拟磁盘。</p>
<p>执行<code>make qemu</code>可以正式在qemu中运行编译好的操作系统，此时命令行终端会创建一个新的窗口，同时在终端中显示与窗口中同样的内容(并接受同样的输入)。方便起见，这里我们用终端进行接下来的操作。</p>
<p>一开始这个shell只有两条简单的指令：<code>help</code>和<code>kerninfo</code>。后者会打印出目前的内核状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Special kernel symbols:</span><br><span class="line">  _start                  0010000c (phys)</span><br><span class="line">  entry  f010000c (virt)  0010000c (phys)</span><br><span class="line">  etext  f01019df (virt)  001019df (phys)</span><br><span class="line">  edata  f0113060 (virt)  00113060 (phys)</span><br><span class="line">  end    f01136a0 (virt)  001136a0 (phys)</span><br><span class="line">Kernel executable memory footprint: 78KB</span><br></pre></td></tr></table></figure>
<p>要退出qemu可以打出<code>Ctrl+a x</code>。</p>
<h5 id="Layout-of-the-physical-address-space"><a href="#Layout-of-the-physical-address-space" class="headerlink" title="Layout of the physical address space"></a>Layout of the physical address space</h5><table>
<thead>
<tr>
<th style="text-align:center">+——————————+</th>
<th>&lt;- 0xFFFFFFFF(4GB)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\</td>
<td>内存映射的虚拟地址  \</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">+——————————+</td>
<td>&lt;- 取决于RAM的数量</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td>扩展内存           \</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">+——————————+</td>
<td>&lt;- 0x00100000 (1MB)</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td>BIOS所在的ROM    \</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">+——————————+</td>
<td>&lt;- 0x000F0000 (960KB)</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td>16位机使用的扩展ROM\</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">+——————————+</td>
<td>&lt;- 0x000C0000 (768KB)</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td>VGA Display        \</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">+——————————+</td>
<td>&lt;- 0x000A0000 (640KB)</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td>Low Memory       \</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">+——————————+</td>
<td>&lt;- 0x00000000</td>
</tr>
</tbody>
</table>
<p>一开始的16位机只能使用最下面那一共<strong>1MB</strong>的物理存储，而可用的内存只有标识为Low Memory的<strong>640KB</strong>。标注有VGA Display的部分是硬件保留区，用于当作VGA显示屏的缓冲区。</p>
<p>就算是在Intel突破了“1MB的瓶颈”之后，PC设计师也仍然对于最低的1MB地址空间使用原始的架构，这是为了软件的向后兼容性。这样就在LowMemory和扩展内存之间留下了一个<strong>空洞</strong>(IO hole)。在操作系统的内存分配中，这个空洞所对应的地址段不应被虚拟地址系统所使用。</p>
<p>在计算机从32位升级为64位时，BIOS在地址空间的最顶段因为类似的理由留下了第二个空洞，不过由于本实验在32位系统下进行，这个空洞不予考虑。</p>
<h5 id="The-ROM-BIOS"><a href="#The-ROM-BIOS" class="headerlink" title="The ROM BIOS"></a>The ROM BIOS</h5><p>为了单步调试计算机的启动过程，我们需要两个终端，一个用<code>make qemu-gdb</code>来启动qemu虚拟机，一个用<code>make gdb</code>来将gdb调试环境连接到虚拟机上。</p>
<p><code>make qemu-gdb</code>会将处理器暂停在即将执行第一条指令之前并等待gdb的连接，这时在另一个终端中使用<code>make gdb</code>就可以通过gdb来调试操作系统内核。</p>
<p>gdb终端会显示一段结尾如下的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The target architecture is assumed to be i8086</span><br><span class="line">[f000:fff0]    0xffff0: ljmp   $0xf000,$0xe05b</span><br><span class="line">0x0000fff0 in ?? ()</span><br><span class="line">+ symbol-file obj/kern/kernel</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>其中的第二行代表着目前将要执行的指令，也就是虚拟机开启过程的第一条指令。</p>
<p>这条指令的含义是：</p>
<ul>
<li><code>0xffff0:</code>：指令位于的虚拟存储系统地址，对应于上面的架构，这个位置是属于BIOS的ROM区域的最上面，也就是BIOS程序的起始位置。</li>
<li><code>[f000:fff0]</code>：指示当前CS和IP寄存器的值。CS寄存器指示代码所在的数据段，IP则是偏移量。</li>
<li><code>ljmp</code>：跳转指令，跳转到CS和IP为<code>[f000:e05b]</code>的位置，转换成存储地址就是<code>0xfe05b</code>。<ul>
<li>CS和IP寄存器与物理地址的转换规则为<code>ADDR = CS&lt;&lt;4 + IP</code>。</li>
</ul>
</li>
</ul>
<p>保证启动时优先执行BIOS代码是很重要的，因为一开始内存中根本不会有其他可以执行的代码。BIOS会初始化所有启动所需要的重要设备，检查内存和磁盘的挂载情况。最后，就像操作系统课程中所学的那样，它找到磁盘上的boot loader并将控制权转移给它。</p>
<ul>
<li>对GDB使用<code>si</code>命令可以继续单步调试之后的汇编代码，观察BIOS所做的工作。</li>
</ul>
<h4 id="Part-2-The-boot-loader"><a href="#Part-2-The-boot-loader" class="headerlink" title="Part 2 The boot loader"></a>Part 2 The boot loader</h4><p>众所周知，软盘和硬盘都被分成大小为<code>512字节</code>的段，而这些段是系统级IO的最小单位。如果一个磁盘是启动盘，那么它的第一个段就被称为 <strong>boot sector</strong> ，并被存放boot loader的代码。当BIOS找到一个boot sector后，它就会将其加载到内存中，并将控制权转交给boot loader代码段。</p>
<p>(对于CD-ROM来说，它的前2M都属于boot sector，因此可以存放更大的启动镜像)</p>
<p>在6.828文件夹中，boot loader的代码存放于<code>boot/boot.S</code>与<code>boot/main.c</code>中。这些代码主要完成两件事：</p>
<ol>
<li>将处理器模式切换到<code>32位保护模式</code>，这样软件才可以访问大于1MB的物理地址空间。这个工作由<code>boot.S</code>完成。除此之外，<code>boot.S</code>还要建立一个程序栈，让C程序得以运行。</li>
<li>将内核代码从硬盘中加载到内存，并将控制转交给内核代码的入口函数。这个工作由<code>main.c</code>完成。</li>
</ol>
<p>阅读<code>main.c</code>的代码可以发现很多 <del>非常dirty的</del> 细节(<del>包括但不限于：使用goto，while(1)代替sleep，写的很乱的函数指针</del>)，如果对于这个过程的细节感兴趣可以直接阅读源码，注释写的很详细明白。</p>
<p>bootloader的代码会被BIOS加载到<code>0x7c00</code>，这是由<code>boot/Makefrag</code>文件所决定的。修改这个文件中<code>-Ttext</code>参数后面的地址可以让BIOS从其他地址来加载，执行<code>make clean &amp;&amp; make</code>重新编译可以查看这样做会引发什么样的系统错误(事实上系统会停机并进入一个无限循环等待用户的操作)；在GDB调试时可以在这个位置设置断点，以精确地进入bootloader代码段。</p>
<p><code>obj/boot/boot.asm</code>和<code>obj/kern/kernel.asm</code>分别包含着bootloader和kernel的反汇编结果以及注释，可以用于调试和分析。下面就来分析一下BootLoader的代码逻辑。</p>
<ul>
<li>BootLoader代码逻辑研究<ul>
<li>第一阶段：<strong>初始化</strong><ul>
<li><strong>宏常量的设定</strong>：<code>.set CR0_PE_ON 0x1</code> 这个常量是控制32位保护模式开关的指标。</li>
<li><strong>全局设置</strong>：<code>cli</code>指令关闭中断处理，<code>cld</code>指令将串操作的内存地址访问模式设为增序<ul>
<li>这两个指令其实是设置了<code>DF</code>和<code>IF</code>两个标志位的值</li>
</ul>
</li>
<li><strong>寄存器初始化</strong>：用xor和mov指令将几个关键寄存器清零<ul>
<li><code>ds</code>：数据段寄存器，存放全局变量区域的头指针</li>
<li><code>ss</code>：栈段寄存器，存放堆栈段的首地址(<code>esp</code>寄存器存储的是偏移量)</li>
<li><code>es</code>：扩展段寄存器</li>
</ul>
</li>
</ul>
</li>
<li>第二阶段：<strong>打开32位保护模式</strong><ul>
<li><strong>开启A20地址线</strong>：在16位模式下，用于寻址的地址总线只有20根，这种情况下大于1MB的地址空间是全部被置为0的。只有开启20～23号四条地址线，才能对1MB以上的地址空间进行寻址，从而进入32位模式。<ul>
<li>通过一个循环来等待A20设备准备完毕：用<code>in</code>指令从<code>0x64</code>端口接受信息，如果不是代表准备完毕的信息则继续循环。</li>
<li>向<code>0x64</code>和<code>0x60</code>端口发送信号，打开A20地址线。</li>
</ul>
</li>
<li><strong>建立32位段虚拟内存与物理存储器的映射关系表</strong>：<code>lgdt gdtdesc</code>指令。</li>
<li><strong>启动32位保护模式</strong>：用<code>CR0_PE_ON</code>与<code>cr0</code>寄存器的值做或运算，打开32位保护模式。<code>cr0</code>到<code>cr3</code>四个寄存器是系统控制寄存器，它们的值直接决定系统的运行状态。<code>cr0</code>控制的是处理器，因此可以通过修改其值来进入其他运行模式。</li>
<li><strong>跳转到32位代码区的下一条指令</strong>。</li>
</ul>
</li>
<li>第三阶段：修改段寄存器的值为32位区地址，初始化<code>esp</code>寄存器的值，建立C程序栈</li>
<li>第四阶段：进入<code>main.c</code>的bootmain函数，开始读取内核代码。</li>
<li>第五阶段：跳转到内核代码区，交还控制权。</li>
</ul>
</li>
</ul>
<blockquote>
<h5 id="习题解答"><a href="#习题解答" class="headerlink" title="习题解答"></a>习题解答</h5><p>Q: 处理器什么时候开始执行32位代码？哪条指令切换了处理器模式？</p>
<p>A：<code>0x7c2a:  mov    %eax,%cr0</code>指令切换了处理器模式，从随后的跳转指令开始，处理器开始执行32位代码。</p>
<p>Q：Bootloader执行的最后一条指令是什么？kernel执行的第一条指令又是什么?</p>
<p>A：Bootloader执行的最后一条指令是向内核代码段跳转的指令<code>0x7d71:      call   *0x10018</code>，kernel执行的第一条指令是<code>0x10000c:    movw   $0x1234,0x472</code>。</p>
<p>Q：Bootloader是如何决定它要读取多少数据的？它从哪里获取的kernel大小信息？</p>
<p>A：Bootloader首先从内核代码区读取了长度固定的ELF头部，再从头部中获取了这个区域是否为ELF文件、数据段数量、每段的长度、起始地址等信息。</p>
</blockquote>
<p>(课程网页在这一部分讲了一大堆ELF头和指针的知识，如果已经学过CSAPP第7章的话完全可以跳过。需要注意的是，6.828所采用的可执行目标文件代码 <strong>并非是位置无关代码</strong> ，因而 <strong>链接器会将程序将加载到的内存位置写在文件中</strong> 。利用这一点，我们可以执行<code>objdump -f &lt;filename&gt;</code>命令，获取程序在内存中的入口位置。)</p>
<h4 id="Part-3-The-kernel"><a href="#Part-3-The-kernel" class="headerlink" title="Part 3 The kernel"></a>Part 3 The kernel</h4><p>在内核被授予控制权后，它要做如下几件事：</p>
<h5 id="Virtual-memory-address-mapping"><a href="#Virtual-memory-address-mapping" class="headerlink" title="Virtual memory address mapping"></a>Virtual memory address mapping</h5><p>当我们观察bootloader程序的时候，我们可以发现它的 <strong>链接地址</strong>(指用<code>objdump -h</code>打印出来的ELF节头部信息中的<code>LMA</code>，linked memory address) 和 <strong>虚拟地址</strong>(指用<code>objdump -h</code>打印出来的ELF节头部信息中的<code>VMA</code>，virtual memory address) 是完全一致的；然而对于kernel，这两个地址却有着不小的差距。</p>
<p>操作系统内核常常会在非常高的虚拟地址空间(例如0xf0100000)运行，这是为了把比较低的虚拟地址空间留给用户进程使用。然而大部分机器没有这么多的内存，于是它们将虚拟地址0xf0100000映射到物理地址0x00100000。这样一来虽然内核所在的加载地址很高，它的实际加载地址却是位于RAM区域的最底端，挨着BIOS所在的ROM地址区域。</p>
<p>虚拟地址映射操作是由专门的硬件来完成的，要打开虚拟地址映射只需要对<code>cr0</code>寄存器设置<code>CR0_PG</code>标志，就像之前打开32位保护模式所做的那样。除此之外，为了能让虚拟地址映射正常工作，我们需要将页表的首地址装入<code>cr3</code>寄存器。</p>
<p>kernel被加载的地址为0x100000,因此它从此处开始运行。它所做的第一项工作就是打开虚拟地址映射，然后跳转到虚拟地址<code>0xf010002f</code>的位置，恰好对应于物理地址中下一条指令所在的位置。这样，内核就自然地实现了从物理地址到虚拟地址的转换。</p>
<h5 id="Formatted-printing-to-the-console"><a href="#Formatted-printing-to-the-console" class="headerlink" title="Formatted printing to the console"></a>Formatted printing to the console</h5><p>在完成虚拟地址映射之后，下一步是对终端进行格式化输入输出以创建交互式操作界面。</p>
<p><code>lib/printfmt.c</code>中提供了输出函数的原型，<code>kern/printf.c</code>和<code>kern/console.c</code>则提供了有关内核输出和交互的函数。</p>
<blockquote>
<p><strong>Answer to Exercise 8</strong></p>
<p>本题要求补全printfmt函数对于<code>%o</code>(8进制输出)的处理机制，只需要仿照下面十六进制的机制即可。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">  num = getuint(&amp;ap, lflag);</span><br><span class="line">  base = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">goto</span> number;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>习题解答</strong></p>
<p>Q：解释printf.c和console.c之间的接口，尤其是console.c中的哪个函数被如何用于printf.c。</p>
<p>A：console.c向printf.c提供了cputchar函数,它希望在调用printf.c中的输出函数时可以利用cputchar函数来输出每一个字符。printf.c遵守这个约定,以包含cputchar的外壳函数调用printfmt.c中的输出函数,保证了所有输出都按照console.c所规定的标准来输出。</p>
<p>Q：解释console.c中的这一段代码:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">  <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">    crt_buf[i] = <span class="number">0x0700</span> | <span class="string">' '</span>;</span><br><span class="line">    crt_pos -= CRT_COLS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>A：</p>
<p>这段代码来自cga_putc函数,这个函数是在CGA显示屏图形卡上打印字符的函数。crt_pos是一个整形全局变量,它的含义是目前光标在屏幕上的位置。阅读<code>console.h</code>的内容可以发现CRT_SIZE被定义为屏幕上能够容纳的字符个数,而CRT_COLS则是屏幕的宽度。</p>
<p>条件判断是为了确认当前光标的位置是否已经超出了屏幕底端。如果超出了，就把屏幕上第二行到最后一行的内容全部上移一行，并将空出来的位置用<code>0x0700 | &#39; &#39;</code>填满。</p>
<p>总而言之，这段代码是为了实现屏幕满了之后向上滚动的功能。</p>
<p>Q：单步调试如下代码：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</span><br><span class="line">cprintf(<span class="string">"x %d, y %x, z %d\n"</span>, x, y, z);</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>在对cprintf的调用中，fmt对应的实参是什么？ap呢？</li>
<li>列出对<code>cons_putc</code>, <code>va_arg</code>和<code>vcprintf</code>的每一次调用，以及<code>cons_putc</code>的参数,<code>va_arg</code>中ap的指向和<code>vcprintf</code>的参数值。</li>
</ol>
<p>A：</p>
<ol>
<li>fmt对应的实参是<code>&quot;x %d, y %x, z %d\n&quot;</code>，ap指向带有x，y和z的参数数组。</li>
<li>甚至不需要单步调试，自己阅读<code>lib/printfmt.c</code>就足够了。</li>
</ol>
<p>Q：运行如下代码：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line">cprintf(<span class="string">"H%x Wo%s"</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释输出结果。如果这段代码运行在大端序机器上而非小端序机器上，你会如何修改它来得到同样的结果？</p>
<p>A：输出结果是<code>He110 World</code>。前面的e110是57616在十六进制下的表示(因为使用了<code>%x</code>)，后面的rld是字符串输出的结果。int占4个字节而每个字符占一个字节，因而i所占的内存空间与一个长度为4的字符数组是相同的。这样一来，如果用i的地址去输出字符串，就会从i的地址开始按字符去读取内存中的数据，直到读到0为止。由于运行在小端序机器，0x72排在最前面一个字节，被解析成ASCII码值为0x72的<code>r</code>；接下来0x6c和0x64分别被解释为<code>l</code>和<code>d</code>。最后一个字节是0x00,正好是字符串终结符。</p>
<p>如果机器是大端序，只需要将i修改为<code>0x726c6400</code>即可，57616不需要改变。</p>
<p>Q：被<code>cprintf(&quot;x=%d y=%d&quot;, 3);</code>打印出的y值会是多少？为什么？</p>
<p>A：会是一个随机的整形数。因为cprintf解析到了两个<code>%d</code>符号，但<code>ap</code>的长度只有1,这导致第二个<code>%d</code>读到了一片未赋值的内存地址，其值自然是随机的。</p>
</blockquote>
<h5 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h5><p>(仔细读过CSAPP第三章的话汇编语言和程序栈这一块应该没问题了，就不说了)</p>
<blockquote>
<p><strong>Answer to Exercise 9</strong></p>
<p>Q：确定内核在什么时候初始化程序栈及程序栈的初始位置。内核是如何为栈保存空间的？</p>
<p>A：<code>f010034: mov $0xf0110000, %esp</code>：这一条指令初始化了栈指针，将程序栈建立于虚拟地址<code>0xf0110000</code>位置。从这个地址开始，程序栈随着程序运行向下增长。</p>
</blockquote>
<p><code>ebp</code>指针被称为“基指针”，它的作用是追踪每个函数的栈帧位置。每个被调用的C函数都要进行如下操作：将ebp寄存器的值压栈、将当前esp指针值拷贝到ebp寄存器。在返回之前，这个函数从栈中取出并恢复ebp寄存器的值。通过这种机制，<strong>任何时候ebp寄存器的值都指向正在执行的函数的栈帧头部，而栈帧头部的前一个数据节的值指向该函数调用者的栈帧头部</strong>，于是可以通过ebp链来还原函数调用链。</p>
<blockquote>
<p><strong>Answer to Exercise 10</strong></p>
<p>这个Exercise的目的是让学生熟悉backtrace的操作和C的程序栈结构。在kernel中有一个自我递归的<code>test_backtrace</code>函数,通过对这个函数打上断点可以使用<code>p $ebp</code>获取每次调用的栈帧起始位置.</p>
<p>第一次调用:栈帧的起始位置为<code>0xf010ffd8</code><br>第二次调用:栈帧的起始位置为<code>0xf010ffb8</code></p>
<p>可以看出这个函数的每个栈帧大小都是<code>0x20</code>,也就是32个字节，对于32位系统来说是八个数据。</p>
<p>使用<code>x/xw</code>命令查看从<code>0xf010ffe0</code>开始整个栈帧的结构。(因为32位系统每个数据是四个字节，所以使用<code>x/xw</code>来查看)</p>
<p><code>x/xw 0xf010ffe0</code>：<code>0x00000005</code> 按照栈帧的结构，这个位置应该是调用者压入栈内的参数。第一次对<code>test_backtrace</code>的调用的确只有一个实参5。</p>
<p><code>x/xw 0xf010ffdc</code>：<code>0xf01000f4</code> 由于栈帧是向下的，这条指令其实查看的是上一个栈帧的最后一部分，也就是函数的返回地址，经验证的确指向调用者的下一条指令。</p>
<p><code>x/xw 0xf010ffd8</code>：<code>0xf010fff8</code> 当前函数栈帧的第一部分，保存着上一个函数的基指针值(<code>%ebp</code>的值)，由于上一个函数已经是整个程序栈底部的函数了，这个地址向上就没有数据了，上个函数的基指针指向的是物理内存区的函数。</p>
<p><code>x/xw 0xf010ffd4</code>：<code>0x000100b4</code> 被调用者保存的<code>%esi</code>寄存器的值 </p>
<p><code>x/xw 0xf010ffd0</code>：<code>0xf011304c</code> 被调用者保存的<code>%ebx</code>寄存器的值</p>
<p><code>x/xw 0xf010ffcc</code>：<code>0xf010004a</code> 是<code>test_backtrace</code>中一行代码的地址</p>
<p><code>x/xw 0xf010ffc8</code>：<code>0x00000000</code> 空的，没有数据</p>
<p><code>x/xw 0xf010ffc4</code>：<code>0x00000005</code> 局部变量5</p>
<p><code>x/xw 0xf010ffc0</code>：<code>0x00000004</code> 即将进行下一次递归调用，这是压入的参数4</p>
<p>再往下就是返回地址，然后就是下一个栈帧。总的来说，<code>test_backtrace</code>函数的栈帧结构就是这样。</p>
</blockquote>
<p>完成了对栈帧结构的观察后，就可以利用观察结果去做一下任务了。Exercise 11要求我们实现一个<code>mon_backtrace</code>函数，它记录并打印出栈帧信息。<code>inc/x86.h</code>中提供了<code>read_ebp()</code>函数可以直接返回ebp寄存器的值。</p>
<p>输出格式规定如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack backtrace:</span><br><span class="line">  ebp f0109e58  eip f0100a62  args 00000001 f0109e80 f0109e98 f0100ed2 00000031</span><br><span class="line">  ebp f0109ed8  eip f01000d6  args 00000000 00000000 f0100058 f0109f28 00000061</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Answer to Exercise 11</strong></p>
<p>本题要求是按上面的要求修改<code>kern/monitor.c</code>中的<code>mon_backtrace</code>函数，并将其添加到指令集中。</p>
<p>对代码的修改如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一处修改</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Command</span> <span class="title">commands</span>[] = &#123;</span></span><br><span class="line">        &#123; <span class="string">"help"</span>, <span class="string">"Display this list of commands"</span>, mon_help &#125;,</span><br><span class="line">        &#123; <span class="string">"kerninfo"</span>, <span class="string">"Display information about the kernel"</span>, mon_kerninfo &#125;,</span><br><span class="line">        &#123; <span class="string">"backtrace"</span>, <span class="string">"Display the structure of the stack"</span>, mon_backtrace &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第二处修改</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Your code here.</span></span><br><span class="line">        cprintf(<span class="string">"Stack backtrace:\n"</span>);</span><br><span class="line">        <span class="keyword">int</span> ebp = read_ebp();</span><br><span class="line">        <span class="keyword">int</span> eip = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">int</span> args[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                args[i] = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>*i + <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,ebp,eip,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],args[<span class="number">3</span>],args[<span class="number">4</span>]);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                ebp = *(<span class="keyword">int</span> *)ebp;</span><br><span class="line">                <span class="keyword">if</span> (!ebp) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> eip = *(<span class="keyword">int</span> *)(ebp+<span class="number">4</span>);</span><br><span class="line">                <span class="keyword">int</span> args[<span class="number">5</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                        args[i] = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>*i + <span class="number">8</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,ebp,eip,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],args[<span class="number">3</span>],args[<span class="number">4</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Exercise 12要求我们升级这个函数，使其支持如下的输出格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stack backtrace:</span><br><span class="line">  ebp f010ff78  eip f01008ae  args 00000001 f010ff8c 00000000 f0110580 00000000</span><br><span class="line">         kern/monitor.c:143: monitor+106</span><br><span class="line">  ebp f010ffd8  eip f0100193  args 00000000 00001aac 00000660 00000000 00000000</span><br><span class="line">         kern/init.c:49: i386_init+59</span><br><span class="line">  ebp f010fff8  eip f010003d  args 00000000 00000000 0000ffff 10cf9a00 0000ffff</span><br><span class="line">         kern/entry.S:70: &lt;unknown&gt;+0</span><br></pre></td></tr></table></figure>
<p>为了根据eip找到函数名，行数和文件名等一系列信息，<code>kern/kdebug.c</code>中提供了<code>debuginfo_eip()</code>函数，我们需要完整地实现<code>debuginfo_eip()</code>函数，并在<code>mon_backtrace</code>中调用这个函数来获得信息。</p>
<blockquote>
<p><strong>Answer to Exercise 12</strong></p>
<p>在<code>debuginfo_eip</code>函数中有一些以<code>__STAB_</code>开头的宏常量,它们所代表的是ELF文件中<code>.stab</code>(在CSAPP中是<code>.symtab</code>)区的开头和结尾位置,以及<code>.stabstr</code>(在CSAPP中是<code>.strtab</code>)区的开头和结尾位置,它们是在链接过程中由<code>kernel.ld</code>定义的。</p>
<p>以下是修改内容：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kern/monitor.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Your code here.</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">        cprintf(<span class="string">"Stack backtrace:\n"</span>);</span><br><span class="line">        <span class="comment">// Parse the structure of the stack</span></span><br><span class="line">        <span class="keyword">int</span> ebp = read_ebp();</span><br><span class="line">        <span class="keyword">int</span> eip = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">int</span> args[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                args[i] = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>*i + <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Print some information in restricted format.</span></span><br><span class="line">        cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,ebp,eip,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],args[<span class="number">3</span>],args[<span class="number">4</span>]);</span><br><span class="line">        <span class="comment">// Exercise 12, get the debuginfo by eip</span></span><br><span class="line">        debuginfo_eip(eip, &amp;info);</span><br><span class="line">        cprintf(<span class="string">"         %s:%d: "</span>,info.eip_file, info.eip_line);</span><br><span class="line">        <span class="comment">// info.eip_fn_name is a non-null-terminated string</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;info.eip_fn_namelen;i++) cprintf(<span class="string">"%c"</span>,*(info.eip_fn_name+i));</span><br><span class="line">        cprintf(<span class="string">"+%d\n"</span>,eip - info.eip_fn_addr);</span><br><span class="line">        <span class="comment">// Backtracing</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                ebp = *(<span class="keyword">int</span> *)ebp;</span><br><span class="line">                <span class="keyword">if</span> (!ebp) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> eip = *(<span class="keyword">int</span> *)(ebp+<span class="number">4</span>);</span><br><span class="line">                <span class="keyword">int</span> args[<span class="number">5</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                        args[i] = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>*i + <span class="number">8</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,ebp,eip,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],args[<span class="number">3</span>],args[<span class="number">4</span>]);</span><br><span class="line">                debuginfo_eip(eip, &amp;info);</span><br><span class="line">                cprintf(<span class="string">"         %s:%d: "</span>,info.eip_file, info.eip_line);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;info.eip_fn_namelen;i++) cprintf(<span class="string">"%c"</span>,*(info.eip_fn_name+i));</span><br><span class="line">                cprintf(<span class="string">"+%d\n"</span>,eip - info.eip_fn_addr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kern/kdebug.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">debuginfo_eip(<span class="keyword">uintptr_t</span> addr, struct Eipdebuginfo *info)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line">    stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</span><br><span class="line">    <span class="keyword">if</span> (lline &lt;= rline) info-&gt;eip_line = stabs[lline].n_desc;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此Lab1结束。运行<code>make grade</code>，<code>50/50</code>大成功。</p>
<h3 id="Lab2-Memory-Management"><a href="#Lab2-Memory-Management" class="headerlink" title="Lab2 Memory Management"></a>Lab2 Memory Management</h3><p>在这个Lab中，我们需要实现操作系统的内存管理系统。内存管理系统包括两个部分：</p>
<ul>
<li>物理内存调度：我们要实现一个以4096个字节大小的页为单位的内存分配器，它将空闲的内存分配给内核和用户，并释放使用完的内存。</li>
<li>虚拟内存映射</li>
</ul>
<p>执行<code>git checkout -b lab2 origin/lab2</code>命令切换到lab2分支，执行<code>git merge lab1</code>合并在lab1所做的更改。</p>
<p>Lab2增加的文件有：</p>
<ul>
<li><code>inc/memlayout.h</code>：定义描述虚拟内存空间的布局的函数，定义PageInfo结构体</li>
<li><code>kern/pmap.c</code>和<code>kern/pmap.h</code>：实现<code>inc/memlayout.h</code>中定义的函数</li>
<li><code>kern/kclock.c</code>和<code>kern/kclock.h</code>：与CMOS硬件沟通，读取PC的硬件信息</li>
</ul>
<p><code>inc/mmu.h</code>中记录了应当烧录于MMU<br>单元中的逻辑代码，同样可能对这个lab有所帮助。</p>
<h4 id="Background-knowledge"><a href="#Background-knowledge" class="headerlink" title="Background knowledge"></a>Background knowledge</h4><p>由于虚拟内存是将很小的物理内存映射到很大的虚拟内存空间，这个映射关系需要一个输入地址和一个输出地址才能作用。<strong>物理地址</strong>是物理内存中真实的地址，可以直接由硬件寻址得到；<strong>虚拟地址/线性地址</strong>是物理地址通过转换得到的，用于虚拟内存空间索引的地址。</p>
<p><code>mmu.h</code>中详细地介绍了线性地址的结构。大体上讲，线性地址分为三段：</p>
<ul>
<li><code>Page directory index</code>：页目录的序号(10位)</li>
<li><code>Page table index</code>：页表的序号(10位)</li>
<li><code>Page offset</code>：地址在页内的偏移(12位)</li>
</ul>
<p>从线性地址的三段式结构可以看出，每个页表包括<code>1024</code>(2的10次方)个页，每个页目录包括<code>1024</code>个页表，而每一页的大小是<code>4096</code>个字节(也就是<code>4KB</code>)。</p>
<p>3段加起来的总长度是<code>32 bits</code>，也就是<code>4个字节</code>，这代表着线性地址可以用一个<code>int32</code>变量表示。</p>
<p>我们可以使用宏命令来取出线性地址的各个段，或将线性地址映射为物理地址。在本lab中，虚拟地址似乎是特指<code>物理地址+固定偏置值</code>所映射到的地址。</p>
<p>在<code>memlayout.h</code>中可以查看到整个虚拟内存地址空间的分配，在此列出并加以解释：</p>
<p><img src="memlayout.png" alt="memlayout"></p>
<ul>
<li><code>0xf0000000</code>以上：<code>Remapped physical memory</code>，物理内存的原样映射，这一部分为虚拟地址</li>
<li><code>0xefc00000</code>以上：内核栈区域，存放各个CPU的内核栈。<ul>
<li><code>0xef800000</code>：内核内存区和用户内存区的分界线，这以上用户不可读写</li>
</ul>
</li>
<li><code>0xef400000</code>以上：页表区域</li>
<li><code>0xef000000</code>以上：页区域</li>
<li><code>0xeec00000</code>以上：当前进程的环境变量区域<ul>
<li><code>0xeec00000</code>：用户只读区和读写区的分界线，这以上用户只有读权限</li>
</ul>
</li>
<li><code>1 PGSIZE</code>：用户的异常栈</li>
<li><code>1 PGSIZE</code>：用户栈，可以增长</li>
<li><code>一段留空内存</code></li>
<li><code>0x00800000</code>以上：用户的堆区域和程序数据</li>
<li>以下：用户的符号表区域和空内存</li>
</ul>
<h4 id="Definitions-guide"><a href="#Definitions-guide" class="headerlink" title="Definitions guide"></a>Definitions guide</h4><p>6.828的代码充满了缩写这种使人不明所以的命名,且有些地方码风诡异,因而将一些可能用到的概念和缩写列举如下:</p>
<ol>
<li><code>V</code>和<code>P</code>:带V的标识符指<code>virtual</code>,与内核虚拟内存有关；而带P的标识符往往指<code>physical</code>,与物理存储有关。如：<ul>
<li><code>kva</code>:<code>kernel virtual address</code>的简写</li>
<li><code>pa</code>:<code>physical address</code>的简写</li>
<li><code>la</code>:<code>linear address</code>的简写</li>
</ul>
</li>
<li><code>PT</code>和<code>PD</code>：分别指<code>page table</code>和<code>page directory</code>。</li>
<li><code>U</code>和<code>K</code>:带U的标识符指<code>User</code>，而带K的标识符指<code>Kernel</code>。如：<ul>
<li><code>UVPT</code>：<code>User virtual page table</code>的缩写，是用户页表的开始地址。</li>
<li><code>UTOP</code>：用户地址空间的上限</li>
</ul>
</li>
</ol>
<p>为了实现目标功能的代码，我们需要调用许多定义好的函数或者宏，为了方便查看和使用将一些可能需要使用的函数和宏列举如下：</p>
<ul>
<li><code>pmap.h</code>:<ul>
<li><code>PADDR(addr)</code>:将虚拟地址addr转换为物理地址返回</li>
<li><code>KADDR(addr)</code>:将物理地址addr转换为虚拟地址返回</li>
<li><code>PTE_ADDR(addr)</code>:将物理地址addr中的权限位去掉</li>
<li><code>page2pa(PageInfo*)</code>:将PageInfo结构体转换为对应Page的物理地址</li>
<li><code>pa2page(addr)</code>:将物理地址转换为pages数组中的PageInfo</li>
<li><code>page2kva(PageInfo*)</code>:将PageInfo结构体转换为对应Page的虚拟地址</li>
</ul>
</li>
<li><code>mmu.h</code>:<ul>
<li><code>PDX(la)</code>:将线性地址转换为页目录(page directory)的索引</li>
<li><code>PTX(la)</code>:将线性地址转换为页表的索引</li>
</ul>
</li>
</ul>
<h4 id="Part-1-Physical-page-management"><a href="#Part-1-Physical-page-management" class="headerlink" title="Part 1 Physical page management"></a>Part 1 Physical page management</h4><p>在这个部分我们需要实现物理内存管理器。这个函数追踪一个由<code>PageInfo</code>结构体组成的链表(这个链表的节点代表着一页未分配的内存)，并负责物理内存的分配和回收。</p>
<p>要想完成这部分的任务，必须要提前了解虚拟内存系统的概念(可以参考操作系统专业教材或者计算机系统教材)，才能看懂并运用各种神奇的操作。</p>
<blockquote>
<p><strong>boot_alloc</strong></p>
</blockquote>
<p>这个函数是在建立虚拟内存系统过程中用来为数据结构分配内存空间的，在虚拟内存系统建立之后就会废弃。因而，其功能比较简单。</p>
<p>值得注意的是，这个函数首次调用的时候，会从内核区bss段的结束处开始分配内存块，具体的位置是通过<code>extern</code>从链接器那里得知的。首次调用情况下的代码已经被完成了，我们只需要照葫芦画瓢地完成之后调用时的代码即可。</p>
<p>这里所谓“内核区bss段的结束处”是指内核区中没有分配代码段和数据段的第一个位置，它在虚拟地址空间中的位置在<code>0xf0000000</code>以上的部分，也就是物理内存的映射区。从这里开始，我们开始建立用于管理虚拟内存的内核数据结构。</p>
<ul>
<li><em>panic函数可以被当作printf的一个能够引发中断的版本。灵活利用它可以方便地调试系统。</em></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a chunk large enough to hold 'n' bytes, then update</span></span><br><span class="line">	<span class="comment">// nextfree.  Make sure nextfree is kept aligned</span></span><br><span class="line">	<span class="comment">// to a multiple of PGSIZE.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// LAB 2: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!n)	<span class="keyword">return</span> nextfree;</span><br><span class="line">	result = nextfree;</span><br><span class="line">	nextfree = ROUNDUP((<span class="keyword">char</span> *) (nextfree+n), PGSIZE);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>mem_init</strong></p>
</blockquote>
<p>这个函数首先用之前实现好的<code>boot_alloc</code>函数分配了 <strong>一页</strong> 空闲内存，初始化之，并用一个<code>kern_pgdir</code>指针指向了这片内存的起始位置。这一片区域用来存放<code>page directory</code>。</p>
<p>接下来是我们的工作：为一个页数组<code>pages</code>分配内存。</p>
<p><code>pages</code>数组存储了每个分页的信息，其索引和页的物理地址可以用函数相互转换。可以说，<code>pages</code>的每一个元素都唯一对应着一个物理页面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pages = (struct PageInfo *) boot_alloc(<span class="keyword">sizeof</span>(struct PageInfo) * npages);</span><br><span class="line"><span class="built_in">memset</span>(pages, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct PageInfo) * npages);</span><br></pre></td></tr></table></figure>
<p>这样我们就已经为内存分配相关的内核数据结构分配好了空间。接下来，<code>mem_init</code>函数调用<code>page_init</code>函数，去初始化所有物理内存分页。这个步骤结束之后，所有内存相关操作都可以通过<code>page</code>开头的函数来完成。</p>
<blockquote>
<p><strong>page_init</strong></p>
</blockquote>
<p>Lab中已经给出了示例代码，但是这段代码是不严谨的(它将所有物理内存页都标记为是free的)，有几处问题没有考虑到：</p>
<ul>
<li><strong>物理页面0应该标记为used</strong>。这是因为这一部分保存着BIOS数据结构和IDT(中断描述符表)，我们以后可能会用到这些结构。</li>
<li>之前讲到过的由于考虑到向后兼容性而留下的<code>IO hole</code>不应该被分配。</li>
<li>在<code>IO hole</code>之后就是extended memory部分，这一部分中的有些位置存放了内核代码和内核数据结构，因而这些位置不能标记为free。</li>
</ul>
<p>我们的任务是修改代码，使其只将那些该标记为free的放进<code>page_free_list</code>。</p>
<p>考察<code>memlayout.h</code>中的<code>PageInfo</code>结构体，可以发现其属性<code>pp_ref</code>用于指示引用这一页的进程数量,而<code>pp_link</code>指向空闲链表中下一项的地址。对于要放入<code>page_free_list</code>的pages，我们将其<code>pp_ref</code>设定为0，并利用<code>pp_link</code>将其插入空闲链表。</p>
<p><strong>本任务的难点在于如何确定Extended Memory中的哪一部分已经被Kernel所占用</strong>。观察之前的代码可以发现，<code>boot_alloc</code>是从kernel代码和数据段的结束位置开始分配内存的，而kernel代码段的起始位置是<code>IO hole</code>的结束位置(<code>0x100000</code>,参考Lab 1)，这意味着从<code>IO hole</code>到<code>boot_alloc</code>分配的最后一块内存末尾之间的所有内存都是被占用的。</p>
<p>而根据之前的两个函数，<code>boot_alloc</code>分配的最后一块内存应该就是页表的最后一块内存(也就是<code>pages</code>数组的末尾)，因此我们从<code>pages</code>的头地址开始向后应该就可以找到kernel占用内存区的末尾位置。</p>
<p>根据这些信息，可以修改代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">size_t</span> i;</span><br><span class="line">	<span class="comment">// 1) First page, ignore it</span></span><br><span class="line">	<span class="comment">// 2) Base memory</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; npages_basemem; i++) &#123;</span><br><span class="line">		pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">		pages[i].pp_link = page_free_list;</span><br><span class="line">		page_free_list = &amp;pages[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3) IO hole</span></span><br><span class="line">	<span class="comment">// Mention that npages_basemem = IOPHYSMEM / PGSIZE</span></span><br><span class="line">	<span class="comment">// IOPHYSMEM and EXTPHYSMEM is represented by B instead of KB, so div it by PGSIZE.</span></span><br><span class="line">	<span class="comment">// (Here is no operation, because we do not need to deal with occupied pages.)</span></span><br><span class="line">	;</span><br><span class="line">	<span class="comment">// 4) Extended memory</span></span><br><span class="line">	<span class="comment">// The question is where is the end of kernel segment.</span></span><br><span class="line">	<span class="keyword">char</span>* end_addr = (<span class="keyword">char</span> *)envs + <span class="keyword">sizeof</span>(struct Env) * NENV - KERNBASE;</span><br><span class="line">	<span class="keyword">int</span> end_index = (<span class="keyword">int</span>)(ROUNDUP(end_addr, PGSIZE)) / PGSIZE;</span><br><span class="line">	<span class="keyword">for</span> (i = end_index; i &lt; npages; i++) &#123;</span><br><span class="line">		pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">		pages[i].pp_link = page_free_list;</span><br><span class="line">		page_free_list = &amp;pages[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>page_alloc</strong></p>
</blockquote>
<p>这个函数就是很简单的链表操作，仔细阅读注释的内容即可正确实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *</span></span><br><span class="line"><span class="class"><span class="title">page_alloc</span>(<span class="title">int</span> <span class="title">alloc_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Returns NULL if out of free memory</span></span><br><span class="line">	<span class="keyword">if</span> (page_free_list == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// Get a free page from page_free_list</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">free_page</span> = <span class="title">page_free_list</span>;</span></span><br><span class="line">	page_free_list = free_page-&gt;pp_link;</span><br><span class="line">	<span class="comment">// Init the free page</span></span><br><span class="line">	free_page-&gt;pp_link = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (alloc_flags &amp; ALLOC_ZERO)</span><br><span class="line">		<span class="built_in">memset</span>(page2kva(free_page), <span class="number">0</span>, PGSIZE);</span><br><span class="line">	<span class="comment">// Return the free page to caller</span></span><br><span class="line">	<span class="keyword">return</span> free_page;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>page_free</strong></p>
</blockquote>
<p>同样没有什么难度，直接贴出代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_free(struct PageInfo *pp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></span><br><span class="line">	<span class="comment">// pp-&gt;pp_link is not NULL.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pp-&gt;pp_ref) panic(<span class="string">"This page is still occupied by other processes."</span>);</span><br><span class="line">	<span class="keyword">if</span> (pp-&gt;pp_link) panic(<span class="string">"You can't free a freed page."</span>);</span><br><span class="line">	pp-&gt;pp_link = page_free_list;</span><br><span class="line">	page_free_list = pp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Part-2-Virtual-Memory"><a href="#Part-2-Virtual-Memory" class="headerlink" title="Part 2 Virtual Memory"></a>Part 2 Virtual Memory</h4><p>在开始这一部分之前，先要对几个地址之间的转换有一个大概的了解。</p>
<h5 id="Segments"><a href="#Segments" class="headerlink" title="Segments"></a>Segments</h5><p>在保护模式下，有关段的信息是非常复杂的。对于一个段来说，除了段基地址之外，还有段的大小，特权级，类型，是否被执行过，读写权限等等多种信息要保存。用于描述这些信息的数据项称为 <strong>描述符(Descirptor)</strong> 。</p>
<p>描述符一般用<code>4个字</code>来表述所有信息，具体的描述符结构如下图所示：</p>
<p><img src="descriptor.png" alt="descriptor"></p>
<p>其中各个部分的作用：</p>
<ul>
<li>第一个字：<strong>段的界限</strong>，也就是这个段的长度。需要注意的是一个段的长度是用20位来表示的，因此这个字表示的段界限是不完整的，需要和描述符中另一段数据拼接起来才是完整的段界限。</li>
<li>第二个字：<strong>段的基址</strong>，段在虚拟地址空间内的起始位置。由于虚拟空间地址是32位的，这个字同样无法表示完整的段基址，需要与另外两段数据进行拼接。</li>
<li>第三个字：<ul>
<li>高字节分为如下几个字段：<ul>
<li><code>P</code>：<strong>存在位</strong>，表示该描述符对应的段是否已经读入内存。</li>
<li><code>DPL</code>：长度为两位，表示该段所属的特权级</li>
<li><code>1</code>或<code>0</code>：记录段的类型是存储段还是系统段</li>
<li><code>TYPE</code>：记录段的属性<ul>
<li>如果是存储段，那么是代码段还是数据段</li>
<li>段的读写权限如何</li>
</ul>
</li>
<li><code>A</code>：访问位，记录段是否被访问过</li>
</ul>
</li>
<li>低字节为段基址的16-23位。</li>
</ul>
</li>
<li>第四个字：<ul>
<li>高字节为段基址的24-31位。</li>
<li>低字节分为如下几个字段：<ul>
<li><code>G</code>：<strong>粒度位</strong>，G=0说明段长度的单位是<code>Byte</code>，而G=1说明单位是<code>page</code>。</li>
<li><code>X</code>：用于区分32位和16位访问方式。</li>
<li><code>O</code>和<code>AVL</code>：保留位和系统专用位</li>
<li><code>LIMIT</code>：段界限的16-19位</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>所有的描述符都储存在 <strong>描述符表</strong> 中。描述符表分为以下三类：</p>
<ul>
<li><code>LDT</code>：局部描述符表。每个进程都有它自己的局部描述符表，存放在一个特定的系统段内。LDT中存放着对应进程的代码和数据段位置等信息。</li>
<li><code>GDT</code>：全局描述符表。只有一个，存放着操作系统内核使用的描述符和所有系统段的描述符。通过GDT可以去索引所有的LDT。</li>
<li><code>IDT</code>：中断描述符表。用于定位所有的中断处理程序。</li>
</ul>
<p>在这个Lab中，我们暂时不涉及内存的分段机制，因而GDT中每个描述符的base为0而limit为0xffffffff。在kernel代码段中我们已经建立了一个简单的页表(能够映射4MB大小的内存),现在我们需要做的是拓展这个页表以映射整个虚拟内存。</p>
<h5 id="Pages"><a href="#Pages" class="headerlink" title="Pages"></a>Pages</h5><p>在Background knowledge里面我们已经讲了线性地址的构成，现在为了能够完成下面的实验，需要进一步了解一些关于页目录和页表的知识。</p>
<p>在MMU取到一个线性地址la时，它会首先取出la中的 <strong>页目录索引部分</strong> ，并用其与<code>cr3</code>中存放的页目录首地址结合去找到la所在的 <strong>页表首地址</strong> 。在此之后，MMU取出la中的 <strong>页表索引部分</strong> ，与之前找到的页表首地址结合来找到la所对应的具体 <strong>页表项</strong> 。</p>
<p>在这个过程中，la所在的页目录表项被称为 <strong>DIR entry</strong> ，而它所在的页表表项被称为 <strong>Page table entry</strong>。Directory entry中存放的物理地址与la的页表索引部分的结合是Page table entry的地址，而page table entry中存放的物理地址与la的偏移部分的结合是la所对应物理页的地址。</p>
<p>每个PDE或者PTE的内容都是<code>phyaddr</code>和 <strong>权限位</strong> 的组合。因为PDE和PTE的内容都指向一个物理页的首地址，它们的最后12位是用不到的。这12位被内存管理系统用作权限位，每一位都代表一个特定的权限，管理系统通过将这些位置0或置1来设定这一页的权限。</p>
<h5 id="Addresses"><a href="#Addresses" class="headerlink" title="Addresses"></a>Addresses</h5><blockquote>
<p><strong>Exercise 3</strong></p>
<p>你可以在<code>qemu-gdb</code>中键入<code>ctrl-a c</code>来进入qemu的monitor。在这里，你可以用<code>xp</code>命令来查询指定物理地址的数据(<code>xp</code>指令的用法与gdb的<code>x</code>指令类似)。与此同时，在<code>gdb</code>中用<code>x</code>指令可以查询指定虚拟地址的数据。将存在映射关系的虚拟地址与物理地址存放的内容作对比，看看是否是一致的。</p>
</blockquote>
<p>JOS的源代码定义了<code>uintptr_t</code>来存放虚拟地址，而<code>physaddr_t</code>用来存放物理地址。</p>
<blockquote>
<p><strong>Question</strong></p>
<p>Q:如果下面的代码是正确的,变量x的类型应当是uintptr_t还是physaddr_t?</p>
<p>A:uintptr_t,因为C中的指针都是指向虚拟地址的.</p>
</blockquote>
<p>JOS内核有时需要读取或修改只知道物理地址的内存。例如，向页表添加映射可能需要分配物理内存来存储页目录，然后初始化该内存。但是，内核不能绕过虚拟地址转换，因此不能直接修改物理地址。这就是为什么我们要把物理内存用一个线性函数映射到虚拟内存中<code>0xf0000000</code>以上的区域:这方便了内核直接操作物理内存。<code>PADDR</code>和<code>KADDR</code>两个宏定义让我们可以很方便地实现物理地址和虚拟地址之间的转换。</p>
<h5 id="page-management"><a href="#page-management" class="headerlink" title="page management"></a>page management</h5><p>我们知道，同一个物理页面可能会被映射到数个不同虚拟空间的数个虚拟页面，我们通过修改<code>PageInfo</code>结构体中的<code>pp_ref</code>属性来反映这一点。每当我们分配一个UTOP以下的页面，我们让该物理页面的<code>pp_ref</code>属性+1。(UTOP以上的页面属于内核，它们永远不应该被free，因而无需更改这个属性)</p>
<p>需要注意的是，我们在实现<code>page_alloc</code>函数时并没有让它去增加<code>pp_ref</code>属性值，因此调用<code>page_alloc</code>的函数需要 <strong>自行增加这个属性的值</strong> 。</p>
<blockquote>
<p><strong>pgdir_walk</strong></p>
</blockquote>
<p>这个函数接受一个线性地址和一个页目录，返回线性地址对应的页面所在页表的物理地址。为了达成这个目的，我们可以通过线性地址中的页目录索引部分去找到页目录中的对应页表地址。如果这个页表还没有被创建，且create参数为真，那就创建一个新的页表并返回它的物理地址。</p>
<p>根据函数前面的注释，<strong>MMU会同时检查页目录表项和页表表项中的权限位</strong>，因而我们对于页目录中新页表物理地址的权限可以把要求放宽松一点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pte_t</span> *</span><br><span class="line">pgdir_walk(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">int</span> create)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find the page table where va locates.</span></span><br><span class="line">	<span class="keyword">physaddr_t</span> pgtab = pgdir[PDX(va)];</span><br><span class="line">	<span class="keyword">if</span> (!pgtab) &#123;</span><br><span class="line">		<span class="keyword">if</span> (create) &#123;</span><br><span class="line">			<span class="comment">// Allocate a new page table.</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">new_pt</span> = <span class="title">page_alloc</span>(<span class="title">ALLOC_ZERO</span>);</span></span><br><span class="line">			<span class="keyword">if</span> (new_pt == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				new_pt-&gt;pp_ref++;</span><br><span class="line">				<span class="comment">// Leave permissions of pt more permissive</span></span><br><span class="line">				<span class="comment">// We allow users to read this page</span></span><br><span class="line">				pgdir[PDX(va)] = page2pa(new_pt) | PTE_P | PTE_U | PTE_W;</span><br><span class="line">				<span class="keyword">return</span> KADDR(PTE_ADDR(pgdir[PDX(va)])+PTX(va)*<span class="keyword">sizeof</span>(<span class="keyword">pte_t</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// We need to return the address of page table **entry**</span></span><br><span class="line">		<span class="comment">// PTE_ADDR: get rid of the permission bits in `pgtab`</span></span><br><span class="line">		<span class="comment">// PTX(va)*sizeof(pte_t): find the 'PTX(va)'th element in a `pte_t` array.</span></span><br><span class="line">		<span class="keyword">return</span> KADDR(PTE_ADDR(pgtab)+PTX(va)*<span class="keyword">sizeof</span>(<span class="keyword">pte_t</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>boot_map_region</strong></p>
</blockquote>
<p>这个函数将一段指定的虚拟地址映射到同样长度的指定的物理地址。因为映射以页为单位，我们可以依次映射这段地址中的每一页：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">boot_map_region(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> va, <span class="keyword">size_t</span> size, <span class="keyword">physaddr_t</span> pa, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> page_num = size / PGSIZE;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; page_num; i++) &#123;</span><br><span class="line">		<span class="keyword">pte_t</span>* pgtab = pgdir_walk(pgdir,(<span class="keyword">void</span>*)(va+i*PGSIZE),<span class="number">1</span>);</span><br><span class="line">		*pgtab = (pa+i*PGSIZE) | perm | PTE_P;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>page_lookup</strong></p>
</blockquote>
<p>这个函数寻找va在pgdir中的页表地址和物理地址。依照注释完成,没有多大难度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *</span></span><br><span class="line"><span class="class"><span class="title">page_lookup</span>(<span class="title">pde_t</span> *<span class="title">pgdir</span>, <span class="title">void</span> *<span class="title">va</span>, <span class="title">pte_t</span> **<span class="title">pte_store</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">pte_t</span>* pgtab = pgdir_walk(pgdir, va, <span class="number">0</span>); <span class="comment">// Page table address</span></span><br><span class="line">	<span class="keyword">if</span> (pgtab == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (pte_store != <span class="literal">NULL</span>)</span><br><span class="line">			*pte_store = pgtab;</span><br><span class="line">		<span class="keyword">return</span> pa2page(PTE_ADDR(*pgtab));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>page_remove</strong></p>
</blockquote>
<p>这个函数移除va指定的页。基本上都是在调用函数，只要认真阅读了注释即很简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_remove(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">pte_t</span> *pg_pte;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pgtab</span> = <span class="title">page_lookup</span>(<span class="title">pgdir</span>, <span class="title">va</span>, &amp;<span class="title">pg_pte</span>);</span></span><br><span class="line">	<span class="keyword">if</span> (!pgtab) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// This function frees the page automatically if refcount reaches 0.</span></span><br><span class="line">	page_decref(pgtab);</span><br><span class="line">	*pg_pte = <span class="number">0</span>;</span><br><span class="line">	tlb_invalidate(pgdir, va);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>page_insert</strong></p>
</blockquote>
<p>这个函数将虚拟地址va所对应的页设定为pp。这个函数的一个很容易出错的边界条件是将一个 <strong>原本空闲的</strong> page <strong>连续插入两次</strong> ，按正常的逻辑第二次插入应该不会有任何影响，但实现不当的话会出现问题。</p>
<p>如果先进行<code>page_remove</code>再增加引用数的话，首先在调用<code>page_remove</code>的时候这个page已经进入了<code>page_free_list</code>，但接下来我们接着又要用到这个page且没有经过<code>page_alloc</code>，这样一来这个page既在空闲链表中引用数又不为0，会成为一个bug。</p>
<p>根据注释的提示，有一种优雅的无需条件判断的方式可以解决这个问题。这种方式就是 <strong>将增加引用数的步骤提前</strong> ，这样这个页面在<code>page_remove</code>之前引用数就是2，就不会在<code>page_remove</code>中被回收到<code>page_free_list</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">page_insert(<span class="keyword">pde_t</span> *pgdir, struct PageInfo *pp, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">pte_t</span>* pgtab = pgdir_walk(pgdir, va, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (pgtab == <span class="literal">NULL</span>) <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	pp-&gt;pp_ref++;</span><br><span class="line">	<span class="keyword">if</span> (*pgtab &amp; PTE_P)</span><br><span class="line">		page_remove(pgdir, va);</span><br><span class="line">	*pgtab = page2pa(pp) | perm | PTE_P;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Part-3-Kernel-address-space"><a href="#Part-3-Kernel-address-space" class="headerlink" title="Part 3 Kernel address space"></a>Part 3 Kernel address space</h4><p>JOS的地址空间被<code>ULIM</code>划分为两个部分：<strong>用户地址空间</strong> 和 <strong>内核地址空间</strong> 。后者大概拥有256MB的剩余空间可以使用。</p>
<p>由于用户区和内核区同在一个地址空间内，我们需要使用页表管理中的 <strong>权限位</strong> 来保证用户只能访问用户区的页。</p>
<ul>
<li>常用的权限位：<ul>
<li><code>PTE_P</code>: 页面存在</li>
<li><code>PTE_W</code>: 该页是可写的</li>
<li><code>PTE_U</code>: 该页可以由用户访问</li>
</ul>
</li>
</ul>
<p>用户不应有访问任何<code>ULIM</code>以上内存的权限,而内核应当能读写这一块区域。在<code>UTOP</code>和<code>ULIM</code>之间的区域是 <strong>只读区</strong>(对用户和内核都是) 。低于<code>UTOP</code>的内存区域权限由用户自行设置。</p>
<h5 id="Initializing-the-Kernel-Address-Space"><a href="#Initializing-the-Kernel-Address-Space" class="headerlink" title="Initializing the Kernel Address Space"></a>Initializing the Kernel Address Space</h5><blockquote>
<p><strong>Exercise 5</strong></p>
</blockquote>
<p>这个任务要求我们补全<code>mem_init</code>函数。</p>
<p>第一段要求我们把整个<code>pages</code>数组映射到<code>UPAGE</code>地址以上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cautious: we map the phyaddr of pages instead of their content</span></span><br><span class="line"><span class="comment">// So we use PADDR here, not page2pa.</span></span><br><span class="line">boot_map_region(kern_pgdir, UPAGES, npages*<span class="keyword">sizeof</span>(struct PageInfo), PADDR(pages), PTE_U);</span><br></pre></td></tr></table></figure>
<p>第二段要求我们把内核栈映射到<code>KSTACKTOP-KSTKSIZE</code>到<code>KSTACKTOP</code>区域。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boot_map_region(kern_pgdir, (KSTACKTOP-KSTKSIZE), KSTKSIZE, PADDR(bootstack), PTE_P | PTE_W);</span><br></pre></td></tr></table></figure>
<p>第三段要求我们映射整个内核区域。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> kern_size = (<span class="keyword">unsigned</span>)~<span class="number">0</span> - KERNBASE;</span><br><span class="line">boot_map_region(kern_pgdir, KERNBASE, kern_size, <span class="number">0</span>, PTE_P | PTE_W);</span><br></pre></td></tr></table></figure>
<p>三段都是看着注释调函数即可，没有很大难度。不得不说6.828的注释仔细研究可以省去很多精力。</p>
<blockquote>
<p><strong>Questions</strong></p>
<p>Q：在这个过程中哪些PDE被填入了信息？它们对应哪些线性地址，又指向哪些物理地址？</p>
<p>A：被填入的PDE索引：</p>
<ul>
<li>956-UPAGES，线性地址0xef000000,指向pages数组在物理内存中的首地址</li>
<li>957-UVPT，线性地址0xef400000,指向kern_pgdir在物理内存中的地址</li>
<li>959-KSTACK，线性地址0xefc00000,指向bootstack数组在物理内存中的首地址</li>
<li>960～1023-内核内存区，线性地址0xf0000000以上，指向物理内存地址0。</li>
</ul>
<p>Q：既然我们把用户和内核的内存区域放在同一个地址空间中，到底是什么机制保护了内核内存不能被用户访问？</p>
<p>A：权限位<code>PTE_U</code>决定了一页能否被用户访问。</p>
<p>Q：这个操作系统能够支持多大的物理内存？为什么？</p>
<p>A：内存空间内能存放pages的空间是一个PTSIZE，也就是最多能够映射PTSIZE/sizeof(struct PageInfo)个页面，每页大小为4KB，因此总共能映射的物理内存大小为2GB。</p>
<p>Q：如果我们拥有能支持的最大的物理内存，管理这些内存需要多少空间开销？如何减少这些开销？</p>
<p>A：管理满载的512K个页面需要512个页表，每个页表占内存空间都是一个PGSIZE，总共就会有4MB左右内存用于页表储存。加上用于存放pages的4MB和页目录的4KB，总共会有8MB左右空间开销。如果把PGSIZE取大一点，这种开销就可以稍微减小。</p>
<p>Q：在我们刚打开分页机制的时候，程序还运行在低地址，控制流在什么时候跳转到KERNBASE以上？为什么在打开分页机制之后我们仍能够运行在一个低地址？</p>
<p>A：在打开分页的下一步，控制流就用jmp指令跳转到了KERNBASE以上的高地址。打开分页机制后仍能在低地址运行的原因是低地址和KERNBASE以上的高地址都被映射到同一片物理内存，这是为了保持兼容性。</p>
</blockquote>
<p>完成上面的所有代码之后，运行<code>make grade</code>，<code>70/70</code>大成功。</p>
<blockquote>
<p><strong>Challenge</strong></p>
</blockquote>
<p>这个挑战的内容主要是为JOS的monitor加入一些实用的指令，以方便之后的调试过程，具体的指令细节可以自己调整和定制。增加指令后，要记得在<code>monitor.h</code>中添加声明。</p>
<p>我主要做了以下几条指令(下面是修改后的Commands数组)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>pageinfo</strong></li>
</ol>
<p>这个指令接受一个命令行参数。</p>
<p><code>pageinfo addr</code>：打印出虚拟地址addr所在的页目录，页表，以及所在的物理页面，物理地址。</p>
<p>如果addr使用十六进制地址，必须在数字前面加上<code>0x</code>。</p>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Must include pmap.h in monitor.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;kern/pmap.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_pageinfo(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cannot declare vars in switch-case statement.</span></span><br><span class="line">    <span class="keyword">physaddr_t</span> addr;</span><br><span class="line">    <span class="keyword">pte_t</span>* pte;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (argc) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            cprintf(<span class="string">"Error: too few arguments.\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            addr = str2int(argv[<span class="number">1</span>]);</span><br><span class="line">            pte = pgdir_walk(kern_pgdir, (<span class="keyword">void</span> *)addr, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!pte) &#123;</span><br><span class="line">                cprintf(<span class="string">"This address has not been mapped yet.\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!(*pte &amp; PTE_P)) &#123;</span><br><span class="line">                cprintf(<span class="string">"Exception: Page does not exist.\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cprintf(<span class="string">"Mapping information of address %x:\n"</span>, addr);</span><br><span class="line">            cprintf(<span class="string">"  Page directory entry: %d\n"</span>, PDX(addr));</span><br><span class="line">            cprintf(<span class="string">"  Page table entry: %d\n"</span>, PTX(addr));</span><br><span class="line">            cprintf(<span class="string">"  Page physical address: %x\n"</span>, PTE_ADDR(*pte));</span><br><span class="line">            cprintf(<span class="string">"  Physical address: %x\n"</span>, PTE_ADDR(*pte) + PGOFF(addr));</span><br><span class="line">            cprintf(<span class="string">"  Page permission:\n"</span>);</span><br><span class="line">            <span class="keyword">if</span> ((*pte &amp; PTE_U) &amp;&amp; (*pte &amp; PTE_W)) &#123;</span><br><span class="line">                cprintf(<span class="string">"    Readable and writeable by user and kernel\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((*pte &amp; PTE_U)) &#123;</span><br><span class="line">                cprintf(<span class="string">"    Readable by user and kernel\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((*pte &amp; PTE_W)) &#123;</span><br><span class="line">                cprintf(<span class="string">"    Readable and writeable by kernel\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cprintf(<span class="string">"    Readable by kernel\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cprintf(<span class="string">"Error: too many arguments.\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">str2int(<span class="keyword">char</span>* str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">'0'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(++str) != <span class="string">'x'</span>)</span><br><span class="line">            base = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            base = <span class="number">16</span>;</span><br><span class="line">            str++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> (base == <span class="number">10</span> || base == <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">while</span> (*str) &#123;</span><br><span class="line">            num = num * base + *str - <span class="string">'0'</span>;</span><br><span class="line">            str++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">while</span> (*str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*str &gt;= <span class="string">'a'</span> &amp;&amp; *str &lt;= <span class="string">'f'</span>)</span><br><span class="line">            num = num * base + *str - <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*str &gt;= <span class="string">'A'</span> &amp;&amp; *str &lt;= <span class="string">'F'</span>)</span><br><span class="line">            num = num * base + *str - <span class="string">'A'</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            num = num * base + *str - <span class="string">'0'</span>;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>chperm</strong></li>
</ol>
<p>这个指令接受三个命令行参数。</p>
<p><code>chperm &lt;PDX&gt; &lt;PTX&gt; &lt;perm&gt;</code>：修改<code>&lt;PDX&gt;</code>和<code>&lt;PTX&gt;</code>对应页面的权限。</p>
<p><code>&lt;perm&gt;</code>的使用方法：</p>
<ul>
<li><code>+</code>：增加一种权限</li>
<li><code>-</code>：消除一种权限</li>
<li><code>w</code>：对应于<code>PTE_W</code></li>
<li><code>u</code>：对应于<code>PTE_U</code></li>
<li><code>p</code>：对应于<code>PTE_P</code></li>
</ul>
<p>使用样例：<code>chperm 960 256 -w</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Change the permittions of a certain page.</span></span><br><span class="line"><span class="comment">// chperm &lt;PDX&gt; &lt;PTX&gt; &lt;perm&gt;</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_chperm(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pdx, ptx, perm = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>* ptr;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">// 0 represents '-', 1 represents '+'</span></span><br><span class="line">    <span class="keyword">pte_t</span>* pgaddr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (argc) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"></span><br><span class="line">            pdx = str2int(argv[<span class="number">1</span>]);</span><br><span class="line">            ptx = str2int(argv[<span class="number">2</span>]);</span><br><span class="line">            ptr = argv[<span class="number">3</span>];</span><br><span class="line">            pgaddr = pgdir_walk(kern_pgdir, (<span class="keyword">void</span> *)(PGADDR(pdx,ptx,<span class="number">0</span>)), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (*ptr) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>: flag = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>: flag = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    cprintf(<span class="string">"Error: Illegal operation \'%c\'.\n"</span>, *ptr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (*(ptr+<span class="number">1</span>))   &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'w'</span>:</span><br><span class="line">                    <span class="keyword">if</span> (flag) *pgaddr = *pgaddr | PTE_W;</span><br><span class="line">                    <span class="keyword">else</span> *pgaddr = *pgaddr &amp; (~PTE_W);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">                    <span class="keyword">if</span> (flag) *pgaddr = *pgaddr | PTE_U;</span><br><span class="line">                    <span class="keyword">else</span> *pgaddr = *pgaddr &amp; (~PTE_U);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'p'</span>:</span><br><span class="line">                    <span class="keyword">if</span> (flag) *pgaddr = *pgaddr | PTE_P;</span><br><span class="line">                    <span class="keyword">else</span> *pgaddr = *pgaddr &amp; (~PTE_P);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    cprintf(<span class="string">"Error: Illegal operation \'%c\'.\n"</span>, *(ptr+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cprintf(<span class="string">"Error: bad usage.\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>man</strong></li>
</ol>
<p>虽然命名为man，但是其实这个命令的行为更像<code>--help</code>。</p>
<p>需要注意的是，每增加一条新的命令就要增加<code>command_usage</code>数组的内容。并且，这个数组中的元素顺序必须与<code>commands</code>数组中的顺序一致。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* command_usage[] = &#123;</span><br><span class="line">    <span class="string">"help\nDisplay the list of commands"</span>,</span><br><span class="line">    <span class="string">"exit\nLeave the monitor and shutdown"</span>,</span><br><span class="line">    <span class="string">"kerninfo\nDisplay information about the kernel"</span>,</span><br><span class="line">    <span class="string">"backtrace\nDisplay the structure of the stack"</span>,</span><br><span class="line">    <span class="string">"pageinfo &lt;addr&gt;\nDisplay the information of the page virtual address &lt;addr&gt; locates"</span>,</span><br><span class="line">    <span class="string">"chperm &lt;PDX&gt; &lt;PTX&gt; &lt;perm&gt;\nChange the permittion of the page with index &lt;PDX&gt; and &lt;PTX&gt;\n  \</span></span><br><span class="line"><span class="string">&lt;perm&gt; is the combination of a symbol('+' or '-') and a permittion code. \</span></span><br><span class="line"><span class="string">In particular, '+' is for permittion addition and '-' is for permittion erasure.\n\</span></span><br><span class="line"><span class="string">Possible permittion codes:\n  u: PTE_U\n  p: PTE_P\n  w: PTE_W\n"</span>,</span><br><span class="line">    <span class="string">"man\nDisplay the usage of a command"</span>,  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Display the usage of a command.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_man(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        cprintf(<span class="string">"Usage: man &lt;command&gt;\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE(commands); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], commands[i].name) == <span class="number">0</span>) &#123;</span><br><span class="line">            cprintf(<span class="string">"Usage: %s\n"</span>, command_usage[i]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">"Error: no such command.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这一章的最后还有几个挑战，一个是实现一种不同的分页机制使用户可以不受限制地使用整个4GB内存空间，由于并没有什么主流操作系统使用这种模式就没写。另一个是实现一个类似于<code>malloc/free</code>堆内存分配的分配机制，过于麻烦，等有空再写这个吧。</p>
<h4 id="Summarize"><a href="#Summarize" class="headerlink" title="Summarize"></a>Summarize</h4><p>总结一下JOS使用的内存管理机制：</p>
<p>目前整个操作系统由一个页目录——<strong>内核页目录</strong>(<code>kern_pgdir</code>)来维持，页目录的大小为一页，包括<em>1024</em>个条目。每个条目都是一个4字节的物理地址，指向对应的页表所在的物理内存地址。每个页表大小也是一页，同样包括<em>1024</em>个条目，每个条目指向对应的页所在的物理内存地址。</p>
<p>每个物理地址与一个线性地址唯一对应。线性地址的前10位和中间10位分别是这个地址所在物理页面的<strong>页目录索引</strong>和<strong>页表索引</strong>，最后12位代表这个地址在物理页面内的<strong>偏移量</strong>。</p>
<p>除此之外，内核还维护着一个<code>pages</code>数组。真正的page每个<strong>4KB</strong>，由整个物理地址空间平分；pages数组中的元素<code>PageInfo</code>大小<strong>8字节</strong>，记录着这个page的引用数和空闲链表中它的下一个元素的地址。<strong>pages数组中元素的索引可以线性地换算出对应page在物理内存中的首地址</strong>。</p>
<p><code>page_free_list</code>指针是空闲链表的头指针。它指向pages数组中第一个空闲的元素。空闲链表中的其他元素可以由<code>PageInfo</code>中的指针来索引。</p>
<p>这个内存管理机制被外界调用的接口函数有：</p>
<ul>
<li><code>page_alloc</code>：分配一块空闲的物理页，并将其对应的<code>PageInfo</code>结构体指针返回。注意调用者需要自行增加<code>pp_ref</code>的值。</li>
<li><code>page_free</code>：释放一块被占用的物理页。</li>
<li><code>page_insert</code>：将一块已分配的物理页与一个虚拟地址建立关系</li>
</ul>
<h3 id="Lab-3-User-Environments"><a href="#Lab-3-User-Environments" class="headerlink" title="Lab 3 User Environments"></a>Lab 3 User Environments</h3><p>在前两个Lab中，我们成功加载并运行了JOS内核，还建立了整个内核虚拟地址空间的内存映射，但这些都只是对内核的操作。在这个Lab里，我们要开始建立一个用户环境。换句话说，我们要建立一个用户进程，并使其受内核的监管。内核应当接受并处理所有用户进程发起的系统调用和引发的异常。</p>
<p>执行<code>git checkout -b lab3 origin/lab3</code>命令切换到lab3分支，执行<code>git merge lab2</code>合并在lab2所做的更改。这一步可能会出现conflict，解决之后重新commit即可。</p>
<p>Lab3增加的文件有：</p>
<table>
<thead>
<tr>
<th></th>
<th>文件名</th>
<th>文件功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>inc/</code></td>
<td><code>env.h</code></td>
<td>有关用户环境的一些声明和定义</td>
</tr>
<tr>
<td></td>
<td><code>trap.h</code></td>
<td>关于trap类异常处理的声明和定义(有关四种异常可以参考CSAPP第八章)</td>
</tr>
<tr>
<td></td>
<td><code>syscall.h</code></td>
<td>关于系统调用处理的声明和定义</td>
</tr>
<tr>
<td></td>
<td><code>lib.h</code></td>
<td>用户使用的系统库</td>
</tr>
<tr>
<td><code>kern/</code></td>
<td><code>env.h</code>/<code>env.c</code></td>
<td>内核维持用户环境所需要的声明和定义</td>
</tr>
<tr>
<td></td>
<td><code>trap.h</code>/<code>trap.c</code></td>
<td>内核对trap类异常的接受和处理</td>
</tr>
<tr>
<td></td>
<td><code>trapentry.S</code></td>
<td>汇编语言编写的trap异常处理程序入口</td>
</tr>
<tr>
<td></td>
<td><code>syscall.h</code>/<code>syscall.c</code></td>
<td>内核对系统调用的接受和处理</td>
</tr>
<tr>
<td><code>lib/</code></td>
<td><code>Makefrag</code></td>
<td>用来构建<code>obj/lib/libjos.a</code>的makefile</td>
</tr>
<tr>
<td></td>
<td><code>entry.S</code></td>
<td>汇编语言编写的用户进程入口</td>
</tr>
<tr>
<td></td>
<td><code>libmain.c</code></td>
<td><code>entry.S</code>调用的用于初始化用户环境的代码</td>
</tr>
<tr>
<td></td>
<td><code>syscall.c</code></td>
<td>用户环境的系统调用函数</td>
</tr>
<tr>
<td></td>
<td><code>console.c</code></td>
<td>用户模式下的 <code>putchar</code> 和 <code>getchar</code>实现, 用于提供console的I/O</td>
</tr>
<tr>
<td></td>
<td><code>exit.c</code></td>
<td>用户模式下的 <code>exit</code></td>
</tr>
<tr>
<td></td>
<td><code>panic.c</code></td>
<td>用户模式下的<code>panic</code></td>
</tr>
<tr>
<td><code>user/</code></td>
<td><code>*</code></td>
<td>测试程序</td>
</tr>
</tbody>
</table>
<p>除此之外，lab3更改了不少lab2中的文件。可以执行<code>git diff lab2</code>来查看具体的改动。</p>
<p>在这个Lab中，GCC提供的<strong>内联汇编</strong>特性非常有帮助。内联汇编的格式可以参考<a href="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html" target="_blank" rel="noopener">6.828提供的教程</a>，也可以参考<a href="https://dracit7.github.io/blog/2018/11/23/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/">中文的博客</a>。</p>
<h4 id="Part-1-User-Environments-and-Exception-Handling"><a href="#Part-1-User-Environments-and-Exception-Handling" class="headerlink" title="Part 1 User Environments and Exception Handling"></a>Part 1 User Environments and Exception Handling</h4><p><code>inc/env.h</code>包含着对<code>Env</code>结构的定义。<code>Env</code>结构类似于<code>PageInfo</code>结构，只不过后者储存的是页面的信息而前者储存的是用户环境的信息。内核利用这些结构来管理所有用户环境。在这个Lab中我们只需要实现一个用户环境，但我们也要完成管理多个用户环境的机制，以支持以后的Lab功能。</p>
<p>在<code>kern/inv.c</code>中定义有三个变量:</p>
<ul>
<li><code>struct Env *envs</code>：所有用户环境信息链表头指针</li>
<li><code>struct Env *curenv</code>：当前的用户环境</li>
<li><code>static struct Env *env_free_list</code>：空闲的用户环境链表头指针</li>
</ul>
<p>JOS系统最多能够支持<code>NENV</code>个用户环境，这个常量的定义在<code>inc/kern.h</code>中，默认的值是10。在初始化时，<code>envs</code>数组会被初始化为<code>NENV</code>长度的链表。</p>
<p><strong>注</strong>：在这个Lab中，<strong>用户环境和进程是指的同一个东西</strong>。</p>
<h5 id="Environment-State"><a href="#Environment-State" class="headerlink" title="Environment State"></a>Environment State</h5><p>我们可以分析一下<code>Env</code>结构的内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span>	<span class="comment">// Saved registers</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span>		<span class="comment">// Next free Env</span></span><br><span class="line">	<span class="keyword">envid_t</span> env_id;			<span class="comment">// Unique environment identifier</span></span><br><span class="line">	<span class="keyword">envid_t</span> env_parent_id;		<span class="comment">// env_id of this env's parent</span></span><br><span class="line">	<span class="keyword">enum</span> EnvType env_type;		<span class="comment">// Indicates special system environments</span></span><br><span class="line">	<span class="keyword">unsigned</span> env_status;		<span class="comment">// Status of the environment</span></span><br><span class="line">	<span class="keyword">uint32_t</span> env_runs;		<span class="comment">// Number of times environment has run</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Address space</span></span><br><span class="line">	<span class="keyword">pde_t</span> *env_pgdir;		<span class="comment">// Kernel virtual address of page dir</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>env_tf</code>：这是一个<code>Trapframe</code>结构体，它负责在这个用户环境挂起的时候<strong>保存其所有寄存器值</strong>。可以观察一下<code>Trapframe</code>结构体的<span id="trapframe">定义</span>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">	<span class="keyword">uint16_t</span> tf_es;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_padding1;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_ds;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_padding2;</span><br><span class="line">	<span class="keyword">uint32_t</span> tf_trapno;</span><br><span class="line">	<span class="comment">/* below here defined by x86 hardware */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> tf_err;</span><br><span class="line">	<span class="keyword">uintptr_t</span> tf_eip;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_cs;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_padding3;</span><br><span class="line">	<span class="keyword">uint32_t</span> tf_eflags;</span><br><span class="line">	<span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> tf_esp;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_ss;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_padding4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，所有x86的关键寄存器的值在这里都有保存(通用寄存器的值都保存在<code>PushRegs</code>结构内)。</p>
<ul>
<li><code>env_link</code>：指向空闲用户环境链表中的下一个元素</li>
<li><code>env_id</code>：内核用于<strong>唯一地标识</strong>这个用户环境的描述符，也就是进程的pid。当用户环境被回收时这个id也会被回收，也就是说id和这个<code>Env</code>在链表中的位置是无关的。</li>
<li><code>env_parent_id</code>：这个进程的父进程的id。</li>
<li><code>env_type</code>：用于区分进程的类型(用户进程还是系统服务进程)</li>
<li><p><code>env_status</code>：当前用户环境的状态</p>
<ul>
<li><code>ENV_FREE</code>：位于<code>env_free_list</code>中</li>
<li><code>ENV_RUNNABLE</code>：该进程可以运行，正在等待CPU的调度</li>
<li><code>ENV_RUNNING</code>：该进程正在CPU上运行</li>
<li><code>ENV_NOT_RUNNABLE</code>：该进程是活动的，但由于某些原因无法运行</li>
<li><code>ENV_DYING</code>：该进程目前是僵尸进程</li>
</ul>
</li>
<li><p><code>env_pgdir</code>：当前用户环境使用的页目录地址</p>
</li>
</ul>
<h5 id="Allocating-the-Environments-Array"><a href="#Allocating-the-Environments-Array" class="headerlink" title="Allocating the Environments Array"></a>Allocating the Environments Array</h5><blockquote>
<p><strong>Exercise 1</strong></p>
<p>你需要向<code>mem_init</code>函数中添加初始化<code>envs</code>数组的代码，就像之前初始化<code>pages</code>那样。此外，你还需要将初始化后的<code>envs</code>数组映射到<code>UENVS</code>地址以使用户能够查看它。</p>
</blockquote>
<p>由于有了之前初始化pages的经验，这里使用相同的方法可以轻松完成任务：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">envs = (struct Env *) boot_alloc(<span class="keyword">sizeof</span>(struct Env) * NENV);</span><br><span class="line"><span class="built_in">memset</span>(envs, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct Env) * NENV);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boot_map_region(kern_pgdir, UENVS, NENV*<span class="keyword">sizeof</span>(struct Env), PADDR(envs), PTE_U);</span><br></pre></td></tr></table></figure>
<p>运行后一看，为什么本来过了的<code>check_page_free_list()</code>失败了呢？百思不得其解，逆着逻辑流往前找，最终发现是因为之前在<code>page_init</code>函数中在计算内核空闲地址空间的起始位置时用到了<code>pages</code>，而现在我们在<code>pages</code>数组后面又分配了更多的空间给<code>envs</code>，原本空闲的内存变得不空闲了，但<code>page_init</code>的逻辑没有变，于是本来正确的函数出现了错误。改正方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// char* end_addr = (char *)pages + sizeof(struct PageInfo) * npages - KERNBASE;</span></span><br><span class="line"><span class="keyword">char</span>* end_addr = (<span class="keyword">char</span> *)envs + <span class="keyword">sizeof</span>(struct Env) * NENV - KERNBASE;</span><br></pre></td></tr></table></figure>
<h5 id="Creating-and-Running-Environments"><a href="#Creating-and-Running-Environments" class="headerlink" title="Creating and Running Environments"></a>Creating and Running Environments</h5><p>我们现在需要完善<code>kern/env.c</code>中的代码来运行一个用户环境。由于我们现在还没有构建文件系统，我们会让内核加载一个静态的二进制镜像(这个镜像是以ELF格式嵌在内核中的)。</p>
<p>Lab3的<code>GNUMakefile</code>在<code>obj/user</code>目录中生成了很多二进制镜像。<code>kern</code>目录中的<code>Makefrag</code>文件将它们利用linker的<code>-b</code>参数直接嵌入内核的可执行文件当中(不是以可重定位文件<code>.o</code>的形式，是将整个二进制文件原样嵌入)，内核可以在运行时索引并运行这些镜像。</p>
<blockquote>
<p><strong>Exercise 2</strong></p>
<p>完成下列函数来初始化用户环境：</p>
<ul>
<li><code>env_init()</code>：初始化所有<code>envs</code>数组中的元素并将它们加入<code>env_free_list</code>链表中。这个函数还应该调用<code>env_init_percpu</code>来配置关于分段机制的硬件。</li>
<li><code>env_setup_vm()</code>：为新的用户环境初始化一个<strong>页目录</strong>并初始化这个用户环境的内核部分内存</li>
<li><code>region_alloc()</code>：用于为用户环境分配物理内存</li>
<li><code>load_icode()</code>：解析用户进程要跑的任务文件的ELF头，并将二进制文件加载到虚拟地址空间</li>
<li><code>env_create()</code>：调用上面两个函数来为一个任务建立一个新的用户环境</li>
<li><code>env_run()</code>：运行一个用户环境</li>
</ul>
</blockquote>
<p>这一部分编码涉及到比较多的错误码处理，在这里可以活用<code>cprintf</code>的<code>%e</code>转义字符：它可以打印出一个errorcode对应的错误信息。</p>
<p>首先是<code>env_init</code>函数。只要认真阅读过函数前面的注释，按部就班地来就没有什么难度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Set up envs array</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		envs[i].env_id = <span class="number">0</span>;</span><br><span class="line">		envs[i].env_status = ENV_FREE;</span><br><span class="line">		envs[i].env_link = env_free_list;</span><br><span class="line">		env_free_list = &amp;envs[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">	env_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后是<code>env_setup_vm</code>函数。这个函数的作用是为这个用户环境建立整个虚拟内存系统。看上去很吓人，但注释中提示我们，所有用户环境在UTOP以上的虚拟内存空间都是内核虚拟内存空间中这一部分的副本，而UTOP以下的部分在初始化过程中全都可以置0，因此我们可以直接以<code>kern_pgdir</code>为模板来初始化<code>e-&gt;env_pgdir</code>的表项：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the page directory</span></span><br><span class="line">p-&gt;pp_ref++;</span><br><span class="line">e-&gt;env_pgdir = page2kva(p);</span><br><span class="line"><span class="comment">// Set up the virtual memory space</span></span><br><span class="line"><span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</span><br></pre></td></tr></table></figure>
<p>接下来是<code>region_alloc</code>函数，这个函数其实不写也行，主要是为了简化物理内存的分配过程。在<code>load_icode</code>函数中我们要频繁地为一段虚拟内存分配物理内存，这个函数就是为了简化这一过程而生的。</p>
<p>如果我们对之前Lab2中自己实现过的函数的功能和调用关系很熟悉的话，这个函数的实现会很简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">region_alloc(struct Env *e, <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">uintptr_t</span> start_addr = ROUNDDOWN((<span class="keyword">uintptr_t</span>)va, PGSIZE);</span><br><span class="line">	<span class="keyword">uintptr_t</span> end_addr = ROUNDUP((<span class="keyword">uintptr_t</span>)(va + len), PGSIZE);</span><br><span class="line">	<span class="keyword">for</span> ( ; start_addr &lt; end_addr; start_addr += PGSIZE) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">rawpg</span> = <span class="title">page_alloc</span>(<span class="title">ALLOC_ZERO</span>);</span></span><br><span class="line">		<span class="keyword">if</span> (!rawpg) panic(<span class="string">"region_alloc: %e"</span>,-E_NO_MEM);</span><br><span class="line">		page_insert(e-&gt;env_pgdir, rawpg, (<span class="keyword">void</span> *)start_addr, PTE_U | PTE_W);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一个函数<code>load_icode</code>的实现难度就比较大了，它会<strong>将目标ELF镜像文件加载到内存中</strong>，为此它需要解析ELF头的内容，这一步与bootloader所做的比较相似，可以参考<code>boot/main.c</code>中的实现；它还会为这个已经加载的二进制文件<strong>建立一个程序栈</strong>。</p>
<p>在<code>inc/elf.h</code>中已经定义好了ELF头和段头的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> e_magic;	<span class="comment">// must equal ELF_MAGIC</span></span><br><span class="line">	<span class="keyword">uint8_t</span> e_elf[<span class="number">12</span>];</span><br><span class="line">	<span class="keyword">uint16_t</span> e_type;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_machine;</span><br><span class="line">	<span class="keyword">uint32_t</span> e_version;</span><br><span class="line">	<span class="keyword">uint32_t</span> e_entry;</span><br><span class="line">	<span class="keyword">uint32_t</span> e_phoff;</span><br><span class="line">	<span class="keyword">uint32_t</span> e_shoff;</span><br><span class="line">	<span class="keyword">uint32_t</span> e_flags;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_ehsize;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_phentsize;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_phnum;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_shentsize;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_shnum;</span><br><span class="line">	<span class="keyword">uint16_t</span> e_shstrndx;</span><br><span class="line">&#125;; <span class="comment">// ELF头的结构</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> p_type;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_offset;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_va;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_pa;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_filesz;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_memsz;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_flags;</span><br><span class="line">	<span class="keyword">uint32_t</span> p_align;</span><br><span class="line">&#125;; <span class="comment">// 段头部的结构</span></span><br></pre></td></tr></table></figure>
<p>关于ELF文件结构的详细知识可以参考CSAPP的第7章链接部分知识，我们现在只需要知道，<strong>ELF头</strong>位于一个二进制文件的开头部分，而且通过解析ELF头的信息可以得到<strong>段头部表</strong>的位置和大小。通过解析每个段头部，我们又可以得知所有段的信息，从而将它们有选择性地加载到内存中。</p>
<p>这里可能需要解释一下6.828的诡异命名的含义：<code>ph</code>是指二进制文件中各个段的段头部结构体指针，其类型为<code>struct Proghdr*</code>。只要理解了这一层，按照注释就可以按部就班地完成这个函数了。</p>
<p>比较需要注意的一点是<code>cr3</code>寄存器值的切换。在这个函数执行之前当前运行的环境是kernel，因此<code>cr3</code>的值是<code>kern_pgdir</code>，如果我们直接用<code>memcpy</code>函数去加载binary就会将binary加载到<strong>内核地址空间</strong>而非<strong>用户环境地址空间</strong>。所以我们需要在加载binary之前先用<code>lcr3</code>函数切换<code>cr3</code>寄存器的值，在加载完之后再切换回<code>kern_pgdir</code>。</p>
<p>另一个问题是如何设置加载进内存的二进制程序的<strong>入口点</strong>。根据注释中的提示观察<code>env_pop_tf</code>函数可以发现，这个函数从<code>env_tf</code>结构中恢复了所有上下文寄存器的值，其中就包括<code>tf_eip</code>这个决定着下一条命令位置的寄存器，随后就执行<code>iret</code>汇编指令切换用户环境。这样一来，只要我们将<code>(e-&gt;env_tf).tf_eip</code>的值修改为二进制程序入口点的值，就可以让控制流自然地跳转到那个位置了。</p>
<p>但是二进制程序入口点的值是什么呢？这个值其实存放在ELF头中，就是<code>e_entry</code>这个结构体元素的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">load_icode(struct Env *e, <span class="keyword">uint8_t</span> *binary)</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Elf</span>* <span class="title">elf_ptr</span> = <span class="title">binary</span>;</span> <span class="comment">// The pointer to the binary's elf header</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check the type of the binary</span></span><br><span class="line">	<span class="keyword">if</span> (elf_ptr-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">		panic(<span class="string">"This binary is not a valid ELF file!"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Load each program segment</span></span><br><span class="line">	ph = (struct Proghdr *)(binary + elf_ptr-&gt;e_phoff);</span><br><span class="line">	eph = ph + elf_ptr-&gt;e_phnum;</span><br><span class="line">	<span class="comment">// As we need to load the binary into e's virtual memory,</span></span><br><span class="line">	<span class="comment">// we should change cr3 to e's page directory (or the binary</span></span><br><span class="line">	<span class="comment">// would be loaded to kernel's virtual memory).</span></span><br><span class="line">	lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">	<span class="keyword">for</span> (; ph &lt; eph; ph++) &#123;</span><br><span class="line">		<span class="comment">// Do what the hint told us to</span></span><br><span class="line">		<span class="keyword">if</span> (ph-&gt;p_type == ELF_PROG_LOAD) &#123;</span><br><span class="line">			region_alloc(e, ph-&gt;p_va, ph-&gt;p_memsz);</span><br><span class="line">			<span class="built_in">memcpy</span>(ph-&gt;p_va, binary + ph-&gt;p_offset, ph-&gt;p_filesz);</span><br><span class="line">			<span class="built_in">memset</span>(binary + ph-&gt;p_va + ph-&gt;p_filesz, <span class="number">0</span>, ph-&gt;p_memsz - ph-&gt;p_filesz);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Change cr3 back to kern_pgdir.</span></span><br><span class="line">	lcr3(PADDR(kern_pgdir));</span><br><span class="line">	<span class="comment">// Set the entry point of the binary</span></span><br><span class="line">	(e-&gt;env_tf).tf_eip = elf_ptr-&gt;e_entry;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now map one page for the program's initial stack</span></span><br><span class="line">	<span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	region_alloc(e, USTACKTOP - PGSIZE, PGSIZE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数完成之后，剩下的两个函数就比较简单了。<code>env_create</code>函数直接按照注释中的要求调用函数即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_create(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">new_env</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err = env_alloc(&amp;new_env, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		panic(<span class="string">"env_create: %e"</span>, err);</span><br><span class="line">	load_icode(new_env, binary);</span><br><span class="line">	new_env-&gt;env_type = type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的<code>env_run</code>也按照注释的要求完成即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_run(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1</span></span><br><span class="line">	<span class="keyword">if</span> (curenv != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (curenv-&gt;env_status == ENV_RUNNING)</span><br><span class="line">			curenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">		<span class="keyword">else</span> panic(<span class="string">"env_run: The current process's status is not ENV_RUNNING."</span>);</span><br><span class="line">	&#125;	<span class="comment">// 1.</span></span><br><span class="line">	curenv = e; <span class="comment">// 2.</span></span><br><span class="line">	curenv-&gt;env_status = ENV_RUNNING; <span class="comment">// 3.</span></span><br><span class="line">	curenv-&gt;env_runs++; <span class="comment">// 4.</span></span><br><span class="line">	lcr3(PADDR(e-&gt;env_pgdir)); <span class="comment">// 5.</span></span><br><span class="line">	<span class="comment">// Step 2</span></span><br><span class="line">	env_pop_tf(&amp;curenv-&gt;env_tf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们还没有完成系统调用相关的处理代码，加载完成的binary并无法正常工作。在binary执行到系统调用那一步之后，CPU会发现它还不能处理这个中断，于是抛出一个<strong>一般保护错误</strong>(general protection fault)。然而这个保护错误目前不能被处理，于是CPU再抛出一个<code>double fault</code>异常，并发现这也不能被处理，最终放弃治疗并抛出<code>triple fault</code>异常，也就是我们之前在调试过程中常见的那个<code>triple fault</code>。</p>
<p>一个<code>triple fault</code>异常通常会引起系统重启，但为了方便debug，6.828修改了qemu使得它在<code>triple fault</code>的时候打印出所有寄存器的值和内存状态。</p>
<p>为了检验我们的工作是否正确完成，我们可以用<code>qemu-gdb</code>和<code>gdb</code>来进行调试。首先在<code>env_pop_tf</code>函数处打上断点并<code>c</code>到这个函数，<code>si</code>单步调试直到<code>iret</code>将控制流跳转到用户地址空间，这时可以发现<code>gdb</code>中的地址信息显示从<code>0xf0000000</code>以上变成了<code>0x00800000</code>以上，能进行到这一步说明我们对于用户地址空间创建的实现没有问题。</p>
<p>在<code>0x800101</code>处(系统调用的前一句指令)打一个断点，执行到这一句汇编指令。如果在执行到这里的过程中始终没有触发错误，说明我们Exercise 2的实现是没有问题的。</p>
<h5 id="Handling-Interrupts-and-Exceptions"><a href="#Handling-Interrupts-and-Exceptions" class="headerlink" title="Handling Interrupts and Exceptions"></a>Handling Interrupts and Exceptions</h5><p>现在的情况是，一旦用户环境执行了系统调用，控制流是无法从内核返回给用户环境的。我们现在需要实现的是内核对于<strong>基本的异常和系统调用的处理</strong>，首先我们要熟悉x86的中断和异常机制。</p>
<blockquote>
<p><strong>Exercise 3</strong></p>
<p>阅读<a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/c09.htm" target="_blank" rel="noopener">80386 Programmer’s Manual中有关异常和中断处理的部分</a>。</p>
</blockquote>
<p>(如果已经阅读过CSAPP第八章异常控制流，有关这部分的内容会变得很易于理解。)</p>
<p>中断和异常都是<strong>受保护的控制流转移</strong>，也就是说这两个过程是受内核控制的。内核通过中断或异常来切换到内核态，以使得用户代码没有干预内核运行的机会。</p>
<p>Intel是这样定义<strong>异常</strong>和<strong>中断</strong>的：</p>
<ul>
<li>中断(Interrupt)是<strong>处理器外部</strong>的设备向处理器发出的<strong>异步</strong>(<em>asynchronous</em>)信号引起的(典型的例子是IO)。</li>
<li>异常(Exception)是<strong>处理器本身</strong>执行的代码所触发的<strong>同步</strong>(<em>synchronous</em>)信号引起的，系统调用和错误都算做异常。</li>
</ul>
<p>从这个定义我们可以看出，Intel对中断的定义和CSAPP一致，但异常的定义其实是包括了CSAPP中定义的<strong>陷阱</strong>(trap)，<strong>错误</strong>(fault)和<strong>终止</strong>(abort)。</p>
<p>为了保证这种控制流转移是<strong>受保护的</strong>，intel使用了两种机制：</p>
<ul>
<li><strong>中断描述符表</strong>(IDT)：处理器保证了当异常或中断触发时，控制流的转移位置是由<strong>内核</strong>而非<strong>触发异常的代码</strong>定义的。intel定义了256种异常，每一种异常有一个独一无二的<strong>异常号</strong>(直译是异常向量，但将一个数称为向量感觉会引起误解)，CPU以异常号为索引去中断描述符表中寻找对应的表项，从而进行对特定中断的处理。CPU可以从中断描述符表中获得：<ul>
<li>指向中断处理程序首地址的eip值</li>
<li>用于处理中断的特权级所对应的CS寄存器值(能处理中断的只有0级和1级，在JOS中均为0级)</li>
</ul>
</li>
<li><strong>任务状态段</strong>(TSS)：在跳转到中断处理程序之前，CPU需要保存它的状态以便在处理完之后将控制权交还。但是这个保存状态的位置必须是用户特权级所不能访问的，否则恶意的用户代码就能够去干预内核的行为。为此CPU为异常处理程序建立了一个<strong>独立于用户栈之外的栈</strong>，在这个栈中处理器压入SS，ESP，EFLAGS，CS，IP等关键信息，并重新设置SS和ESP以将这个栈作为新的程序栈。</li>
</ul>
<p>所有异常都使用<strong>0-31之间</strong>的32个异常号，而剩下的异常号通常对应于软件或硬件引发的中断。</p>
<p>现在我们来看一个例子：假设一个用户环境在执行一条代码的时候试图进行除零运算。</p>
<ul>
<li>处理器根据TSS所定义的SS0和ESP0来切换程序栈，在JOS中它们分别对应着<code>GD_KD</code>和<code>KSTACKTOP</code>。</li>
<li>处理器将需要保护的上下文信息压入新的栈(先后是SS，ESP，EFLAGS，CS，EIP，有些时候还会压入errorcode)。</li>
<li>处理器根据除法异常的异常号(0)找到<code>IDT[0]</code>，并根据其内容设定新的CS：EIP</li>
<li>异常处理程序接管控制流并进行异常处理</li>
</ul>
<p>值得注意的是，<strong>只有当从用户态进入内核态时CPU才会进行程序栈切换</strong>，如果在内核态下发生了中断或异常，CPU不会建立一个新栈，而是在已有的内核栈中先后压入<code>EFLAGS</code>，<code>CS</code>和<code>EIP</code>(有时压入errorcode)，然后进行控制流跳转，这为异常的嵌套提供了一种优雅的解决方式。</p>
<h5 id="Setting-Up-the-IDT"><a href="#Setting-Up-the-IDT" class="headerlink" title="Setting Up the IDT"></a>Setting Up the IDT</h5><p>在这个Lab中我们会建立能够处理异常和系统调用的IDT，<code>inc/trap.h</code>和<code>kern/trap.h</code>可以为我们的工作提供很多帮助，其中后者提供的定义只能由内核访问，前者的定义则可以由内核和用户共同访问。</p>
<p><strong>注意：</strong>有些异常是被intel保留的，这意味着你不需要处理它们。</p>
<p>在<code>trapentry.S</code>中定义了每个中断或异常的处理程序，<code>trap_init()</code>函数应当用它们的地址来初始化IDT。每个处理程序都应当在栈上建立一个<code>struct Trapframe</code>，并以这个结构的指针为参数调用<code>trap.c</code>中的<code>trap()</code>函数。</p>
<blockquote>
<p><strong>Exercise 4</strong></p>
<p>修改<code>trapentry.S</code>和<code>trap.c</code>来实现上面描述的功能。可能有帮助的宏定义有：</p>
<ul>
<li><code>trapentry.S</code>中的<code>TRAPHANDLER</code>和<code>TRAPHANDLER_NOEC</code></li>
<li><code>inc/trap.h</code>中的<code>T_*</code>宏定义们</li>
</ul>
<p>你需要用这些宏为<code>inc/trap.h</code>中定义的每一个trap增加一个入口点。由于每个异常处理函数都会<code>jmp</code>到<code>_alltraps</code>，你还需要完成这段代码的实现。你的<code>_alltraps</code>需要完成这些工作：</p>
<ul>
<li>向栈中压入数据，使栈的结构看起来像<code>struct Trapframe</code>(可以使用<code>pushal</code>指令)</li>
<li>将<code>GD_KD</code>加载到<code>%ds</code>和<code>%es</code></li>
<li><code>pushl %esp</code>作为<code>trap</code>函数的参数</li>
<li>调用<code>trap</code>函数</li>
</ul>
<p>你还需要修改<code>trap_init()</code>函数来初始化IDT，让它的每个表项指向<code>trapentry.S</code>中定义的一个入口点，在这个过程中<code>SETGATE</code>函数可能会有用。</p>
</blockquote>
<p>首先观察<code>trapentry.S</code>中对两个宏的定义和注释，理解它们的作用。<code>TRAPHANDLER</code>接受两个参数<code>name</code>和<code>num</code>，定义一个名为<code>name</code>的<strong>全局的</strong>处理<code>num</code>所对应异常的异常处理函数；而<code>TRAPHANDLER_NOEC</code>与其唯一的区别就是后者会在压入<strong>异常号</strong>之前多压入一个32位的<code>0</code>。这个操作的用意是什么呢？</p>
<p><code>_alltraps</code>定义了所有异常处理函数的公共部分，我们可以从要求中得知它的第一步就是要将一个<code>Trapframe</code>结构压入程序栈。这个结构的定义<a href="#trapframe">在之前遇到过</a>，现在我们来仔细研究一下它的结构：</p>
<p><img src="/home/drac_zhang/Workplace/PersonalWebsite/Blog/source/_posts/MIT_6.828/trapframe.png" alt=""></p>
<p>在之前的描述中我们已经知道在异常触发的时候处理器会帮我们切换好程序栈并压入一些必要信息，其中对于<code>errorcode</code>这一项，有些异常会压入，但有些异常不会压入。如果我们对所有异常一概使用<code>TRAPHANDLER</code>宏去处理，没有压入<code>errorcode</code>的异常的<code>Trapframe</code>就会向上“塌陷”，致使从trap number往下的所有数据错位。为了保持结构的完整性，我们需要对已经压入<code>errorcode</code>的异常使用<code>TRAPHANDLER</code>宏，而对没有压入的异常使用<code>TRAPHANDLER_NOEC</code>宏。</p>
<p>哪些异常压入过<code>errorcode</code>呢？通过查阅<a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/s09_10.htm" target="_blank" rel="noopener">80380 Programmer’s Manual</a>，可以发现一个<code>Error-Code Summary</code>，可以根据这个表给出的信息来选择应该用哪个宏。</p>
<p>在我们成功构造好<code>Trapframe</code>之后，下一步是修改<code>ds</code>和<code>es</code>的值，压入<code>esp</code>的值，最后<code>call trap</code>。只要熟悉AT&amp;T标准的语法和规范，这几步应该不算难。</p>
<p><code>trapentry.S</code>的代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Lab 3: Your code here for generating entry points for the different traps.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">TRAPHANDLER_NOEC(_divide, T_DIVIDE)</span><br><span class="line">TRAPHANDLER_NOEC(_debug, T_DEBUG)</span><br><span class="line">TRAPHANDLER_NOEC(_nmi, T_NMI)</span><br><span class="line">TRAPHANDLER_NOEC(_brkpt, T_BRKPT)</span><br><span class="line">TRAPHANDLER_NOEC(_oflow, T_OFLOW)</span><br><span class="line">TRAPHANDLER_NOEC(_bound, T_BOUND)</span><br><span class="line">TRAPHANDLER_NOEC(_illop, T_ILLOP)</span><br><span class="line">TRAPHANDLER_NOEC(_device, T_DEVICE)</span><br><span class="line">TRAPHANDLER_NOEC(_dblflt, T_DBLFLT)</span><br><span class="line">TRAPHANDLER(_tss, T_TSS)</span><br><span class="line">TRAPHANDLER(_segnp, T_SEGNP)</span><br><span class="line">TRAPHANDLER(_stack, T_STACK)</span><br><span class="line">TRAPHANDLER(_gpflt, T_GPFLT)</span><br><span class="line">TRAPHANDLER(_pgflt, T_PGFLT)</span><br><span class="line">TRAPHANDLER_NOEC(_fperr, T_FPERR)</span><br><span class="line">TRAPHANDLER_NOEC(_align, T_ALIGN)</span><br><span class="line">TRAPHANDLER_NOEC(_mchk, T_MCHK)</span><br><span class="line">TRAPHANDLER_NOEC(_simderr, T_SIMDERR)</span><br><span class="line">TRAPHANDLER_NOEC(_syscall, T_SYSCALL)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Lab 3: Your code here for _alltraps</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">_alltraps:</span><br><span class="line"></span><br><span class="line">	pushw $0x0</span><br><span class="line">	pushw %ds</span><br><span class="line">	pushw $0x0</span><br><span class="line">	pushw %es</span><br><span class="line">	pushal</span><br><span class="line">	movw $(GD_KD), %ax ; Note that ds and es can not be assigned straightly by immediates</span><br><span class="line">	movw %ax, %ds</span><br><span class="line">	movw %ax, %es</span><br><span class="line">	pushl %esp</span><br><span class="line">	call trap</span><br></pre></td></tr></table></figure>
<p>在<code>trap.c</code>中的部分就比较简单了，只需要阅读一下<code>SETGATE</code>这个宏的具体定义(位于<code>inc/mmu.h</code>)，明确各个参数的作用就可以做了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETGATE(gate, istrap, sel, off, dpl)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>gate</code>：这个异常在IDT中的异常描述符</li>
<li><code>istrap</code>：如果是异常则为1，中断则为0</li>
<li><code>sel</code>：异常处理函数的数据段，这里显然是内核代码段<code>GD_KT</code>(各个段选择符的定义在<code>inc/memlayout.h</code>中有)</li>
<li><code>off</code>：异常处理函数首地址的偏移，这里可以使用对应的函数指针</li>
<li><code>dpl</code>：异常处理函数的权限级，在JOS中一律为<code>0</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declarations</span></span><br><span class="line"><span class="keyword">void</span> _divide();</span><br><span class="line"><span class="keyword">void</span> _debug();</span><br><span class="line"><span class="keyword">void</span> _nmi();</span><br><span class="line"><span class="keyword">void</span> _brkpt();</span><br><span class="line"><span class="keyword">void</span> _oflow();</span><br><span class="line"><span class="keyword">void</span> _bound();</span><br><span class="line"><span class="keyword">void</span> _illop();</span><br><span class="line"><span class="keyword">void</span> _device();</span><br><span class="line"><span class="keyword">void</span> _dblflt();</span><br><span class="line"><span class="keyword">void</span> _tss();</span><br><span class="line"><span class="keyword">void</span> _segnp(); </span><br><span class="line"><span class="keyword">void</span> _stack(); </span><br><span class="line"><span class="keyword">void</span> _gpflt(); </span><br><span class="line"><span class="keyword">void</span> _pgflt(); </span><br><span class="line"><span class="keyword">void</span> _fperr(); </span><br><span class="line"><span class="keyword">void</span> _align(); </span><br><span class="line"><span class="keyword">void</span> _mchk();</span><br><span class="line"><span class="keyword">void</span> _simderr();</span><br><span class="line"><span class="keyword">void</span> _syscall();</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Segdesc</span> <span class="title">gdt</span>[];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	SETGATE(idt[<span class="number">0</span>], <span class="number">1</span>, GD_KT, _divide, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">1</span>], <span class="number">1</span>, GD_KT, _debug, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">2</span>], <span class="number">1</span>, GD_KT, _nmi, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">3</span>], <span class="number">1</span>, GD_KT, _brkpt, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">4</span>], <span class="number">1</span>, GD_KT, _oflow, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">5</span>], <span class="number">1</span>, GD_KT, _bound, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">6</span>], <span class="number">1</span>, GD_KT, _illop, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">7</span>], <span class="number">1</span>, GD_KT, _device, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">8</span>], <span class="number">1</span>, GD_KT, _dblflt, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">10</span>], <span class="number">1</span>, GD_KT, _tss, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">11</span>], <span class="number">1</span>, GD_KT, _segnp, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">12</span>], <span class="number">1</span>, GD_KT, _stack, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">13</span>], <span class="number">1</span>, GD_KT, _gpflt, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">14</span>], <span class="number">1</span>, GD_KT, _pgflt, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">16</span>], <span class="number">1</span>, GD_KT, _fperr, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">17</span>], <span class="number">1</span>, GD_KT, _align, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">18</span>], <span class="number">1</span>, GD_KT, _mchk, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">19</span>], <span class="number">1</span>, GD_KT, _simderr, <span class="number">0</span>);</span><br><span class="line">	SETGATE(idt[<span class="number">48</span>], <span class="number">1</span>, GD_KT, _syscall, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Per-CPU setup </span></span><br><span class="line">	trap_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/2018/11/24/用自己建造的DockerImage创建k8s容器/" rel="next" title="用自己建造的DockerImage创建k8s容器">
                <i class="fa fa-chevron-left"></i> 用自己建造的DockerImage创建k8s容器
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/2019/03/10/在ArchLinux下安装和配置LaTex编译环境/" rel="prev" title="在ArchLinux下安装和配置LaTex编译环境">
                在ArchLinux下安装和配置LaTex编译环境 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/blog/images/lyrica.png" alt="Drac Zhang">
            
              <p class="site-author-name" itemprop="name">Drac Zhang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/blog/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/dracit7" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#MIT-6-828-Labs-实验记录"><span class="nav-number">1.</span> <span class="nav-text">MIT 6.828 Labs 实验记录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Overall"><span class="nav-number">1.1.</span> <span class="nav-text">Overall</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Build-up-the-environment"><span class="nav-number">1.2.</span> <span class="nav-text">Build up the environment</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Compiler-Toolchain"><span class="nav-number">1.2.1.</span> <span class="nav-text">Compiler Toolchain</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#QEMU-emulator"><span class="nav-number">1.2.2.</span> <span class="nav-text">QEMU emulator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Other-problems"><span class="nav-number">1.2.3.</span> <span class="nav-text">Other problems</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Dependencies-upgraded"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">Dependencies upgraded</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lab-1-Booting-a-PC"><span class="nav-number">1.3.</span> <span class="nav-text">Lab 1 Booting a PC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Part-1-PC-bootstrap"><span class="nav-number">1.3.1.</span> <span class="nav-text">Part 1 PC bootstrap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Layout-of-the-physical-address-space"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">Layout of the physical address space</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#The-ROM-BIOS"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">The ROM BIOS</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Part-2-The-boot-loader"><span class="nav-number">1.3.2.</span> <span class="nav-text">Part 2 The boot loader</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#习题解答"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">习题解答</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Part-3-The-kernel"><span class="nav-number">1.3.3.</span> <span class="nav-text">Part 3 The kernel</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Virtual-memory-address-mapping"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">Virtual memory address mapping</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Formatted-printing-to-the-console"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">Formatted printing to the console</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#The-Stack"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">The Stack</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lab2-Memory-Management"><span class="nav-number">1.4.</span> <span class="nav-text">Lab2 Memory Management</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Background-knowledge"><span class="nav-number">1.4.1.</span> <span class="nav-text">Background knowledge</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Definitions-guide"><span class="nav-number">1.4.2.</span> <span class="nav-text">Definitions guide</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Part-1-Physical-page-management"><span class="nav-number">1.4.3.</span> <span class="nav-text">Part 1 Physical page management</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Part-2-Virtual-Memory"><span class="nav-number">1.4.4.</span> <span class="nav-text">Part 2 Virtual Memory</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Segments"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">Segments</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Pages"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">Pages</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Addresses"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">Addresses</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#page-management"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">page management</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Part-3-Kernel-address-space"><span class="nav-number">1.4.5.</span> <span class="nav-text">Part 3 Kernel address space</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Initializing-the-Kernel-Address-Space"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">Initializing the Kernel Address Space</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Summarize"><span class="nav-number">1.4.6.</span> <span class="nav-text">Summarize</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lab-3-User-Environments"><span class="nav-number">1.5.</span> <span class="nav-text">Lab 3 User Environments</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Part-1-User-Environments-and-Exception-Handling"><span class="nav-number">1.5.1.</span> <span class="nav-text">Part 1 User Environments and Exception Handling</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Environment-State"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">Environment State</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Allocating-the-Environments-Array"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">Allocating the Environments Array</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Creating-and-Running-Environments"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">Creating and Running Environments</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Handling-Interrupts-and-Exceptions"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">Handling Interrupts and Exceptions</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Setting-Up-the-IDT"><span class="nav-number">1.5.1.5.</span> <span class="nav-text">Setting Up the IDT</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Drac Zhang</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/blog/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/blog/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://Drac_zhang.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://dracit7.github.io/blog/2019/02/24/MIT_6.828/';
          this.page.identifier = '2019/02/24/MIT_6.828/';
          this.page.title = 'MIT 6.828 Labs 实验记录';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://Drac_zhang.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
