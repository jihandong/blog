<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="MIT 6.828 Labs 实验记录本博客中所有代码所对应的github repo地址：6.828 Overall 6.828自带了一个打分系统，在Lab文件夹下执行make grade即可运行这个系统来检验自己的解答。  Build up the environmentCompiler Toolchain由于Archlinux中的objdump和gcc均满足Lab的要求，不需要手动搭建编译环境">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT 6.828 Labs 实验记录">
<meta property="og:url" content="https://dracit7.github.io/blog/2019/02/24/MIT_6.828/index.html">
<meta property="og:site_name" content="Gensokyo">
<meta property="og:description" content="MIT 6.828 Labs 实验记录本博客中所有代码所对应的github repo地址：6.828 Overall 6.828自带了一个打分系统，在Lab文件夹下执行make grade即可运行这个系统来检验自己的解答。  Build up the environmentCompiler Toolchain由于Archlinux中的objdump和gcc均满足Lab的要求，不需要手动搭建编译环境">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://dracit7.github.io/blog/2019/02/24/MIT_6.828/memlayout.png">
<meta property="og:image" content="https://dracit7.github.io/blog/2019/02/24/MIT_6.828/descriptor.png">
<meta property="og:updated_time" content="2019-04-04T08:22:53.794Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MIT 6.828 Labs 实验记录">
<meta name="twitter:description" content="MIT 6.828 Labs 实验记录本博客中所有代码所对应的github repo地址：6.828 Overall 6.828自带了一个打分系统，在Lab文件夹下执行make grade即可运行这个系统来检验自己的解答。  Build up the environmentCompiler Toolchain由于Archlinux中的objdump和gcc均满足Lab的要求，不需要手动搭建编译环境">
<meta name="twitter:image" content="https://dracit7.github.io/blog/2019/02/24/MIT_6.828/memlayout.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://dracit7.github.io/blog/2019/02/24/MIT_6.828/">





  <title>MIT 6.828 Labs 实验记录 | Gensokyo</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Gensokyo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Youkai's Mountain</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/blog/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://dracit7.github.io/blog/blog/2019/02/24/MIT_6.828/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Drac Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/lyrica.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gensokyo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">MIT 6.828 Labs 实验记录</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-24T20:10:08+08:00">
                2019-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/" itemprop="url" rel="index">
                    <span itemprop="name">Academic or Technical</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Academic-or-Technical/Operating-System/" itemprop="url" rel="index">
                    <span itemprop="name">Operating System</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2019/02/24/MIT_6.828/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/02/24/MIT_6.828/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="MIT-6-828-Labs-实验记录"><a href="#MIT-6-828-Labs-实验记录" class="headerlink" title="MIT 6.828 Labs 实验记录"></a>MIT 6.828 Labs 实验记录</h2><p>本博客中所有代码所对应的github repo地址：<a href="https://github.com/dracit7/6.828" target="_blank" rel="noopener">6.828</a></p>
<h3 id="Overall"><a href="#Overall" class="headerlink" title="Overall"></a>Overall</h3><ul>
<li>6.828自带了一个打分系统，在Lab文件夹下执行<code>make grade</code>即可运行这个系统来检验自己的解答。</li>
</ul>
<h3 id="Build-up-the-environment"><a href="#Build-up-the-environment" class="headerlink" title="Build up the environment"></a>Build up the environment</h3><h4 id="Compiler-Toolchain"><a href="#Compiler-Toolchain" class="headerlink" title="Compiler Toolchain"></a>Compiler Toolchain</h4><p>由于Archlinux中的objdump和gcc均满足Lab的要求，不需要手动搭建编译环境。</p>
<h4 id="QEMU-emulator"><a href="#QEMU-emulator" class="headerlink" title="QEMU emulator"></a>QEMU emulator</h4><p>建议follow一下MIT官网上最新版的6.828课程页面。老的课程页面上的链接可能不可用。此处根据<a href="https://pdos.csail.mit.edu/6.828/2018/tools.html" target="_blank" rel="noopener">Fall 2018的课程页面</a>进行配置。</p>
<p>由于QEMU的调试系统不完善，课程组准备了改进过的QEMU，使它可以与系统中的GDB调试器绑定，并使用GDB来调试。执行以下步骤安装打好补丁的QEMU:</p>
<ol>
<li>执行<code>git clone https://github.com/mit-pdos/6.828-qemu.git qemu</code>拉取源代码</li>
<li>安装各种依赖。在Archlinux下的安装方式如下：<ul>
<li>libdtc：<code>yay DTC</code>，任选一项安装。</li>
<li>python：坑爹的是都8102年了这门课还不支持python3.不过Arch一般自带python2,问题不大</li>
</ul>
</li>
<li>进入源代码文件夹，Configure the source code<ul>
<li>执行<code>./configure --disable-kvm --disable-werror --python= &lt;pathToPython2&gt;</code></li>
</ul>
</li>
<li>执行<code>make &amp;&amp; make install</code>进行安装</li>
</ol>
<p>安装到一半，报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">qga/commands-posix.c: 在函数‘dev_major_minor’中:</span><br><span class="line">qga/commands-posix.c:634:21: 警告：implicit declaration of function ‘major’; did you mean ‘_m_por’? [-Wimplicit-function-declaration]</span><br><span class="line">         *devmajor = major(st.st_rdev);</span><br><span class="line">                     ^~~~~</span><br><span class="line">                     _m_por</span><br><span class="line">qga/commands-posix.c:634:21: 警告：对‘major’的嵌套的外部声明 [-Wnested-externs]</span><br><span class="line">qga/commands-posix.c:635:21: 警告：implicit declaration of function ‘minor’; did you mean ‘mknod’? [-Wimplicit-function-declaration]</span><br><span class="line">         *devminor = minor(st.st_rdev);</span><br><span class="line">                     ^~~~~</span><br><span class="line">                     mknod</span><br><span class="line">qga/commands-posix.c:635:21: 警告：对‘minor’的嵌套的外部声明 [-Wnested-externs]</span><br></pre></td></tr></table></figure>
<p>很显然是有两个函数major和minor在使用之前并未声明。这是两个库函数，在linux下的<code>&lt;sys/sysmacros.h&gt;</code>头文件中有定义，然而MIT给的代码里并没有包含这个头文件。根据报错信息打开<code>qga/commands-posix.c</code>，添加<code>#include &lt;sys/sysmacros.h&gt;</code>，保存。</p>
<p>再次安装，装到一半又报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: ../hw/9pfs/virtio-9p.o: in function `stat_to_v9stat&apos;:</span><br><span class="line">/home/drac_zhang/Downloads/qemu/hw/9pfs/virtio-9p.c:796: undefined reference to `minor&apos;</span><br><span class="line">/usr/bin/ld: /home/drac_zhang/Downloads/qemu/hw/9pfs/virtio-9p.c:796: undefined reference to `major&apos;</span><br><span class="line">/usr/bin/ld: ../hw/9pfs/virtio-9p.o: in function `v9fs_mknod&apos;:</span><br><span class="line">/home/drac_zhang/Downloads/qemu/hw/9pfs/virtio-9p.c:2803: undefined reference to `makedev&apos;</span><br><span class="line">/usr/bin/ld: ../hw/9pfs/virtio-9p.o: in function `v9fs_create&apos;:</span><br><span class="line">/home/drac_zhang/Downloads/qemu/hw/9pfs/virtio-9p.c:2124: undefined reference to `makedev&apos;</span><br><span class="line">collect2: 错误：ld 返回 1</span><br></pre></td></tr></table></figure>
<p>差不多的理由，还是缺少库函数。也不管重复包含dirty不dirty了，向<code>hw/9pfs/virtio-9p.c</code>中添加<code>#include &lt;sys/sysmacros.h&gt;</code>，保存后再次编译。</p>
<p>因为类似的理由，还需要添加这个头文件的源文件有<code>linux-user/strace.c</code>。</p>
<h4 id="Other-problems"><a href="#Other-problems" class="headerlink" title="Other problems"></a>Other problems</h4><p>这里是其他各种各样可能会出现的玄学错误。</p>
<h5 id="Dependencies-upgraded"><a href="#Dependencies-upgraded" class="headerlink" title="Dependencies upgraded"></a>Dependencies upgraded</h5><p>在我完成这个lab的过程中，<code>libnfs</code>库在我滚arch的时候升级了，结果一运行<code>make</code>就会报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error <span class="keyword">while</span> loading shared libraries: libnfs.so.12: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
<p>执行<code>whereis libnfs.so.12</code>，发现系统的库中只有<code>libnfs.so.13</code>，原来是这个库在升级的时候名字变掉了……</p>
<p>没办法，只好用<code>downgrade</code>命令手动降级到<code>4.0.0-2</code>版本，再执行<code>make</code>的时候就没事了。</p>
<h3 id="Lab-1-Booting-a-PC"><a href="#Lab-1-Booting-a-PC" class="headerlink" title="Lab 1 Booting a PC"></a>Lab 1 Booting a PC</h3><p>Lab1的源码可以从<code>https://pdos.csail.mit.edu/6.828/2018/jos.git</code>处clone到。</p>
<h4 id="Part-1-PC-bootstrap"><a href="#Part-1-PC-bootstrap" class="headerlink" title="Part 1 PC bootstrap"></a>Part 1 PC bootstrap</h4><p>这一部分的目的是让我们熟悉x86汇编语言和PC bootstrap过程，并熟悉QEMU和gdb的操作。</p>
<p>首先在lab目录下执行<code>make</code>命令来编译内核和启动器。编译完成的内核与启动器位于<code>obj/kern/kernel.img</code>镜像文件中，这个镜像文件是一个用于模拟真实硬盘的虚拟磁盘。</p>
<p>执行<code>make qemu</code>可以正式在qemu中运行编译好的操作系统，此时命令行终端会创建一个新的窗口，同时在终端中显示与窗口中同样的内容(并接受同样的输入)。方便起见，这里我们用终端进行接下来的操作。</p>
<p>一开始这个shell只有两条简单的指令：<code>help</code>和<code>kerninfo</code>。后者会打印出目前的内核状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Special kernel symbols:</span><br><span class="line">  _start                  0010000c (phys)</span><br><span class="line">  entry  f010000c (virt)  0010000c (phys)</span><br><span class="line">  etext  f01019df (virt)  001019df (phys)</span><br><span class="line">  edata  f0113060 (virt)  00113060 (phys)</span><br><span class="line">  end    f01136a0 (virt)  001136a0 (phys)</span><br><span class="line">Kernel executable memory footprint: 78KB</span><br></pre></td></tr></table></figure>
<p>要退出qemu可以打出<code>Ctrl+a x</code>。</p>
<h5 id="Layout-of-the-physical-address-space"><a href="#Layout-of-the-physical-address-space" class="headerlink" title="Layout of the physical address space"></a>Layout of the physical address space</h5><table>
<thead>
<tr>
<th>—————–</th>
<th>&lt;- 0xFFFFFFFF(4GB)</th>
</tr>
</thead>
<tbody>
<tr>
<td>内存映射的虚拟地址</td>
<td></td>
</tr>
<tr>
<td>—————–</td>
<td>&lt;- 取决于RAM的数量</td>
</tr>
<tr>
<td>扩展内存</td>
<td></td>
</tr>
<tr>
<td>—————–</td>
<td>&lt;- 0x00100000 (1MB)</td>
</tr>
<tr>
<td>BIOS所在的ROM</td>
<td></td>
</tr>
<tr>
<td>—————–</td>
<td>&lt;- 0x000F0000 (960KB)</td>
</tr>
<tr>
<td>16位机使用的扩展ROM</td>
<td></td>
</tr>
<tr>
<td>—————–</td>
<td>&lt;- 0x000C0000 (768KB)</td>
</tr>
<tr>
<td>VGA Display</td>
<td></td>
</tr>
<tr>
<td>—————–</td>
<td>&lt;- 0x000A0000 (640KB)</td>
</tr>
<tr>
<td>Low Memory</td>
<td></td>
</tr>
<tr>
<td>—————–</td>
<td>&lt;- 0x00000000</td>
</tr>
</tbody>
</table>
<p>对于一开始的16位机来说，它们只能使用一共最下面那1MB的物理存储，而可用的内存只有标识为Low Memory的640KB。VGA区是硬件保留区，用于当作视频播放缓冲区等。</p>
<p>就算是在Intel突破了“1MB的瓶颈”之后，PC设计师也仍然对于最低的1MB地址空间使用原始的架构，这是为了软件的向后兼容性。这样就在LowMemory和扩展内存之间留下了一个 <strong>空洞</strong> ，为那些16位的软硬件所使用。</p>
<p>在计算机从32位升级为64位时，BIOS在地址空间的最顶段因为类似的理由留下了第二个空洞。</p>
<h5 id="The-ROM-BIOS"><a href="#The-ROM-BIOS" class="headerlink" title="The ROM BIOS"></a>The ROM BIOS</h5><p>为了单步调试计算机的启动过程，我们需要两个终端，一个用<code>make qemu-gdb</code>来启动qemu虚拟机，一个用<code>make gdb</code>来将gdb调试环境连接到虚拟机上。</p>
<p><code>make qemu-gdb</code>会将处理器暂停在即将执行第一条指令之前并等待gdb的连接，这时在另一个终端中使用<code>make gdb</code>就可以通过gdb来调试操作系统内核。</p>
<p>gdb终端会显示一段结尾如下的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The target architecture is assumed to be i8086</span><br><span class="line">[f000:fff0]    0xffff0: ljmp   $0xf000,$0xe05b</span><br><span class="line">0x0000fff0 in ?? ()</span><br><span class="line">+ symbol-file obj/kern/kernel</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>其中的第二行代表着目前将要执行的指令，也就是虚拟机开启过程的第一条指令。</p>
<p>这条指令的含义是：</p>
<ul>
<li><code>0xffff0:</code>：指令位于的虚拟存储系统地址，对应于上面的架构，这个位置是属于BIOS的ROM区域的最上面，也就是BIOS程序的起始位置。</li>
<li><code>[f000:fff0]</code>：指示当前CS和IP寄存器的值。CS寄存器指示代码所在的数据段，IP则是偏移量。</li>
<li><code>ljmp</code>：跳转指令，跳转到CS和IP为<code>[f000:e05b]</code>的位置，转换成存储地址就是<code>0xfe05b</code>。<ul>
<li>CS和IP寄存器与物理地址的转换规则为<code>ADDR = CS&lt;&lt;4 + IP</code>。</li>
</ul>
</li>
</ul>
<p>保证启动时优先执行BIOS代码是很重要的，因为一开始内存中根本不会有其他可以执行的代码。BIOS会初始化所有启动所需要的重要设备，检查内存和磁盘的挂载情况。最后，就像操作系统课程中所学的那样，它找到磁盘上的boot loader并将控制权转移给它。</p>
<ul>
<li>对GDB使用<code>si</code>命令可以继续单步调试之后的汇编代码，观察BIOS所做的工作。</li>
</ul>
<h4 id="Part-2-The-boot-loader"><a href="#Part-2-The-boot-loader" class="headerlink" title="Part 2 The boot loader"></a>Part 2 The boot loader</h4><p>众所周知，软盘和硬盘都被分成大小为<code>512字节</code>的段，而这些段是系统级IO的最小单位。如果一个磁盘是启动盘，那么它的第一个段就被称为 <strong>boot sector</strong> ，并被存放boot loader的代码。当BIOS找到一个boot sector后，它就会将其加载到内存中，并将控制权转交给boot loader代码段。</p>
<p>(对于CD-ROM来说，它的前2M都属于boot sector，因此可以存放更大的启动镜像)</p>
<p>在6.828文件夹中，boot loader的代码存放于<code>boot/boot.S</code>与<code>boot/main.c</code>中。这些代码主要完成两件事：</p>
<ol>
<li>将处理器模式切换到<code>32位保护模式</code>，这样软件才可以访问大于1MB的物理地址空间。这个工作由<code>boot.S</code>完成。除此之外，<code>boot.S</code>还要建立一个程序栈，让C程序得以运行。</li>
<li>将内核代码从硬盘中加载到内存，并将控制转交给内核代码的入口函数。这个工作由<code>main.c</code>完成。</li>
</ol>
<p>阅读<code>main.c</code>的代码可以发现很多 <del>非常dirty的</del> 细节(<del>包括但不限于：使用goto，while(1)代替sleep，写的很乱的函数指针</del>)，如果对于这个过程的细节感兴趣可以直接阅读源码，注释写的很详细明白。</p>
<p>bootloader的代码会被BIOS加载到<code>0x7c00</code>，这是由<code>boot/Makefrag</code>文件所决定的。修改这个文件中<code>-Ttext</code>参数后面的地址可以让BIOS从其他地址来加载，执行<code>make clean &amp;&amp; make</code>重新编译可以查看这样做会引发什么样的系统错误(事实上系统会停机并进入一个无限循环等待用户的操作)；在GDB调试时可以在这个位置设置断点，以精确地进入bootloader代码段。</p>
<p><code>obj/boot/boot.asm</code>和<code>obj/kern/kernel.asm</code>分别包含着bootloader和kernel的反汇编结果以及注释，可以用于调试和分析。下面就来分析一下BootLoader的代码逻辑。</p>
<ul>
<li>BootLoader代码逻辑研究<ul>
<li>第一阶段：<strong>初始化</strong><ul>
<li><strong>宏常量的设定</strong>：<code>.set CR0_PE_ON 0x1</code> 这个常量是控制32位保护模式开关的指标。</li>
<li><strong>全局设置</strong>：<code>cli</code>指令关闭中断处理，<code>cld</code>指令将串操作的内存地址访问模式设为增序<ul>
<li>这两个指令其实是设置了<code>DF</code>和<code>IF</code>两个标志位的值</li>
</ul>
</li>
<li><strong>寄存器初始化</strong>：用xor和mov指令将几个关键寄存器清零<ul>
<li><code>ds</code>：数据段寄存器，存放全局变量区域的头指针</li>
<li><code>ss</code>：栈段寄存器，存放堆栈段的首地址(<code>esp</code>寄存器存储的是偏移量)</li>
<li><code>es</code>：扩展段寄存器</li>
</ul>
</li>
</ul>
</li>
<li>第二阶段：<strong>打开32位保护模式</strong><ul>
<li><strong>开启A20地址线</strong>：在16位模式下，用于寻址的地址总线只有20根，这种情况下大于1MB的地址空间是全部被置为0的。只有开启20～23号四条地址线，才能对1MB以上的地址空间进行寻址，从而进入32位模式。<ul>
<li>通过一个循环来等待A20设备准备完毕：用<code>in</code>指令从<code>0x64</code>端口接受信息，如果不是代表准备完毕的信息则继续循环。</li>
<li>向<code>0x64</code>和<code>0x60</code>端口发送信号，打开A20地址线。</li>
</ul>
</li>
<li><strong>建立32位段虚拟内存与物理存储器的映射关系表</strong>：<code>lgdt gdtdesc</code>指令。</li>
<li><strong>启动32位保护模式</strong>：用<code>CR0_PE_ON</code>与<code>cr0</code>寄存器的值做或运算，打开32位保护模式。<code>cr0</code>到<code>cr3</code>四个寄存器是系统控制寄存器，它们的值直接决定系统的运行状态。<code>cr0</code>控制的是处理器，因此可以通过修改其值来进入其他运行模式。</li>
<li><strong>跳转到32位代码区的下一条指令</strong>。</li>
</ul>
</li>
<li>第三阶段：修改段寄存器的值为32位区地址，初始化<code>esp</code>寄存器的值，建立C程序栈</li>
<li>第四阶段：进入<code>main.c</code>的bootmain函数，开始读取内核代码。</li>
<li>第五阶段：跳转到内核代码区，交还控制权。</li>
</ul>
</li>
</ul>
<blockquote>
<h5 id="习题解答"><a href="#习题解答" class="headerlink" title="习题解答"></a>习题解答</h5><p>Q: 处理器什么时候开始执行32位代码？哪条指令切换了处理器模式？</p>
<p>A：<code>0x7c2a:  mov    %eax,%cr0</code>指令切换了处理器模式，从随后的跳转指令开始，处理器开始执行32位代码。</p>
<p>Q：Bootloader执行的最后一条指令是什么？kernel执行的第一条指令又是什么?</p>
<p>A：Bootloader执行的最后一条指令是向内核代码段跳转的指令<code>0x7d71:      call   *0x10018</code>，kernel执行的第一条指令是<code>0x10000c:    movw   $0x1234,0x472</code>。</p>
<p>Q：Bootloader是如何决定它要读取多少数据的？它从哪里获取的kernel大小信息？</p>
<p>A：Bootloader首先从内核代码区读取了长度固定的ELF头部，再从头部中获取了这个区域是否为ELF文件、数据段数量、每段的长度、起始地址等信息。</p>
</blockquote>
<p>(课程网页在这一部分讲了一大堆ELF头和指针的知识，如果已经学过CSAPP第7章的话完全可以跳过。需要注意的是，6.828所采用的可执行目标文件代码 <strong>并非是位置无关代码</strong> ，因而 <strong>链接器会将程序将加载到的内存位置写在文件中</strong> 。利用这一点，我们可以执行<code>objdump -f &lt;filename&gt;</code>命令，获取程序在内存中的入口位置。)</p>
<h4 id="Part-3-The-kernel"><a href="#Part-3-The-kernel" class="headerlink" title="Part 3 The kernel"></a>Part 3 The kernel</h4><p>在内核被授予控制权后，它要做如下几件事：</p>
<h5 id="Virtual-memory-address-mapping"><a href="#Virtual-memory-address-mapping" class="headerlink" title="Virtual memory address mapping"></a>Virtual memory address mapping</h5><p>当我们观察bootloader程序的时候，我们可以发现它的 <strong>链接地址</strong>(指用<code>objdump -h</code>打印出来的ELF节头部信息中的<code>LMA</code>，linked memory address) 和 <strong>虚拟地址</strong>(指用<code>objdump -h</code>打印出来的ELF节头部信息中的<code>VMA</code>，virtual memory address) 是完全一致的；然而对于kernel，这两个地址却有着不小的差距。</p>
<p>操作系统内核常常会在非常高的虚拟地址空间(例如0xf0100000)运行，这是为了把比较低的虚拟地址空间留给用户进程使用。然而大部分机器没有这么多的内存，于是它们将虚拟地址0xf0100000映射到物理地址0x00100000。这样一来虽然内核所在的加载地址很高，它的实际加载地址却是位于RAM区域的最底端，挨着BIOS所在的ROM地址区域。</p>
<p>虚拟地址映射操作是由专门的硬件来完成的，要打开虚拟地址映射只需要对<code>cr0</code>寄存器设置<code>CR0_PG</code>标志，就像之前打开32位保护模式所做的那样。除此之外，为了能让虚拟地址映射正常工作，我们需要将页表的首地址装入<code>cr3</code>寄存器。</p>
<p>kernel被加载的地址为0x100000,因此它从此处开始运行。它所做的第一项工作就是打开虚拟地址映射，然后跳转到虚拟地址<code>0xf010002f</code>的位置，恰好对应于物理地址中下一条指令所在的位置。这样，内核就自然地实现了从物理地址到虚拟地址的转换。</p>
<h5 id="Formatted-printing-to-the-console"><a href="#Formatted-printing-to-the-console" class="headerlink" title="Formatted printing to the console"></a>Formatted printing to the console</h5><p>在完成虚拟地址映射之后，下一步是对终端进行格式化输入输出以创建交互式操作界面。</p>
<p><code>lib/printfmt.c</code>中提供了输出函数的原型，<code>kern/printf.c</code>和<code>kern/console.c</code>则提供了有关内核输出和交互的函数。</p>
<blockquote>
<p><strong>Answer to Exercise 8</strong></p>
<p>本题要求补全printfmt函数对于<code>%o</code>(8进制输出)的处理机制，只需要仿照下面十六进制的机制即可。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">  num = getuint(&amp;ap, lflag);</span><br><span class="line">  base = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">goto</span> number;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>习题解答</strong></p>
<p>Q：解释printf.c和console.c之间的接口，尤其是console.c中的哪个函数被如何用于printf.c。</p>
<p>A：console.c向printf.c提供了cputchar函数,它希望在调用printf.c中的输出函数时可以利用cputchar函数来输出每一个字符。printf.c遵守这个约定,以包含cputchar的外壳函数调用printfmt.c中的输出函数,保证了所有输出都按照console.c所规定的标准来输出。</p>
<p>Q：解释console.c中的这一段代码:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">  <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">    crt_buf[i] = <span class="number">0x0700</span> | <span class="string">' '</span>;</span><br><span class="line">    crt_pos -= CRT_COLS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>A：</p>
<p>这段代码来自cga_putc函数,这个函数是在CGA显示屏图形卡上打印字符的函数。crt_pos是一个整形全局变量,它的含义是目前光标在屏幕上的位置。阅读<code>console.h</code>的内容可以发现CRT_SIZE被定义为屏幕上能够容纳的字符个数,而CRT_COLS则是屏幕的宽度。</p>
<p>条件判断是为了确认当前光标的位置是否已经超出了屏幕底端。如果超出了，就把屏幕上第二行到最后一行的内容全部上移一行，并将空出来的位置用<code>0x0700 | &#39; &#39;</code>填满。</p>
<p>总而言之，这段代码是为了实现屏幕满了之后向上滚动的功能。</p>
<p>Q：单步调试如下代码：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</span><br><span class="line">cprintf(<span class="string">"x %d, y %x, z %d\n"</span>, x, y, z);</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>在对cprintf的调用中，fmt对应的实参是什么？ap呢？</li>
<li>列出对<code>cons_putc</code>, <code>va_arg</code>和<code>vcprintf</code>的每一次调用，以及<code>cons_putc</code>的参数,<code>va_arg</code>中ap的指向和<code>vcprintf</code>的参数值。</li>
</ol>
<p>A：</p>
<ol>
<li>fmt对应的实参是<code>&quot;x %d, y %x, z %d\n&quot;</code>，ap指向带有x，y和z的参数数组。</li>
<li>甚至不需要单步调试，自己阅读<code>lib/printfmt.c</code>就足够了。</li>
</ol>
<p>Q：运行如下代码：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line">cprintf(<span class="string">"H%x Wo%s"</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释输出结果。如果这段代码运行在大端序机器上而非小端序机器上，你会如何修改它来得到同样的结果？</p>
<p>A：输出结果是<code>He110 World</code>。前面的e110是57616在十六进制下的表示(因为使用了<code>%x</code>)，后面的rld是字符串输出的结果。int占4个字节而每个字符占一个字节，因而i所占的内存空间与一个长度为4的字符数组是相同的。这样一来，如果用i的地址去输出字符串，就会从i的地址开始按字符去读取内存中的数据，直到读到0为止。由于运行在小端序机器，0x72排在最前面一个字节，被解析成ASCII码值为0x72的<code>r</code>；接下来0x6c和0x64分别被解释为<code>l</code>和<code>d</code>。最后一个字节是0x00,正好是字符串终结符。</p>
<p>如果机器是大端序，只需要将i修改为<code>0x726c6400</code>即可，57616不需要改变。</p>
<p>Q：被<code>cprintf(&quot;x=%d y=%d&quot;, 3);</code>打印出的y值会是多少？为什么？</p>
<p>A：会是一个随机的整形数。因为cprintf解析到了两个<code>%d</code>符号，但<code>ap</code>的长度只有1,这导致第二个<code>%d</code>读到了一片未赋值的内存地址，其值自然是随机的。</p>
</blockquote>
<h5 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h5><p>(仔细读过CSAPP第三章的话汇编语言和程序栈这一块应该没问题了，就不说了)</p>
<blockquote>
<p><strong>Answer to Exercise 9</strong></p>
<p>Q：确定内核在什么时候初始化程序栈及程序栈的初始位置。内核是如何为栈保存空间的？</p>
<p>A：<code>f010034: mov $0xf0110000, %esp</code>：这一条指令初始化了栈指针，将程序栈建立于虚拟地址<code>0xf0110000</code>位置。从这个地址开始，程序栈随着程序运行向下增长。</p>
</blockquote>
<p><code>ebp</code>指针被称为“基指针”，它的作用是追踪每个函数的栈帧位置。每个被调用的C函数都要进行如下操作：将ebp寄存器的值压栈、将当前esp指针值拷贝到ebp寄存器。在返回之前，这个函数从栈中取出并恢复ebp寄存器的值。通过这种机制，<strong>任何时候ebp寄存器的值都指向正在执行的函数的栈帧头部，而栈帧头部的前一个数据节的值指向该函数调用者的栈帧头部</strong>，于是可以通过ebp链来还原函数调用链。</p>
<blockquote>
<p><strong>Answer to Exercise 10</strong></p>
<p>这个Exercise的目的是让学生熟悉backtrace的操作和C的程序栈结构。在kernel中有一个自我递归的<code>test_backtrace</code>函数,通过对这个函数打上断点可以使用<code>p $ebp</code>获取每次调用的栈帧起始位置.</p>
<p>第一次调用:栈帧的起始位置为<code>0xf010ffd8</code><br>第二次调用:栈帧的起始位置为<code>0xf010ffb8</code></p>
<p>可以看出这个函数的每个栈帧大小都是<code>0x20</code>,也就是32个字节，对于32位系统来说是八个数据。</p>
<p>使用<code>x/xw</code>命令查看从<code>0xf010ffe0</code>开始整个栈帧的结构。(因为32位系统每个数据是四个字节，所以使用<code>x/xw</code>来查看)</p>
<p><code>x/xw 0xf010ffe0</code>：<code>0x00000005</code> 按照栈帧的结构，这个位置应该是调用者压入栈内的参数。第一次对<code>test_backtrace</code>的调用的确只有一个实参5。</p>
<p><code>x/xw 0xf010ffdc</code>：<code>0xf01000f4</code> 由于栈帧是向下的，这条指令其实查看的是上一个栈帧的最后一部分，也就是函数的返回地址，经验证的确指向调用者的下一条指令。</p>
<p><code>x/xw 0xf010ffd8</code>：<code>0xf010fff8</code> 当前函数栈帧的第一部分，保存着上一个函数的基指针值(<code>%ebp</code>的值)，由于上一个函数已经是整个程序栈底部的函数了，这个地址向上就没有数据了，上个函数的基指针指向的是物理内存区的函数。</p>
<p><code>x/xw 0xf010ffd4</code>：<code>0x000100b4</code> 被调用者保存的<code>%esi</code>寄存器的值 </p>
<p><code>x/xw 0xf010ffd0</code>：<code>0xf011304c</code> 被调用者保存的<code>%ebx</code>寄存器的值</p>
<p><code>x/xw 0xf010ffcc</code>：<code>0xf010004a</code> 是<code>test_backtrace</code>中一行代码的地址</p>
<p><code>x/xw 0xf010ffc8</code>：<code>0x00000000</code> 空的，没有数据</p>
<p><code>x/xw 0xf010ffc4</code>：<code>0x00000005</code> 局部变量5</p>
<p><code>x/xw 0xf010ffc0</code>：<code>0x00000004</code> 即将进行下一次递归调用，这是压入的参数4</p>
<p>再往下就是返回地址，然后就是下一个栈帧。总的来说，<code>test_backtrace</code>函数的栈帧结构就是这样。</p>
</blockquote>
<p>完成了对栈帧结构的观察后，就可以利用观察结果去做一下任务了。Exercise 11要求我们实现一个<code>mon_backtrace</code>函数，它记录并打印出栈帧信息。<code>inc/x86.h</code>中提供了<code>read_ebp()</code>函数可以直接返回ebp寄存器的值。</p>
<p>输出格式规定如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack backtrace:</span><br><span class="line">  ebp f0109e58  eip f0100a62  args 00000001 f0109e80 f0109e98 f0100ed2 00000031</span><br><span class="line">  ebp f0109ed8  eip f01000d6  args 00000000 00000000 f0100058 f0109f28 00000061</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Answer to Exercise 11</strong></p>
<p>本题要求是按上面的要求修改<code>kern/monitor.c</code>中的<code>mon_backtrace</code>函数，并将其添加到指令集中。</p>
<p>对代码的修改如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一处修改</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Command</span> <span class="title">commands</span>[] = &#123;</span></span><br><span class="line">        &#123; <span class="string">"help"</span>, <span class="string">"Display this list of commands"</span>, mon_help &#125;,</span><br><span class="line">        &#123; <span class="string">"kerninfo"</span>, <span class="string">"Display information about the kernel"</span>, mon_kerninfo &#125;,</span><br><span class="line">        &#123; <span class="string">"backtrace"</span>, <span class="string">"Display the structure of the stack"</span>, mon_backtrace &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第二处修改</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Your code here.</span></span><br><span class="line">        cprintf(<span class="string">"Stack backtrace:\n"</span>);</span><br><span class="line">        <span class="keyword">int</span> ebp = read_ebp();</span><br><span class="line">        <span class="keyword">int</span> eip = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">int</span> args[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                args[i] = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>*i + <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,ebp,eip,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],args[<span class="number">3</span>],args[<span class="number">4</span>]);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                ebp = *(<span class="keyword">int</span> *)ebp;</span><br><span class="line">                <span class="keyword">if</span> (!ebp) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> eip = *(<span class="keyword">int</span> *)(ebp+<span class="number">4</span>);</span><br><span class="line">                <span class="keyword">int</span> args[<span class="number">5</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                        args[i] = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>*i + <span class="number">8</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,ebp,eip,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],args[<span class="number">3</span>],args[<span class="number">4</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Exercise 12要求我们升级这个函数，使其支持如下的输出格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stack backtrace:</span><br><span class="line">  ebp f010ff78  eip f01008ae  args 00000001 f010ff8c 00000000 f0110580 00000000</span><br><span class="line">         kern/monitor.c:143: monitor+106</span><br><span class="line">  ebp f010ffd8  eip f0100193  args 00000000 00001aac 00000660 00000000 00000000</span><br><span class="line">         kern/init.c:49: i386_init+59</span><br><span class="line">  ebp f010fff8  eip f010003d  args 00000000 00000000 0000ffff 10cf9a00 0000ffff</span><br><span class="line">         kern/entry.S:70: &lt;unknown&gt;+0</span><br></pre></td></tr></table></figure>
<p>为了根据eip找到函数名，行数和文件名等一系列信息，<code>kern/kdebug.c</code>中提供了<code>debuginfo_eip()</code>函数，我们需要完整地实现<code>debuginfo_eip()</code>函数，并在<code>mon_backtrace</code>中调用这个函数来获得信息。</p>
<blockquote>
<p><strong>Answer to Exercise 12</strong></p>
<p>在<code>debuginfo_eip</code>函数中有一些以<code>__STAB_</code>开头的宏常量,它们所代表的是ELF文件中<code>.stab</code>(在CSAPP中是<code>.symtab</code>)区的开头和结尾位置,以及<code>.stabstr</code>(在CSAPP中是<code>.strtab</code>)区的开头和结尾位置,它们是在链接过程中由<code>kernel.ld</code>定义的。</p>
<p>以下是修改内容：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kern/monitor.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Your code here.</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">        cprintf(<span class="string">"Stack backtrace:\n"</span>);</span><br><span class="line">        <span class="comment">// Parse the structure of the stack</span></span><br><span class="line">        <span class="keyword">int</span> ebp = read_ebp();</span><br><span class="line">        <span class="keyword">int</span> eip = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">int</span> args[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                args[i] = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>*i + <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Print some information in restricted format.</span></span><br><span class="line">        cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,ebp,eip,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],args[<span class="number">3</span>],args[<span class="number">4</span>]);</span><br><span class="line">        <span class="comment">// Exercise 12, get the debuginfo by eip</span></span><br><span class="line">        debuginfo_eip(eip, &amp;info);</span><br><span class="line">        cprintf(<span class="string">"         %s:%d: "</span>,info.eip_file, info.eip_line);</span><br><span class="line">        <span class="comment">// info.eip_fn_name is a non-null-terminated string</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;info.eip_fn_namelen;i++) cprintf(<span class="string">"%c"</span>,*(info.eip_fn_name+i));</span><br><span class="line">        cprintf(<span class="string">"+%d\n"</span>,eip - info.eip_fn_addr);</span><br><span class="line">        <span class="comment">// Backtracing</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                ebp = *(<span class="keyword">int</span> *)ebp;</span><br><span class="line">                <span class="keyword">if</span> (!ebp) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">int</span> eip = *(<span class="keyword">int</span> *)(ebp+<span class="number">4</span>);</span><br><span class="line">                <span class="keyword">int</span> args[<span class="number">5</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                        args[i] = *(<span class="keyword">int</span> *)(ebp + <span class="number">4</span>*i + <span class="number">8</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,ebp,eip,args[<span class="number">0</span>],args[<span class="number">1</span>],args[<span class="number">2</span>],args[<span class="number">3</span>],args[<span class="number">4</span>]);</span><br><span class="line">                debuginfo_eip(eip, &amp;info);</span><br><span class="line">                cprintf(<span class="string">"         %s:%d: "</span>,info.eip_file, info.eip_line);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;info.eip_fn_namelen;i++) cprintf(<span class="string">"%c"</span>,*(info.eip_fn_name+i));</span><br><span class="line">                cprintf(<span class="string">"+%d\n"</span>,eip - info.eip_fn_addr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kern/kdebug.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">debuginfo_eip(<span class="keyword">uintptr_t</span> addr, struct Eipdebuginfo *info)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line">    stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</span><br><span class="line">    <span class="keyword">if</span> (lline &lt;= rline) info-&gt;eip_line = stabs[lline].n_desc;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此Lab1结束。运行<code>make grade</code>，<code>50/50</code>大成功。</p>
<h3 id="Lab2-Memory-Management"><a href="#Lab2-Memory-Management" class="headerlink" title="Lab2 Memory Management"></a>Lab2 Memory Management</h3><p>在这个Lab中，我们需要实现操作系统的内存管理系统。内存管理系统包括两个部分：</p>
<ul>
<li>物理内存调度：我们要实现一个以4096个字节大小的页为单位的内存分配器，它将空闲的内存分配给内核和用户，并释放使用完的内存。</li>
<li>虚拟内存映射</li>
</ul>
<p>执行<code>git checkout -b lab2 origin/lab2</code>命令切换到lab2分支，执行<code>git merge lab1</code>合并在lab1所做的更改。</p>
<p>Lab2增加的文件有：</p>
<ul>
<li><code>inc/memlayout.h</code>：定义描述虚拟内存空间的布局的函数，定义PageInfo结构体</li>
<li><code>kern/pmap.c</code>和<code>kern/pmap.h</code>：实现<code>inc/memlayout.h</code>中定义的函数</li>
<li><code>kern/kclock.c</code>和<code>kern/kclock.h</code>：与CMOS硬件沟通，读取PC的硬件信息</li>
</ul>
<p><code>inc/mmu.h</code>中记录了应当烧录于MMU<br>单元中的逻辑代码，同样可能对这个lab有所帮助。</p>
<h4 id="Background-knowledge"><a href="#Background-knowledge" class="headerlink" title="Background knowledge"></a>Background knowledge</h4><p>由于虚拟内存是将很小的物理内存映射到很大的虚拟内存空间，这个映射关系需要一个输入地址和一个输出地址才能作用。<strong>物理地址</strong>是物理内存中真实的地址，可以直接由硬件寻址得到；<strong>虚拟地址/线性地址</strong>是物理地址通过转换得到的，用于虚拟内存空间索引的地址。</p>
<p><code>mmu.h</code>中详细地介绍了线性地址的结构。大体上讲，线性地址分为三段：</p>
<ul>
<li><code>Page directory index</code>：页目录的序号(10位)</li>
<li><code>Page table index</code>：页表的序号(10位)</li>
<li><code>Page offset</code>：地址在页内的偏移(12位)</li>
</ul>
<p>从线性地址的三段式结构可以看出，每个页表包括<code>1024</code>(2的10次方)个页，每个页目录包括<code>1024</code>个页表，而每一页的大小是<code>4096</code>个字节(也就是<code>4KB</code>)。</p>
<p>3段加起来的总长度是<code>32 bits</code>，也就是<code>4个字节</code>，这代表着线性地址可以用一个<code>int32</code>变量表示。</p>
<p>我们可以使用宏命令来取出线性地址的各个段，或将线性地址映射为物理地址。在本lab中，虚拟地址似乎是特指<code>物理地址+固定偏置值</code>所映射到的地址。</p>
<p>在<code>memlayout.h</code>中可以查看到整个虚拟内存地址空间的分配，在此列出并加以解释：</p>
<p><img src="memlayout.png" alt="memlayout"></p>
<ul>
<li><code>0xf0000000</code>以上：<code>Remapped physical memory</code>，物理内存的原样映射，这一部分为虚拟地址</li>
<li><code>0xefc00000</code>以上：内核栈区域，存放各个CPU的内核栈。<ul>
<li><code>0xef800000</code>：内核内存区和用户内存区的分界线，这以上用户不可读写</li>
</ul>
</li>
<li><code>0xef400000</code>以上：页表区域</li>
<li><code>0xef000000</code>以上：页区域</li>
<li><code>0xeec00000</code>以上：当前进程的环境变量区域<ul>
<li><code>0xeec00000</code>：用户只读区和读写区的分界线，这以上用户只有读权限</li>
</ul>
</li>
<li><code>1 PGSIZE</code>：用户的异常栈</li>
<li><code>1 PGSIZE</code>：用户栈，可以增长</li>
<li><code>一段留空内存</code></li>
<li><code>0x00800000</code>以上：用户的堆区域和程序数据</li>
<li>以下：用户的符号表区域和空内存</li>
</ul>
<h4 id="Definitions-guide"><a href="#Definitions-guide" class="headerlink" title="Definitions guide"></a>Definitions guide</h4><p>6.828的代码充满了缩写这种使人不明所以的命名,且有些地方码风诡异,因而将一些可能用到的概念和缩写列举如下:</p>
<ol>
<li><code>V</code>和<code>P</code>:带V的标识符指<code>virtual</code>,与内核虚拟内存有关；而带P的标识符往往指<code>physical</code>,与物理存储有关。如：<ul>
<li><code>kva</code>:<code>kernel virtual address</code>的简写</li>
<li><code>pa</code>:<code>physical address</code>的简写</li>
<li><code>la</code>:<code>linear address</code>的简写</li>
</ul>
</li>
<li><code>PT</code>和<code>PD</code>：分别指<code>page table</code>和<code>page directory</code>。</li>
<li><code>U</code>和<code>K</code>:带U的标识符指<code>User</code>，而带K的标识符指<code>Kernel</code>。如：<ul>
<li><code>UVPT</code>：<code>User virtual page table</code>的缩写，是用户页表的开始地址。</li>
<li><code>UTOP</code>：用户地址空间的上限</li>
</ul>
</li>
</ol>
<p>为了实现目标功能的代码，我们需要调用许多定义好的函数或者宏，为了方便查看和使用将一些可能需要使用的函数和宏列举如下：</p>
<ul>
<li><code>pmap.h</code>:<ul>
<li><code>PADDR(addr)</code>:将虚拟地址addr转换为物理地址返回</li>
<li><code>KADDR(addr)</code>:将物理地址addr转换为虚拟地址返回</li>
<li><code>PTE_ADDR(addr)</code>:将物理地址addr中的权限位去掉</li>
<li><code>page2pa(PageInfo*)</code>:将PageInfo结构体转换为对应Page的物理地址</li>
<li><code>pa2page(addr)</code>:将物理地址转换为pages数组中的PageInfo</li>
<li><code>page2kva(PageInfo*)</code>:将PageInfo结构体转换为对应Page的虚拟地址</li>
</ul>
</li>
<li><code>mmu.h</code>:<ul>
<li><code>PDX(la)</code>:将线性地址转换为页目录(page directory)的索引</li>
</ul>
</li>
</ul>
<h4 id="Part-1-Physical-page-management"><a href="#Part-1-Physical-page-management" class="headerlink" title="Part 1 Physical page management"></a>Part 1 Physical page management</h4><p>在这个部分我们需要实现物理内存管理器。这个函数追踪一个由<code>PageInfo</code>结构体组成的链表(这个链表的节点代表着一页未分配的内存)，并负责物理内存的分配和回收。</p>
<p>要想完成这部分的任务，必须要提前了解虚拟内存系统的概念(可以参考操作系统专业教材或者计算机系统教材)，才能看懂并运用各种神奇的操作。</p>
<blockquote>
<p><strong>boot_alloc</strong></p>
</blockquote>
<p>这个函数是在建立虚拟内存系统过程中用来为数据结构分配内存空间的，在虚拟内存系统建立之后就会废弃。因而，其功能比较简单。</p>
<p>值得注意的是，这个函数首次调用的时候，会从内核区bss段的结束处开始分配内存块，具体的位置是通过<code>extern</code>从链接器那里得知的。首次调用情况下的代码已经被完成了，我们只需要照葫芦画瓢地完成之后调用时的代码即可。</p>
<p>这里所谓“内核区bss段的结束处”是指内核区中没有分配代码段和数据段的第一个位置，它在虚拟地址空间中的位置在<code>0xf0000000</code>以上的部分，也就是物理内存的映射区。从这里开始，我们开始建立用于管理虚拟内存的内核数据结构。</p>
<ul>
<li><em>panic函数可以被当作printf的一个能够引发中断的版本。灵活利用它可以方便地调试系统。</em></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!n) <span class="keyword">return</span> nextfree;</span><br><span class="line">result = nextfree;</span><br><span class="line">nextfree = ROUNDUP((<span class="keyword">char</span> *) (nextfree+n), PGSIZE);</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>mem_init</strong></p>
</blockquote>
<p>这个函数首先用之前实现好的<code>boot_alloc</code>函数分配了 <strong>一页</strong> 空闲内存，初始化之，并用一个<code>kern_pgdir</code>指针指向了这片内存的起始位置。这一片区域用来存放<code>page directory</code>。</p>
<p>接下来是我们的工作：为一个页数组<code>pages</code>分配内存。</p>
<p><code>pages</code>数组存储了每个分页的信息，其索引和页的物理地址可以用函数相互转换。可以说，<code>pages</code>的每一个元素都唯一对应着一个物理页面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pages = (struct PageInfo *) boot_alloc(<span class="keyword">sizeof</span>(struct PageInfo) * npages);</span><br><span class="line"><span class="built_in">memset</span>(pages, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct PageInfo) * npages);</span><br></pre></td></tr></table></figure>
<p>这样我们就已经为内存分配相关的内核数据结构分配好了空间。接下来，<code>mem_init</code>函数调用<code>page_init</code>函数，去初始化所有物理内存分页。这个步骤结束之后，所有内存相关操作都可以通过<code>page</code>开头的函数来完成。</p>
<blockquote>
<p><strong>page_init</strong></p>
</blockquote>
<p>Lab中已经给出了示例代码，但是这段代码是不严谨的(它将所有物理内存页都标记为是free的)，有几处问题没有考虑到：</p>
<ul>
<li><strong>物理页面0应该标记为used</strong>。这是因为这一部分保存着BIOS数据结构和IDT(中断描述符表)，我们以后可能会用到这些结构。</li>
<li>之前讲到过的由于考虑到向后兼容性而留下的<code>IO hole</code>不应该被分配。</li>
<li>在<code>IO hole</code>之后就是extended memory部分，这一部分中的有些位置存放了内核代码和内核数据结构，因而这些位置不能标记为free。</li>
</ul>
<p>我们的任务是修改代码，使其只将那些该标记为free的放进<code>page_free_list</code>。</p>
<p>考察<code>memlayout.h</code>中的<code>PageInfo</code>结构体，可以发现其属性<code>pp_ref</code>用于指示引用这一页的进程数量,而<code>pp_link</code>指向空闲链表中下一项的地址。对于要放入<code>page_free_list</code>的pages，我们将其<code>pp_ref</code>设定为0，并利用<code>pp_link</code>将其插入空闲链表。</p>
<p><strong>本任务的难点在于如何确定Extended Memory中的哪一部分已经被Kernel所占用</strong>。观察之前的代码可以发现，<code>boot_alloc</code>是从kernel代码和数据段的结束位置开始分配内存的，而kernel代码段的起始位置是<code>IO hole</code>的结束位置(<code>0x100000</code>,参考Lab 1)，这意味着从<code>IO hole</code>到<code>boot_alloc</code>分配的最后一块内存末尾之间的所有内存都是被占用的。</p>
<p>而根据之前的两个函数，<code>boot_alloc</code>分配的最后一块内存应该就是页表的最后一块内存(也就是<code>pages</code>数组的末尾)，因此我们从<code>pages</code>的头地址开始向后应该就可以找到kernel占用内存区的末尾位置。</p>
<p>根据这些信息，可以修改代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="comment">// 1) First page, ignore it</span></span><br><span class="line">    <span class="comment">// 2) Base memory</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; npages_basemem; i++) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">        pages[i].pp_link = page_free_list;</span><br><span class="line">        page_free_list = &amp;pages[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3) IO hole</span></span><br><span class="line">    <span class="comment">// Mention that npages_basemem = IOPHYSMEM / PGSIZE</span></span><br><span class="line">    <span class="comment">// IOPHYSMEM and EXTPHYSMEM is represented by B instead of KB, so div it by PGSIZE.</span></span><br><span class="line">    <span class="comment">// (Here is no operation, because we do not need to deal with occupied pages.)</span></span><br><span class="line">    ;</span><br><span class="line">    <span class="comment">// 4) Extended memory</span></span><br><span class="line">    <span class="comment">// The question is where is the end of kernel segment.</span></span><br><span class="line">    <span class="keyword">char</span>* end_addr = (<span class="keyword">char</span> *)pages + <span class="keyword">sizeof</span>(struct PageInfo) * npages - KERNBASE;</span><br><span class="line">    <span class="keyword">int</span> end_index = (<span class="keyword">int</span>)(ROUNDUP(end_addr, PGSIZE)) / PGSIZE;</span><br><span class="line">    <span class="keyword">for</span> (i = end_index; i &lt; npages; i++) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">        pages[i].pp_link = page_free_list;</span><br><span class="line">        page_free_list = &amp;pages[i];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>page_alloc</strong></p>
</blockquote>
<p>这个函数就是很简单的链表操作，仔细阅读注释的内容即可正确实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns NULL if out of free memory</span></span><br><span class="line">    <span class="keyword">if</span> (page_free_list == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// Get a free page from page_free_list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">free_page</span> = <span class="title">page_free_list</span>;</span></span><br><span class="line">    page_free_list = free_page-&gt;pp_link;</span><br><span class="line">    <span class="comment">// Init the free page</span></span><br><span class="line">    free_page-&gt;pp_link = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (alloc_flags &amp; ALLOC_ZERO)</span><br><span class="line">        <span class="built_in">memset</span>(page2kva(free_page), <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="comment">// Return the free page to caller</span></span><br><span class="line">    <span class="keyword">return</span> free_page;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>page_free</strong></p>
</blockquote>
<p>同样没有什么难度，直接贴出代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pp-&gt;pp_ref) panic(<span class="string">"This page is still occupied by other processes."</span>);</span><br><span class="line"><span class="keyword">if</span> (pp-&gt;pp_link) panic(<span class="string">"You can't free a freed page."</span>);</span><br><span class="line">pp-&gt;pp_link = page_free_list;</span><br><span class="line">page_free_list = pp;</span><br></pre></td></tr></table></figure>
<h4 id="Part-2-Virtual-Memory"><a href="#Part-2-Virtual-Memory" class="headerlink" title="Part 2 Virtual Memory"></a>Part 2 Virtual Memory</h4><p>在开始这一部分之前，先要对几个地址之间的转换有一个大概的了解。</p>
<h5 id="Segments"><a href="#Segments" class="headerlink" title="Segments"></a>Segments</h5><p>在保护模式下，有关段的信息是非常复杂的。对于一个段来说，除了段基地址之外，还有段的大小，特权级，类型，是否被执行过，读写权限等等多种信息要保存。用于描述这些信息的数据项称为 <strong>描述符(Descirptor)</strong> 。</p>
<p>描述符一般用<code>4个字</code>来表述所有信息，具体的描述符结构如下图所示：</p>
<p><img src="descriptor.png" alt="descriptor"></p>
<p>其中各个部分的作用：</p>
<ul>
<li>第一个字：<strong>段的界限</strong>，也就是这个段的长度。需要注意的是一个段的长度是用20位来表示的，因此这个字表示的段界限是不完整的，需要和描述符中另一段数据拼接起来才是完整的段界限。</li>
<li>第二个字：<strong>段的基址</strong>，段在虚拟地址空间内的起始位置。由于虚拟空间地址是32位的，这个字同样无法表示完整的段基址，需要与另外两段数据进行拼接。</li>
<li>第三个字：<ul>
<li>高字节分为如下几个字段：<ul>
<li><code>P</code>：<strong>存在位</strong>，表示该描述符对应的段是否已经读入内存。</li>
<li><code>DPL</code>：长度为两位，表示该段所属的特权级</li>
<li><code>1</code>或<code>0</code>：记录段的类型是存储段还是系统段</li>
<li><code>TYPE</code>：记录段的属性<ul>
<li>如果是存储段，那么是代码段还是数据段</li>
<li>段的读写权限如何</li>
</ul>
</li>
<li><code>A</code>：访问位，记录段是否被访问过</li>
</ul>
</li>
<li>低字节为段基址的16-23位。</li>
</ul>
</li>
<li>第四个字：<ul>
<li>高字节为段基址的24-31位。</li>
<li>低字节分为如下几个字段：<ul>
<li><code>G</code>：<strong>粒度位</strong>，G=0说明段长度的单位是<code>Byte</code>，而G=1说明单位是<code>page</code>。</li>
<li><code>X</code>：用于区分32位和16位访问方式。</li>
<li><code>O</code>和<code>AVL</code>：保留位和系统专用位</li>
<li><code>LIMIT</code>：段界限的16-19位</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>所有的描述符都储存在 <strong>描述符表</strong> 中。描述符表分为以下三类：</p>
<ul>
<li><code>LDT</code>：局部描述符表。每个进程都有它自己的局部描述符表，存放在一个特定的系统段内。LDT中存放着对应进程的代码和数据段位置等信息。</li>
<li><code>GDT</code>：全局描述符表。只有一个，存放着操作系统内核使用的描述符和所有系统段的描述符。通过GDT可以去索引所有的LDT。</li>
<li><code>IDT</code>：中断描述符表。用于定位所有的中断处理程序。</li>
</ul>
<p>在这个Lab中，我们暂时不涉及内存的分段机制，因而GDT中每个描述符的base为0而limit为0xffffffff。在kernel代码段中我们已经建立了一个简单的页表(能够映射4MB大小的内存),现在我们需要做的是拓展这个页表以映射整个虚拟内存。</p>
<h5 id="Pages"><a href="#Pages" class="headerlink" title="Pages"></a>Pages</h5><p>在Background knowledge里面我们已经讲了线性地址的构成，现在为了能够完成下面的实验，需要进一步了解一些关于页目录和页表的知识。</p>
<p>在MMU取到一个线性地址la时，它会首先取出la中的 <strong>页目录索引部分</strong> ，并用其与<code>cr3</code>中存放的页目录首地址结合去找到la所在的 <strong>页表首地址</strong> 。在此之后，MMU取出la中的 <strong>页表索引部分</strong> ，与之前找到的页表首地址结合来找到la所对应的具体 <strong>页表项</strong> 。</p>
<p>在这个过程中，la所在的页目录表项被称为 <strong>DIR entry</strong> ，而它所在的页表表项被称为 <strong>Page table entry</strong>。Directory entry中存放的物理地址与la的页表索引部分的结合是Page table entry的地址，而page table entry中存放的物理地址与la的偏移部分的结合是la所对应物理页的地址。</p>
<p>每个PDE或者PTE的内容都是<code>phyaddr</code>和 <strong>权限位</strong> 的组合。因为PDE和PTE的内容都指向一个物理页的首地址，它们的最后12位是用不到的。这12位被内存管理系统用作权限位，每一位都代表一个特定的权限，管理系统通过将这些位置0或置1来设定这一页的权限。</p>
<h5 id="Addresses"><a href="#Addresses" class="headerlink" title="Addresses"></a>Addresses</h5><blockquote>
<p><strong>Exercise 3</strong></p>
<p>你可以在<code>qemu-gdb</code>中键入<code>ctrl-a c</code>来进入qemu的monitor。在这里，你可以用<code>xp</code>命令来查询指定物理地址的数据(<code>xp</code>指令的用法与gdb的<code>x</code>指令类似)。与此同时，在<code>gdb</code>中用<code>x</code>指令可以查询指定虚拟地址的数据。将存在映射关系的虚拟地址与物理地址存放的内容作对比，看看是否是一致的。</p>
</blockquote>
<p>JOS的源代码定义了<code>uintptr_t</code>来存放虚拟地址，而<code>physaddr_t</code>用来存放物理地址。</p>
<blockquote>
<p><strong>Question</strong></p>
<p>Q:如果下面的代码是正确的,变量x的类型应当是uintptr_t还是physaddr_t?</p>
<p>A:uintptr_t,因为C中的指针都是指向虚拟地址的.</p>
</blockquote>
<p>JOS内核有时需要读取或修改只知道物理地址的内存。例如，向页表添加映射可能需要分配物理内存来存储页目录，然后初始化该内存。但是，内核不能绕过虚拟地址转换，因此不能直接修改物理地址。这就是为什么我们要把物理内存用一个线性函数映射到虚拟内存中<code>0xf0000000</code>以上的区域:这方便了内核直接操作物理内存。<code>PADDR</code>和<code>KADDR</code>两个宏定义让我们可以很方便地实现物理地址和虚拟地址之间的转换。</p>
<h5 id="page-management"><a href="#page-management" class="headerlink" title="page management"></a>page management</h5><p>我们知道，同一个物理页面可能会被映射到数个不同虚拟空间的数个虚拟页面，我们通过修改<code>PageInfo</code>结构体中的<code>pp_ref</code>属性来反映这一点。每当我们分配一个UTOP以下的页面，我们让该物理页面的<code>pp_ref</code>属性+1。(UTOP以上的页面属于内核，它们永远不应该被free，因而无需更改这个属性)</p>
<p>需要注意的是，我们在实现<code>page_alloc</code>函数时并没有让它去增加<code>pp_ref</code>属性值，因此调用<code>page_alloc</code>的函数需要 <strong>自行增加这个属性的值</strong> 。</p>
<blockquote>
<p><strong>pgdir_walk</strong></p>
</blockquote>
<p>这个函数接受一个线性地址和一个页目录，返回线性地址对应的页面所在页表的物理地址。为了达成这个目的，我们可以通过线性地址中的页目录索引部分去找到页目录中的对应页表地址。如果这个页表还没有被创建，且create参数为真，那就创建一个新的页表并返回它的物理地址。</p>
<p>根据函数前面的注释，<strong>MMU会同时检查页目录表项和页表表项中的权限位</strong>，因而我们对于页目录中新页表物理地址的权限可以把要求放宽松一点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find the page table where va locates.</span></span><br><span class="line"><span class="keyword">physaddr_t</span> pgtab = pgdir[PDX(va)];</span><br><span class="line"><span class="keyword">if</span> (!pgtab) &#123;</span><br><span class="line">    <span class="keyword">if</span> (create) &#123;</span><br><span class="line">        <span class="comment">// Allocate a new page table.</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">new_pt</span> = <span class="title">page_alloc</span>(<span class="title">ALLOC_ZERO</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (new_pt == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            new_pt-&gt;pp_ref++;</span><br><span class="line">            <span class="comment">// Leave permissions of pt more permissive</span></span><br><span class="line">            <span class="comment">// We allow users to read this page</span></span><br><span class="line">            pgdir[PDX(va)] = page2pa(new_pt) | PTE_P | PTE_U | PTE_W;</span><br><span class="line">            <span class="keyword">return</span> KADDR(PTE_ADDR(pgdir[PDX(va)])+PTX(va)*<span class="keyword">sizeof</span>(<span class="keyword">pte_t</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// We need to return the address of page table **entry**</span></span><br><span class="line">    <span class="comment">// PTE_ADDR: get rid of the permission bits in `pgtab`</span></span><br><span class="line">    <span class="comment">// PTX(va)*sizeof(pte_t): find the 'PTX(va)'th element in a `pte_t` array.</span></span><br><span class="line">    <span class="keyword">return</span> KADDR(PTE_ADDR(pgtab)+PTX(va)*<span class="keyword">sizeof</span>(<span class="keyword">pte_t</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>boot_map_region</strong></p>
</blockquote>
<p>这个函数将一段指定的虚拟地址映射到同样长度的指定的物理地址。因为映射以页为单位，我们可以依次映射这段地址中的每一页：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> page_num = size / PGSIZE;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; page_num; i++) &#123;</span><br><span class="line">    <span class="keyword">pte_t</span>* pgtab = pgdir_walk(pgdir,(<span class="keyword">void</span>*)(va+i*PGSIZE),<span class="number">1</span>);</span><br><span class="line">    *pgtab = (pa+i*PGSIZE) | perm | PTE_P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>page_lookup</strong></p>
</blockquote>
<p>这个函数寻找va在pgdir中的页表地址和物理地址。依照注释完成,没有多大难度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pte_t</span>* pgtab = pgdir_walk(pgdir, va, <span class="number">0</span>); <span class="comment">// Page table address</span></span><br><span class="line"><span class="keyword">if</span> (pgtab == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pte_store != <span class="literal">NULL</span>)</span><br><span class="line">        *pte_store = pgtab;</span><br><span class="line">    <span class="keyword">return</span> pa2page(PTE_ADDR(*pgtab));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>page_remove</strong></p>
</blockquote>
<p>这个函数移除va指定的页。基本上都是在调用函数，只要认真阅读了注释即很简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pte_t</span> *pg_pte;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pgtab</span> = <span class="title">page_lookup</span>(<span class="title">pgdir</span>, <span class="title">va</span>, &amp;<span class="title">pg_pte</span>);</span></span><br><span class="line"><span class="keyword">if</span> (!pgtab) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// This function frees the page automatically if refcount reaches 0.</span></span><br><span class="line">page_decref(pgtab);</span><br><span class="line">*pg_pte = <span class="number">0</span>;</span><br><span class="line">tlb_invalidate(pgdir, va);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>page_insert</strong></p>
</blockquote>
<p>这个函数将pp插入va所指定的位置。这个函数的一个很容易出错的边界条件是将一个 <strong>原本空闲的</strong> page <strong>连续插入两次</strong> ，按正常的逻辑第二次插入应该不会有任何影响，但实现不当的话会出现问题。</p>
<p>如果先进行<code>page_remove</code>再增加引用数的话，首先在调用<code>page_remove</code>的时候这个page已经进入了<code>page_free_list</code>，但接下来我们接着又要用到这个page且没有经过<code>page_alloc</code>，这样一来这个page既在空闲链表中引用数又不为0，会成为一个bug。</p>
<p>根据注释的提示，有一种优雅的无需条件判断的方式可以解决这个问题。这种方式就是 <strong>将增加引用数的步骤提前</strong> ，这样这个页面在<code>page_remove</code>之前引用数就是2，就不会在<code>page_remove</code>中被回收到<code>page_free_list</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pte_t</span>* pgtab = pgdir_walk(pgdir, va, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (pgtab == <span class="literal">NULL</span>) <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">pp-&gt;pp_ref++;</span><br><span class="line"><span class="keyword">if</span> (*pgtab &amp; PTE_P)</span><br><span class="line">    page_remove(pgdir, va);</span><br><span class="line">*pgtab = page2pa(pp) | perm | PTE_P;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h4 id="Part-3-Kernel-address-space"><a href="#Part-3-Kernel-address-space" class="headerlink" title="Part 3 Kernel address space"></a>Part 3 Kernel address space</h4><p>JOS的地址空间被<code>ULIM</code>划分为两个部分：<strong>用户地址空间</strong> 和 <strong>内核地址空间</strong> 。后者大概拥有256MB的剩余空间可以使用。</p>
<p>由于用户区和内核区同在一个地址空间内，我们需要使用页表管理中的 <strong>权限位</strong> 来保证用户只能访问用户区的页。</p>
<ul>
<li>常用的权限位：<ul>
<li><code>PTE_P</code>: 页面存在</li>
<li><code>PTE_W</code>: 该页是可写的</li>
<li><code>PTE_U</code>: 该页可以由用户访问</li>
</ul>
</li>
</ul>
<p>用户不应有访问任何<code>ULIM</code>以上内存的权限,而内核应当能读写这一块区域。在<code>UTOP</code>和<code>ULIM</code>之间的区域是 <strong>只读区</strong>(对用户和内核都是) 。低于<code>UTOP</code>的内存区域权限由用户自行设置。</p>
<h5 id="Initializing-the-Kernel-Address-Space"><a href="#Initializing-the-Kernel-Address-Space" class="headerlink" title="Initializing the Kernel Address Space"></a>Initializing the Kernel Address Space</h5><blockquote>
<p><strong>Exercise 5</strong></p>
</blockquote>
<p>这个任务要求我们补全<code>mem_init</code>函数。</p>
<p>第一段要求我们把整个<code>pages</code>数组映射到<code>UPAGE</code>地址以上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cautious: we map the phyaddr of pages instead of their content</span></span><br><span class="line"><span class="comment">// So we use PADDR here, not page2pa.</span></span><br><span class="line">boot_map_region(kern_pgdir, UPAGES, npages*<span class="keyword">sizeof</span>(struct PageInfo), PADDR(pages), PTE_U);</span><br></pre></td></tr></table></figure>
<p>第二段要求我们把内核栈映射到<code>KSTACKTOP-KSTKSIZE</code>到<code>KSTACKTOP</code>区域。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boot_map_region(kern_pgdir, (KSTACKTOP-KSTKSIZE), KSTKSIZE, PADDR(&amp;bootstack), PTE_P | PTE_W);</span><br></pre></td></tr></table></figure>
<p>第三段要求我们映射整个内核区域。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> kern_size = (<span class="keyword">unsigned</span>)~<span class="number">0</span> - KERNBASE;</span><br><span class="line">boot_map_region(kern_pgdir, KERNBASE, kern_size, <span class="number">0</span>, PTE_P | PTE_W);</span><br></pre></td></tr></table></figure>
<p>三段都是看着注释调函数即可，没有很大难度。不得不说6.828的注释仔细研究可以省去很多精力。</p>
<blockquote>
<p><strong>Questions</strong></p>
<p>Q：在这个过程中哪些PDE被填入了信息？它们对应哪些线性地址，又指向哪些物理地址？</p>
<p>A：被填入的PDE索引：</p>
<ul>
<li>956-UPAGES，线性地址0xef000000,指向pages数组在物理内存中的首地址</li>
<li>957-UVPT，线性地址0xef400000,指向kern_pgdir在物理内存中的地址</li>
<li>959-KSTACK，线性地址0xefc00000,指向bootstack数组在物理内存中的首地址</li>
<li>960～1023-内核内存区，线性地址0xf0000000以上，指向物理内存地址0。</li>
</ul>
<p>Q：既然我们把用户和内核的内存区域放在同一个地址空间中，到底是什么机制保护了内核内存不能被用户访问？</p>
<p>A：权限位<code>PTE_U</code>决定了一页能否被用户访问。</p>
<p>Q：这个操作系统能够支持多大的物理内存？为什么？</p>
<p>A：内存空间内能存放pages的空间是一个PTSIZE，也就是最多能够映射PTSIZE/sizeof(struct PageInfo)个页面，每页大小为4KB，因此总共能映射的物理内存大小为2GB。</p>
<p>Q：如果我们拥有能支持的最大的物理内存，管理这些内存需要多少空间开销？如何减少这些开销？</p>
<p>A：管理满载的512K个页面需要512个页表，每个页表占内存空间都是一个PGSIZE，总共就会有4MB左右内存用于页表储存。加上用于存放pages的4MB和页目录的4KB，总共会有8MB左右空间开销。如果把PGSIZE取大一点，这种开销就可以稍微减小。</p>
<p>Q：在我们刚打开分页机制的时候，程序还运行在低地址，控制流在什么时候跳转到KERNBASE以上？为什么在打开分页机制之后我们仍能够运行在一个低地址？</p>
<p>A：在打开分页的下一步，控制流就用jmp指令跳转到了KERNBASE以上的高地址。打开分页机制后仍能在低地址运行的原因是低地址和KERNBASE以上的高地址都被映射到同一片物理内存，这是为了保持兼容性。</p>
</blockquote>
<p>完成上面的所有代码之后，运行<code>make grade</code>，<code>70/70</code>大成功。</p>
<blockquote>
<p><strong>Challenge</strong></p>
</blockquote>
<p>这个挑战的内容主要是为JOS的monitor加入一些实用的指令，以方便之后的调试过程，具体的指令细节可以自己调整和定制。增加指令后，要记得在<code>monitor.h</code>中添加声明。</p>
<p>我主要做了以下几条指令(下面是修改后的Commands数组)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>pageinfo</li>
</ol>
<p>这个指令接受一个命令行参数。</p>
<p><code>pageinfo addr</code>：打印出虚拟地址addr所在的页目录，页表，以及所在的物理页面，物理地址。</p>
<p>如果addr使用十六进制地址，必须在数字前面加上<code>0x</code>。</p>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Must include pmap.h in monitor.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;kern/pmap.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_pageinfo(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cannot declare vars in switch-case statement.</span></span><br><span class="line">    <span class="keyword">physaddr_t</span> addr;</span><br><span class="line">    <span class="keyword">pte_t</span>* pte;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (argc) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            cprintf(<span class="string">"Error: too few arguments.\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            addr = str2int(argv[<span class="number">1</span>]);</span><br><span class="line">            pte = pgdir_walk(kern_pgdir, (<span class="keyword">void</span> *)addr, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!pte) &#123;</span><br><span class="line">                cprintf(<span class="string">"This address has not been mapped yet.\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!(*pte &amp; PTE_P)) &#123;</span><br><span class="line">                cprintf(<span class="string">"Exception: Page does not exist.\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cprintf(<span class="string">"Mapping information of address %x:\n"</span>, addr);</span><br><span class="line">            cprintf(<span class="string">"  Page directory entry: %d\n"</span>, PDX(addr));</span><br><span class="line">            cprintf(<span class="string">"  Page table entry: %d\n"</span>, PTX(addr));</span><br><span class="line">            cprintf(<span class="string">"  Page physical address: %x\n"</span>, PTE_ADDR(*pte));</span><br><span class="line">            cprintf(<span class="string">"  Physical address: %x\n"</span>, PTE_ADDR(*pte) + PGOFF(addr));</span><br><span class="line">            cprintf(<span class="string">"  Page permission:\n"</span>);</span><br><span class="line">            <span class="keyword">if</span> ((*pte &amp; PTE_U) &amp;&amp; (*pte &amp; PTE_W)) &#123;</span><br><span class="line">                cprintf(<span class="string">"    Readable and writeable by user and kernel\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((*pte &amp; PTE_U)) &#123;</span><br><span class="line">                cprintf(<span class="string">"    Readable by user and kernel\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((*pte &amp; PTE_W)) &#123;</span><br><span class="line">                cprintf(<span class="string">"    Readable and writeable by kernel\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cprintf(<span class="string">"    Readable by kernel\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cprintf(<span class="string">"Error: too many arguments.\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">str2int(<span class="keyword">char</span>* str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">'0'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(++str) != <span class="string">'x'</span>)</span><br><span class="line">            base = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            base = <span class="number">16</span>;</span><br><span class="line">            str++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> (base == <span class="number">10</span> || base == <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">while</span> (*str) &#123;</span><br><span class="line">            num = num * base + *str - <span class="string">'0'</span>;</span><br><span class="line">            str++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">while</span> (*str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*str &gt;= <span class="string">'a'</span> &amp;&amp; *str &lt;= <span class="string">'f'</span>)</span><br><span class="line">            num = num * base + *str - <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*str &gt;= <span class="string">'A'</span> &amp;&amp; *str &lt;= <span class="string">'F'</span>)</span><br><span class="line">            num = num * base + *str - <span class="string">'A'</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            num = num * base + *str - <span class="string">'0'</span>;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>chperm</li>
</ol>
<p>这个指令接受三个命令行参数。</p>
<p><code>chperm &lt;PDX&gt; &lt;PTX&gt; &lt;perm&gt;</code>：修改<code>&lt;PDX&gt;</code>和<code>&lt;PTX&gt;</code>对应页面的权限。</p>
<p><code>&lt;perm&gt;</code>的使用方法：</p>
<ul>
<li><code>+</code>：增加一种权限</li>
<li><code>-</code>：消除一种权限</li>
<li><code>w</code>：对应于<code>PTE_W</code></li>
<li><code>u</code>：对应于<code>PTE_U</code></li>
<li><code>p</code>：对应于<code>PTE_P</code></li>
</ul>
<p>使用样例：<code>chperm 960 256 -w</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Change the permittions of a certain page.</span></span><br><span class="line"><span class="comment">// chperm &lt;PDX&gt; &lt;PTX&gt; &lt;perm&gt;</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_chperm(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pdx, ptx, perm = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>* ptr;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">// 0 represents '-', 1 represents '+'</span></span><br><span class="line">    <span class="keyword">pte_t</span>* pgaddr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (argc) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"></span><br><span class="line">            pdx = str2int(argv[<span class="number">1</span>]);</span><br><span class="line">            ptx = str2int(argv[<span class="number">2</span>]);</span><br><span class="line">            ptr = argv[<span class="number">3</span>];</span><br><span class="line">            pgaddr = pgdir_walk(kern_pgdir, (<span class="keyword">void</span> *)(PGADDR(pdx,ptx,<span class="number">0</span>)), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (*ptr) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>: flag = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>: flag = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    cprintf(<span class="string">"Error: Illegal operation \'%c\'.\n"</span>, *ptr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (*(ptr+<span class="number">1</span>))   &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'w'</span>:</span><br><span class="line">                    <span class="keyword">if</span> (flag) *pgaddr = *pgaddr | PTE_W;</span><br><span class="line">                    <span class="keyword">else</span> *pgaddr = *pgaddr &amp; (~PTE_W);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">                    <span class="keyword">if</span> (flag) *pgaddr = *pgaddr | PTE_U;</span><br><span class="line">                    <span class="keyword">else</span> *pgaddr = *pgaddr &amp; (~PTE_U);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'p'</span>:</span><br><span class="line">                    <span class="keyword">if</span> (flag) *pgaddr = *pgaddr | PTE_P;</span><br><span class="line">                    <span class="keyword">else</span> *pgaddr = *pgaddr &amp; (~PTE_P);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    cprintf(<span class="string">"Error: Illegal operation \'%c\'.\n"</span>, *(ptr+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cprintf(<span class="string">"Error: bad usage.\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>man</li>
</ol>
<p>虽然命名为man，但是其实这个命令的行为更像<code>--help</code>。</p>
<p>需要注意的是，每增加一条新的命令就要增加<code>command_usage</code>数组的内容。并且，这个数组中的元素顺序必须与<code>commands</code>数组中的顺序一致。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* command_usage[] = &#123;</span><br><span class="line">    <span class="string">"help\nDisplay the list of commands"</span>,</span><br><span class="line">    <span class="string">"exit\nLeave the monitor and shutdown"</span>,</span><br><span class="line">    <span class="string">"kerninfo\nDisplay information about the kernel"</span>,</span><br><span class="line">    <span class="string">"backtrace\nDisplay the structure of the stack"</span>,</span><br><span class="line">    <span class="string">"pageinfo &lt;addr&gt;\nDisplay the information of the page virtual address &lt;addr&gt; locates"</span>,</span><br><span class="line">    <span class="string">"chperm &lt;PDX&gt; &lt;PTX&gt; &lt;perm&gt;\nChange the permittion of the page with index &lt;PDX&gt; and &lt;PTX&gt;\n  \</span></span><br><span class="line"><span class="string">&lt;perm&gt; is the combination of a symbol('+' or '-') and a permittion code. \</span></span><br><span class="line"><span class="string">In particular, '+' is for permittion addition and '-' is for permittion erasure.\n\</span></span><br><span class="line"><span class="string">Possible permittion codes:\n  u: PTE_U\n  p: PTE_P\n  w: PTE_W\n"</span>,</span><br><span class="line">    <span class="string">"man\nDisplay the usage of a command"</span>,  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Display the usage of a command.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_man(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        cprintf(<span class="string">"Usage: man &lt;command&gt;\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE(commands); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], commands[i].name) == <span class="number">0</span>) &#123;</span><br><span class="line">            cprintf(<span class="string">"Usage: %s\n"</span>, command_usage[i]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">"Error: no such command.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这一章的最后还有几个挑战，一个是实现一种不同的分页机制使用户可以不受限制地使用整个4GB内存空间，由于并没有什么主流操作系统使用这种模式就没写。另一个是实现一个类似于<code>malloc/free</code>堆内存分配的分配机制，过于麻烦，等有空再写这个吧。</p>
<h4 id="Summarize"><a href="#Summarize" class="headerlink" title="Summarize"></a>Summarize</h4><p>总结一下JOS使用的内存管理机制：</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/2018/11/24/用自己建造的DockerImage创建k8s容器/" rel="next" title="用自己建造的DockerImage创建k8s容器">
                <i class="fa fa-chevron-left"></i> 用自己建造的DockerImage创建k8s容器
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/2019/03/10/在ArchLinux下安装和配置LaTex编译环境/" rel="prev" title="在ArchLinux下安装和配置LaTex编译环境">
                在ArchLinux下安装和配置LaTex编译环境 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/blog/images/lyrica.png" alt="Drac Zhang">
            
              <p class="site-author-name" itemprop="name">Drac Zhang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/blog/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/dracit7" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#MIT-6-828-Labs-实验记录"><span class="nav-number">1.</span> <span class="nav-text">MIT 6.828 Labs 实验记录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Overall"><span class="nav-number">1.1.</span> <span class="nav-text">Overall</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Build-up-the-environment"><span class="nav-number">1.2.</span> <span class="nav-text">Build up the environment</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Compiler-Toolchain"><span class="nav-number">1.2.1.</span> <span class="nav-text">Compiler Toolchain</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#QEMU-emulator"><span class="nav-number">1.2.2.</span> <span class="nav-text">QEMU emulator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Other-problems"><span class="nav-number">1.2.3.</span> <span class="nav-text">Other problems</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Dependencies-upgraded"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">Dependencies upgraded</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lab-1-Booting-a-PC"><span class="nav-number">1.3.</span> <span class="nav-text">Lab 1 Booting a PC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Part-1-PC-bootstrap"><span class="nav-number">1.3.1.</span> <span class="nav-text">Part 1 PC bootstrap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Layout-of-the-physical-address-space"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">Layout of the physical address space</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#The-ROM-BIOS"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">The ROM BIOS</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Part-2-The-boot-loader"><span class="nav-number">1.3.2.</span> <span class="nav-text">Part 2 The boot loader</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#习题解答"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">习题解答</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Part-3-The-kernel"><span class="nav-number">1.3.3.</span> <span class="nav-text">Part 3 The kernel</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Virtual-memory-address-mapping"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">Virtual memory address mapping</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Formatted-printing-to-the-console"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">Formatted printing to the console</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#The-Stack"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">The Stack</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lab2-Memory-Management"><span class="nav-number">1.4.</span> <span class="nav-text">Lab2 Memory Management</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Background-knowledge"><span class="nav-number">1.4.1.</span> <span class="nav-text">Background knowledge</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Definitions-guide"><span class="nav-number">1.4.2.</span> <span class="nav-text">Definitions guide</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Part-1-Physical-page-management"><span class="nav-number">1.4.3.</span> <span class="nav-text">Part 1 Physical page management</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Part-2-Virtual-Memory"><span class="nav-number">1.4.4.</span> <span class="nav-text">Part 2 Virtual Memory</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Segments"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">Segments</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Pages"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">Pages</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Addresses"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">Addresses</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#page-management"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">page management</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Part-3-Kernel-address-space"><span class="nav-number">1.4.5.</span> <span class="nav-text">Part 3 Kernel address space</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Initializing-the-Kernel-Address-Space"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">Initializing the Kernel Address Space</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Summarize"><span class="nav-number">1.4.6.</span> <span class="nav-text">Summarize</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Drac Zhang</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/blog/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/blog/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://Drac_zhang.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://dracit7.github.io/blog/2019/02/24/MIT_6.828/';
          this.page.identifier = '2019/02/24/MIT_6.828/';
          this.page.title = 'MIT 6.828 Labs 实验记录';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://Drac_zhang.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
